"""
Extracted handler implementations: backups
Auto-generated by refactor_main.py
"""
import json
import sys
import time
import asyncio
import traceback
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from service_context import get_service_context

# All handlers receive (self, payload) where self is BackendService instance.
# They are called via: await handler_impl(self, payload)
# Inside, use self.db, self.send_event(), self.telegram_manager, etc.
# This is a transitional pattern - later, replace self.xxx with ctx.xxx


async def handle_create_backup(self, payload: Dict[str, Any]):
    """Handle create-backup command"""
    try:
        if not self.backup_manager:
            self.send_log("備份管理器未初始化", "error")
            return
        
        backup_type = payload.get('type', 'manual')
        compress = payload.get('compress', True)
        backup_path = await self.backup_manager.create_backup(
            backup_type=backup_type,
            compress=compress
        )
        
        self.send_log(f"✓ 備份創建成功: {backup_path.name}", "success")
        self.send_event("backup-created", {
            "backupPath": str(backup_path),
            "backupName": backup_path.name,
            "size": backup_path.stat().st_size,
            "type": backup_type
        })
    except Exception as e:
        app_error = handle_error(e, {"command": "create-backup", "payload": payload})
        self.send_log(f"創建備份失敗: {str(app_error)}", "error")


async def handle_restore_backup(self, payload: Dict[str, Any]):
    """Handle restore-backup command"""
    try:
        from pathlib import Path
        backup_path_str = payload.get('backupPath')
        create_current_backup = payload.get('createCurrentBackup', True)
        
        if not backup_path_str:
            self.send_log("No backup path provided", "error")
            return
        
        backup_path = Path(backup_path_str)
        
        if not self.backup_manager:
            self.send_log("備份管理器未初始化", "error")
            return
        
        success = await self.backup_manager.restore_backup(backup_path, create_current_backup)
        
        if success:
            self.send_log(f"✓ 數據庫已從備份恢復: {backup_path.name}", "success")
            self.send_event("backup-restored", {
                "backupPath": str(backup_path)
            })
            
            # Reload initial state after restore
            await self.handle_get_initial_state()
        else:
            self.send_log("恢復備份失敗", "error")
    except Exception as e:
        app_error = handle_error(e, {"command": "restore-backup", "payload": payload})
        self.send_log(f"Error restoring backup: {str(app_error)}", "error")


async def handle_list_backups(self):
    """Handle list-backups command"""
    try:
        backup_manager = get_backup_manager()
        backups = backup_manager.list_backups()
        
        backup_list = []
        for backup in backups:
            backup_time = datetime.fromtimestamp(backup.stat().st_mtime)
            backup_list.append({
                "name": backup.name,
                "path": str(backup),
                "size": backup.stat().st_size,
                "sizeMB": round(backup.stat().st_size / (1024 * 1024), 2),
                "timestamp": backup_time.isoformat()
            })
        
        self.send_event("backups-listed", {
            "backups": backup_list
        })
    except Exception as e:
        app_error = handle_error(e, {"command": "list-backups"})
        self.send_log(f"Error listing backups: {str(app_error)}", "error")


async def handle_get_backup_info(self):
    """Handle get-backup-info command"""
    try:
        backup_manager = get_backup_manager()
        info = backup_manager.get_backup_info()
        self.send_event("backup-info", info)
    except Exception as e:
        app_error = handle_error(e, {"command": "get-backup-info"})
        self.send_log(f"Error getting backup info: {str(app_error)}", "error")

