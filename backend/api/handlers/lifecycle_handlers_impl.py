"""
Extracted handler implementations: lifecycle
Auto-generated by refactor_main.py
"""
import json
import sys
import time
import asyncio
import traceback
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from service_context import get_service_context

# All handlers receive (self, payload) where self is BackendService instance.
# They are called via: await handler_impl(self, payload)
# Inside, use self.db, self.send_event(), self.telegram_manager, etc.
# This is a transitional pattern - later, replace self.xxx with ctx.xxx


# ==================== Command Handlers ====================

async def handle_get_initial_state(self):
    """Handle get-initial-state command and restore monitoring state if needed"""
    try:
        import sys
        import time
        start_time = time.time()
        print("[Backend] handle_get_initial_state called", file=sys.stderr)
        
        # ğŸ†• ç™¼é€è¼‰å…¥é€²åº¦äº‹ä»¶ï¼ˆä¸‰éšæ®µé€²åº¦ï¼‰
        self.send_event("loading-progress", {
            "step": "start",
            "message": "ğŸ”— æ­£åœ¨é€£æ¥æ•¸æ“šåº«...",
            "progress": 10
        })
        
        # ========== å„ªåŒ–ï¼šä¸¦è¡Œç²å–æ‰€æœ‰æ•¸æ“š ==========
        print("[Backend] Loading all data in parallel...", file=sys.stderr)
        parallel_start = time.time()
        
        # ä¸¦è¡ŒåŸ·è¡Œæ‰€æœ‰æ•¸æ“šåº«æŸ¥è©¢
        results = await asyncio.gather(
            db.get_all_accounts(),
            db.get_all_keyword_sets(),
            db.get_all_groups(),
            db.get_all_campaigns(),
            db.get_all_templates(),
            db.get_leads_with_total(limit=20, initial_load=True),  # ğŸ†• é¦–æ‰¹åªåŠ è¼‰ 20 æ¢ï¼Œæ¸›å°‘å•Ÿå‹•æ™‚é–“
            db.get_recent_logs(limit=50),
            db.get_all_settings(),
            db.get_monitoring_config(),
            db.get_all_trigger_rules(),  # ğŸ”§ FIX: ä¹ŸåŠ è¼‰è§¸ç™¼è¦å‰‡
            return_exceptions=True
        )
        
        parallel_duration = time.time() - parallel_start
        print(f"[Backend] Parallel data loading completed in {parallel_duration:.3f}s", file=sys.stderr)
        
        # ğŸ†• ç™¼é€è¼‰å…¥é€²åº¦äº‹ä»¶ï¼ˆéšæ®µ2ï¼šæ•¸æ“šè™•ç†ï¼‰
        self.send_event("loading-progress", {
            "step": "data_loaded",
            "message": "ğŸ“Š æ•¸æ“šè¼‰å…¥å®Œæˆï¼Œæ­£åœ¨åˆå§‹åŒ–...",
            "progress": 50
        })
        
        # è§£æçµæœï¼ˆè™•ç†å¯èƒ½çš„ç•°å¸¸ï¼‰
        accounts = results[0] if not isinstance(results[0], Exception) else []
        keyword_sets = results[1] if not isinstance(results[1], Exception) else []
        monitored_groups = results[2] if not isinstance(results[2], Exception) else []
        campaigns = results[3] if not isinstance(results[3], Exception) else []
        message_templates = results[4] if not isinstance(results[4], Exception) else []
        leads_data = results[5] if not isinstance(results[5], Exception) else {'leads': [], 'total': 0, 'hasMore': False}
        leads = leads_data.get('leads', []) if isinstance(leads_data, dict) else []
        leads_total = leads_data.get('total', 0) if isinstance(leads_data, dict) else 0
        leads_has_more = leads_data.get('hasMore', False) if isinstance(leads_data, dict) else False
        logs = results[6] if not isinstance(results[6], Exception) else []
        settings = results[7] if not isinstance(results[7], Exception) else {}
        monitoring_config = results[8] if not isinstance(results[8], Exception) else {}
        trigger_rules = results[9] if not isinstance(results[9], Exception) else []  # ğŸ”§ FIX: è§¸ç™¼è¦å‰‡
        
        # è¨˜éŒ„ä»»ä½•æŸ¥è©¢éŒ¯èª¤
        for i, result in enumerate(results):
            if isinstance(result, Exception):
                print(f"[Backend] Query {i} failed: {result}", file=sys.stderr)
        
        print(f"[Backend] Loaded: {len(accounts)} accounts, {len(keyword_sets)} keyword_sets, {len(monitored_groups)} groups, {len(campaigns)} campaigns, {len(message_templates)} templates, {len(trigger_rules)} trigger_rules, {len(leads)} leads, {len(logs)} logs", file=sys.stderr)
        
        # ğŸ†• å„ªåŒ–ï¼šæ‰¹é‡åŒæ­¥å¸³è™Ÿé€£æ¥ç‹€æ…‹ï¼ˆæ¸›å°‘æ•¸æ“šåº«èª¿ç”¨ï¼‰
        sync_start = time.time()
        print("[Backend] Syncing account connection status...", file=sys.stderr)
        
        # æ”¶é›†éœ€è¦é‡ç½®ç‚º Offline çš„å¸³è™Ÿ ID
        accounts_to_reset = []
        
        for account in accounts:
            phone = account.get('phone')
            db_status = account.get('status', 'Offline')
            should_reset = False
            
            # æ£€æŸ¥ Telegram å®¢æˆ·ç«¯æ˜¯å¦çœŸæ­£è¿æ¥
            client = self.telegram_manager.get_client(phone) if phone else None
            is_actually_connected = client and client.is_connected if client else False
            
            # å¦‚æœæ•°æ®åº“æ˜¾ç¤ºåœ¨çº¿ä½†å®¢æˆ·ç«¯æœªè¿æ¥
            if db_status == 'Online' and not is_actually_connected:
                should_reset = True
                print(f"[Backend] Account {mask_phone(phone)}: Online but not connected -> Offline", file=sys.stderr)
            
            # ä¿®å¾© Error ç‹€æ…‹
            elif db_status.lower() in ['error', 'proxy error', 'auth error', 'session expired']:
                should_reset = True
                print(f"[Backend] Account {phone}: {db_status} -> Offline (resetting error)", file=sys.stderr)
            elif 'error' in db_status.lower():
                should_reset = True
                print(f"[Backend] Account {phone}: {db_status} -> Offline (contains error)", file=sys.stderr)
            
            if should_reset:
                account['status'] = 'Offline'
                if account.get('id'):
                    accounts_to_reset.append(account['id'])
            
            account['isConnected'] = is_actually_connected
        
        # ğŸ†• æ‰¹é‡æ›´æ–°æ•¸æ“šåº«ï¼ˆå–®ä¸€ SQL èª¿ç”¨ï¼‰
        if accounts_to_reset:
            updated_count = await db.batch_update_account_status(accounts_to_reset, 'Offline')
            print(f"[Backend] Batch updated {updated_count} accounts to Offline in {time.time() - sync_start:.3f}s", file=sys.stderr)
        else:
            print(f"[Backend] No accounts need status update ({time.time() - sync_start:.3f}s)", file=sys.stderr)
        
        # ========== å„ªåŒ–ï¼šæ‰¹é‡è™•ç†æ™‚é–“æˆ³ ==========
        def normalize_timestamp(ts):
            """å¿«é€Ÿæ ¼å¼åŒ–æ™‚é–“æˆ³"""
            if ts is None:
                return datetime.now().isoformat() + "Z"
            if isinstance(ts, str):
                return ts if ts.endswith('Z') else ts + "Z"
            try:
                return datetime.fromisoformat(str(ts)).isoformat() + "Z"
            except (ValueError, TypeError):
                return datetime.now().isoformat() + "Z"
        
        ts_start = time.time()
        
        # æ‰¹é‡è™•ç† leads æ™‚é–“æˆ³
        for lead in leads:
            lead['timestamp'] = normalize_timestamp(lead.get('timestamp'))
            # åªè™•ç†å‰å¹¾å€‹ interactionï¼ˆå„ªåŒ–ï¼‰
            interactions = lead.get('interactionHistory', [])
            for interaction in interactions[:10]:  # åªè™•ç†æœ€è¿‘10å€‹
                interaction['timestamp'] = normalize_timestamp(interaction.get('timestamp'))
        
        # æ‰¹é‡è™•ç† logs æ™‚é–“æˆ³
        for log in logs:
            log['timestamp'] = normalize_timestamp(log.get('timestamp'))
        
        ts_duration = time.time() - ts_start
        print(f"[Backend] Timestamps processed in {ts_duration:.3f}s", file=sys.stderr)
        
        # Settings å’Œ monitoring_config å·²åœ¨ä¸¦è¡ŒæŸ¥è©¢ä¸­ç²å–
        is_monitoring = monitoring_config.get('isActive', False)
        print(f"[Backend] Monitoring config: isActive={is_monitoring}", file=sys.stderr)
        
        # ğŸ†• å»¶é²æ¢å¾©ç›£æ§ï¼šä¸é˜»å¡åˆå§‹ç‹€æ…‹ç™¼é€ï¼Œæ”¹ç‚ºå¾Œå°ä»»å‹™
        should_restore_monitoring = False
        if is_monitoring and not self.is_monitoring:
            # Check if we can restore monitoring
            listener_accounts = [a for a in accounts if a.get('role') == 'Listener' and a.get('status') == 'Online']
            if listener_accounts and monitored_groups and keyword_sets:
                should_restore_monitoring = True
                print("[Backend] Will restore monitoring in background after initial-state sent", file=sys.stderr)
            else:
                # Cannot restore, reset state
                await db.set_monitoring_active(False)
                is_monitoring = False
                print("[Backend] Cannot restore monitoring: missing requirements", file=sys.stderr)
        
        self.is_monitoring = is_monitoring
        
        # ğŸ†• æ¼¸é€²å¼ç™¼é€ï¼šåˆ†æ‰¹ç™¼é€æ•¸æ“šï¼Œè®“ UI ç›¡å¿«é¡¯ç¤º
        print(f"[Backend] Sending initial-state progressively with {len(accounts)} accounts, {leads_total} leads total", file=sys.stderr)
        print(f"[Backend] Account details: {[(a.get('phone'), a.get('firstName'), a.get('status')) for a in accounts]}", file=sys.stderr)
        
        # éšæ®µ 1: ç™¼é€æ ¸å¿ƒæ•¸æ“šï¼ˆå¸³è™Ÿã€è¨­ç½®ï¼‰- è®“ UI ç«‹å³é¡¯ç¤º
        self.send_event("loading-progress", {
            "step": "sending",
            "message": "æ­£åœ¨ç™¼é€å¸³è™Ÿæ•¸æ“š...",
            "progress": 70
        })
        
        self.send_event("initial-state-core", {
            "accounts": accounts,
            "settings": settings,
            "isMonitoring": is_monitoring
        })
        
        # éšæ®µ 2: ç™¼é€é…ç½®æ•¸æ“š
        self.send_event("loading-progress", {
            "step": "sending",
            "message": "æ­£åœ¨ç™¼é€é…ç½®æ•¸æ“š...",
            "progress": 80
        })
        
        self.send_event("initial-state-config", {
            "keywordSets": keyword_sets,
            "monitoredGroups": monitored_groups,
            "campaigns": campaigns,
            "messageTemplates": message_templates,
            "chatTemplates": message_templates,
            "triggerRules": trigger_rules  # ğŸ”§ FIX: åŒ…å«è§¸ç™¼è¦å‰‡
        })
        
        # éšæ®µ 3: ç™¼é€æ¥­å‹™æ•¸æ“šï¼ˆleadsã€logsï¼‰
        self.send_event("loading-progress", {
            "step": "sending",
            "message": "æ­£åœ¨ç™¼é€å®¢æˆ¶æ•¸æ“š...",
            "progress": 90
        })
        
        self.send_event("initial-state-data", {
            "leads": leads,
            "leadsTotal": leads_total,
            "leadsHasMore": leads_has_more,  # ğŸ†• æ˜¯å¦æœ‰æ›´å¤š leads éœ€è¦åŠ è¼‰
            "logs": logs
        })
        
        # ğŸ”„ å…¼å®¹èˆŠé‚è¼¯ï¼šä»ç„¶ç™¼é€å®Œæ•´çš„ initial-stateï¼ˆç”¨æ–¼å°šæœªæ›´æ–°çš„çµ„ä»¶ï¼‰
        self.send_event("initial-state", {
            "accounts": accounts,
            "keywordSets": keyword_sets,
            "monitoredGroups": monitored_groups,
            "campaigns": campaigns,
            "messageTemplates": message_templates,
            "chatTemplates": message_templates,
            "triggerRules": trigger_rules,  # ğŸ”§ FIX: åŒ…å«è§¸ç™¼è¦å‰‡
            "leads": leads,
            "leadsTotal": leads_total,
            "leadsHasMore": leads_has_more,  # ğŸ†• æ˜¯å¦æœ‰æ›´å¤š leads
            "logs": logs,
            "settings": settings,
            "isMonitoring": is_monitoring
        })
        
        # é¡å¤–ç™¼é€ accounts-updated äº‹ä»¶ç¢ºä¿å‰ç«¯æ¥æ”¶ï¼ˆå¤šç§Ÿæˆ¶å®‰å…¨ï¼‰
        await self._send_accounts_updated()
        
        total_duration = time.time() - start_time
        print(f"[Backend] âœ“ Initial state sent in {total_duration:.3f}s (parallel query: {parallel_duration:.3f}s)", file=sys.stderr)
        
        # ğŸ†• ç™¼é€è¼‰å…¥å®Œæˆäº‹ä»¶ï¼ˆéšæ®µ3ï¼šå®Œæˆï¼‰
        self.send_event("loading-progress", {
            "step": "complete",
            "message": f"âœ… é€£æ¥æˆåŠŸ ({total_duration:.1f}ç§’)",
            "progress": 100,
            "duration": total_duration
        })
        
        await db.add_log(f"Initial state sent to frontend ({total_duration:.2f}s)", "success")
        
        # ğŸ†• å¾Œå°æ¢å¾©ç›£æ§ï¼ˆä¸é˜»å¡ä¸»ç·šç¨‹ï¼‰
        if should_restore_monitoring:
            async def restore_monitoring_background():
                try:
                    print("[Backend] Restoring monitoring in background...", file=sys.stderr)
                    await self.handle_start_monitoring()
                    await db.add_log("Monitoring state restored from database", "info")
                    print("[Backend] âœ“ Monitoring restored successfully", file=sys.stderr)
                except Exception as e:
                    print(f"[Backend] Failed to restore monitoring: {e}", file=sys.stderr)
                    await db.add_log(f"Failed to restore monitoring: {str(e)}", "warning")
                    await db.set_monitoring_active(False)
            
            # å»¶é² 1 ç§’å¾Œåœ¨å¾Œå°æ¢å¾©ç›£æ§
            asyncio.get_event_loop().call_later(1.0, lambda: asyncio.create_task(restore_monitoring_background()))
        
        # ğŸ†• è¿”å› HTTP éŸ¿æ‡‰ï¼ˆWeb æ¨¡å¼éœ€è¦ï¼‰
        return {
            "success": True,
            "accounts": accounts,
            "keywordSets": keyword_sets,
            "monitoredGroups": monitored_groups,
            "campaigns": campaigns,
            "messageTemplates": message_templates,
            "chatTemplates": message_templates,
            "triggerRules": trigger_rules,
            "leads": leads,
            "leadsTotal": leads_total,
            "leadsHasMore": leads_has_more,
            "logs": logs,
            "settings": settings,
            "isMonitoring": is_monitoring
        }
    
    except Exception as e:
        import traceback
        print(f"[Backend] â˜…â˜…â˜… ERROR in handle_get_initial_state: {str(e)} â˜…â˜…â˜…", file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        self.send_log(f"Error getting initial state: {str(e)}", "error")


async def handle_graceful_shutdown(self):
    """Handle graceful shutdown - disconnect all clients and close database"""
    import sys
    print("[Backend] Graceful shutdown initiated...", file=sys.stderr)
    
    try:
        # 1. Stop monitoring if running
        if self.is_monitoring:
            print("[Backend] Stopping monitoring...", file=sys.stderr)
            try:
                await self.telegram_manager.stop_monitoring()
                self.is_monitoring = False
            except Exception as e:
                print(f"[Backend] Error stopping monitoring: {e}", file=sys.stderr)
        
        # 2. Disconnect all Telegram clients
        print("[Backend] Disconnecting all Telegram clients...", file=sys.stderr)
        try:
            await self.telegram_manager.disconnect_all()
        except Exception as e:
            print(f"[Backend] Error disconnecting clients: {e}", file=sys.stderr)
        
        # 3. Stop scheduler
        print("[Backend] Stopping scheduler...", file=sys.stderr)
        try:
            await scheduler.stop()
        except Exception as e:
            print(f"[Backend] Error stopping scheduler: {e}", file=sys.stderr)
        
        # 4. Close database connection
        print("[Backend] Closing database connection...", file=sys.stderr)
        try:
            await db.close()
        except Exception as e:
            print(f"[Backend] Error closing database: {e}", file=sys.stderr)
        
        # 5. Cancel all background tasks
        print("[Backend] Cancelling background tasks...", file=sys.stderr)
        for task in self.background_tasks:
            try:
                task.cancel()
            except Exception as e:
                pass
        
        print("[Backend] Graceful shutdown completed", file=sys.stderr)
        
        # Send confirmation and exit
        self.send_event("shutdown-complete", {"success": True})
        
        # Stop the running flag to exit the main loop
        self.running = False
        
    except Exception as e:
        print(f"[Backend] Error during graceful shutdown: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
    
    # Exit the process
    print("[Backend] Exiting...", file=sys.stderr)
    sys.exit(0)


