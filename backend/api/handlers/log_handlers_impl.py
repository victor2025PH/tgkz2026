"""
Extracted handler implementations: logs
Auto-generated by refactor_main.py
"""
import json
import sys
import time
import asyncio
import traceback
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from service_context import get_service_context
from database import db
from config import config

# All handlers receive (self, payload) where self is BackendService instance.
# They are called via: await handler_impl(self, payload)
# Inside, use self.db, self.send_event(), self.telegram_manager, etc.
# This is a transitional pattern - later, replace self.xxx with ctx.xxx


async def handle_get_logs(self, payload: Dict[str, Any]):
    """Handle get-logs command with filtering"""
    try:
        limit = payload.get('limit', 100)
        log_type = payload.get('type')  # Optional: 'info', 'success', 'warning', 'error'
        start_date = payload.get('startDate')  # Optional: ISO format
        end_date = payload.get('endDate')  # Optional: ISO format
        search_query = payload.get('search')  # Optional: search string
        
        logs = await db.get_recent_logs(
            limit=limit,
            log_type=log_type,
            start_date=start_date,
            end_date=end_date,
            search_query=search_query
        )
        
        # Format timestamps
        for log in logs:
            if isinstance(log.get('timestamp'), str):
                pass  # Already a string
            else:
                log['timestamp'] = datetime.fromisoformat(log['timestamp']).isoformat() + "Z"
        
        # Get total count
        total_count = await db.get_logs_count(
            log_type=log_type,
            start_date=start_date,
            end_date=end_date,
            search_query=search_query
        )
        
        self.send_event("logs-loaded", {
            "logs": logs,
            "total": total_count,
            "limit": limit
        })
    
    except Exception as e:
        self.send_log(f"Error getting logs: {str(e)}", "error")


async def handle_export_logs(self, payload: Dict[str, Any]):
    """Handle export-logs command"""
    try:
        import openpyxl
        from openpyxl import Workbook
        from pathlib import Path
        
        log_type = payload.get('type')
        start_date = payload.get('startDate')
        end_date = payload.get('endDate')
        search_query = payload.get('search')
        
        # Get all matching logs (no limit for export)
        logs = await db.get_recent_logs(
            limit=10000,  # Large limit for export
            log_type=log_type,
            start_date=start_date,
            end_date=end_date,
            search_query=search_query
        )
        
        # Create Excel workbook
        wb = Workbook()
        ws = wb.active
        ws.title = "Logs"
        
        # Headers
        ws.append(["ID", "Timestamp", "Type", "Message"])
        
        # Data
        for log in logs:
            ws.append([
                log.get('id'),
                log.get('timestamp'),
                log.get('type'),
                log.get('message')
            ])
        
        # Save to file
        export_dir = config.TEMPLATES_DIR.parent / "exports"
        export_dir.mkdir(exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"logs_export_{timestamp}.xlsx"
        filepath = export_dir / filename
        
        wb.save(filepath)
        
        await db.add_log(f"Logs exported to {filename}", "success")
        self.send_log(f"Logs exported to {filename}", "success")
        
        # Send file path to frontend
        self.send_event("logs-exported", {
            "filepath": str(filepath),
            "filename": filename,
            "count": len(logs)
        })
    
    except Exception as e:
        self.send_log(f"Error exporting logs: {str(e)}", "error")


async def handle_clear_logs(self):
    """Handle clear-logs command"""
    try:
        await db.clear_logs()
        await db.add_log("Logs cleared", "info")
    
    except Exception as e:
        self.send_log(f"Error clearing logs: {str(e)}", "error")

