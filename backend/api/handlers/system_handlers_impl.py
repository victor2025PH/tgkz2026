"""
Extracted handler implementations: system
Auto-generated by refactor_main.py
"""
import json
import sys
import time
import asyncio
import traceback
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from service_context import get_service_context

# All handlers receive (self, payload) where self is BackendService instance.
# They are called via: await handler_impl(self, payload)
# Inside, use self.db, self.send_event(), self.telegram_manager, etc.
# This is a transitional pattern - later, replace self.xxx with ctx.xxx


# ==================== Database Management ====================

async def handle_rebuild_database(self):
    """重建數據庫（會刪除所有數據）"""
    import shutil
    from pathlib import Path
    
    try:
        db_path = Path(config.DATABASE_URL)
        db_dir = db_path.parent
        
        self.send_log("開始重建數據庫...", "info")
        
        # 步驟 1: 備份現有數據庫
        if db_path.exists():
            backup_path = db_dir / f"tgmatrix_backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.db"
            try:
                shutil.copy2(db_path, backup_path)
                self.send_log(f"數據庫已備份到: {backup_path.name}", "success")
            except Exception as e:
                self.send_log(f"備份失敗: {str(e)}", "warning")
        
        # 步驟 2: 關閉當前數據庫連接
        try:
            await db.close()
        except:
            pass
        
        # 步驟 3: 刪除舊數據庫文件
        try:
            if db_path.exists():
                db_path.unlink()
            # 刪除 WAL 和 SHM 文件
            wal_path = Path(str(db_path) + "-wal")
            shm_path = Path(str(db_path) + "-shm")
            if wal_path.exists():
                wal_path.unlink()
            if shm_path.exists():
                shm_path.unlink()
            self.send_log("舊數據庫文件已刪除", "info")
        except Exception as e:
            self.send_log(f"刪除舊數據庫失敗: {str(e)}", "error")
            self.send_event("database-rebuild-result", {
                "success": False,
                "error": f"刪除舊數據庫失敗: {str(e)}"
            })
            return
        
        # 步驟 4: 重新初始化數據庫
        try:
            await db.initialize()
            await db.connect()
            
            # 驗證數據庫完整性
            cursor = await db._connection.execute("PRAGMA integrity_check")
            result = await cursor.fetchone()
            if result and result[0] == 'ok':
                self.send_log("數據庫重建成功，完整性檢查通過", "success")
            else:
                self.send_log(f"數據庫重建完成，但完整性檢查警告: {result[0] if result else 'Unknown'}", "warning")
            
            # 重新初始化全文搜索索引
            try:
                from config import DATABASE_PATH
                search_engine = await get_init_search_engine()(str(DATABASE_PATH))
                self.send_log("全文搜索索引已重建", "success")
            except Exception as e:
                self.send_log(f"全文搜索索引重建失敗（可選）: {str(e)}", "warning")
            
            self.send_event("database-rebuild-result", {
                "success": True,
                "message": "數據庫重建成功"
            })
            
            # 發送初始狀態事件，讓前端刷新
            await self.handle_get_initial_state()
            
        except Exception as e:
            import traceback
            error_details = traceback.format_exc()
            print(f"[Backend] Database rebuild error: {error_details}", file=sys.stderr)
            self.send_log(f"數據庫重建失敗: {str(e)}", "error")
            self.send_event("database-rebuild-result", {
                "success": False,
                "error": str(e)
            })
            
    except Exception as e:
        import traceback
        error_details = traceback.format_exc()
        print(f"[Backend] Database rebuild error: {error_details}", file=sys.stderr)
        self.send_event("database-rebuild-result", {
            "success": False,
            "error": str(e)
        })


async def handle_get_active_executions(self, payload: Dict[str, Any]):
    """獲取活躍執行"""
    try:
        script_engine = get_script_engine()
        if not script_engine:
            self.send_event("active-executions", {"success": False, "error": "劇本引擎未初始化"})
            return
        
        result = await script_engine.get_active_executions()
        self.send_event("active-executions", result)
        
    except Exception as e:
        self.send_event("active-executions", {"success": False, "error": str(e)})


async def handle_get_execution_stats(self, payload: Dict[str, Any]):
    """獲取執行統計"""
    try:
        script_engine = get_script_engine()
        if not script_engine:
            self.send_event("execution-stats", {"success": False, "error": "劇本引擎未初始化"})
            return
        
        result = await script_engine.get_execution_stats()
        self.send_event("execution-stats", result)
        
    except Exception as e:
        self.send_event("execution-stats", {"success": False, "error": str(e)})


async def handle_get_background_tasks(self, payload: Dict[str, Any]):
    """獲取背景任務列表"""
    try:
        tasks = member_extraction_service.get_all_background_tasks()
        
        self.send_event("background-tasks", {
            "success": True,
            "tasks": tasks
        })
        
    except Exception as e:
        self.send_event("background-tasks", {
            "success": False,
            "error": str(e),
            "tasks": []
        })


async def handle_recalculate_scores(self, payload: Dict[str, Any]):
    """重新計算成員評分"""
    try:
        chat_id = payload.get('chatId')
        
        count = await member_extraction_service.recalculate_member_scores(chat_id)
        
        self.send_log(f"✅ 重新計算評分完成: {count} 個成員", "success")
        self.send_event("scores-recalculated", {
            "success": True,
            "count": count
        })
        
    except Exception as e:
        self.send_event("scores-recalculated", {
            "success": False,
            "error": str(e)
        })

