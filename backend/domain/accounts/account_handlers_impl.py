"""
Extracted handler implementations: accounts
Auto-generated by refactor_main.py
"""
import json
import sys
import time
import asyncio
import traceback
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from service_context import get_service_context
from database import db
from config import config

import os
import gc
from error_handler import handle_error, AppError, ErrorType
from validators import validate_account, AccountValidator, ValidationError
from pathlib import Path
from service_locator import get_DeviceFingerprintGenerator, get_ProxyManager, get_WarmupManager
# All handlers receive (self, payload) where self is BackendService instance.
# They are called via: await handler_impl(self, payload)
# Inside, use self.db, self.send_event(), self.telegram_manager, etc.
# This is a transitional pattern - later, replace self.xxx with ctx.xxx


async def handle_add_account(self, payload: Dict[str, Any]):
    """Handle add-account command"""
    try:
        import sys
        import re as re_module
        import logging
        _logger = logging.getLogger('backend.add_account')
        
        owner_user_id = payload.get('ownerUserId')
        _logger.info(f"[add-account] START phone={payload.get('phone')}, proxy={payload.get('proxy')}, usePlatformApi={payload.get('usePlatformApi')}, ownerUserId={owner_user_id}")
        
        # ğŸ”§ P4-3: ä½¿ç”¨åŸå­åŒ–çš„é…é¡æª¢æŸ¥ + é ç•™æ“ä½œï¼ˆé˜²æ­¢ä¸¦ç™¼è¶…é¡ï¼‰
        quota_reserved = False  # è¿½è¹¤é ç•™ç‹€æ…‹ï¼Œç”¨æ–¼å¾ŒçºŒ commit/rollback
        
        # Electron æ¨¡å¼è·³éé…é¡æª¢æŸ¥
        is_electron = os.environ.get('ELECTRON_MODE', 'false').lower() == 'true'
        if not is_electron and owner_user_id:
            try:
                from core.quota_service import get_quota_service
                quota_service = get_quota_service()
                
                # åŸå­åŒ–ï¼šæª¢æŸ¥ + é ç•™ä¸€æ­¥å®Œæˆï¼ŒæŒæœ‰é–æœŸé–“å…¶ä»–è«‹æ±‚ç„¡æ³•æ’å…¥
                allowed, quota_result_obj = quota_service.atomic_check_and_reserve(
                    owner_user_id, 'tg_accounts', 1
                )
                quota_result = quota_result_obj.to_dict() if hasattr(quota_result_obj, 'to_dict') else {}
                
                print(f"[Backend] Atomic quota check for tg_accounts: allowed={allowed}, "
                      f"user_id={owner_user_id}, limit={quota_result.get('limit', '?')}, "
                      f"used={quota_result.get('used', '?')}, reserved={quota_result.get('reserved', '?')}", 
                      file=sys.stderr)
                
                if not allowed:
                    limit = quota_result.get('limit', 0)
                    used = quota_result.get('used', 0)
                    detail_msg = f"TG å¸³è™Ÿæ•¸é‡å·²é”ä¸Šé™ï¼ˆå·²æœ‰ {used}/{limit} å€‹å¸³è™Ÿï¼‰"
                    upgrade_msg = quota_result.get('upgrade_suggestion', 'å‡ç´šæœƒå“¡ç­‰ç´šå¯æ·»åŠ æ›´å¤šå¸³è™Ÿ')
                    
                    self.send_event('account-added', {
                        'success': False,
                        'error': detail_msg,
                        'code': 'QUOTA_EXCEEDED',
                        'quota_type': 'tg_accounts',
                        'quota': quota_result,
                        'upgrade_suggestion': upgrade_msg,
                        'detail': {
                            'limit': limit,
                            'used': used,
                            'remaining': 0
                        }
                    })
                    return {"success": False, "error": detail_msg, "code": "QUOTA_EXCEEDED", 
                            "detail": {"limit": limit, "used": used}}
                
                quota_reserved = True  # é ç•™æˆåŠŸï¼Œå¾ŒçºŒéœ€è¦ commit æˆ– rollback
                
            except Exception as e:
                print(f"[Backend] Atomic quota check error (allowing): {e}", file=sys.stderr)
        
        # Clean phone number - remove spaces, dashes, and parentheses
        if 'phone' in payload:
            payload['phone'] = re_module.sub(r'[\s\-\(\)]', '', payload['phone'].strip())
        
        print(f"[Backend] Handling add-account command for phone: {payload.get('phone', 'unknown')}", file=sys.stderr)
        
        # ç•¶ usePlatformApi ç‚º true æ™‚ï¼Œå…ˆå¾ API æ± æˆ–å¾Œå‚™æ†‘æ“šå¡«å…… apiId/apiHash
        if payload.get('usePlatformApi'):
            try:
                from core.api_pool_integration import process_login_payload
                process_login_payload(payload)
                if payload.get('_api_error'):
                    err = payload['_api_error']
                    self.send_log(err, "error")
                    self.send_event("account-validation-error", {"errors": [err], "account_data": payload})
                    # ğŸ”§ P4-3: å›æ»¾é…é¡é ç•™
                    if quota_reserved and owner_user_id:
                        try:
                            quota_service.atomic_commit_or_rollback(owner_user_id, 'tg_accounts', 1, commit=False)
                        except: pass
                    return {"success": False, "error": err}
            except Exception as e:
                print(f"[Backend] process_login_payload error: {e}", file=sys.stderr)
        
        # Validate account data
        is_valid, errors = validate_account(payload)
        if not is_valid:
            error_message = "éªŒè¯å¤±è´¥: " + "; ".join(errors)
            print(f"[Backend] Validation failed: {errors}", file=sys.stderr)
            self.send_log(error_message, "error")
            self.send_event("account-validation-error", {
                "errors": errors,
                "account_data": payload
            })
            handle_error(
                AppError(ErrorType.VALIDATION_ERROR, error_message, {"errors": errors}),
                {"command": "add-account", "payload": payload}
            )
            # ğŸ”§ P4-3: é©—è­‰å¤±æ•—ï¼Œå›æ»¾é…é¡é ç•™
            if quota_reserved and owner_user_id:
                try:
                    quota_service.atomic_commit_or_rollback(owner_user_id, 'tg_accounts', 1, commit=False)
                except: pass
            # ğŸ†• è¿”å›éŒ¯èª¤çµæœï¼ˆHTTP API æ¨¡å¼éœ€è¦ï¼‰
            return {
                "success": False,
                "error": error_message,
                "errors": errors
            }
        
        print(f"[Backend] Validation passed, checking for existing account/session...", file=sys.stderr)
        
        phone = payload.get('phone', '')
        
        # Check if account already exists in database
        existing_account = await db.get_account_by_phone(phone)
        _logger.info(f"[add-account] phone={phone}, existing_account={'YES id=' + str(existing_account.get('id')) + ' status=' + existing_account.get('status', '?') if existing_account else 'NO'}")
        if existing_account:
            # ğŸ”§ P4-3: å¸³è™Ÿå·²å­˜åœ¨ï¼Œä¸éœ€è¦æ¶ˆè€—æ–°é…é¡ï¼Œå›æ»¾é ç•™
            if quota_reserved and owner_user_id:
                try:
                    quota_service.atomic_commit_or_rollback(owner_user_id, 'tg_accounts', 1, commit=False)
                    quota_reserved = False
                    print(f"[Backend] Quota reservation rolled back (account already exists)", file=sys.stderr)
                except: pass
            
            # ğŸ”§ å¤šç§Ÿæˆ¶ï¼šè©²æ‰‹æ©Ÿè™Ÿå·²è¢«å…¶ä»–ç”¨æˆ¶æ·»åŠ æ™‚ï¼Œä¸å…è¨±è¦†è“‹æˆ–èª¤æ“ä½œ
            existing_owner = existing_account.get('owner_user_id') or existing_account.get('ownerUserId') or ''
            if not is_electron and owner_user_id and existing_owner and existing_owner not in ('', 'local_user'):
                if existing_owner != owner_user_id:
                    error_msg = "è¯¥æ‰‹æœºå·å·²è¢«å…¶ä»–ç”¨æˆ·æ·»åŠ ï¼Œæ— æ³•é‡å¤æ·»åŠ ã€‚"
                    self.send_log(error_msg, "error")
                    self.send_event("account-validation-error", {
                        "errors": [error_msg],
                        "account_data": payload,
                        "error_type": "phone_taken_by_other_user"
                    })
                    return {
                        "success": False,
                        "error": error_msg,
                        "code": "PHONE_TAKEN_BY_OTHER_USER",
                        "phone": phone
                    }
            
            existing_status = existing_account.get('status', 'Offline')
            existing_id = existing_account.get('id')
            
            # CRITICAL: If account is already Online, just return success - don't trigger any login
            if existing_status == "Online":
                print(f"[Backend] Account {phone} already exists and is Online, skipping", file=sys.stderr)
                # Send duplicate error to inform user
                error_msg = f"è´¦æˆ·å·²å­˜åœ¨: ç”µè¯å·ç  {phone} å·²ç»åœ¨ç³»ç»Ÿä¸­ï¼ˆçŠ¶æ€: åœ¨çº¿ï¼‰ã€‚æ— éœ€é‡å¤æ·»åŠ ã€‚"
                self.send_log(error_msg, "info")
                self.send_event("account-validation-error", {
                    "errors": [error_msg],
                    "account_data": payload,
                    "error_type": "duplicate"
                })
                return {
                    "success": False,
                    "error": error_msg,
                    "code": "DUPLICATE_ACCOUNT",
                    "phone": phone
                }
            
            # OPTIMIZATION: If account exists with "error" or "Offline" status, 
            # automatically trigger login instead of showing "account already exists" error
            if existing_status in ["error", "Offline"]:
                print(f"[Backend] Account exists with status '{existing_status}', automatically triggering login...", file=sys.stderr)
                
                # Reset status to Offline and clear login state
                await db.update_account(existing_id, {"status": "Offline"})
                # Clear any login callbacks for this phone
                self.telegram_manager.login_callbacks.pop(phone, None)
                
                # Update account data if provided (API ID, API Hash, etc.)
                update_data = {}
                old_api_id = existing_account.get('apiId')
                new_api_id = payload.get('apiId')
                
                if new_api_id:
                    update_data['apiId'] = new_api_id
                if payload.get('apiHash'):
                    update_data['apiHash'] = payload['apiHash']
                if payload.get('proxy'):
                    update_data['proxy'] = payload['proxy']
                if payload.get('group'):
                    update_data['group'] = payload['group']
                if payload.get('twoFactorPassword'):
                    update_data['twoFactorPassword'] = payload['twoFactorPassword']
                if payload.get('role'):
                    update_data['role'] = payload['role']
                
                if update_data:
                    await db.update_account(existing_id, update_data)
                    print(f"[Backend] Updated account data for {phone}", file=sys.stderr)
                
                # æ›´æ–° API æ†‘æ“šä½¿ç”¨è¨ˆæ•¸ï¼ˆç•¶ API ID æ”¹è®Šæ™‚ï¼‰
                if new_api_id and new_api_id != old_api_id:
                    try:
                        from api_credential_pool import get_api_credential_pool
                        data_dir = str(Path(config.DATA_PATH))
                        pool = get_api_credential_pool(data_dir)
                        
                        # é‡‹æ”¾èˆŠçš„ API æ†‘æ“š
                        if old_api_id:
                            pool.release_credential(old_api_id)
                            print(f"[Backend] Released old API credential {old_api_id}", file=sys.stderr)
                        
                        # åˆ†é…æ–°çš„ API æ†‘æ“š
                        pool.allocate_credential(new_api_id)
                        print(f"[Backend] Allocated new API credential {new_api_id}", file=sys.stderr)
                        
                        # ç™¼é€æ›´æ–°çš„æ†‘æ“šä¿¡æ¯
                        credentials = pool.list_credentials()
                        self.send_event("api-credentials-updated", {"credentials": credentials})
                    except Exception as e:
                        print(f"[Backend] Error updating API credential usage: {e}", file=sys.stderr)
                
                # Send updated accounts list (ğŸ”§ å¤šç§Ÿæˆ¶å®‰å…¨)
                await self._send_accounts_updated(owner_user_id)
                
                # Automatically trigger login
                print(f"[Backend] Auto-triggering login for existing account {phone} (ID: {existing_id})", file=sys.stderr)
                self.send_log(f"è´¦æˆ· {phone} å·²å­˜åœ¨ï¼Œè‡ªåŠ¨è§¦å‘ç™»å½•...", "info")
                
                # Trigger login asynchronously (don't block the response)
                asyncio.create_task(self.handle_login_account({
                    "accountId": existing_id,
                    "phoneCode": None,
                    "phoneCodeHash": None
                }))
                
                # Return success with a message indicating auto-login was triggered
                return {
                    "success": True,
                    "account_id": existing_id,
                    "phone": phone,
                    "message": f"è´¦æˆ· {phone} å·²å­˜åœ¨ï¼Œè‡ªåŠ¨è§¦å‘ç™»å½•..."
                }
            
            # Check if account has stuck status (Logging in... or Waiting Code)
            if existing_status in ['Logging in...', 'Waiting Code', 'Waiting 2FA']:
                # CRITICAL: If account is in login process (especially Waiting Code), 
                # DO NOT update account data or send events that might trigger re-login
                # Just return success silently to prevent status loop
                print(f"[Backend] Account {phone} is in login process (status: {existing_status}), skipping update to prevent status loop", file=sys.stderr)
                
                # Only update account data if there are actual changes AND status is not Waiting Code
                # If status is Waiting Code, user is waiting for verification code - do NOT update
                if existing_status != 'Waiting Code':
                    # For Logging in... or Waiting 2FA, allow minimal updates
                    update_data = {}
                    if payload.get('apiId'):
                        update_data['apiId'] = payload.get('apiId')
                    if payload.get('apiHash'):
                        update_data['apiHash'] = payload.get('apiHash')
                    
                    if update_data and existing_id:
                        await db.update_account(existing_id, update_data)
                        print(f"[Backend] Updated account data for {phone}", file=sys.stderr)
                        # Only send accounts-updated if we actually updated something (ğŸ”§ å¤šç§Ÿæˆ¶å®‰å…¨)
                        await self._send_accounts_updated(owner_user_id)
                
                # Return success - account exists and is in login process
                # DO NOT send accounts-updated event if status is Waiting Code to prevent loop
                return {
                    "success": True,
                    "account_id": existing_id,
                    "phone": phone,
                    "message": f"è´¦æˆ· {phone} æ­£åœ¨ç™»å½•ä¸­ï¼ˆçŠ¶æ€: {existing_status}ï¼‰"
                }
            
            # If account exists with other statuses (Online, Offline, error), show error
            error_msg = f"è´¦æˆ·å·²å­˜åœ¨: ç”µè¯å·ç  {phone} å·²ç»åœ¨ç³»ç»Ÿä¸­ï¼ˆçŠ¶æ€: {existing_status}ï¼‰ã€‚å¦‚éœ€æ›´æ–°è´¦æˆ·ä¿¡æ¯ï¼Œè¯·ä½¿ç”¨æ›´æ–°åŠŸèƒ½ã€‚"
            print(f"[Backend] Account already exists in database: {phone}, status: {existing_status}", file=sys.stderr)
            self.send_log(error_msg, "error")
            self.send_event("account-validation-error", {
                "errors": [error_msg],
                "account_data": payload,
                "error_type": "duplicate"
            })
            return {
                "success": False,
                "error": error_msg,
                "code": "DUPLICATE_ACCOUNT",
                "phone": phone
            }
        
        # Check if session file exists (but account not in database)
        from config import SESSIONS_DIR
        safe_phone = phone.replace("+", "").replace("-", "").replace(" ", "")
        session_file = SESSIONS_DIR / f"{safe_phone}.session"
        session_journal = SESSIONS_DIR / f"{safe_phone}.session.journal"
        
        if session_file.exists() or session_journal.exists():
            # Session file exists but account not in database
            # This could be an orphaned session file
            print(f"[Backend] Warning: Session file exists for {phone} but account not in database", file=sys.stderr)
            
            # CRITICAL: Ensure any client using this session is disconnected first
            try:
                await self.telegram_manager.remove_client(phone, wait_for_disconnect=True)
                # Force garbage collection to release file handles
                gc.collect()
                await asyncio.sleep(0.3)  # Give OS time to release file handles
            except Exception as e:
                print(f"[Backend] Warning: Could not remove client for {phone} (may not exist): {e}", file=sys.stderr)
            
            # Now try to delete the orphaned session files
            print(f"[Backend] Deleting orphaned session file: {session_file}", file=sys.stderr)
            session_deleted = await self.safe_delete_session_file(session_file)
            
            if session_journal.exists():
                journal_deleted = await self.safe_delete_session_file(session_journal)
            else:
                journal_deleted = True
            
            if not session_deleted or not journal_deleted:
                # If we can't delete the session file, we should not add the account
                # This prevents database inconsistency
                error_msg = f"æ— æ³•åˆ é™¤å·²å­˜åœ¨çš„ä¼šè¯æ–‡ä»¶ã€‚è¯·ç¡®ä¿æ²¡æœ‰å…¶ä»–ç¨‹åºæ­£åœ¨ä½¿ç”¨è¯¥æ–‡ä»¶ï¼Œç„¶åé‡è¯•ã€‚"
                print(f"[Backend] Cannot delete orphaned session file, aborting account addition", file=sys.stderr)
                self.send_log(error_msg, "error")
                self.send_event("account-validation-error", {
                    "errors": [error_msg],
                    "account_data": payload,
                    "error_type": "file_locked"
                })
                # ğŸ”§ P4-3: å›æ»¾é…é¡é ç•™
                if quota_reserved and owner_user_id:
                    try:
                        quota_service.atomic_commit_or_rollback(owner_user_id, 'tg_accounts', 1, commit=False)
                    except: pass
                return
            
            print(f"[Backend] Orphaned session file deleted successfully", file=sys.stderr)
        
        print(f"[Backend] Adding account to database...", file=sys.stderr)
        
        # Generate device fingerprint for anti-ban (é˜²å°)
        DeviceFingerprintGenerator = get_DeviceFingerprintGenerator()
        device_config = DeviceFingerprintGenerator.generate_for_phone(phone)
        print(f"[Backend] Generated device fingerprint for {phone}: {device_config.get('device_model')} ({device_config.get('platform')})", file=sys.stderr)
        
        # Add device fingerprint to payload
        payload['deviceModel'] = device_config.get('device_model')
        payload['systemVersion'] = device_config.get('system_version')
        payload['appVersion'] = device_config.get('app_version')
        payload['langCode'] = device_config.get('lang_code')
        payload['platform'] = device_config.get('platform')
        payload['deviceId'] = device_config.get('device_id')
        
        # Get proxy country from phone number (if proxy is provided)
        if payload.get('proxy'):
            try:
                PM = get_ProxyManager()
                proxy_country = PM.get_country_from_phone(phone) if PM else None
            except Exception:
                proxy_country = None
            if proxy_country:
                payload['proxyCountry'] = proxy_country
                payload['proxyType'] = 'residential'  # Default to residential proxy
        
        # Ensure status is set to Offline when adding account
        payload['status'] = 'Offline'
        
        account_id = await db.add_account(payload)
        _logger.info(f"[add-account] SUCCESS account_id={account_id}, phone={phone}")
        print(f"[Backend] Account added successfully with ID: {account_id}", file=sys.stderr)
        
        # Double-check: ensure status is Offline (in case of any issues)
        await db.update_account(account_id, {"status": "Offline"})
        print(f"[Backend] Account status set to Offline for {phone}", file=sys.stderr)
        
        # æ›´æ–° API æ†‘æ“šæ± ä½¿ç”¨è¨ˆæ•¸
        api_id = payload.get('apiId')
        if api_id:
            try:
                from api_credential_pool import get_api_credential_pool
                data_dir = str(Path(config.DATA_PATH))
                pool = get_api_credential_pool(data_dir)
                if pool.allocate_credential(api_id):
                    print(f"[Backend] API credential {api_id} usage count incremented", file=sys.stderr)
                    # ç™¼é€æ›´æ–°çš„æ†‘æ“šä¿¡æ¯
                    credentials = pool.list_credentials()
                    self.send_event("api-credentials-updated", {"credentials": credentials})
            except Exception as e:
                print(f"[Backend] Error updating API credential usage: {e}", file=sys.stderr)
        
        # ğŸ”§ åŒæ­¥ API æ± åˆ†é…ï¼ˆå¹³å° APIï¼‰
        if payload.get('usePlatformApi') and api_id:
            try:
                from admin.api_pool import get_api_pool_manager
                api_pool = get_api_pool_manager()
                api_pool.link_allocation_to_account(phone, str(account_id), api_id=api_id)
            except Exception as e:
                print(f"[Backend] Error linking API allocation: {e}", file=sys.stderr)
        
        await db.add_log(f"Account added: {payload.get('phone')}", "success")
        self.send_log(f"è´¦æˆ·æ·»åŠ æˆåŠŸ: {payload.get('phone')}", "success")
        
        # Send updated accounts list (ğŸ”§ å¤šç§Ÿæˆ¶å®‰å…¨)
        await self._send_accounts_updated(owner_user_id)
        
        # ğŸ”§ P4-3: å¸³è™Ÿæ–°å¢æˆåŠŸ â†’ æäº¤é…é¡é ç•™
        if quota_reserved and owner_user_id:
            try:
                from core.quota_service import get_quota_service
                qs = get_quota_service()
                qs.atomic_commit_or_rollback(owner_user_id, 'tg_accounts', 1, commit=True)
                print(f"[Backend] Quota reservation committed for user {owner_user_id}", file=sys.stderr)
            except Exception as e:
                print(f"[Backend] Quota commit error (non-fatal): {e}", file=sys.stderr)
        
        # ğŸ”§ P3-3: å¸³è™Ÿæ–°å¢å¾Œç«‹å³å¤±æ•ˆé…é¡ç·©å­˜
        try:
            from core.quota_service import get_quota_service
            qs = get_quota_service()
            owner_id = payload.get('owner_user_id') or payload.get('ownerUserId')
            if owner_id:
                qs.invalidate_cache(owner_id)
            else:
                qs.invalidate_cache()  # ç„¡æ³•ç¢ºå®šç”¨æˆ¶ï¼Œå…¨é‡å¤±æ•ˆ
            print(f"[Backend] Quota cache invalidated after add-account for user {owner_id}", file=sys.stderr)
        except Exception as e:
            print(f"[Backend] Quota cache invalidation error: {e}", file=sys.stderr)
        
        # ğŸ†• è¿”å›æˆåŠŸçµæœï¼ˆHTTP API æ¨¡å¼éœ€è¦ï¼‰
        return {
            "success": True,
            "account_id": account_id,
            "phone": phone,
            "message": f"è´¦æˆ· {phone} æ·»åŠ æˆåŠŸ"
        }
    
    except ValidationError as e:
        import sys
        # ğŸ”§ P4-3: å¸³è™Ÿæ–°å¢å¤±æ•— â†’ å›æ»¾é…é¡é ç•™
        if quota_reserved and owner_user_id:
            try:
                from core.quota_service import get_quota_service
                qs = get_quota_service()
                qs.atomic_commit_or_rollback(owner_user_id, 'tg_accounts', 1, commit=False)
                print(f"[Backend] Quota reservation rolled back for user {owner_user_id}", file=sys.stderr)
            except Exception as qe:
                print(f"[Backend] Quota rollback error: {qe}", file=sys.stderr)
        
        print(f"[Backend] ValidationError: {e.message}", file=sys.stderr)
        self.send_log(f"éªŒè¯é”™è¯¯: {e.message}", "error")
        self.send_event("account-validation-error", {
            "errors": [e.message],
            "field": e.field
        })
    except ValueError as e:
        # Handle specific errors like duplicate phone number
        import sys
        import logging as _log2
        _log2.getLogger('backend.add_account').error(f"[add-account] ValueError: {e}")
        # ğŸ”§ P4-3: å¸³è™Ÿæ–°å¢å¤±æ•— â†’ å›æ»¾é…é¡é ç•™
        if quota_reserved and owner_user_id:
            try:
                from core.quota_service import get_quota_service
                qs = get_quota_service()
                qs.atomic_commit_or_rollback(owner_user_id, 'tg_accounts', 1, commit=False)
                print(f"[Backend] Quota reservation rolled back for user {owner_user_id}", file=sys.stderr)
            except Exception as qe:
                print(f"[Backend] Quota rollback error: {qe}", file=sys.stderr)
        
        error_msg = str(e)
        print(f"[Backend] ValueError adding account: {error_msg}", file=sys.stderr)
        self.send_log(error_msg, "error")
        self.send_event("account-validation-error", {
            "errors": [error_msg],
            "account_data": payload,
            "error_type": "duplicate" if "å·²å­˜åœ¨" in error_msg else "validation"
        })
    except Exception as e:
        import sys
        # ğŸ”§ P4-3: å¸³è™Ÿæ–°å¢å¤±æ•— â†’ å›æ»¾é…é¡é ç•™
        if quota_reserved and owner_user_id:
            try:
                from core.quota_service import get_quota_service
                qs = get_quota_service()
                qs.atomic_commit_or_rollback(owner_user_id, 'tg_accounts', 1, commit=False)
                print(f"[Backend] Quota reservation rolled back for user {owner_user_id}", file=sys.stderr)
            except Exception as qe:
                print(f"[Backend] Quota rollback error: {qe}", file=sys.stderr)
        
        error_msg = str(e)
        import logging as _log3
        _log3.getLogger('backend.add_account').error(f"[add-account] Exception: {error_msg}")
        print(f"[Backend] Exception adding account: {error_msg}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
        
        # Provide user-friendly error message
        if "UNIQUE constraint failed: accounts.phone" in error_msg or "phone" in error_msg.lower():
            friendly_msg = f"è´¦æˆ·å·²å­˜åœ¨: ç”µè¯å·ç  {payload.get('phone', '')} å·²ç»åœ¨ç³»ç»Ÿä¸­ã€‚å¦‚éœ€æ›´æ–°è´¦æˆ·ä¿¡æ¯ï¼Œè¯·ä½¿ç”¨æ›´æ–°åŠŸèƒ½ã€‚"
        else:
            friendly_msg = f"æ·»åŠ è´¦æˆ·å¤±è´¥: {error_msg}"
        
        self.send_log(friendly_msg, "error")
        self.send_event("account-validation-error", {
            "errors": [friendly_msg],
            "account_data": payload,
            "error_type": "duplicate" if "å·²å­˜åœ¨" in friendly_msg else "error"
        })
        handle_error(e, {"command": "add-account", "payload": payload})


async def handle_send_code(self, payload: Dict[str, Any]):
    """
    Handle send-code command - ç™¼é€é©—è­‰ç¢¼
    
    é€™æ˜¯ç¨ç«‹çš„é©—è­‰ç¢¼ç™¼é€å‘½ä»¤ï¼Œç”¨æ–¼ SaaS ç‰ˆæœ¬
    """
    try:
        import sys
        print(f"[Backend] handle_send_code called with payload: {payload}", file=sys.stderr)
        
        phone = payload.get('phone', '').strip()
        api_id = payload.get('api_id') or payload.get('apiId')
        api_hash = payload.get('api_hash') or payload.get('apiHash')
        proxy = payload.get('proxy')
        two_factor_password = payload.get('twoFactorPassword') or payload.get('two_factor_password')
        
        if not phone:
            self.send_event("send-code-error", {
                "success": False,
                "error": "é›»è©±è™Ÿç¢¼ä¸èƒ½ç‚ºç©º"
            })
            return
        
        # å¦‚æœæ²’æœ‰æä¾› API ID/Hashï¼Œå˜—è©¦ä½¿ç”¨æ¨è–¦çš„æ†‘è­‰
        if not api_id or not api_hash:
            try:
                from api_credential_pool import get_api_credential_pool
                data_dir = str(Path(config.DATA_PATH))
                pool = get_api_credential_pool(data_dir)
                recommended = pool.get_recommended_credential()
                if recommended:
                    api_id = api_id or recommended.get('api_id')
                    api_hash = api_hash or recommended.get('api_hash')
                    print(f"[Backend] Using recommended credential: {api_id}", file=sys.stderr)
            except Exception as e:
                print(f"[Backend] Could not get recommended credential: {e}", file=sys.stderr)
        
        if not api_id or not api_hash:
            self.send_event("send-code-error", {
                "success": False,
                "error": "è«‹æä¾› API ID å’Œ API Hashï¼Œæˆ–åœ¨ API æ†‘è­‰æ± ä¸­æ·»åŠ æ†‘è­‰"
            })
            return
        
        # ä½¿ç”¨ TelegramManager ç™¼é€é©—è­‰ç¢¼
        print(f"[Backend] Sending verification code to {phone}...", file=sys.stderr)
        
        result = await self.telegram_manager.login_account(
            phone=phone,
            api_id=api_id,
            api_hash=api_hash,
            proxy=proxy,
            two_factor_password=two_factor_password
        )
        
        if result.get('success'):
            # é©—è­‰ç¢¼å·²ç™¼é€
            self.send_log(result.get('message', f"é©—è­‰ç¢¼å·²ç™¼é€åˆ° {phone}"), "success")
            response = {
                "success": True,
                "phone": phone,
                "status": result.get('status', 'waiting_code'),
                "message": result.get('message'),
                "send_type": result.get('send_type', 'unknown'),
                "requires_code": result.get('requires_code', True),
                "phone_code_hash": result.get('phone_code_hash')
            }
            self.send_event("send-code-result", response)
            return response
        else:
            # ç™¼é€å¤±æ•—
            error_msg = result.get('message', 'ç™¼é€é©—è­‰ç¢¼å¤±æ•—')
            self.send_log(error_msg, "error")
            response = {
                "success": False,
                "phone": phone,
                "error": error_msg,
                "status": result.get('status', 'error')
            }
            self.send_event("send-code-error", response)
            return response
            
    except Exception as e:
        import traceback
        print(f"[Backend] Error in handle_send_code: {e}", file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        self.send_log(f"ç™¼é€é©—è­‰ç¢¼å¤±æ•—: {str(e)}", "error")
        response = {
            "success": False,
            "error": str(e)
        }
        self.send_event("send-code-error", response)
        return response


async def handle_login_account(self, payload: Any):
    """Handle login-account command with Pyrogram"""
    try:
        import sys
        import logging
        _logger = logging.getLogger('backend.login_account')
        _logger.info(f"[login-account] START payload_keys={list(payload.keys()) if isinstance(payload, dict) else type(payload)}, phone={payload.get('phone') if isinstance(payload, dict) else 'N/A'}")
        print(f"[Backend] handle_login_account called with payload: {payload}", file=sys.stderr)
        
        # Payload can be account_id (int) or dict with account_id and login details
        if isinstance(payload, int):
            account_id = payload
            account = await db.get_account(account_id)
            phone_code = None
            phone_code_hash = None
            two_factor_password = None
        else:
            account_id = payload.get('accountId')
            phone_code = payload.get('phoneCode')
            phone_code_hash = payload.get('phoneCodeHash')
            two_factor_password = payload.get('twoFactorPassword')
            
            # Try to get account by ID first, then by phone number
            if account_id:
                account = await db.get_account(account_id)
            else:
                # If no accountId provided, try to find by phone number
                phone_from_payload = payload.get('phone')
                if phone_from_payload:
                    account = await db.get_account_by_phone(phone_from_payload)
                    if account:
                        account_id = account.get('id')
                        print(f"[Backend] Found account by phone {phone_from_payload}, ID: {account_id}", file=sys.stderr)
                else:
                    account = None
        
        if not account:
            error_msg = f"Account {account_id} not found"
            _logger.warning(f"[login-account] ACCOUNT NOT FOUND account_id={account_id}, phone={payload.get('phone') if isinstance(payload, dict) else 'N/A'}")
            print(f"[Backend] {error_msg}", file=sys.stderr)
            self.send_log(error_msg, "error")
            return {
                "success": False,
                "error": error_msg,
                "phone": payload.get('phone', '') if isinstance(payload, dict) else ''
            }
        
        phone = account.get('phone')
        current_status = account.get('status', 'Offline')
        _logger.info(f"[login-account] FOUND account_id={account_id}, phone={phone}, status={current_status}, apiId={account.get('apiId')}, hasApiHash={'yes' if account.get('apiHash') else 'no'}")
        print(f"[Backend] Found account: {phone}, API ID: {account.get('apiId')}, API Hash: {'***' if account.get('apiHash') else 'None'}", file=sys.stderr)
        
        # CRITICAL: If account is already Online and no verification code is being submitted,
        # skip login to prevent database lock and unnecessary operations
        if current_status == 'Online' and not phone_code:
            print(f"[Backend] Account {phone} is already Online, skipping login", file=sys.stderr)
            # Just verify the account is still valid
            try:
                status_result = await self.telegram_manager.check_account_status(phone)
                if status_result.get('online'):
                    print(f"[Backend] Account {phone} verified online", file=sys.stderr)
                    return {
                        "success": True,
                        "status": "Online",
                        "logged_in": True,
                        "phone": phone,
                        "account_id": account_id,
                        "message": f"å¸³è™Ÿ {phone} å·²åœ¨ç·š"
                    }
            except Exception as e:
                print(f"[Backend] Error checking account status: {e}, will proceed with login", file=sys.stderr)
        
        # CRITICAL: If account is in 'Waiting Code' status and we're NOT submitting a code,
        # just return the existing hash (don't resend code)
        if current_status == 'Waiting Code' and not phone_code:
            if phone in self.telegram_manager.login_callbacks:
                existing_hash = self.telegram_manager.login_callbacks[phone].get("phone_code_hash")
                if existing_hash:
                    existing_send_type = self.telegram_manager.login_callbacks[phone].get("send_type", "app")
                    print(f"[Backend] Account {phone} already waiting for code, returning existing hash", file=sys.stderr)
                    self.send_event("login-requires-code", {
                        "accountId": account_id,
                        "phone": phone,
                        "phoneCodeHash": existing_hash,
                        "sendType": existing_send_type,
                        "message": "éªŒè¯ç å·²å‘é€ï¼Œè¯·åœ¨ Telegram åº”ç”¨ä¸­æŸ¥çœ‹",
                        "canRetrySMS": False
                    })
                    return {
                        "success": True,
                        "requires_code": True,
                        "phone": phone,
                        "phone_code_hash": existing_hash,
                        "send_type": existing_send_type,
                        "message": "éªŒè¯ç å·²å‘é€ï¼Œè¯·åœ¨ Telegram åº”ç”¨ä¸­æŸ¥çœ‹"
                    }
            print(f"[Backend] Account {phone} status is 'Waiting Code' but no callback found, will resend code", file=sys.stderr)
        
        # Update status to "Logging in..."
        await db.update_account(account_id, {"status": "Logging in..."})
        # ğŸ”§ å¤šç§Ÿæˆ¶å®‰å…¨
        _login_owner = account.get('owner_user_id')
        await self._send_accounts_updated(_login_owner)
        
        self.send_log(f"Login initiated for account {phone}", "info")
        print(f"[Backend] Status updated to 'Logging in...', calling telegram_manager.login_account", file=sys.stderr)
        
        # Login with Pyrogram (ä½¿ç”¨è®¾å¤‡æŒ‡çº¹é˜²å°)
        print(f"[Backend] Calling telegram_manager.login_account for {phone}", file=sys.stderr)
        
        # Get device fingerprint from account (if exists) or generate new one
        device_model = account.get('deviceModel')
        system_version = account.get('systemVersion')
        app_version = account.get('appVersion')
        lang_code = account.get('langCode')
        platform = account.get('platform')
        
        # If device fingerprint not in account, generate it (for existing accounts)
        if not device_model or not system_version or not app_version:
            DeviceFingerprintGenerator = get_DeviceFingerprintGenerator()
            device_config = DeviceFingerprintGenerator.generate_for_phone(phone, prefer_platform=platform)
            device_model = device_model or device_config.get('device_model')
            system_version = system_version or device_config.get('system_version')
            app_version = app_version or device_config.get('app_version')
            lang_code = lang_code or device_config.get('lang_code')
            platform = platform or device_config.get('platform')
            
            # Update account with device fingerprint
            await db.update_account(account_id, {
                'deviceModel': device_model,
                'systemVersion': system_version,
                'appVersion': app_version,
                'langCode': lang_code,
                'platform': platform,
                'deviceId': device_config.get('device_id')
            })
            print(f"[Backend] Generated and saved device fingerprint for {phone}: {device_model} ({platform})", file=sys.stderr)
        
        _logger.info(f"[login-account] CALLING telegram_manager.login_account phone={phone}, proxy={account.get('proxy')}, apiId={account.get('apiId')}")
        result = await self.telegram_manager.login_account(
            phone=phone,
            api_id=account.get('apiId'),
            api_hash=account.get('apiHash'),
            proxy=account.get('proxy'),
            two_factor_password=two_factor_password or account.get('twoFactorPassword'),
            phone_code=phone_code,
            phone_code_hash=phone_code_hash,
            # Device fingerprint parameters (é˜²å°)
            device_model=device_model,
            system_version=system_version,
            app_version=app_version,
            lang_code=lang_code,
            platform=platform
        )
        
        _logger.info(f"[login-account] RESULT success={result.get('success')}, requires_code={result.get('requires_code')}, requires_2fa={result.get('requires_2fa')}, status={result.get('status')}, message={str(result.get('message', ''))[:100]}")
        print(f"[Backend] login_account result: success={result.get('success')}, requires_code={result.get('requires_code')}, requires_2fa={result.get('requires_2fa')}", file=sys.stderr)
        
        if result.get('success'):
            if result.get('requires_code'):
                # Need verification code
                phone_code_hash = result.get('phone_code_hash')
                send_type = result.get('send_type', 'unknown')
                next_type = result.get('next_type')
                message = result.get('message', f"éªŒè¯ç å·²å‘é€åˆ° {phone}")
                
                print(f"[Backend] Sending login-requires-code event for account {account_id} (phone: {phone}), phone_code_hash: {phone_code_hash[:8] if phone_code_hash else 'None'}...", file=sys.stderr)
                print(f"[Backend] Code send type: {send_type}, next_type: {next_type}, message: {message}", file=sys.stderr)
                
                # Check if we can retry for SMS (if previous was app and enough time has passed)
                can_retry_sms = result.get('canRetrySMS', False) or result.get('can_retry_sms', False)
                wait_seconds = result.get('waitSeconds', None)
                
                event_data = {
                    "accountId": account_id,
                    "phone": phone,
                    "phoneCodeHash": phone_code_hash,
                    "sendType": send_type,  # Include send type
                    "nextType": next_type,  # Include next type
                    "message": message,  # Include message
                    "canRetrySMS": can_retry_sms,  # Include canRetrySMS flag
                    "waitSeconds": wait_seconds  # Include wait seconds if available
                }
                self.send_event("login-requires-code", event_data)
                print(f"[Backend] login-requires-code event sent successfully", file=sys.stderr)
                # State: Requesting Code -> Waiting Code
                await db.update_account(account_id, {"status": "Waiting Code"})
                print(f"[Backend] Account status updated to 'Waiting Code'", file=sys.stderr)
                # ğŸ†• è¿”å›çµæœï¼ˆHTTP API æ¨¡å¼éœ€è¦ï¼‰
                return {
                    "success": True,
                    "requires_code": True,
                    "phone": phone,
                    "phone_code_hash": phone_code_hash,
                    "send_type": send_type,
                    "message": message
                }
            elif result.get('requires_2fa'):
                # Need 2FA password
                self.send_event("login-requires-2fa", {
                    "accountId": account_id,
                    "phone": phone
                })
                await db.update_account(account_id, {"status": "Waiting 2FA"})
                # ğŸ†• è¿”å›çµæœï¼ˆHTTP API æ¨¡å¼éœ€è¦ï¼‰
                return {
                    "success": True,
                    "requires_2fa": True,
                    "phone": phone,
                    "message": "éœ€è¦äºŒæ­¥é©—è­‰å¯†ç¢¼"
                }
            else:
                # Successfully logged in
                await db.update_account(account_id, {"status": result.get('status', 'Online')})
                await db.add_account_event(account_id, "login", None)
                self.send_log(f"Account {phone} logged in successfully", "success")
                
                # ğŸ”§ P1: ç²å–ç”¨æˆ¶è³‡æ–™ï¼ˆè·³é bio é¿å… FloodWaitï¼‰
                try:
                    full_profile = await self.telegram_manager.get_full_user_profile(phone, download_avatar=True, skip_bio=True)
                    if full_profile.get('success'):
                        # ä¿å­˜ç”¨æˆ¶ä¿¡æ¯åˆ°æ•¸æ“šåº«
                        await db.update_account(account_id, {
                            "firstName": full_profile.get('firstName', ''),
                            "lastName": full_profile.get('lastName', ''),
                            "username": full_profile.get('username', ''),
                            "bio": full_profile.get('bio', ''),
                            "avatarPath": full_profile.get('avatarPath', ''),
                            "telegramId": full_profile.get('id', '')
                        })
                        print(f"[Backend] Full profile saved for {phone}: {full_profile.get('firstName')} @{full_profile.get('username')}", file=sys.stderr)
                except Exception as profile_err:
                    print(f"[Backend] Could not get full profile for {phone}: {profile_err}", file=sys.stderr)
                
                # ç²å–å¸³è™Ÿä¿¡æ¯
                account = await db.get_account(account_id)
                account_role = account.get('role', 'Unassigned')
                
                # ========== æ™ºèƒ½è§’è‰²åˆ†é… ==========
                # å¦‚æœå¸³è™Ÿæœªåˆ†é…è§’è‰²ï¼Œæ ¹æ“šç¾æœ‰å¸³è™Ÿæƒ…æ³è‡ªå‹•åˆ†é…
                if account_role == 'Unassigned':
                    all_accounts = await db.get_all_accounts()
                    has_listener = any(a.get('role') == 'Listener' for a in all_accounts)
                    has_sender = any(a.get('role') == 'Sender' for a in all_accounts)
                    
                    new_role = None
                    role_message = None
                    
                    if not has_listener:
                        # å„ªå…ˆåˆ†é…ç‚ºç›£æ§è™Ÿ
                        new_role = 'Listener'
                        role_message = f'å·²è‡ªå‹•å°‡ {phone} è¨­ç‚ºã€Œç›£æ§è™Ÿã€ï¼ˆç”¨æ–¼ç›£æ§ç¾¤çµ„æ¶ˆæ¯ï¼‰'
                    elif not has_sender:
                        # å…¶æ¬¡åˆ†é…ç‚ºç™¼é€è™Ÿ
                        new_role = 'Sender'
                        role_message = f'å·²è‡ªå‹•å°‡ {phone} è¨­ç‚ºã€Œç™¼é€è™Ÿã€ï¼ˆç”¨æ–¼ç™¼é€æ¶ˆæ¯çµ¦æ½›åœ¨å®¢æˆ¶ï¼‰'
                    
                    if new_role:
                        await db.update_account(account_id, {"role": new_role})
                        account_role = new_role
                        self.send_log(f"ğŸ¯ {role_message}", "success")
                        print(f"[Backend] Auto-assigned role {new_role} to account {phone}", file=sys.stderr)
                    else:
                        self.send_log(f"ğŸ’¡ å¸³è™Ÿ {phone} å·²ç™»å…¥ï¼Œè«‹åœ¨å¸³è™Ÿç®¡ç†ä¸­åˆ†é…è§’è‰²", "info")
                # ========== æ™ºèƒ½è§’è‰²åˆ†é…çµæŸ ==========

                # ç™¼é€ç™»å…¥æˆåŠŸäº‹ä»¶çµ¦å‰ç«¯ï¼ˆåŒ…å«å®Œæ•´ä¿¡æ¯ï¼‰
                user_info = result.get('user_info', {})
                self.send_event("login-success", {
                    "accountId": account_id,
                    "phone": phone,
                    "status": "Online",
                    "role": account_role,  # åŒ…å«è§’è‰²ä¿¡æ¯
                    "message": f"å¸³è™Ÿ {phone} ç™»å…¥æˆåŠŸ",
                    "userInfo": {
                        "phone": phone,
                        "firstName": account.get('firstName') or user_info.get('first_name', ''),
                        "lastName": account.get('lastName') or user_info.get('last_name', ''),
                        "username": account.get('username') or user_info.get('username', ''),
                        "id": account.get('telegramId') or user_info.get('id', ''),
                        "bio": account.get('bio', ''),
                        "avatarPath": account.get('avatarPath', '')
                    }
                })
                print(f"[Backend] login-success event sent for account {account_id} ({phone}), role={account_role}", file=sys.stderr)
                
                # === P0: ä¿å­˜ Session Metadata ===
                try:
                    await self._save_session_metadata(phone, {
                        'phone': phone,
                        'apiId': account.get('apiId'),
                        'apiHash': account.get('apiHash'),
                        'firstName': account.get('firstName') or user_info.get('first_name', ''),
                        'lastName': account.get('lastName') or user_info.get('last_name', ''),
                        'username': account.get('username') or user_info.get('username', ''),
                        'telegramId': str(account.get('telegramId') or user_info.get('id', '')),
                        'role': account_role,
                        'created_at': datetime.now().isoformat()
                    })
                    print(f"[Backend] Session metadata saved for {phone}", file=sys.stderr)
                except Exception as e:
                    print(f"[Backend] Error saving session metadata: {e}", file=sys.stderr)
                
                # åˆ·æ–° API æ†‘æ“šåˆ—è¡¨ï¼ˆç¢ºä¿ç¶å®šå¸³è™Ÿæ•¸æ“šæ­£ç¢ºï¼‰
                try:
                    await self.handle_get_api_credentials({})
                except Exception as e:
                    print(f"[Backend] Error refreshing API credentials after login: {e}", file=sys.stderr)
                
                # ç‚ºæ‰€æœ‰å¸³è™Ÿè¨»å†Šç§ä¿¡è™•ç†å™¨ï¼ˆè™•ç†ç”¨æˆ¶å›å¾©ï¼‰
                try:
                    await self.telegram_manager.register_private_message_handler(
                        phone=phone,
                        account_role=account_role
                    )
                    self.send_log(f"å·²ç‚ºå¸³è™Ÿ {phone} ({account_role}) è¨»å†Šç§ä¿¡è™•ç†å™¨", "success")
                except Exception as e:
                        self.send_log(f"è¨»å†Šç§ä¿¡è™•ç†å™¨å¤±æ•—: {e}", "warning")
                
                # Start Warmup if enabled and not already started (é˜²å°)
                warmup_enabled = account.get('warmupEnabled', False)
                warmup_start_date = account.get('warmupStartDate')
                
                if warmup_enabled and not warmup_start_date:
                    # Start Warmup (datetime å·²åœ¨æ–‡ä»¶é ‚éƒ¨å…¨å±€å°å…¥)
                    _WarmupManager = get_WarmupManager()
                    warmup_info = _WarmupManager.start_warmup(account_id, datetime.now())
                    
                    await db.update_account(account_id, {
                        'warmupStartDate': warmup_info['warmup_start_date'],
                        'warmupStage': warmup_info['warmup_stage'],
                        'warmupDaysCompleted': 0
                    })
                    
                    stage_info = warmup_info['current_stage_info']
                    self.send_log(
                        f"è´¦æˆ· {phone} Warmup å·²å¯åŠ¨: {stage_info.get('stage_name')} "
                        f"(æ¯æ—¥é™åˆ¶: {stage_info.get('daily_limit')} æ¡)",
                        "info"
                    )
                    print(f"[Backend] Warmup started for {phone}: Stage {stage_info.get('stage')} - {stage_info.get('stage_name')}", file=sys.stderr)
                elif warmup_enabled and warmup_start_date:
                    # Update Warmup progress
                    _WarmupManager = get_WarmupManager()
                    warmup_progress = _WarmupManager.get_warmup_progress(account)
                    if warmup_progress.get('enabled') and warmup_progress.get('stage'):
                        stage_info = warmup_progress['stage']
                        await db.update_account(account_id, {
                            'warmupStage': stage_info.get('stage'),
                            'warmupDaysCompleted': stage_info.get('days_completed', 0)
                        })
                        print(f"[Backend] Warmup progress updated for {phone}: Stage {stage_info.get('stage')} - {stage_info.get('stage_name')}, Days: {stage_info.get('days_completed')}", file=sys.stderr)
                
                # ğŸ”§ é—œéµä¿®å¾©ï¼šç™»å…¥æˆåŠŸå¾Œç™¼é€ accounts-updated äº‹ä»¶æ›´æ–°å‰ç«¯ç‹€æ…‹ï¼ˆå¤šç§Ÿæˆ¶å®‰å…¨ï¼‰
                await self._send_accounts_updated(account.get('owner_user_id'))
                
                # ğŸ†• è¿”å›çµæœï¼ˆHTTP API æ¨¡å¼éœ€è¦ï¼‰
                return {
                    "success": True,
                    "status": "Online",
                    "phone": phone,
                    "account_id": account_id,
                    "user_info": {
                        "phone": phone,
                        "firstName": account.get('firstName') or user_info.get('first_name', ''),
                        "lastName": account.get('lastName') or user_info.get('last_name', ''),
                        "username": account.get('username') or user_info.get('username', '')
                    }
                }
        else:
            # Login failed
            import sys
            error_status = result.get('status', 'Error')
            error_message = result.get('message', 'æœªçŸ¥é”™è¯¯')
            flood_wait = result.get('flood_wait')
            
            print(f"[Backend] Login failed for {phone}: status={error_status}, message={error_message}", file=sys.stderr)
            
            # Handle FloodWait
            if flood_wait:
                friendly_msg = f'è´¦æˆ· {phone} ç™»å½•å¤±è´¥ï¼šè¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç­‰å¾… {flood_wait} ç§’åé‡è¯•ã€‚'
                self.send_event("account-login-error", {
                    "accountId": account_id,
                    "phone": phone,
                    "status": error_status,
                    "message": error_message,
                    "friendlyMessage": friendly_msg,
                    "floodWait": flood_wait
                })
                await db.update_account(account_id, {"status": "Offline"})
                # ğŸ†• è¿”å›çµæœï¼ˆHTTP API æ¨¡å¼éœ€è¦ï¼‰
                return {
                    "success": False,
                    "error": friendly_msg,
                    "flood_wait": flood_wait,
                    "phone": phone
                }
            
            await db.update_account(account_id, {"status": error_status})
            
            # Provide user-friendly error message
            if "API ID and API Hash are required" in error_message:
                friendly_msg = f"è´¦æˆ· {phone} ç™»å½•å¤±è´¥ï¼šAPI ID æˆ– API Hash æœªå¡«å†™ã€‚è¯·åœ¨è´¦æˆ·ç®¡ç†ä¸­å¡«å†™æ­£ç¡®çš„ API å‡­è¯ã€‚"
            elif "Invalid verification code" in error_message or "PhoneCodeInvalid" in error_message or "PHONE_CODE_INVALID" in error_message.upper():
                friendly_msg = f"è´¦æˆ· {phone} ç™»å½•å¤±è´¥ï¼šéªŒè¯ç é”™è¯¯ã€‚è¯·æ£€æŸ¥éªŒè¯ç æ˜¯å¦æ­£ç¡®ï¼Œç„¶åé‡æ–°è¾“å…¥ã€‚"
                # Keep the login state so user can retry
                # Don't close the dialog, let user try again
            elif "code expired" in error_message.lower() or "PHONE_CODE_EXPIRED" in error_message.upper() or result.get('code_expired'):
                friendly_msg = f'è´¦æˆ· {phone} ç™»å½•å¤±è´¥ï¼šéªŒè¯ç å·²è¿‡æœŸã€‚è¯·ç‚¹å‡»"é‡æ–°å‘é€"è·å–æ–°çš„éªŒè¯ç ã€‚'
                # Non-recoverable error: State: Logging in... -> Offline (need to restart)
                await db.update_account(account_id, {"status": "Offline"})
                # Clear login callbacks
                self.telegram_manager.login_callbacks.pop(phone, None)
                # Mark as code expired so frontend can handle it
                self.send_event("account-login-error", {
                    "accountId": account_id,
                    "phone": phone,
                    "status": "Offline",
                    "message": error_message,
                    "friendlyMessage": friendly_msg,
                    "codeExpired": True
                })
                # Don't send duplicate error event below
                await self._send_accounts_updated(account.get('owner_user_id'))
                return {
                    "success": False,
                    "error": friendly_msg,
                    "phone": phone,
                    "code_expired": True,
                    "codeExpired": True
                }
            elif "hash mismatch" in error_message.lower() or "hash" in error_message.lower() and "mismatch" in error_message.lower():
                friendly_msg = f'è´¦æˆ· {phone} ç™»å½•å¤±è´¥ï¼šéªŒè¯ç å“ˆå¸Œä¸åŒ¹é…ã€‚è¿™é€šå¸¸æ˜¯å› ä¸ºå®¢æˆ·ç«¯è¢«é‡æ–°åˆ›å»ºã€‚è¯·ç‚¹å‡»"é‡æ–°å‘é€"è·å–æ–°çš„éªŒè¯ç ã€‚'
                # Non-recoverable error: State: Logging in... -> Offline (need to restart)
                await db.update_account(account_id, {"status": "Offline"})
                # Clear login callbacks
                self.telegram_manager.login_callbacks.pop(phone, None)
                # Mark as code expired so frontend can handle it
                self.send_event("account-login-error", {
                    "accountId": account_id,
                    "phone": phone,
                    "status": "Offline",
                    "message": error_message,
                    "friendlyMessage": friendly_msg,
                    "codeExpired": True
                })
                await self._send_accounts_updated(account.get('owner_user_id'))
                return {
                    "success": False,
                    "error": friendly_msg,
                    "phone": phone,
                    "code_expired": True,
                    "codeExpired": True
                }
            elif "Invalid 2FA password" in error_message or "2FA" in error_message and "password" in error_message.lower():
                friendly_msg = f"å¸³è™Ÿ {phone} ç™»å…¥å¤±æ•—ï¼šäºŒæ­¥é©—è­‰å¯†ç¢¼éŒ¯èª¤ã€‚è«‹æª¢æŸ¥å¯†ç¢¼å¾Œé‡è©¦ã€‚"
            elif "2FA verification timeout" in error_message or ("2FA" in error_message and "timeout" in error_message.lower()):
                friendly_msg = f"å¸³è™Ÿ {phone} ç™»å…¥å¤±æ•—ï¼šäºŒæ­¥é©—è­‰è¶…æ™‚ã€‚è«‹æª¢æŸ¥ç¶²çµ¡é€£æ¥å¾Œé‡è©¦ã€‚"
            elif "Flood wait" in error_message or "FLOOD_WAIT" in error_message.upper() or result.get('flood_wait'):
                wait_time = result.get('flood_wait', 0)
                friendly_msg = f"è´¦æˆ· {phone} ç™»å½•å¤±è´¥ï¼šè¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç­‰å¾… {wait_time} ç§’åé‡è¯•ã€‚"
            elif "Invalid phone number" in error_message or "PHONE_NUMBER_INVALID" in error_message.upper():
                friendly_msg = f"è´¦æˆ· {phone} ç™»å½•å¤±è´¥ï¼šç”µè¯å·ç æ ¼å¼ä¸æ­£ç¡®ã€‚è¯·ç¡®ä¿æ ¼å¼ä¸º +å›½å®¶ä»£ç +å·ç ã€‚"
            elif "è¶…æ™‚" in error_message or "timeout" in error_message.lower():
                friendly_msg = f"è´¦æˆ· {phone} ç™»å½•å¤±è´¥ï¼šè¿æ¥è¶…æ—¶ã€‚è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ä»£ç†è®¾ç½®åé‡è¯•ã€‚"
                # Non-recoverable error: State: Logging in... -> Offline (need to restart)
                await db.update_account(account_id, {"status": "Offline"})
                # Clear login callbacks
                self.telegram_manager.login_callbacks.pop(phone, None)
            elif "Proxy" in error_message or "proxy" in error_message.lower():
                friendly_msg = f"è´¦æˆ· {phone} ç™»å½•å¤±è´¥ï¼šä»£ç†è¿æ¥é”™è¯¯ã€‚è¯·æ£€æŸ¥ä»£ç†é…ç½®æˆ–æš‚æ—¶ç§»é™¤ä»£ç†ã€‚"
            elif "Connection" in error_message or "connection" in error_message.lower():
                friendly_msg = f"è´¦æˆ· {phone} ç™»å½•å¤±è´¥ï¼šç½‘ç»œè¿æ¥é”™è¯¯ã€‚è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ä»£ç†è®¾ç½®ã€‚"
            elif "Client connection lost" in error_message or "No valid client" in error_message:
                friendly_msg = f'è´¦æˆ· {phone} ç™»å½•å¤±è´¥ï¼šå®¢æˆ·ç«¯è¿æ¥ä¸¢å¤±ã€‚è¯·ç‚¹å‡»"é‡æ–°å‘é€"è·å–æ–°çš„éªŒè¯ç ã€‚'
                # Non-recoverable error: State: Logging in... -> Offline (need to restart)
                await db.update_account(account_id, {"status": "Offline"})
                # Clear login callbacks
                self.telegram_manager.login_callbacks.pop(phone, None)
                # Mark as code expired so frontend can handle it
                self.send_event("account-login-error", {
                    "accountId": account_id,
                    "phone": phone,
                    "status": "Offline",
                    "message": error_message,
                    "friendlyMessage": friendly_msg,
                    "codeExpired": True
                })
                await self._send_accounts_updated(account.get('owner_user_id'))
                return {
                    "success": False,
                    "error": friendly_msg,
                    "phone": phone,
                    "code_expired": True,
                    "codeExpired": True
                }
            else:
                friendly_msg = f"è´¦æˆ· {phone} ç™»å½•å¤±è´¥ï¼š{error_message}"
            
            self.send_log(friendly_msg, "error")
            
            # Also send a specific error event for frontend
            self.send_event("account-login-error", {
                "accountId": account_id,
                "phone": phone,
                "status": error_status,
                "message": error_message,
                "friendlyMessage": friendly_msg
            })
            
            # ğŸ†• è¿”å›éŒ¯èª¤çµæœï¼ˆHTTP API æ¨¡å¼éœ€è¦ï¼‰
            return {
                "success": False,
                "error": friendly_msg,
                "phone": phone,
                "status": error_status
            }
        
        # Update accounts list
        await self._send_accounts_updated()
    
    except Exception as e:
        import sys
        import traceback
        error_msg = f"Error logging in account: {str(e)}"
        print(f"[Backend] {error_msg}", file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        self.send_log(error_msg, "error")
        return {
            "success": False,
            "error": f"ç™»å½•å¤±è´¥ï¼š{str(e)}",
            "phone": payload.get('phone', '') if isinstance(payload, dict) else ''
        }


# ===================== End Credential Scraper Handlers =====================

async def handle_check_account_status(self, payload: int):
    """Handle check-account-status command with Pyrogram"""
    try:
        account_id = payload
        account = await db.get_account(account_id)
        
        if not account:
            self.send_log(f"è´¦æˆ· ID {account_id} ä¸å­˜åœ¨ã€‚æ— æ³•æ£€æŸ¥çŠ¶æ€ã€‚", "error")
            return
        
        phone = account.get('phone')
        
        # Check status with Pyrogram
        status_result = await self.telegram_manager.check_account_status(phone)
        
        # Update database
        await db.update_account(account_id, {"status": status_result.get('status', 'Offline')})
        
        # Send status update event
        status_info = {
            "accountId": account_id,
            "status": status_result.get('status', 'Offline'),
            "online": status_result.get('online', False),
            "message": status_result.get('message', ''),
            "user": status_result.get('user')
        }
        
        self.send_event("account-status-updated", status_info)
        
        # Update accounts list
        await self._send_accounts_updated()
    
    except Exception as e:
        self.send_log(f"Error checking account status: {str(e)}", "error")


async def handle_update_account_data(self, payload: Dict[str, Any]):
    """Handle update-account-data command"""
    try:
        account_id = payload.get('id')
        updates = payload.get('updates', {})
        await db.update_account(account_id, updates)
        
        await self._send_accounts_updated()
        await db.add_log(f"Account {account_id} updated", "success")
    
    except Exception as e:
        self.send_log(f"Error updating account: {str(e)}", "error")


async def handle_update_account(self, payload: Dict[str, Any]):
    """Handle update-account command - å®Œæ•´å¸³è™Ÿç·¨è¼¯"""
    try:
        import sys
        account_id = payload.get('id')
        phone = payload.get('phone')
        
        if not account_id:
            self.send_event("update-account-result", {"success": False, "error": "ç¼ºå°‘å¸³è™Ÿ ID"})
            return

        # æ§‹å»ºæ›´æ–°æ•¸æ“š
        update_data = {}
        
        # åŸºæœ¬è¨­ç½®
        if 'nickname' in payload:
            update_data['nickname'] = payload['nickname']
        if 'notes' in payload:
            update_data['notes'] = payload['notes']
        if 'dailySendLimit' in payload:
            update_data['dailySendLimit'] = payload['dailySendLimit']
        if 'group' in payload:
            update_data['group'] = payload['group']
        if 'enableWarmup' in payload:
            update_data['enableWarmup'] = 1 if payload['enableWarmup'] else 0

        # API å‡­è¯ï¼ˆæ•°æ®åº“å­—æ®µåæ˜¯ apiId å’Œ apiHashï¼‰
        if 'apiId' in payload and payload['apiId']:
            update_data['apiId'] = payload['apiId']
        if 'apiHash' in payload and payload['apiHash']:
            update_data['apiHash'] = payload['apiHash']

        # ä»£ç†è¨­ç½®
        if 'proxy' in payload:
            update_data['proxy'] = payload['proxy']
        if 'proxyType' in payload:
            update_data['proxyType'] = payload['proxyType']
        if 'proxyHost' in payload:
            update_data['proxyHost'] = payload['proxyHost']
        if 'proxyPort' in payload:
            update_data['proxyPort'] = payload['proxyPort']
        if 'proxyUsername' in payload:
            update_data['proxyUsername'] = payload['proxyUsername']
        if 'proxyPassword' in payload:
            update_data['proxyPassword'] = payload['proxyPassword']
        if 'proxyCountry' in payload:
            update_data['proxyCountry'] = payload['proxyCountry']
        if 'proxyRotationEnabled' in payload:
            update_data['proxyRotationEnabled'] = 1 if payload['proxyRotationEnabled'] else 0

        # è§’è‰²è¨­ç½®
        if 'role' in payload:
            update_data['role'] = payload['role']
        if 'aiPersonality' in payload:
            update_data['aiPersonality'] = payload['aiPersonality']

        # AI è¨­ç½®
        if 'aiEnabled' in payload:
            update_data['aiEnabled'] = 1 if payload['aiEnabled'] else 0
        if 'aiModel' in payload:
            update_data['aiModel'] = payload['aiModel']

        # åŸ·è¡Œæ›´æ–°
        await db.update_account(account_id, update_data)
        print(f"[Backend] Account {phone or account_id} updated: {list(update_data.keys())}", file=sys.stderr)

        # åˆ·æ–°å¸³è™Ÿåˆ—è¡¨
        await self._send_accounts_updated()
        
        # ç™¼é€æˆåŠŸéŸ¿æ‡‰
        self.send_event("update-account-result", {"success": True})
        await db.add_log(f"å¸³è™Ÿ {phone or account_id} è¨­ç½®å·²æ›´æ–°", "success")

    except Exception as e:
        import sys
        print(f"[Backend] Error updating account: {e}", file=sys.stderr)
        self.send_event("update-account-result", {"success": False, "error": str(e)})
        self.send_log(f"Error updating account: {str(e)}", "error")


async def handle_test_proxy(self, payload: Dict[str, Any]):
    """Handle test-proxy command - æ¸¬è©¦ä»£ç†é€£æ¥"""
    import sys
    import asyncio
    import aiohttp
    
    try:
        proxy_type = payload.get('type', 'socks5')
        host = payload.get('host', '')
        port = payload.get('port', 0)
        username = payload.get('username', '')
        password = payload.get('password', '')

        if not host or not port:
            self.send_event("test-proxy-result", {
                "success": False, 
                "error": "è«‹å¡«å¯«ä»£ç†åœ°å€å’Œç«¯å£"
            })
            return

        print(f"[Backend] Testing proxy: {proxy_type}://{host}:{port}", file=sys.stderr)

        # æ§‹å»ºä»£ç† URL
        if username and password:
            proxy_url = f"{proxy_type}://{username}:{password}@{host}:{port}"
        else:
            proxy_url = f"{proxy_type}://{host}:{port}"

        # æ¸¬è©¦é€£æ¥
        start_time = asyncio.get_event_loop().time()
        
        try:
            connector = None
            if proxy_type in ['socks5', 'socks4']:
                # ä½¿ç”¨ aiohttp-socks æ”¯æŒ SOCKS ä»£ç†
                try:
                    from aiohttp_socks import ProxyConnector
                    connector = ProxyConnector.from_url(proxy_url)
                except ImportError:
                    # å¦‚æœæ²’æœ‰ aiohttp-socksï¼Œå˜—è©¦åŸºæœ¬æ¸¬è©¦
                    pass
            
            timeout = aiohttp.ClientTimeout(total=10)
            
            if connector:
                async with aiohttp.ClientSession(connector=connector, timeout=timeout) as session:
                    async with session.get('https://api.telegram.org') as response:
                        end_time = asyncio.get_event_loop().time()
                        latency = int((end_time - start_time) * 1000)
                        
                        if response.status == 200:
                            self.send_event("test-proxy-result", {
                                "success": True,
                                "latency": latency,
                                "message": f"é€£æ¥æˆåŠŸï¼Œå»¶é² {latency}ms"
                            })
                        else:
                            self.send_event("test-proxy-result", {
                                "success": False,
                                "error": f"HTTP ç‹€æ…‹ç¢¼: {response.status}"
                            })
            else:
                # HTTP ä»£ç†æ¸¬è©¦
                async with aiohttp.ClientSession(timeout=timeout) as session:
                    async with session.get('https://api.telegram.org', proxy=proxy_url) as response:
                        end_time = asyncio.get_event_loop().time()
                        latency = int((end_time - start_time) * 1000)
                        
                        if response.status == 200:
                            self.send_event("test-proxy-result", {
                                "success": True,
                                "latency": latency,
                                "message": f"é€£æ¥æˆåŠŸï¼Œå»¶é² {latency}ms"
                            })
                        else:
                            self.send_event("test-proxy-result", {
                                "success": False,
                                "error": f"HTTP ç‹€æ…‹ç¢¼: {response.status}"
                            })
                            
        except asyncio.TimeoutError:
            self.send_event("test-proxy-result", {
                "success": False,
                "error": "é€£æ¥è¶…æ™‚ï¼ˆ10ç§’ï¼‰"
            })
        except Exception as conn_err:
            self.send_event("test-proxy-result", {
                "success": False,
                "error": f"é€£æ¥å¤±æ•—: {str(conn_err)}"
            })

    except Exception as e:
        print(f"[Backend] Error testing proxy: {e}", file=sys.stderr)
        self.send_event("test-proxy-result", {
            "success": False,
            "error": str(e)
        })


async def handle_sync_account_info(self, payload: Dict[str, Any]):
    """Handle sync-account-info command - åŒæ­¥å¸³è™Ÿä¿¡æ¯ï¼ˆåŒ…æ‹¬é ­åƒï¼‰"""
    import sys
    
    try:
        account_id = payload.get('id') or payload.get('accountId')
        phone = payload.get('phone')
        
        if not account_id and not phone:
            self.send_event("sync-account-info-result", {
                "success": False, 
                "error": "ç¼ºå°‘è´¦æˆ· ID æˆ–ç”µè¯å·ç "
            })
            return

        # ç²å–å¸³è™Ÿä¿¡æ¯
        if account_id:
            account = await db.get_account(account_id)
        else:
            account = await db.get_account_by_phone(phone)
        
        if not account:
            self.send_event("sync-account-info-result", {
                "success": False, 
                "error": "è´¦æˆ·ä¸å­˜åœ¨"
            })
            return
        
        phone = account.get('phone')
        account_id = account.get('id')
        
        print(f"[Backend] Syncing account info for {phone}...", file=sys.stderr)
        
        # æ£€æŸ¥å®¢æˆ·ç«¯æ˜¯å¦å·²è¿æ¥ï¼Œå¦‚æœæœªè¿æ¥åˆ™å°è¯•è¿æ¥
        client = self.telegram_manager.get_client(phone)
        if not client or not client.is_connected:
            print(f"[Backend] Client not connected, attempting to connect for {phone}...", file=sys.stderr)
            
            # è·å– API å‡­è¯ï¼ˆæ•°æ®åº“å­—æ®µåæ˜¯ apiId å’Œ apiHashï¼‰
            api_id = account.get('apiId') or account.get('api_id')
            api_hash = account.get('apiHash') or account.get('api_hash')
            
            if not api_id or not api_hash:
                self.send_event("sync-account-info-result", {
                    "success": False, 
                    "error": "è´¦æˆ·ç¼ºå°‘ API å‡­è¯ï¼Œè¯·åœ¨è´¦æˆ·è®¾ç½®ä¸­å¡«å†™ API ID å’Œ API Hash"
                })
                return
            
            # å°è¯•ç™»å½•/è¿æ¥
            try:
                login_result = await self.telegram_manager.login_account(
                    phone=phone,
                    api_id=api_id,
                    api_hash=api_hash,
                    proxy=account.get('proxy')
                )
                
                if not login_result.get('success') and login_result.get('status') != 'Online':
                    self.send_event("sync-account-info-result", {
                        "success": False, 
                        "error": f"æ— æ³•è¿æ¥è´¦æˆ·: {login_result.get('error', 'è¿æ¥å¤±è´¥')}"
                    })
                    return
                    
                print(f"[Backend] Client connected for {phone}", file=sys.stderr)
            except Exception as conn_error:
                self.send_event("sync-account-info-result", {
                    "success": False, 
                    "error": f"è¿æ¥è´¦æˆ·å¤±è´¥: {str(conn_error)}"
                })
                return
        
        # ç²å–å®Œæ•´ç”¨æˆ¶è³‡æ–™
        full_profile = await self.telegram_manager.get_full_user_profile(phone, download_avatar=True)
        
        if not full_profile.get('success'):
            self.send_event("sync-account-info-result", {
                "success": False,
                "error": full_profile.get('error', 'æ— æ³•è·å–ç”¨æˆ·ä¿¡æ¯')
            })
            return
        
        # æ›´æ–°æ•¸æ“šåº«
        await db.update_account(account_id, {
            "firstName": full_profile.get('firstName', ''),
            "lastName": full_profile.get('lastName', ''),
            "username": full_profile.get('username', ''),
            "bio": full_profile.get('bio', ''),
            "avatarPath": full_profile.get('avatarPath', ''),
            "telegramId": str(full_profile.get('id', ''))
        })
        
        print(f"[Backend] Account info synced for {phone}", file=sys.stderr)
        
        # åˆ·æ–°å¸³è™Ÿåˆ—è¡¨
        await self._send_accounts_updated()
        
        # ç™¼é€æˆåŠŸçµæœ
        self.send_event("sync-account-info-result", {
            "success": True,
            "accountId": account_id,
            "phone": phone,
            "profile": full_profile
        })
        
        self.send_log(f"å¸³è™Ÿ {phone} ä¿¡æ¯å·²åŒæ­¥", "success")

    except Exception as e:
        print(f"[Backend] Error syncing account info: {e}", file=sys.stderr)
        self.send_event("sync-account-info-result", {
            "success": False,
            "error": str(e)
        })


async def handle_logout_account(self, payload: Dict[str, Any]):
    """Handle logout-account command - é€€å‡ºè´¦æˆ·ï¼ˆæ–­å¼€è¿æ¥ä½†ä¿ç•™è´¦æˆ·ï¼‰"""
    import sys

    try:
        account_id = payload if isinstance(payload, int) else payload.get('id') or payload.get('accountId')

        if not account_id:
            self.send_event("logout-account-result", {
                "success": False,
                "error": "ç¼ºå°‘è´¦æˆ· ID"
            })
            return

        # è·å–è´¦æˆ·ä¿¡æ¯
        account = await db.get_account(account_id)
        if not account:
            self.send_event("logout-account-result", {
                "success": False,
                "error": "è´¦æˆ·ä¸å­˜åœ¨"
            })
            return

        phone = account.get('phone')
        print(f"[Backend] Logging out account {phone}...", file=sys.stderr)

        # æ–­å¼€å®¢æˆ·ç«¯è¿æ¥
        try:
            await self.telegram_manager.disconnect_account(phone, graceful=True)
            print(f"[Backend] Account {phone} disconnected successfully", file=sys.stderr)
        except Exception as e:
            print(f"[Backend] Warning: Error disconnecting account {phone}: {e}", file=sys.stderr)

        # æ›´æ–°æ•°æ®åº“çŠ¶æ€ä¸ºç¦»çº¿
        await db.update_account(account_id, {"status": "Offline"})
        await db.add_account_event(account_id, "logout", None)

        # åˆ·æ–°è´¦æˆ·åˆ—è¡¨
        await self._send_accounts_updated()

        # å‘é€æˆåŠŸç»“æœ
        self.send_event("logout-account-result", {
            "success": True,
            "accountId": account_id,
            "phone": phone
        })

        self.send_log(f"è´¦æˆ· {phone} å·²é€€å‡º", "success")

    except Exception as e:
        print(f"[Backend] Error logging out account: {e}", file=sys.stderr)
        self.send_event("logout-account-result", {
            "success": False,
            "error": str(e)
        })


async def handle_save_tags(self, payload: Dict[str, Any]):
    """Save tags to settings"""
    try:
        tags = payload.get('tags', [])
        await db.save_setting('account_tags', json.dumps(tags))
        self.send_event("save-tags-result", {"success": True})
    except Exception as e:
        self.send_event("save-tags-result", {"success": False, "error": str(e)})


async def handle_save_groups(self, payload: Dict[str, Any]):
    """Save groups to settings"""
    try:
        groups = payload.get('groups', [])
        await db.save_setting('account_groups', json.dumps(groups))
        self.send_event("save-groups-result", {"success": True})
    except Exception as e:
        self.send_event("save-groups-result", {"success": False, "error": str(e)})


async def handle_get_tags(self, payload: Dict[str, Any]):
    """Get saved tags"""
    try:
        tags_json = await db.get_setting('account_tags')
        tags = json.loads(tags_json) if tags_json else []
        self.send_event("get-tags-result", {"success": True, "tags": tags})
    except Exception as e:
        self.send_event("get-tags-result", {"success": False, "error": str(e), "tags": []})


async def handle_get_groups(self, payload: Dict[str, Any]):
    """Get saved groups"""
    try:
        groups_json = await db.get_setting('account_groups')
        groups = json.loads(groups_json) if groups_json else []
        self.send_event("get-groups-result", {"success": True, "groups": groups})
    except Exception as e:
        self.send_event("get-groups-result", {"success": False, "error": str(e), "groups": []})


async def handle_save_personas(self, payload: Dict[str, Any]):
    """Save custom AI personas to settings"""
    try:
        personas = payload.get('personas', [])
        await db.save_setting('ai_personas', json.dumps(personas))
        self.send_event("save-personas-result", {"success": True})
    except Exception as e:
        self.send_event("save-personas-result", {"success": False, "error": str(e)})


async def handle_get_personas(self, payload: Dict[str, Any]):
    """Get saved custom AI personas"""
    try:
        personas_json = await db.get_setting('ai_personas')
        personas = json.loads(personas_json) if personas_json else []
        self.send_event("get-personas-result", {"success": True, "personas": personas})
    except Exception as e:
        self.send_event("get-personas-result", {"success": False, "error": str(e), "personas": []})


async def handle_get_account_events(self, payload: Dict[str, Any]):
    """P1-5: ç²å–å¸³è™Ÿç™»å…¥/æ–·é–‹äº‹ä»¶åˆ—è¡¨ï¼ˆç”¨æ–¼è¨ºæ–·ï¼‰"""
    try:
        account_id = payload.get('accountId') or payload.get('account_id')
        if not account_id:
            self.send_event("get-account-events-result", {"success": False, "error": "ç¼ºå°‘ accountId", "events": []})
            return
        limit = int(payload.get('limit', 30))
        events = await db.get_account_events(account_id, limit=limit)
        self.send_event("get-account-events-result", {"success": True, "accountId": account_id, "events": events})
    except Exception as e:
        self.send_event("get-account-events-result", {"success": False, "error": str(e), "events": []})


async def handle_batch_update_accounts(self, payload: Dict[str, Any]):
    """Handle batch-update-accounts command - æ‰¹é‡æ›´æ–°å¸³è™Ÿè¨­ç½®"""
    import sys
    
    try:
        account_ids = payload.get('accountIds', [])
        updates = payload.get('updates', {})
        
        if not account_ids:
            self.send_event("batch-update-accounts-result", {
                "success": False,
                "error": "æœªé¸æ“‡å¸³è™Ÿ"
            })
            return
        
        if not updates:
            self.send_event("batch-update-accounts-result", {
                "success": False,
                "error": "æœªæä¾›æ›´æ–°æ•¸æ“š"
            })
            return
        
        print(f"[Backend] Batch updating {len(account_ids)} accounts with: {list(updates.keys())}", file=sys.stderr)
        
        # æ‰¹é‡æ›´æ–°æ¯å€‹å¸³è™Ÿ
        success_count = 0
        for account_id in account_ids:
            try:
                await db.update_account(account_id, updates)
                success_count += 1
            except Exception as e:
                print(f"[Backend] Error updating account {account_id}: {e}", file=sys.stderr)
        
        # åˆ·æ–°å¸³è™Ÿåˆ—è¡¨
        await self._send_accounts_updated()
        
        # ç™¼é€æˆåŠŸçµæœ
        self.send_event("batch-update-accounts-result", {
            "success": True,
            "count": success_count,
            "total": len(account_ids)
        })
        
        self.send_log(f"æ‰¹é‡æ›´æ–°å®Œæˆ: {success_count}/{len(account_ids)} å€‹å¸³è™Ÿ", "success")

    except Exception as e:
        print(f"[Backend] Error in batch update: {e}", file=sys.stderr)
        self.send_event("batch-update-accounts-result", {
            "success": False,
            "error": str(e)
        })


async def handle_bulk_assign_role(self, payload: Dict[str, Any]):
    """Handle bulk-assign-role command"""
    try:
        account_ids = payload.get('accountIds', [])
        role = payload.get('role')
        await db.bulk_update_accounts_role(account_ids, role)
        
        await self._send_accounts_updated()
        await db.add_log(f"Bulk assigned role '{role}' to {len(account_ids)} accounts", "success")
    
    except Exception as e:
        self.send_log(f"Error bulk assigning role: {str(e)}", "error")


async def handle_bulk_assign_group(self, payload: Dict[str, Any]):
    """Handle bulk-assign-group command"""
    try:
        account_ids = payload.get('accountIds', [])
        group = payload.get('group')
        await db.bulk_update_accounts_group(account_ids, group)
        
        await self._send_accounts_updated()
        await db.add_log(f"Bulk assigned group '{group}' to {len(account_ids)} accounts", "success")
    
    except Exception as e:
        self.send_log(f"Error bulk assigning group: {str(e)}", "error")


async def handle_bulk_delete_accounts(self, payload: Dict[str, Any]):
    """Handle bulk-delete-accounts command - completely remove accounts and all related resources"""
    try:
        import sys
        from pathlib import Path
        from config import SESSIONS_DIR
        
        account_ids = payload.get('accountIds', [])
        if not account_ids:
            self.send_log("æœªé€‰æ‹©è¦åˆ é™¤çš„è´¦æˆ·", "error")
            return
        
        print(f"[Backend] Bulk deleting {len(account_ids)} accounts", file=sys.stderr)
        
        # ğŸ†• å…ˆé‡‹æ”¾é›™æ± åˆ†é…ï¼ˆåœ¨åˆªé™¤æ•¸æ“šåº«è¨˜éŒ„ä¹‹å‰ï¼‰
        for account_id in account_ids:
            try:
                account = await db.get_account(account_id)
                if account:
                    phone = account.get('phone')
                    if phone:
                        # é‡‹æ”¾ SQLite API å°æ¥æ± 
                        try:
                            from admin.api_pool import get_api_pool_manager
                            api_pool = get_api_pool_manager()
                            api_pool.release_api(phone)
                        except Exception as e:
                            print(f"[Backend] Error releasing API pool for {phone}: {e}", file=sys.stderr)
                        
                        # é‡‹æ”¾ä»£ç†æ± 
                        try:
                            from admin.proxy_pool import get_proxy_pool
                            proxy_pool = get_proxy_pool()
                            proxy_pool.release_proxy(phone=phone)
                        except Exception as e:
                            print(f"[Backend] Error releasing proxy pool for {phone}: {e}", file=sys.stderr)
            except Exception as e:
                print(f"[Backend] Error releasing pools for account {account_id}: {e}", file=sys.stderr)
        
        # Delete from database (this also cleans up related data)
        deleted_phones = await db.bulk_delete_accounts(account_ids)
        print(f"[Backend] {len(deleted_phones)} accounts deleted from database", file=sys.stderr)
        
        # Remove clients from TelegramClientManager and delete session files
        for phone in deleted_phones:
            if phone:
                # Ensure client is fully disconnected
                try:
                    await self.ensure_client_disconnected(phone)
                    print(f"[Backend] Client disconnected and removed for {phone}", file=sys.stderr)
                except Exception as e:
                    print(f"[Backend] Error removing client for {phone}: {e}", file=sys.stderr)
                
                # Delete session files with retry mechanism
                try:
                    safe_phone = phone.replace("+", "").replace("-", "").replace(" ", "")
                    session_file = SESSIONS_DIR / f"{safe_phone}.session"
                    session_journal = SESSIONS_DIR / f"{safe_phone}.session.journal"
                    
                    if session_file.exists():
                        deleted = await self.safe_delete_session_file(session_file)
                        if deleted:
                            print(f"[Backend] Deleted session file: {session_file}", file=sys.stderr)
                        else:
                            print(f"[Backend] WARNING: Failed to delete session file after retries: {session_file}", file=sys.stderr)
                    
                    if session_journal.exists():
                        deleted = await self.safe_delete_session_file(session_journal)
                        if deleted:
                            print(f"[Backend] Deleted session journal: {session_journal}", file=sys.stderr)
                        else:
                            print(f"[Backend] WARNING: Failed to delete session journal after retries: {session_journal}", file=sys.stderr)
                except Exception as e:
                    print(f"[Backend] Error deleting session files for {phone}: {e}", file=sys.stderr)
        
        # Update accounts list and send event
        await self._send_accounts_updated()
        
        await db.add_log(f"æ‰¹é‡åˆ é™¤äº† {len(deleted_phones)} ä¸ªè´¦æˆ·", "success")
        self.send_log(f"å·²åˆ é™¤ {len(deleted_phones)} ä¸ªè´¦æˆ·", "success")
        print(f"[Backend] Bulk delete completed: {len(deleted_phones)} accounts removed", file=sys.stderr)
        
        # ğŸ”§ P3-3: æ‰¹é‡åˆªé™¤å¾Œå¤±æ•ˆé…é¡ç·©å­˜ï¼ˆå…¨é‡å¤±æ•ˆï¼Œå› æ¶‰åŠå¤šå¸³è™Ÿï¼‰
        try:
            from core.quota_service import get_quota_service
            get_quota_service().invalidate_cache()
            print(f"[Backend] Quota cache invalidated after bulk-delete", file=sys.stderr)
        except Exception as qe:
            print(f"[Backend] Quota cache invalidation error: {qe}", file=sys.stderr)
        
        await self._send_accounts_updated()
        await db.add_log(f"Deleted {len(account_ids)} accounts", "success")
    
    except Exception as e:
        self.send_log(f"Error deleting accounts: {str(e)}", "error")


async def handle_remove_account(self, payload: Dict[str, Any]):
    """Handle remove-account command - completely remove account and all related resources"""
    try:
        import sys
        from pathlib import Path
        from config import SESSIONS_DIR
        
        account_id = payload.get('id')
        if not account_id:
            self.send_log("è´¦æˆ·IDä¸èƒ½ä¸ºç©º", "error")
            return
        
        # Get account info before deleting (for cleanup)
        account = await db.get_account(account_id)
        if not account:
            self.send_log(f"è´¦æˆ· {account_id} ä¸å­˜åœ¨", "error")
            return
        
        phone = account.get('phone')
        api_id = account.get('apiId')
        print(f"[Backend] Removing account {account_id} (phone: {phone})", file=sys.stderr)
        
        # 0. é‡‹æ”¾ API æ†‘æ“šä½¿ç”¨è¨ˆæ•¸ï¼ˆèˆŠæ± ï¼‰
        if api_id:
            try:
                from api_credential_pool import get_api_credential_pool
                data_dir = str(Path(config.DATA_PATH))
                pool = get_api_credential_pool(data_dir)
                if pool.release_credential(api_id):
                    print(f"[Backend] API credential {api_id} usage count decremented", file=sys.stderr)
                    # ç™¼é€æ›´æ–°çš„æ†‘æ“šä¿¡æ¯
                    credentials = pool.list_credentials()
                    self.send_event("api-credentials-updated", {"credentials": credentials})
            except Exception as e:
                print(f"[Backend] Error releasing API credential: {e}", file=sys.stderr)
        
        # 0.1 ğŸ†• é‡‹æ”¾ SQLite API å°æ¥æ± åˆ†é…
        if phone:
            try:
                from admin.api_pool import get_api_pool_manager
                api_pool = get_api_pool_manager()
                success, msg = api_pool.release_api(phone)
                if success:
                    print(f"[Backend] SQLite API pool released for {phone}", file=sys.stderr)
            except Exception as e:
                print(f"[Backend] Error releasing SQLite API pool: {e}", file=sys.stderr)
        
        # 0.2 ğŸ†• é‡‹æ”¾ä»£ç†æ± åˆ†é…
        if phone:
            try:
                from admin.proxy_pool import get_proxy_pool
                proxy_pool = get_proxy_pool()
                success = proxy_pool.release_proxy(phone=phone)
                if success:
                    print(f"[Backend] Proxy pool released for {phone}", file=sys.stderr)
            except Exception as e:
                print(f"[Backend] Error releasing proxy pool: {e}", file=sys.stderr)
        
        # 1. Delete from database (this also cleans up related data)
        deleted_phone = await db.remove_account(account_id)
        if not deleted_phone:
            self.send_log(f"åˆ é™¤è´¦æˆ· {account_id} å¤±è´¥", "error")
            return
        
        print(f"[Backend] Account {account_id} deleted from database", file=sys.stderr)
        
        # 2. Remove client from TelegramClientManager (this will disconnect it)
        if phone:
            try:
                await self.telegram_manager.remove_client(phone, wait_for_disconnect=True)
                # Force garbage collection to release file handles
                gc.collect()
                await asyncio.sleep(0.3)  # Give OS time to release file handles
                print(f"[Backend] Client disconnected and removed for {phone}", file=sys.stderr)
            except Exception as e:
                print(f"[Backend] Error removing client from TelegramClientManager: {e}", file=sys.stderr)
                # Continue with file deletion attempt anyway
        
        # 3. Delete session files (with retry mechanism)
        if phone:
            try:
                # Sanitize phone number for filename
                safe_phone = phone.replace("+", "").replace("-", "").replace(" ", "")
                session_file = SESSIONS_DIR / f"{safe_phone}.session"
                session_journal = SESSIONS_DIR / f"{safe_phone}.session.journal"
                
                # Delete session file with retry
                if session_file.exists():
                    deleted = await self.safe_delete_session_file(session_file)
                    if deleted:
                        print(f"[Backend] Deleted session file: {session_file}", file=sys.stderr)
                    else:
                        print(f"[Backend] WARNING: Failed to delete session file after retries: {session_file}", file=sys.stderr)
                
                # Delete session journal file if exists
                if session_journal.exists():
                    deleted = await self.safe_delete_session_file(session_journal)
                    if deleted:
                        print(f"[Backend] Deleted session journal file: {session_journal}", file=sys.stderr)
                    else:
                        print(f"[Backend] WARNING: Failed to delete session journal file after retries: {session_journal}", file=sys.stderr)
                
            except Exception as e:
                print(f"[Backend] Error deleting session files for {phone}: {e}", file=sys.stderr)
                # Don't fail the whole operation if session file deletion fails
                # The account is already deleted from database
        
        # 4. Update accounts list and send event
        await self._send_accounts_updated()
        
        await db.add_log(f"è´¦æˆ· {phone} (ID: {account_id}) å·²å®Œå…¨åˆ é™¤", "success")
        self.send_log(f"è´¦æˆ· {phone} å·²å®Œå…¨åˆ é™¤", "success")
        print(f"[Backend] Account {account_id} ({phone}) completely removed", file=sys.stderr)
        
        # ğŸ”§ P3-3: å¸³è™Ÿåˆªé™¤å¾Œç«‹å³å¤±æ•ˆé…é¡ç·©å­˜
        try:
            from core.quota_service import get_quota_service
            qs = get_quota_service()
            # å˜—è©¦å¾å¸³è™Ÿä¿¡æ¯ç²å– owner_user_idï¼ˆaccount åœ¨åˆªé™¤å‰å·²ç²å–ï¼‰
            owner_id = account.get('owner_user_id') if account else None
            if owner_id:
                qs.invalidate_cache(owner_id)
            else:
                qs.invalidate_cache()
            print(f"[Backend] Quota cache invalidated after remove-account", file=sys.stderr)
        except Exception as qe:
            print(f"[Backend] Quota cache invalidation error: {qe}", file=sys.stderr)
    
    except Exception as e:
        import sys
        import traceback
        error_msg = str(e)
        print(f"[Backend] Error removing account: {error_msg}", file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        self.send_log(f"åˆ é™¤è´¦æˆ·å¤±è´¥: {error_msg}", "error")


# ==================== Monitoring Management Handlers ====================

async def handle_get_accounts(self, payload: Dict[str, Any] = None):
    """ç²å–æ‰€æœ‰å¸³è™Ÿåˆ—è¡¨ï¼ˆå«æ¯å€‹å¸³è™Ÿç¶å®šçš„ä»£ç†/IP é¡¯ç¤ºç”¨ï¼‰ã€‚æ”¯æŒ payload.owner_user_id å¤šç§Ÿæˆ¶éæ¿¾ã€‚"""
    try:
        owner_user_id = None
        if payload:
            owner_user_id = payload.get('owner_user_id') or payload.get('ownerUserId')
        accounts = await db.get_all_accounts(owner_user_id=owner_user_id)
        # ç‚ºæ¯å€‹å¸³è™Ÿé™„åŠ ç•¶å‰ç¶å®šçš„ä»£ç†é¡¯ç¤ºï¼ˆhost:portï¼‰ï¼Œä¾¿æ–¼åœ¨ UI æŸ¥çœ‹ IP
        try:
            from admin.proxy_pool import get_proxy_pool
            pool = get_proxy_pool()
            for a in accounts:
                phone = a.get('phone')
                if not phone:
                    a['proxyDisplay'] = None
                    continue
                px = pool.get_proxy_for_account(phone=phone)
                a['proxyDisplay'] = f"{px.host}:{px.port}" if px else None
        except Exception as _e:
            for a in accounts:
                a['proxyDisplay'] = a.get('proxyDisplay', None)
        # ğŸ”§ å¤šç§Ÿæˆ¶å®‰å…¨ï¼šé€šé _send_accounts_updated ç™¼é€ï¼Œå¸¶ç§Ÿæˆ¶éæ¿¾
        await self._send_accounts_updated()
        # åŒæ™‚è¿”å›æ•¸æ“šçµ¦ HTTP éŸ¿æ‡‰
        return {'success': True, 'accounts': accounts}
    except Exception as e:
        self.send_log(f"âŒ ç²å–å¸³è™Ÿåˆ—è¡¨å¤±æ•—: {e}", "error")
        self.send_event("accounts-updated", [])
        return {'success': False, 'error': str(e), 'accounts': []}

