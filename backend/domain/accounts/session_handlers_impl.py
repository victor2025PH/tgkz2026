"""
Extracted handler implementations: sessions
Auto-generated by refactor_main.py
"""
import json
import sys
import time
import asyncio
import traceback
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from service_context import get_service_context

# All handlers receive (self, payload) where self is BackendService instance.
# They are called via: await handler_impl(self, payload)
# Inside, use self.db, self.send_event(), self.telegram_manager, etc.
# This is a transitional pattern - later, replace self.xxx with ctx.xxx


async def handle_load_accounts_from_excel(self, payload: Dict[str, Any]):
    """Handle load-accounts-from-excel command"""
    try:
        from openpyxl import load_workbook
        from pathlib import Path
        
        file_path = payload.get('filePath')
        if not file_path:
            self.send_log("No file path provided", "error")
            return
        
        file_path_obj = Path(file_path)
        if not file_path_obj.exists():
            self.send_log(f"File not found: {file_path}", "error")
            return
        
        # Load Excel file
        workbook = load_workbook(file_path_obj, data_only=True)
        sheet = workbook.active
        
        # Get headers (first row)
        headers = []
        for cell in sheet[1]:
            headers.append(cell.value.lower().replace(' ', '_') if cell.value else '')
        
        # Map column names
        column_map = {
            'phone': ['phone', 'phone_number', 'ç”µè¯å·ç '],
            'api_id': ['api_id', 'apiid', 'api_id'],
            'api_hash': ['api_hash', 'apihash', 'api_hash'],
            'proxy': ['proxy', 'ä»£ç†'],
            'group': ['group', 'group_name', 'åˆ†ç»„'],
            'two_factor_password': ['two_factor_password', '2fa', '2fa_password', 'two_factor', '2faå¯†ç '],
            'role': ['role', 'è§’è‰²']
        }
        
        # Find column indices
        column_indices = {}
        for key, possible_names in column_map.items():
            for idx, header in enumerate(headers):
                if header in possible_names:
                    column_indices[key] = idx
                    break
        
        if 'phone' not in column_indices:
            self.send_log("Phone column not found in Excel file", "error")
            return
        
        # Read data rows
        imported_count = 0
        skipped_count = 0
        
        for row_idx, row in enumerate(sheet.iter_rows(min_row=2, values_only=False), start=2):
            # Skip empty rows
            if not row[column_indices['phone']].value:
                continue
            
            try:
                account_data = {
                    'phone': str(row[column_indices['phone']].value).strip(),
                    'apiId': str(row[column_indices.get('api_id', 0)].value).strip() if column_indices.get('api_id') and row[column_indices['api_id']].value else '',
                    'apiHash': str(row[column_indices.get('api_hash', 0)].value).strip() if column_indices.get('api_hash') and row[column_indices['api_hash']].value else '',
                    'proxy': str(row[column_indices.get('proxy', 0)].value).strip() if column_indices.get('proxy') and row[column_indices['proxy']].value else '',
                    'group': str(row[column_indices.get('group', 0)].value).strip() if column_indices.get('group') and row[column_indices['group']].value else '',
                    'twoFactorPassword': str(row[column_indices.get('two_factor_password', 0)].value).strip() if column_indices.get('two_factor_password') and row[column_indices['two_factor_password']].value else '',
                    'role': str(row[column_indices.get('role', 0)].value).strip() if column_indices.get('role') and row[column_indices['role']].value else 'Unassigned'
                }
                
                # Validate phone number
                if not account_data['phone']:
                    skipped_count += 1
                    continue
                
                # Check if account already exists
                existing = await db.get_account_by_phone(account_data['phone'])
                if existing:
                    # Update existing account
                    await db.update_account(existing['id'], {
                        'apiId': account_data.get('apiId'),
                        'apiHash': account_data.get('apiHash'),
                        'proxy': account_data.get('proxy'),
                        'group': account_data.get('group'),
                        'role': account_data.get('role', 'Unassigned')
                    })
                    imported_count += 1
                else:
                    # Add new account
                    await db.add_account(account_data)
                    imported_count += 1
            
            except Exception as e:
                self.send_log(f"Error processing row {row_idx}: {str(e)}", "warning")
                skipped_count += 1
                continue
        
        # Send updated accounts
        await self._send_accounts_updated()
        
        self.send_log(f"Imported {imported_count} accounts from Excel (skipped {skipped_count})", "success")
        await db.add_log(f"Imported {imported_count} accounts from Excel", "success")
    
    except Exception as e:
        self.send_log(f"Error loading accounts from Excel: {str(e)}", "error")


async def handle_reload_sessions_and_accounts(self):
    """Handle reload-sessions-and-accounts command - scan sessions directory and sync with database"""
    try:
        from pathlib import Path
        from config import SESSIONS_DIR
        import re
        
        self.send_log("Reloading sessions and accounts", "info")
        
        # Get all session files
        session_files = list(SESSIONS_DIR.glob("*.session"))
        
        if not session_files:
            self.send_log("No session files found", "info")
            await self._send_accounts_updated()
            return
        
        # Get all existing accounts
        existing_accounts = await db.get_all_accounts()
        existing_phones = {acc.get('phone') for acc in existing_accounts}
        
        imported_count = 0
        updated_count = 0
        
        # Process each session file
        for session_file in session_files:
            try:
                # Extract phone number from filename (remove .session extension)
                phone_number = session_file.stem
                
                # Try to normalize phone number (add + if missing)
                if not phone_number.startswith('+'):
                    # Try to detect if it's a valid phone number
                    if phone_number.isdigit() and len(phone_number) >= 10:
                        # Assume it's a phone number without country code
                        # For now, keep as is - user can update manually
                        pass
                
                # Check if account exists
                existing_account = await db.get_account_by_phone(phone_number)
                
                if existing_account:
                    # Update session file path if needed
                    updated_count += 1
                    self.send_log(f"Session found for existing account: {phone_number}", "info")
                else:
                    # Create new account from session file
                    # Try to get account info from session file metadata if possible
                    # For now, create with minimal info
                    await db.add_account({
                        'phone': phone_number,
                        'apiId': '',  # Will need to be filled manually
                        'apiHash': '',  # Will need to be filled manually
                        'proxy': '',
                        'group': '',
                        'role': 'Unassigned',
                        'status': 'Offline'  # Will be updated when logged in
                    })
                    imported_count += 1
                    self.send_log(f"Created account from session file: {phone_number}", "info")
            
            except Exception as e:
                self.send_log(f"Error processing session file {session_file.name}: {str(e)}", "warning")
                continue
        
        # Check for accounts without session files
        accounts_without_sessions = []
        for account in existing_accounts:
            phone = account.get('phone')
            safe_phone = phone.replace("+", "").replace("-", "").replace(" ", "")
            session_file = SESSIONS_DIR / f"{safe_phone}.session"
            if not session_file.exists():
                accounts_without_sessions.append(phone)
        
        # Send updated accounts
        await self._send_accounts_updated()
        
        # Log summary
        summary = f"Reloaded sessions: {len(session_files)} session files found, {imported_count} new accounts created, {updated_count} existing accounts updated"
        if accounts_without_sessions:
            summary += f", {len(accounts_without_sessions)} accounts without session files"
        
        self.send_log(summary, "success")
        await db.add_log(summary, "info")
    
    except Exception as e:
        self.send_log(f"Error reloading sessions: {str(e)}", "error")


async def handle_scan_orphan_sessions(self, payload: Dict[str, Any]):
    """æƒæå­¤ç«‹çš„ Session æ–‡ä»¶ï¼ˆæœ‰ session ä½†ç„¡æ•¸æ“šåº«è¨˜éŒ„ï¼‰"""
    try:
        from pathlib import Path
        from config import SESSIONS_DIR
        
        self.send_log("ğŸ” æ­£åœ¨æƒæå­¤ç«‹çš„ Session æ–‡ä»¶...", "info")
        
        # ç²å–æ‰€æœ‰ session æ–‡ä»¶
        session_files = list(SESSIONS_DIR.glob("*.session"))
        
        if not session_files:
            self.send_event("orphan-sessions-scanned", {
                "success": True,
                "orphan_sessions": [],
                "message": "æ²’æœ‰æ‰¾åˆ° Session æ–‡ä»¶"
            })
            return
        
        # ç²å–æ•¸æ“šåº«ä¸­çš„å¸³è™Ÿ
        existing_accounts = await db.get_all_accounts()
        existing_phones = set()
        for acc in existing_accounts:
            phone = acc.get('phone', '')
            # æ¨™æº–åŒ–é›»è©±è™Ÿç¢¼
            safe_phone = phone.replace("+", "").replace("-", "").replace(" ", "")
            existing_phones.add(safe_phone)
            existing_phones.add(phone)
        
        # æŸ¥æ‰¾å­¤ç«‹çš„ session
        orphan_sessions = []
        for session_file in session_files:
            phone = session_file.stem
            # è·³éè‡¨æ™‚æ–‡ä»¶å’Œ journal æ–‡ä»¶
            if phone.endswith('-journal') or phone.startswith('.'):
                continue
                
            # æª¢æŸ¥æ˜¯å¦åœ¨æ•¸æ“šåº«ä¸­
            if phone not in existing_phones and f"+{phone}" not in existing_phones:
                orphan_sessions.append({
                    "phone": phone,
                    "file_path": str(session_file),
                    "file_size": session_file.stat().st_size,
                    "modified_at": session_file.stat().st_mtime
                })
        
        self.send_log(f"ğŸ“‚ ç™¼ç¾ {len(orphan_sessions)} å€‹å­¤ç«‹çš„ Session æ–‡ä»¶", "info")
        
        self.send_event("orphan-sessions-scanned", {
            "success": True,
            "orphan_sessions": orphan_sessions,
            "total_sessions": len(session_files),
            "existing_accounts": len(existing_accounts)
        })
        
    except Exception as e:
        self.send_log(f"Error scanning orphan sessions: {str(e)}", "error")
        self.send_event("orphan-sessions-scanned", {
            "success": False,
            "error": str(e)
        })


async def handle_recover_orphan_sessions(self, payload: Dict[str, Any]):
    """æ¢å¾©å­¤ç«‹çš„ Session æ–‡ä»¶ï¼Œå‰µå»ºå¸³è™Ÿè¨˜éŒ„"""
    try:
        from pathlib import Path
        from config import SESSIONS_DIR
        from api_credential_pool import get_api_credential_pool
        
        phones_to_recover = payload.get('phones', [])
        api_id = payload.get('apiId', '')
        api_hash = payload.get('apiHash', '')
        
        if not phones_to_recover:
            self.send_event("orphan-sessions-recovered", {
                "success": False,
                "error": "æ²’æœ‰é¸æ“‡è¦æ¢å¾©çš„å¸³è™Ÿ"
            })
            return
        
        # å¦‚æœæ²’æœ‰æä¾› API æ†‘æ“šï¼Œå˜—è©¦å¾ API æ± ç²å–æ¨è–¦çš„
        if not api_id or not api_hash:
            data_dir = str(Path(config.DATA_PATH))
            pool = get_api_credential_pool(data_dir)
            recommendation = pool.get_best_credential()
            if recommendation:
                api_id = recommendation.get('api_id', '')
                api_hash = recommendation.get('api_hash', '')
                self.send_log(f"ä½¿ç”¨æ¨è–¦çš„ API æ†‘æ“š: {api_id}", "info")
        
        results = {
            "success_count": 0,
            "fail_count": 0,
            "accounts": []
        }
        
        for phone in phones_to_recover:
            try:
                self.send_log(f"ğŸ”„ æ­£åœ¨æ¢å¾©å¸³è™Ÿ: {phone}...", "info")
                
                # æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
                existing = await db.get_account_by_phone(phone)
                if existing:
                    self.send_log(f"âš ï¸ å¸³è™Ÿ {phone} å·²å­˜åœ¨ï¼Œè·³é", "warning")
                    results["accounts"].append({
                        "phone": phone,
                        "success": False,
                        "error": "å¸³è™Ÿå·²å­˜åœ¨"
                    })
                    results["fail_count"] += 1
                    continue
                
                # é©—è­‰ session æ–‡ä»¶æ˜¯å¦å­˜åœ¨
                session_file = SESSIONS_DIR / f"{phone}.session"
                if not session_file.exists():
                    results["accounts"].append({
                        "phone": phone,
                        "success": False,
                        "error": "Session æ–‡ä»¶ä¸å­˜åœ¨"
                    })
                    results["fail_count"] += 1
                    continue
                
                # å˜—è©¦é€£æ¥ Telegram ç²å–ç”¨æˆ¶ä¿¡æ¯
                user_info = {}
                try:
                    if api_id and api_hash:
                        # å˜—è©¦ä½¿ç”¨ Pyrogram é€£æ¥é©—è­‰
                        from pyrogram import Client
                        
                        session_name = str(session_file).replace('.session', '')
                        client = Client(
                            name=session_name,
                            api_id=int(api_id),
                            api_hash=api_hash,
                            workdir=str(SESSIONS_DIR)
                        )
                        
                        await client.start()
                        me = await client.get_me()
                        
                        user_info = {
                            "firstName": me.first_name or "",
                            "lastName": me.last_name or "",
                            "username": me.username or "",
                            "telegramId": str(me.id),
                            "phone": me.phone_number or phone
                        }
                        
                        # ä¸‹è¼‰é ­åƒ
                        try:
                            if me.photo:
                                avatar_path = Path(config.DATA_PATH) / "avatars" / f"{phone}.jpg"
                                avatar_path.parent.mkdir(parents=True, exist_ok=True)
                                await client.download_media(me.photo.big_file_id, file_name=str(avatar_path))
                                user_info["avatarPath"] = str(avatar_path)
                        except Exception:
                            pass
                        
                        await client.stop()
                        self.send_log(f"âœ… é©—è­‰æˆåŠŸ: {user_info.get('firstName', '')} @{user_info.get('username', '')}", "success")
                except Exception as e:
                    self.send_log(f"âš ï¸ ç„¡æ³•é©—è­‰ sessionï¼ˆå¯èƒ½å·²éæœŸï¼‰: {e}", "warning")
                    # ä»ç„¶å‰µå»ºå¸³è™Ÿï¼Œä½†æ¨™è¨˜ç‚ºé›¢ç·š
                
                # å‰µå»ºå¸³è™Ÿè¨˜éŒ„
                account_data = {
                    'phone': phone if phone.startswith('+') else f"+{phone}",
                    'apiId': api_id,
                    'apiHash': api_hash,
                    'proxy': '',
                    'group': '',
                    'role': 'Unassigned',
                    'status': 'Online' if user_info else 'Offline',
                    'firstName': user_info.get('firstName', ''),
                    'lastName': user_info.get('lastName', ''),
                    'username': user_info.get('username', ''),
                    'telegramId': user_info.get('telegramId', ''),
                    'avatarPath': user_info.get('avatarPath', '')
                }
                
                await db.add_account(account_data)
                
                results["success_count"] += 1
                results["accounts"].append({
                    "phone": phone,
                    "success": True,
                    "user_info": user_info
                })
                
                self.send_log(f"âœ… å¸³è™Ÿ {phone} æ¢å¾©æˆåŠŸ", "success")
                
            except Exception as e:
                self.send_log(f"âŒ æ¢å¾© {phone} å¤±æ•—: {e}", "error")
                results["fail_count"] += 1
                results["accounts"].append({
                    "phone": phone,
                    "success": False,
                    "error": str(e)
                })
        
        # åˆ·æ–°å¸³è™Ÿåˆ—è¡¨
        await self._send_accounts_updated()
        
        self.send_log(
            f"ğŸ“Š Session æ¢å¾©å®Œæˆ: æˆåŠŸ {results['success_count']}, å¤±æ•— {results['fail_count']}", 
            "success" if results['success_count'] > 0 else "warning"
        )
        
        self.send_event("orphan-sessions-recovered", {
            "success": True,
            **results
        })
        
    except Exception as e:
        self.send_log(f"Error recovering orphan sessions: {str(e)}", "error")
        self.send_event("orphan-sessions-recovered", {
            "success": False,
            "error": str(e)
        })


async def handle_import_session(self, payload: Dict[str, Any]):
    """Handle import-session command - import a session file or package"""
    import sys
    print(f"[Backend] handle_import_session called with payload: {payload}", file=sys.stderr)
    try:
        from pathlib import Path
        import shutil
        from session_package import SessionPackage, BatchSessionPackage
        
        file_path = payload.get('filePath')
        
        if not file_path:
            self.send_log("No file path provided", "error")
            return
        
        file_path = Path(file_path)
        if not file_path.exists():
            self.send_log(f"File not found: {file_path}", "error")
            return
        
        from config import SESSIONS_DIR
        
        # Check file type and handle accordingly
        if SessionPackage.is_package_file(file_path):
            # Import TG-Matrix session package (.tgpkg)
            success, message, account_data = SessionPackage.extract_package(file_path, SESSIONS_DIR)
            
            if not success:
                self.send_log(message, "error")
                self.send_event("session-import-result", {
                    "success": False,
                    "message": message
                })
                return
            
            # Check if account exists
            existing_account = await db.get_account_by_phone(account_data['phone'])
            if existing_account:
                # Update existing account with new credentials
                await db.update_account(existing_account['id'], {
                    'apiId': account_data.get('api_id') or account_data.get('apiId'),
                    'apiHash': account_data.get('api_hash') or account_data.get('apiHash'),
                    'proxy': account_data.get('proxy', existing_account.get('proxy', '')),
                    'status': 'Offline'
                })
                self.send_log(f"âœ… è³¬æˆ¶å·²æ›´æ–°: {account_data['phone']}", "success")
            else:
                # Create new account
                await db.add_account(account_data)
                self.send_log(f"âœ… è³¬æˆ¶å·²å°å…¥: {account_data['phone']}", "success")
            
            self.send_event("session-import-result", {
                "success": True,
                "message": f"Session package imported: {account_data['phone']}",
                "phone": account_data['phone']
            })
            
        elif str(file_path).lower().endswith('.tgbatch'):
            # Import batch package
            success, message, accounts_list = BatchSessionPackage.extract_batch_package(file_path, SESSIONS_DIR)
            
            if not success:
                self.send_log(message, "error")
                self.send_event("session-import-result", {
                    "success": False,
                    "message": message
                })
                return
            
            imported_count = 0
            for account_data in accounts_list:
                existing_account = await db.get_account_by_phone(account_data['phone'])
                if existing_account:
                    await db.update_account(existing_account['id'], {
                        'apiId': account_data.get('api_id') or account_data.get('apiId'),
                        'apiHash': account_data.get('api_hash') or account_data.get('apiHash'),
                        'proxy': account_data.get('proxy', ''),
                        'status': 'Offline'
                    })
                else:
                    await db.add_account(account_data)
                imported_count += 1
            
            self.send_log(f"âœ… æ‰¹é‡å°å…¥å®Œæˆ: {imported_count} å€‹è³¬æˆ¶", "success")
            self.send_event("session-import-result", {
                "success": True,
                "message": f"Batch import complete: {imported_count} accounts",
                "count": imported_count
            })
            
        elif SessionPackage.is_legacy_session(file_path):
            # Legacy .session file - requires API credentials
            print(f"[Backend] Processing legacy session file: {file_path}", file=sys.stderr)
            phone_number = payload.get('phoneNumber', '')
            api_id = payload.get('apiId', '')
            api_hash = payload.get('apiHash', '')
            
            # Determine phone number from filename if not provided
            if not phone_number:
                phone_number = file_path.stem.replace('+', '').replace('-', '').replace(' ', '')
            print(f"[Backend] Phone number from file: {phone_number}", file=sys.stderr)
            
            # Check if we have API credentials
            if not api_id or not api_hash:
                print(f"[Backend] No API credentials provided, checking database...", file=sys.stderr)
                # Try to get from existing account (æ•°æ®åº“å­—æ®µåæ˜¯ apiId å’Œ apiHash)
                # Try with and without + prefix
                existing_account = await db.get_account_by_phone(phone_number)
                if not existing_account:
                    existing_account = await db.get_account_by_phone(f"+{phone_number}")
                print(f"[Backend] Existing account found: {existing_account is not None}", file=sys.stderr)
                
                if existing_account and (existing_account.get('apiId') or existing_account.get('api_id')) and (existing_account.get('apiHash') or existing_account.get('api_hash')):
                    api_id = existing_account.get('apiId') or existing_account.get('api_id')
                    api_hash = existing_account.get('apiHash') or existing_account.get('api_hash')
                    print(f"[Backend] Using credentials from existing account", file=sys.stderr)
                else:
                    # Try to get from API credential pool
                    print(f"[Backend] Trying API credential pool...", file=sys.stderr)
                    try:
                        from api_credential_pool import get_api_credential_pool
                        data_dir = str(Path(config.DATA_PATH))
                        pool = get_api_credential_pool(data_dir)
                        recommended = pool.get_recommended_credential()
                        if recommended:
                            api_id = recommended.api_id
                            api_hash = recommended.api_hash
                            print(f"[Backend] Using recommended API credential: {api_id}", file=sys.stderr)
                    except Exception as pool_err:
                        print(f"[Backend] Error getting API from pool: {pool_err}", file=sys.stderr)
                
                if not api_id or not api_hash:
                    # No credentials - notify frontend to ask user
                    print(f"[Backend] No credentials available, notifying frontend", file=sys.stderr)
                    self.send_event("session-import-needs-credentials", {
                        "filePath": str(file_path),
                        "phoneNumber": phone_number,
                        "message": "æ­¤ session æ–‡ä»¶éœ€è¦ API ID å’Œ API Hash æ‰èƒ½ä½¿ç”¨"
                    })
                    self.send_log("âš ï¸ å°å…¥èˆŠæ ¼å¼ session éœ€è¦æä¾› API ID å’Œ API Hash", "warning")
                    return
            
            # Copy session file (skip if source and target are the same)
            target_path = SESSIONS_DIR / f"{phone_number}.session"
            source_resolved = Path(file_path).resolve()
            target_resolved = target_path.resolve()
            
            if source_resolved != target_resolved:
                # Only copy if different locations
                try:
                    shutil.copy2(file_path, target_path)
                    print(f"[Backend] Session file copied to {target_path}", file=sys.stderr)
                except PermissionError as pe:
                    print(f"[Backend] Permission error copying session: {pe}", file=sys.stderr)
                    # File might be locked, try to continue anyway if target exists
                    if not target_path.exists():
                        raise
                    print(f"[Backend] Target session already exists, continuing...", file=sys.stderr)
            else:
                print(f"[Backend] Source and target are same, skipping copy", file=sys.stderr)
            
            # Create or update account (æ•°æ®åº“å­—æ®µåæ˜¯ apiId å’Œ apiHash)
            existing_account = await db.get_account_by_phone(phone_number)
            if existing_account:
                await db.update_account(existing_account['id'], {
                    'apiId': api_id,
                    'apiHash': api_hash,
                    'status': 'Offline'
                })
            else:
                await db.add_account({
                    'phone': phone_number,
                    'apiId': api_id,
                    'apiHash': api_hash,
                    'proxy': payload.get('proxy', ''),
                    'group': payload.get('group', ''),
                    'role': payload.get('role', 'Unassigned'),
                    'status': 'Offline'
                })
            
            self.send_log(f"âœ… Session å·²å°å…¥: {phone_number}", "success")
            self.send_event("session-import-result", {
                "success": True,
                "message": f"Session imported: {phone_number}",
                "phone": phone_number
            })
        else:
            self.send_log(f"ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼: {file_path.suffix}", "error")
            self.send_event("session-import-result", {
                "success": False,
                "message": f"Unsupported file format: {file_path.suffix}"
            })
            return
        
        # Reload accounts
        await self._send_accounts_updated()
    
    except Exception as e:
        self.send_log(f"Error importing session: {str(e)}", "error")
        self.send_event("session-import-result", {
            "success": False,
            "message": str(e)
        })


async def handle_scan_tdata(self, payload: Dict[str, Any]):
    """æƒæ TData ç›®éŒ„ï¼Œè¿”å›å¸³è™Ÿåˆ—è¡¨"""
    try:
        from tdata_importer import get_tdata_importer
        
        path = payload.get('path', '')
        
        if not path:
            self.send_event("tdata-scan-result", {
                "success": False,
                "error": "æœªæä¾›è·¯å¾‘"
            })
            return
        
        importer = get_tdata_importer()
        result = importer.scan_tdata(path)
        
        self.send_event("tdata-scan-result", result)
        
        if result.get("success"):
            self.send_log(f"ğŸ“‚ ç™¼ç¾ {len(result.get('accounts', []))} å€‹å¸³è™Ÿ", "info")
        else:
            self.send_log(f"âŒ æƒæå¤±æ•—: {result.get('error', 'æœªçŸ¥éŒ¯èª¤')}", "error")
            
    except Exception as e:
        self.send_log(f"Error scanning TData: {str(e)}", "error")
        self.send_event("tdata-scan-result", {
            "success": False,
            "error": str(e)
        })


async def handle_import_tdata_account(self, payload: Dict[str, Any]):
    """å°å…¥å–®å€‹ TData å¸³è™Ÿ"""
    try:
        from tdata_importer import get_tdata_importer
        
        tdata_path = payload.get('tdataPath', '')
        account_index = payload.get('accountIndex', 0)
        api_id = payload.get('apiId')
        api_hash = payload.get('apiHash')
        
        if not tdata_path:
            self.send_event("tdata-import-result", {
                "success": False,
                "error": "æœªæä¾› TData è·¯å¾‘"
            })
            return
        
        self.send_log(f"ğŸ”„ æ­£åœ¨å°å…¥å¸³è™Ÿ #{account_index + 1}...", "info")
        
        importer = get_tdata_importer()
        result = await importer.import_account(
            tdata_path,
            account_index,
            api_id,
            api_hash
        )
        
        if result.get("success"):
            # æ·»åŠ å¸³è™Ÿåˆ°æ•¸æ“šåº«
            phone = result.get("phone", "").replace("+", "")
            existing = await db.get_account_by_phone(phone)
            
            if not existing:
                await db.add_account({
                    'phone': phone,
                    'apiId': api_id or '',
                    'apiHash': api_hash or '',
                    'status': 'Offline',
                    'firstName': result.get('first_name', ''),
                    'lastName': result.get('last_name', ''),
                    'username': result.get('username', ''),
                    'telegramId': str(result.get('user_id', ''))
                })
            
            self.send_log(f"âœ… å¸³è™Ÿå°å…¥æˆåŠŸ: {phone}", "success")
            
            # åˆ·æ–°å¸³è™Ÿåˆ—è¡¨ï¼ˆå¤šç§Ÿæˆ¶å®‰å…¨ï¼‰
            await self._send_accounts_updated()
        else:
            self.send_log(f"âŒ å°å…¥å¤±æ•—: {result.get('error', 'æœªçŸ¥éŒ¯èª¤')}", "error")
        
        self.send_event("tdata-import-result", result)
        
    except Exception as e:
        self.send_log(f"Error importing TData account: {str(e)}", "error")
        self.send_event("tdata-import-result", {
            "success": False,
            "error": str(e)
        })


async def handle_import_tdata_batch(self, payload: Dict[str, Any]):
    """æ‰¹é‡å°å…¥ TData å¸³è™Ÿ"""
    try:
        from tdata_importer import get_tdata_importer
        
        tdata_path = payload.get('tdataPath', '')
        account_indices = payload.get('accountIndices', [])
        api_id = payload.get('apiId')
        api_hash = payload.get('apiHash')
        
        if not tdata_path or not account_indices:
            self.send_event("tdata-batch-result", {
                "success": False,
                "error": "æœªæä¾›å¿…è¦åƒæ•¸"
            })
            return
        
        self.send_log(f"ğŸ”„ é–‹å§‹æ‰¹é‡å°å…¥ {len(account_indices)} å€‹å¸³è™Ÿ...", "info")
        
        importer = get_tdata_importer()
        
        def progress_callback(current, total, message):
            self.send_event("tdata-import-progress", {
                "current": current,
                "total": total,
                "message": message
            })
        
        result = await importer.import_batch(
            tdata_path,
            account_indices,
            api_id,
            api_hash,
            progress_callback
        )
        
        # æ·»åŠ æˆåŠŸçš„å¸³è™Ÿåˆ°æ•¸æ“šåº«
        for account in result.get("accounts", []):
            if account.get("success"):
                phone = account.get("phone", "").replace("+", "")
                existing = await db.get_account_by_phone(phone)
                
                if not existing:
                    await db.add_account({
                        'phone': phone,
                        'apiId': api_id or '',
                        'apiHash': api_hash or '',
                        'status': 'Offline',
                        'firstName': account.get('first_name', ''),
                        'lastName': account.get('last_name', ''),
                        'username': account.get('username', ''),
                        'telegramId': str(account.get('user_id', ''))
                    })
        
        self.send_log(
            f"ğŸ“Š æ‰¹é‡å°å…¥å®Œæˆ: æˆåŠŸ {result.get('success_count', 0)}, å¤±æ•— {result.get('fail_count', 0)}", 
            "success" if result.get('success_count', 0) > 0 else "warning"
        )
        
        # åˆ·æ–°å¸³è™Ÿåˆ—è¡¨ï¼ˆå¤šç§Ÿæˆ¶å®‰å…¨ï¼‰
        await self._send_accounts_updated()
        
        self.send_event("tdata-batch-result", result)
        
    except Exception as e:
        self.send_log(f"Error batch importing TData: {str(e)}", "error")
        self.send_event("tdata-batch-result", {
            "success": False,
            "error": str(e)
        })


async def handle_get_default_tdata_path(self):
    """ç²å–ç³»çµ±é»˜èª TData è·¯å¾‘"""
    try:
        from tdata_importer import get_tdata_importer
        
        importer = get_tdata_importer()
        result = importer.check_default_tdata()
        
        self.send_event("default-tdata-path", result)
        
    except Exception as e:
        self.send_event("default-tdata-path", {
            "path": "",
            "exists": False,
            "error": str(e)
        })


async def handle_export_session(self, payload: Dict[str, Any]):
    """Handle export-session command - export a session package with credentials"""
    try:
        from pathlib import Path
        from session_package import SessionPackage
        
        phone_number = payload.get('phoneNumber')
        export_path = payload.get('filePath')
        export_format = payload.get('format', 'package')  # 'package' or 'legacy'
        
        if not phone_number:
            self.send_log("No phone number provided", "error")
            return
        
        if not export_path:
            self.send_log("No export path provided", "error")
            return
        
        # Get account data
        account = await db.get_account_by_phone(phone_number)
        if not account:
            self.send_log(f"Account not found: {phone_number}", "error")
            return
        
        # Find session file
        from config import SESSIONS_DIR
        safe_phone = phone_number.replace("+", "").replace("-", "").replace(" ", "")
        session_file = SESSIONS_DIR / f"{safe_phone}.session"
        
        if not session_file.exists():
            self.send_log(f"Session file not found for {phone_number}", "error")
            return
        
        export_path_obj = Path(export_path)
        
        if export_format == 'package' or export_path.endswith('.tgpkg'):
            # Export as TG-Matrix session package (recommended)
            # æ•°æ®åº“å­—æ®µåæ˜¯ apiId å’Œ apiHash
            success, message = SessionPackage.create_package(
                session_file_path=session_file,
                api_id=account.get('apiId') or account.get('api_id', ''),
                api_hash=account.get('apiHash') or account.get('api_hash', ''),
                phone=phone_number,
                output_path=export_path_obj,
                proxy=account.get('proxy', ''),
                role=account.get('role', 'Unassigned'),
                group=account.get('group', ''),
                daily_send_limit=account.get('dailySendLimit') or account.get('daily_send_limit', 50),
                notes=account.get('notes', '')
            )
            
            if success:
                self.send_log(f"âœ… Session åŒ…å·²å°å‡º: {phone_number}", "success")
                self.send_event("session-exported", {
                    "phoneNumber": phone_number,
                    "filePath": str(export_path_obj) if not str(export_path_obj).endswith('.tgpkg') else str(export_path_obj),
                    "format": "package"
                })
            else:
                self.send_log(f"å°å‡ºå¤±æ•—: {message}", "error")
        else:
            # Legacy export (just session file, not recommended)
            import shutil
            shutil.copy2(session_file, export_path_obj)
            self.send_log(f"âš ï¸ Session æ–‡ä»¶å·²å°å‡º (ä¸åŒ…å« API æ†‘è­‰): {phone_number}", "warning")
            self.send_event("session-exported", {
                "phoneNumber": phone_number,
                "filePath": export_path,
                "format": "legacy",
                "warning": "ä¸åŒ…å« API æ†‘è­‰ï¼Œå°å…¥æ™‚éœ€è¦é‡æ–°è¼¸å…¥"
            })
    
    except Exception as e:
        self.send_log(f"Error exporting session: {str(e)}", "error")


async def handle_export_sessions_batch(self, payload: Dict[str, Any]):
    """Handle batch export of multiple sessions"""
    try:
        from pathlib import Path
        from session_package import BatchSessionPackage
        from config import SESSIONS_DIR
        
        phone_numbers = payload.get('phoneNumbers', [])
        export_path = payload.get('filePath')
        
        if not phone_numbers:
            self.send_log("No accounts selected for export", "error")
            return
        
        if not export_path:
            self.send_log("No export path provided", "error")
            return
        
        # Get account data for all selected phones
        accounts_data = []
        for phone in phone_numbers:
            account = await db.get_account_by_phone(phone)
            if account:
                accounts_data.append(account)
        
        if not accounts_data:
            self.send_log("No valid accounts found", "error")
            return
        
        export_path_obj = Path(export_path)
        success, message, count = BatchSessionPackage.create_batch_package(
            accounts_data=accounts_data,
            sessions_dir=SESSIONS_DIR,
            output_path=export_path_obj
        )
        
        if success:
            self.send_log(f"âœ… æ‰¹é‡å°å‡ºå®Œæˆ: {count} å€‹è³¬æˆ¶", "success")
            self.send_event("sessions-batch-exported", {
                "count": count,
                "filePath": str(export_path_obj)
            })
        else:
            self.send_log(f"æ‰¹é‡å°å‡ºå¤±æ•—: {message}", "error")
    
    except Exception as e:
        self.send_log(f"Error batch exporting sessions: {str(e)}", "error")


# ==================== TData Import Handlers ====================

async def handle_select_tdata_folder(self, payload: Dict[str, Any]):
    """è™•ç†é¸æ“‡ TData æ–‡ä»¶å¤¾è«‹æ±‚"""
    try:
        # é€™å€‹éœ€è¦ç”±å‰ç«¯çš„ Electron è™•ç†æ–‡ä»¶å°è©±æ¡†
        # é€™è£¡åªæ˜¯ç™¼é€ä¸€å€‹äº‹ä»¶è®“å‰ç«¯æ‰“é–‹å°è©±æ¡†
        self.send_event("open-folder-dialog", {
            "purpose": "tdata",
            "title": "é¸æ“‡ TData æ–‡ä»¶å¤¾"
        })
    except Exception as e:
        print(f"[Backend] Error in select-tdata-folder: {e}", file=sys.stderr)


async def handle_parse_tdata(self, payload: Dict[str, Any]):
    """è§£æ TData æ–‡ä»¶å¤¾"""
    try:
        from tdata_importer import get_tdata_importer
        
        tdata_path = payload.get("path", "")
        
        if not tdata_path:
            self.send_event("tdata-parsed", {
                "success": False,
                "error": "è«‹æŒ‡å®š TData è·¯å¾‘"
            })
            return
        
        importer = get_tdata_importer(str(self.sessions_dir))
        accounts = importer.find_tdata_accounts(tdata_path)
        
        self.send_event("tdata-parsed", {
            "success": True,
            "accounts": accounts,
            "count": len(accounts)
        })
        
        self.send_log(f"ğŸ“‚ å·²è§£æ TDataï¼Œæ‰¾åˆ° {len(accounts)} å€‹å¸³æˆ¶", "info")
        
    except Exception as e:
        print(f"[Backend] Error parsing TData: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("tdata-parsed", {
            "success": False,
            "error": str(e)
        })


async def handle_import_tdata(self, payload: Dict[str, Any]):
    """å°å…¥ TData å¸³æˆ¶"""
    try:
        from tdata_importer import get_tdata_importer
        from database import db
        
        tdata_path = payload.get("path", "")
        accounts = payload.get("accounts", [])
        
        if not tdata_path or not accounts:
            self.send_event("tdata-imported", {
                "success": False,
                "error": "è«‹æŒ‡å®š TData è·¯å¾‘å’Œè¦å°å…¥çš„å¸³æˆ¶"
            })
            return
        
        importer = get_tdata_importer(str(self.sessions_dir))
        result = importer.import_batch(tdata_path, accounts)
        
        # ç‚ºæˆåŠŸå°å…¥çš„å¸³æˆ¶æ·»åŠ åˆ°æ•¸æ“šåº«
        for detail in result.get("details", []):
            if detail.get("success"):
                phone = detail.get("phone")
                try:
                    # æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
                    existing = await db.get_account_by_phone(phone)
                    if not existing:
                        # æ·»åŠ æ–°å¸³æˆ¶
                        from device_fingerprint import DeviceFingerprintGenerator
                        fingerprint = DeviceFingerprintGenerator.generate_for_phone(phone)
                        
                        await db.add_account({
                            "phone": phone,
                            "status": "Offline",
                            "deviceModel": fingerprint.get("device_model", "Unknown"),
                            "systemVersion": fingerprint.get("system_version", "Unknown"),
                            "appVersion": fingerprint.get("app_version", "Unknown"),
                            "langCode": fingerprint.get("lang_code", "en"),
                            "platform": fingerprint.get("platform", "android"),
                            "healthScore": 100,
                            "dailySendLimit": 50
                        })
                except Exception as e:
                    print(f"[Backend] Error adding imported account {phone}: {e}", file=sys.stderr)
        
        self.send_event("tdata-imported", {
            "success": True,
            **result
        })
        
        self.send_log(f"ğŸ“¥ TData å°å…¥å®Œæˆï¼šæˆåŠŸ {result['success_count']} å€‹ï¼Œå¤±æ•— {result['fail_count']} å€‹", "info")
        
        # åˆ·æ–°å¸³æˆ¶åˆ—è¡¨ï¼ˆå¤šç§Ÿæˆ¶å®‰å…¨ï¼‰
        await self._send_accounts_updated()
        
    except Exception as e:
        print(f"[Backend] Error importing TData: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("tdata-imported", {
            "success": False,
            "error": str(e)
        })

