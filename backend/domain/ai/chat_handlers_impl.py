"""
Extracted handler implementations: ai_chat
Auto-generated by refactor_main.py
"""
import json
import sys
import time
import asyncio
import traceback
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from service_context import get_service_context
from database import db

# All handlers receive (self, payload) where self is BackendService instance.
# They are called via: await handler_impl(self, payload)
# Inside, use self.db, self.send_event(), self.telegram_manager, etc.
# This is a transitional pattern - later, replace self.xxx with ctx.xxx


# ==================== AI Auto Chat Handlers ====================

async def handle_get_ai_chat_settings(self):
    """Get AI auto chat settings"""
    try:
        settings = await db.get_ai_settings()
        self.send_event("ai-chat-settings", {
            "success": True,
            "settings": settings
        })
    except Exception as e:
        self.send_event("ai-chat-settings", {
            "success": False,
            "error": str(e)
        })


async def handle_update_ai_chat_settings(self, payload: Dict[str, Any]):
    """Update AI auto chat settings"""
    try:
        settings = payload.get('settings', {})
        await db.update_ai_settings(settings)
        
        # Update AI auto chat service
        await ai_auto_chat.update_settings(settings)
        
        # Update AI endpoint if provided
        if 'localAiEndpoint' in payload:
            ai_auto_chat.set_ai_config(
                payload.get('localAiEndpoint', ''),
                payload.get('localAiModel', '')
            )
        
        self.send_event("ai-chat-settings-updated", {"success": True})
        self.send_log("AI è‡ªå‹•èŠå¤©è¨­ç½®å·²æ›´æ–°", "success")
    except Exception as e:
        self.send_event("ai-chat-settings-updated", {
            "success": False,
            "error": str(e)
        })
        self.send_log(f"æ›´æ–° AI è¨­ç½®å¤±æ•—: {str(e)}", "error")


async def handle_get_chat_history(self, payload: Dict[str, Any]):
    """Get chat history for a user"""
    try:
        user_id = payload.get('userId', '')
        limit = payload.get('limit', 50)
        
        if not user_id:
            self.send_event("chat-history", {"success": False, "error": "Missing userId"})
            return
        
        history = await db.get_chat_history(user_id, limit=limit)
        stats = await db.get_chat_stats(user_id)
        
        self.send_event("chat-history", {
            "success": True,
            "userId": user_id,
            "history": history,
            "stats": stats
        })
    except Exception as e:
        self.send_event("chat-history", {
            "success": False,
            "error": str(e)
        })


async def handle_get_user_context(self, payload: Dict[str, Any]):
    """Get full user context"""
    try:
        user_id = payload.get('userId', '')
        
        if not user_id:
            self.send_event("user-context", {"success": False, "error": "Missing userId"})
            return
        
        context = await ai_context.get_user_context(user_id)
        
        self.send_event("user-context", {
            "success": True,
            "userId": user_id,
            "context": context
        })
    except Exception as e:
        self.send_event("user-context", {
            "success": False,
            "error": str(e)
        })


async def handle_generate_ai_response(self, payload: Dict[str, Any]):
    """Generate AI response for a user message"""
    import time
    import sys
    start_time = time.time()
    
    print(f"[AI] handle_generate_ai_response called with payload keys: {payload.keys()}", file=sys.stderr)
    try:
        user_id = payload.get('userId', '')
        message = payload.get('message', '')
        system_prompt = payload.get('systemPrompt', '')
        endpoint = payload.get('localAiEndpoint', '')
        model = payload.get('localAiModel', '')
        
        print(f"[AI] Endpoint: {endpoint}, Model: {model}", file=sys.stderr)
        print(f"[AI] Message length: {len(message)}, System prompt length: {len(system_prompt)}", file=sys.stderr)
        
        if not message:
            self.send_event("ai-response", {"success": False, "error": "ç¼ºå°‘æ¶ˆæ¯å…§å®¹"})
            return
        
        if not endpoint:
            self.send_event("ai-response", {"success": False, "error": "æœªé…ç½® AI æœå‹™ç«¯é»"})
            return
        
        # å¦‚æœæä¾›äº†ç«¯é»ï¼Œç›´æ¥èª¿ç”¨æœ¬åœ° AI
        if endpoint:
            print(f"[AI] Calling local AI service at {endpoint}...", file=sys.stderr)
            response = await self._call_local_ai(endpoint, model, system_prompt, message)
        else:
            # ä½¿ç”¨ ai_auto_chat æœå‹™
            print(f"[AI] Using ai_auto_chat service...", file=sys.stderr)
            ai_auto_chat.set_ai_config(endpoint, model)
            response = await ai_auto_chat.get_suggested_response(user_id, message)
        
        elapsed = time.time() - start_time
        print(f"[AI] AI generation completed in {elapsed:.2f}s", file=sys.stderr)
        
        if response:
            print(f"[AI] Successfully generated response (length: {len(response)})", file=sys.stderr)
            self.send_event("ai-response", {
                "success": True,
                "userId": user_id,
                "response": response
            })
        else:
            print(f"[AI] AI returned empty response", file=sys.stderr)
            self.send_event("ai-response", {
                "success": False,
                "error": "AI ç”Ÿæˆå¤±æ•—ï¼Œè¿”å›ç‚ºç©ºã€‚è«‹æª¢æŸ¥æœå‹™é…ç½®å’Œæ—¥èªŒ"
            })
    except asyncio.TimeoutError:
        elapsed = time.time() - start_time
        error_msg = f"AI ç”Ÿæˆè¶…æ™‚ï¼ˆ{elapsed:.1f}ç§’ï¼‰ï¼Œè«‹æª¢æŸ¥æœå‹™é€£æ¥"
        print(f"[AI] {error_msg}", file=sys.stderr)
        self.send_event("ai-response", {
            "success": False,
            "error": error_msg
        })
    except Exception as e:
        import traceback
        elapsed = time.time() - start_time
        error_details = traceback.format_exc()
        error_msg = f"AI ç”ŸæˆéŒ¯èª¤: {str(e)}"
        print(f"[AI] Error after {elapsed:.2f}s: {error_details}", file=sys.stderr)
        self.send_event("ai-response", {
            "success": False,
            "error": error_msg
        })


async def handle_add_ai_memory(self, payload: Dict[str, Any]):
    """Add an AI memory for a user"""
    try:
        user_id = payload.get('userId', '')
        memory_type = payload.get('memoryType', 'fact')
        content = payload.get('content', '')
        importance = payload.get('importance', 0.5)
        
        if not user_id or not content:
            self.send_event("ai-memory-added", {"success": False, "error": "Missing userId or content"})
            return
        
        memory_id = await db.add_ai_memory(user_id, memory_type, content, importance)
        
        self.send_event("ai-memory-added", {
            "success": True,
            "memoryId": memory_id
        })
        self.send_log(f"ç‚ºç”¨æˆ¶ {user_id} æ·»åŠ äº†è¨˜æ†¶", "success")
    except Exception as e:
        self.send_event("ai-memory-added", {
            "success": False,
            "error": str(e)
        })


async def handle_get_ai_memories(self, payload: Dict[str, Any]):
    """Get AI memories for a user"""
    try:
        user_id = payload.get('userId', '')
        memory_type = payload.get('memoryType')
        limit = payload.get('limit', 10)
        
        if not user_id:
            self.send_event("ai-memories", {"success": False, "error": "Missing userId"})
            return
        
        memories = await db.get_ai_memories(user_id, memory_type, limit)
        
        self.send_event("ai-memories", {
            "success": True,
            "userId": user_id,
            "memories": memories
        })
    except Exception as e:
        self.send_event("ai-memories", {
            "success": False,
            "error": str(e)
        })


async def handle_analyze_conversation(self, payload: Dict[str, Any]):
    """Analyze conversation and provide insights"""
    try:
        user_id = payload.get('userId', '')
        lead_id = payload.get('leadId')
        
        if not user_id:
            self.send_event("conversation-analysis", {"success": False, "error": "Missing userId"})
            return
        
        # Get conversation history
        history = await db.get_chat_history(user_id, limit=50)
        
        # Analyze conversation
        analysis = await ai_context.analyze_conversation_stage(user_id, history)
        
        self.send_event("conversation-analysis", {
            "success": True,
            "userId": user_id,
            "leadId": lead_id,
            "analysis": analysis
        })
    except Exception as e:
        self.send_event("conversation-analysis", {
            "success": False,
            "error": str(e)
        })


# ==================== AI Marketing Strategy Handlers ====================

async def handle_generate_ai_strategy(self, payload: Dict[str, Any]):
    """ä½¿ç”¨ AI ç”Ÿæˆç‡ŸéŠ·ç­–ç•¥"""
    try:
        user_input = payload.get('userInput', '')
        
        if not user_input:
            self.send_event("ai-strategy-generated", {
                "success": False,
                "error": "è«‹è¼¸å…¥æ‚¨çš„éœ€æ±‚"
            })
            return
        
        # å˜—è©¦ä½¿ç”¨ AI ç”Ÿæˆç­–ç•¥
        try:
            from ai_context import ai_context
            
            prompt = f"""
            æ ¹æ“šç”¨æˆ¶çš„ç‡ŸéŠ·éœ€æ±‚ï¼Œç”Ÿæˆè©³ç´°çš„ç‡ŸéŠ·ç­–ç•¥ã€‚

            ç”¨æˆ¶éœ€æ±‚ï¼š{user_input}

            è«‹è¿”å› JSON æ ¼å¼çš„ç­–ç•¥ï¼ŒåŒ…å«ï¼š
            1. industry: è­˜åˆ¥çš„ç›®æ¨™è¡Œæ¥­
            2. targetAudience: ç›®æ¨™å—çœ¾æè¿°
            3. keywords: åˆ†ç‚º highIntentï¼ˆé«˜æ„å‘ï¼‰ã€mediumIntentï¼ˆä¸­æ„å‘ï¼‰ã€extendedï¼ˆæ“´å±•ï¼‰ä¸‰é¡é—œéµè©
            4. customerProfile: å®¢æˆ¶ç•«åƒï¼ŒåŒ…å« identityï¼ˆèº«ä»½ï¼‰ã€featuresï¼ˆç‰¹å¾µï¼‰ã€needsï¼ˆéœ€æ±‚ï¼‰
            5. recommendedGroups: å»ºè­°æœç´¢çš„ç¾¤çµ„é¡å‹
            6. messageTemplates: æ¶ˆæ¯æ¨¡æ¿ï¼ŒåŒ…å« firstTouchï¼ˆé¦–æ¬¡è§¸é”ï¼‰ã€followUpï¼ˆè·Ÿé€²ï¼‰ã€closingï¼ˆä¿ƒæˆï¼‰
            """
            
            response = await ai_context.generate_response(
                user_id="system",
                message=prompt,
                context=[]
            )
            
            # å˜—è©¦è§£æ AI è¿”å›çš„ JSON
            import json
            import re
            
            # æå– JSON
            json_match = re.search(r'\{[\s\S]*\}', response)
            if json_match:
                strategy = json.loads(json_match.group())
                self.send_event("ai-strategy-generated", {
                    "success": True,
                    "strategy": strategy
                })
                return
                
        except Exception as ai_error:
            print(f"[AI Strategy] AI generation failed: {ai_error}", file=sys.stderr)
        
        # å¦‚æœ AI ç”Ÿæˆå¤±æ•—ï¼Œè¿”å›éŒ¯èª¤è®“å‰ç«¯ä½¿ç”¨æœ¬åœ°æ¨¡æ¿
        self.send_event("ai-strategy-generated", {
            "success": False,
            "error": "AI æœå‹™æš«æ™‚ä¸å¯ç”¨ï¼Œå·²ä½¿ç”¨æœ¬åœ°æ¨¡æ¿"
        })
        
    except Exception as e:
        self.send_event("ai-strategy-generated", {
            "success": False,
            "error": str(e)
        })


async def handle_save_ai_strategy(self, payload: Dict[str, Any]):
    """ä¿å­˜ AI ç­–ç•¥"""
    try:
        name = payload.get('name', f"ç­–ç•¥_{datetime.now().strftime('%Y%m%d_%H%M%S')}")
        strategy = payload.get('strategy', {})
        
        # ä¿å­˜åˆ°æ•¸æ“šåº«
        await db.execute(
            """INSERT INTO ai_strategies (name, strategy_json, created_at) 
               VALUES (?, ?, CURRENT_TIMESTAMP)
               ON CONFLICT(name) DO UPDATE SET strategy_json = ?, updated_at = CURRENT_TIMESTAMP""",
            (name, json.dumps(strategy), json.dumps(strategy))
        )
        
        self.send_log(f"âœ… ç­–ç•¥å·²ä¿å­˜: {name}", "success")
        self.send_event("ai-strategy-saved", {"success": True, "name": name})
        
    except Exception as e:
        self.send_log(f"âŒ ä¿å­˜ç­–ç•¥å¤±æ•—: {e}", "error")
        self.send_event("ai-strategy-saved", {"success": False, "error": str(e)})


async def handle_get_ai_strategies(self, payload: Dict[str, Any]):
    """ç²å–å·²ä¿å­˜çš„ç­–ç•¥åˆ—è¡¨"""
    try:
        strategies = await db.fetch_all(
            "SELECT * FROM ai_strategies ORDER BY created_at DESC LIMIT 50"
        )
        
        result = []
        for s in strategies:
            try:
                result.append({
                    "id": s.get('id'),
                    "name": s.get('name'),
                    "strategy": json.loads(s.get('strategy_json', '{}')),
                    "createdAt": s.get('created_at'),
                    "stats": {
                        "totalLeads": 0,
                        "contacted": 0,
                        "converted": 0
                    }
                })
            except:
                pass
        
        self.send_event("ai-strategies-list", {"success": True, "strategies": result})
        
    except Exception as e:
        self.send_event("ai-strategies-list", {"success": False, "error": str(e)})


async def handle_execute_ai_strategy(self, payload: Dict[str, Any]):
    """åŸ·è¡Œ AI ç‡ŸéŠ·ç­–ç•¥"""
    try:
        strategy = payload.get('strategy', {})
        
        self.send_log(f"ğŸš€ é–‹å§‹åŸ·è¡Œ AI ç­–ç•¥: {strategy.get('industry', 'æœªçŸ¥')}", "info")
        
        # 1. å‰µå»ºé—œéµè©é›†
        keywords = strategy.get('keywords', {})
        all_keywords = (
            keywords.get('highIntent', []) + 
            keywords.get('mediumIntent', []) + 
            keywords.get('extended', [])
        )
        
        if all_keywords:
            # ä¿å­˜ç‚ºé—œéµè©é›†
            keyword_set_name = f"AIç­–ç•¥_{strategy.get('industry', 'è‡ªå®šç¾©')}"
            await db.execute(
                """INSERT INTO keyword_sets (name, keywords, is_active, created_at)
                   VALUES (?, ?, 1, CURRENT_TIMESTAMP)
                   ON CONFLICT(name) DO UPDATE SET keywords = ?, is_active = 1""",
                (keyword_set_name, json.dumps(all_keywords), json.dumps(all_keywords))
            )
            self.send_log(f"âœ… å·²å‰µå»ºé—œéµè©é›†: {keyword_set_name} ({len(all_keywords)} å€‹é—œéµè©)", "success")
        
        # 2. ä¿å­˜æ¶ˆæ¯æ¨¡æ¿
        templates = strategy.get('messageTemplates', {})
        for template_type, content in templates.items():
            if content:
                template_name = f"AI_{strategy.get('industry', '')}_{template_type}"
                await db.execute(
                    """INSERT INTO message_templates (name, content, template_type, created_at)
                       VALUES (?, ?, ?, CURRENT_TIMESTAMP)
                       ON CONFLICT(name) DO UPDATE SET content = ?""",
                    (template_name, content, template_type, content)
                )
        self.send_log(f"âœ… å·²å‰µå»ºæ¶ˆæ¯æ¨¡æ¿", "success")
        
        # 3. ç™¼é€åŸ·è¡Œç‹€æ…‹
        self.send_event("ai-execution-status", {
            "isExecuting": True,
            "phase": "initialized",
            "message": "ç­–ç•¥å·²åˆå§‹åŒ–ï¼Œæº–å‚™é–‹å§‹æœç´¢ç¾¤çµ„..."
        })
        
        # 4. é–‹å§‹æœç´¢ç¾¤çµ„ï¼ˆç•°æ­¥åŸ·è¡Œï¼‰
        asyncio.create_task(self._execute_ai_group_search(strategy))
        
        self.send_event("ai-strategy-executed", {"success": True})
        
    except Exception as e:
        self.send_log(f"âŒ åŸ·è¡Œç­–ç•¥å¤±æ•—: {e}", "error")
        self.send_event("ai-strategy-executed", {"success": False, "error": str(e)})


async def handle_save_conversation_strategy(self, payload: Dict[str, Any]):
    """ğŸ”§ ä¿å­˜å°è©±ç­–ç•¥"""
    try:
        style = payload.get('style', 'friendly')
        response_length = payload.get('responseLength', 'medium')
        use_emoji = payload.get('useEmoji', True)
        custom_persona = payload.get('customPersona', '')
        
        # ä¿å­˜åˆ° ai_settings è¡¨
        await db.execute("""
            INSERT INTO ai_settings (key, value) VALUES ('conversation_strategy', ?)
            ON CONFLICT(key) DO UPDATE SET value = excluded.value, updated_at = CURRENT_TIMESTAMP
        """, (json.dumps({
            'style': style,
            'responseLength': response_length,
            'useEmoji': use_emoji,
            'customPersona': custom_persona
        }),))
        
        # åŒæ™‚æ›´æ–° system_promptï¼ˆå¦‚æœæœ‰è‡ªå®šç¾©äººè¨­ï¼‰
        if custom_persona:
            await db.execute("""
                INSERT INTO ai_settings (key, value) VALUES ('system_prompt', ?)
                ON CONFLICT(key) DO UPDATE SET value = excluded.value, updated_at = CURRENT_TIMESTAMP
            """, (custom_persona,))
        
        print(f"[AI] å°è©±ç­–ç•¥å·²ä¿å­˜: style={style}, length={response_length}, emoji={use_emoji}", file=sys.stderr)
        self.send_event("conversation-strategy-saved", {"success": True})
        
    except Exception as e:
        print(f"[AI] ä¿å­˜å°è©±ç­–ç•¥å¤±æ•—: {e}", file=sys.stderr)
        self.send_event("conversation-strategy-saved", {"success": False, "error": str(e)})


async def handle_get_conversation_strategy(self):
    """ğŸ”§ ç²å–å°è©±ç­–ç•¥"""
    try:
        row = await db.fetch_one(
            "SELECT value FROM ai_settings WHERE key = 'conversation_strategy'"
        )
        
        if row and row.get('value'):
            strategy = json.loads(row['value'])
        else:
            strategy = {
                'style': 'friendly',
                'responseLength': 'medium',
                'useEmoji': True,
                'customPersona': ''
            }
        
        print(f"[AI] å°è©±ç­–ç•¥å·²åŠ è¼‰: {strategy}", file=sys.stderr)
        self.send_event("conversation-strategy-loaded", {"success": True, "strategy": strategy})
        
    except Exception as e:
        print(f"[AI] ç²å–å°è©±ç­–ç•¥å¤±æ•—: {e}", file=sys.stderr)
        self.send_event("conversation-strategy-loaded", {"success": False, "error": str(e)})


# ==================== Chat History Handlers ====================

async def handle_get_chat_history_full(self, payload: Dict[str, Any]):
    """ç²å–å®Œæ•´èŠå¤©è¨˜éŒ„ï¼ˆæ”¯æŒåˆ†é å’Œç·©å­˜ï¼‰"""
    try:
        import sys
        user_id = payload.get('userId', '')
        limit = payload.get('limit', 50)
        offset = payload.get('offset', 0)
        
        print(f"[Backend] Getting chat history for user {user_id}, limit={limit}, offset={offset}", file=sys.stderr)
        
        # å„ªåŒ–ï¼šåªæŸ¥è©¢ä¸€æ¬¡ï¼Œç²å– limit+1 æ¢ä¾†åˆ¤æ–·æ˜¯å¦æœ‰æ›´å¤š
        history = await db.get_chat_history_paginated(
            user_id=user_id,
            limit=limit + 1,  # å¤šå–ä¸€æ¢ä¾†åˆ¤æ–·æ˜¯å¦æœ‰æ›´å¤š
            offset=offset
        )
        
        # åˆ¤æ–·æ˜¯å¦æœ‰æ›´å¤šæ¶ˆæ¯
        has_more = len(history) > limit
        # åªè¿”å› limit æ¢
        if has_more:
            history = history[:limit]
        
        # ç²å–ç¸½æ•¸ï¼ˆä½¿ç”¨æ›´å¿«çš„æŸ¥è©¢ï¼Œåªåœ¨éœ€è¦æ™‚åŸ·è¡Œï¼‰
        # å¦‚æœ offset=0 ä¸”æ²’æœ‰æ›´å¤šæ¶ˆæ¯ï¼Œç¸½æ•¸å°±æ˜¯ç•¶å‰æ•¸é‡
        if offset == 0 and not has_more:
            total_count = len(history)
        else:
            # éœ€è¦æŸ¥è©¢ç¸½æ•¸
            try:
                cursor = await db._connection.execute("""
                    SELECT COUNT(*) as total FROM chat_history WHERE user_id = ?
                """, (user_id,))
                total_row = await cursor.fetchone()
                total_count = total_row['total'] if total_row else len(history)
            except Exception as count_err:
                print(f"[Backend] Error getting total count: {count_err}", file=sys.stderr)
                total_count = len(history)  # é™ç´šï¼šä½¿ç”¨ç•¶å‰æ•¸é‡
        
        # ç²å–ç”¨æˆ¶è³‡æ–™
        profile = await db.get_user_profile(user_id)
        
        # ç²å–ç”¨æˆ¶æ¨™ç±¤
        cursor = await db._connection.execute("""
            SELECT tag, tag_type, confidence FROM user_tags WHERE user_id = ?
        """, (user_id,))
        tags = [dict(row) for row in await cursor.fetchall()]
        
        # æ ¼å¼åŒ–æ¶ˆæ¯ï¼ˆåè½‰é †åºï¼Œå¾èˆŠåˆ°æ–°ï¼‰
        formatted_messages = []
        for msg in reversed(history):  # åè½‰ç‚ºå¾èˆŠåˆ°æ–°
            formatted_messages.append({
                "id": msg.get('id'),
                "role": msg.get('role'),
                "content": msg.get('content'),
                "timestamp": msg.get('timestamp'),
                "accountPhone": msg.get('account_phone'),
                "sourceGroup": msg.get('source_group'),
            })
        
        print(f"[Backend] Sending chat history: {len(formatted_messages)} messages, hasMore={has_more}, total={total_count}", file=sys.stderr)
        
        self.send_event("chat-history-full", {
            "success": True,
            "userId": user_id,
            "messages": formatted_messages,
            "profile": profile,
            "tags": tags,
            "total": total_count,
            "hasMore": has_more  # æ·»åŠ  hasMore å­—æ®µ
        })
    except Exception as e:
        import traceback
        import sys
        error_details = traceback.format_exc()
        print(f"[Backend] Error getting chat history: {error_details}", file=sys.stderr)
        self.send_event("chat-history-full", {
            "success": False,
            "error": str(e),
            "userId": payload.get('userId', '')
        })

