"""
Extracted handler implementations: rag
Auto-generated by refactor_main.py
"""
import json
import sys
import time
import asyncio
import traceback
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from service_context import get_service_context
from database import db

import os
import re
from service_locator import ai_auto_chat, get_knowledge_search_engine
# All handlers receive (self, payload) where self is BackendService instance.
# They are called via: await handler_impl(self, payload)
# Inside, use self.db, self.send_event(), self.telegram_manager, etc.
# This is a transitional pattern - later, replace self.xxx with ctx.xxx


# ==================== ğŸ§  RAG çŸ¥è­˜å¤§è…¦ 2.0 ====================

async def handle_rag_initialize(self, payload: Dict[str, Any]):
    """åˆå§‹åŒ– RAG ç³»çµ±"""
    import sys
    print(f"[Backend] ğŸ§  RAG Initialize", file=sys.stderr)
    
    try:
        from telegram_rag_system import telegram_rag
        
        use_chromadb = payload.get('useChromadb', True)
        # ğŸ”§ Phase 1 å„ªåŒ–ï¼šé»˜èªç¦ç”¨ç¥ç¶“ç¶²çµ¡åµŒå…¥ï¼Œç¯€çœ 300-500MB å…§å­˜
        use_neural = payload.get('useNeural', False)
        
        success = await telegram_rag.initialize(
            use_chromadb=use_chromadb,
            use_neural=use_neural
        )
        
        self.send_event("rag-initialized", {
            "success": success,
            "chromadbEnabled": telegram_rag.use_chromadb,
            "neuralEmbedding": telegram_rag.use_neural_embedding
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("rag-initialized", {
            "success": False,
            "error": str(e)
        })


async def handle_rag_search(self, payload: Dict[str, Any]):
    """RAG èªç¾©æœç´¢"""
    import sys
    print(f"[Backend] ğŸ§  RAG Search: {payload}", file=sys.stderr)
    
    try:
        from telegram_rag_system import telegram_rag, KnowledgeType
        
        query = payload.get('query', '')
        limit = payload.get('limit', 5)
        knowledge_type = payload.get('knowledgeType')
        min_score = payload.get('minScore', 0.3)
        
        # è½‰æ›é¡å‹
        kt = None
        if knowledge_type:
            try:
                kt = KnowledgeType(knowledge_type)
            except:
                pass
        
        results = await telegram_rag.search(
            query=query,
            limit=limit,
            knowledge_type=kt,
            min_score=min_score
        )
        
        # è½‰æ›çµæœ
        result_list = []
        for r in results:
            result_list.append({
                'item': {
                    'id': r.item.id,
                    'knowledge_type': r.item.knowledge_type.value,
                    'question': r.item.question,
                    'answer': r.item.answer,
                    'context': r.item.context,
                    'keywords': r.item.keywords,
                    'success_score': r.item.success_score,
                    'use_count': r.item.use_count
                },
                'similarity': r.similarity,
                'source': r.source
            })
        
        self.send_event("rag-search-results", {
            "success": True,
            "query": query,
            "results": result_list
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("rag-search-results", {
            "success": False,
            "error": str(e),
            "results": []
        })


async def handle_rag_get_stats(self, payload: Dict[str, Any]):
    """ç²å– RAG çµ±è¨ˆ"""
    import sys
    print(f"[Backend] ğŸ§  RAG Get Stats", file=sys.stderr)
    
    try:
        from telegram_rag_system import telegram_rag
        
        stats = await telegram_rag.get_statistics()
        
        self.send_event("rag-stats-updated", {
            "success": True,
            "stats": stats
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("rag-stats-updated", {
            "success": False,
            "error": str(e)
        })



async def handle_rag_record_feedback(self, payload: Dict[str, Any]):
    """è¨˜éŒ„ RAG åé¥‹"""
    import sys
    print(f"[Backend] ğŸ§  RAG Record Feedback: {payload}", file=sys.stderr)
    
    try:
        from telegram_rag_system import telegram_rag
        
        knowledge_id = payload.get('knowledgeId')
        is_positive = payload.get('isPositive', True)
        
        await telegram_rag.record_feedback(
            knowledge_id=knowledge_id,
            is_positive=is_positive
        )
        
        self.send_event("rag-feedback-recorded", {
            "success": True,
            "knowledgeId": knowledge_id
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("rag-feedback-recorded", {
            "success": False,
            "error": str(e)
        })


async def handle_rag_build_from_conversation(self, payload: Dict[str, Any]):
    """ğŸŒŸ å°è©±å¼æ§‹å»ºçŸ¥è­˜åº«ï¼ˆæ”¯æŒç›´æ¥æ–‡æª”è§£æï¼‰"""
    import sys
    import re
    print(f"[Backend] ğŸ§  RAG Build From Conversation: {payload}", file=sys.stderr)
    
    try:
        from telegram_rag_system import telegram_rag, KnowledgeType
        
        business_desc = payload.get('businessDescription', '')
        industry = payload.get('industry', '')
        target_audience = payload.get('targetAudience', '')
        key_products = payload.get('keyProducts', [])
        unique_advantages = payload.get('uniqueAdvantages', [])
        
        # ç™¼é€é€²åº¦æ›´æ–°
        def send_progress(step, total, action, items):
            self.send_event("rag-build-progress", {
                "progress": {
                    "step": step,
                    "totalSteps": total,
                    "currentAction": action,
                    "itemsGenerated": items
                }
            })
        
        total_items = 0
        
        # ğŸ†• P1-1: å…ˆç›´æ¥è§£ææ–‡æª”å…§å®¹ï¼Œæå–çµæ§‹åŒ–çŸ¥è­˜ï¼ˆä¸ä¾è³´ AIï¼‰
        send_progress(1, 6, "è§£ææ–‡æª”å…§å®¹...", 0)
        try:
            direct_items = self._parse_document_to_knowledge(business_desc)
            if direct_items:
                print(f"[RAG] ğŸ“„ å¾æ–‡æª”ç›´æ¥è§£æå‡º {len(direct_items)} æ¢çŸ¥è­˜", file=sys.stderr)
                
                # ğŸ†• P0-3: åˆ†é¡æ˜ å°„
                category_to_type = {
                    'product': KnowledgeType.PRODUCT,
                    'price': KnowledgeType.PRODUCT,
                    'process': KnowledgeType.SCRIPT,
                    'faq': KnowledgeType.FAQ,
                    'resource': KnowledgeType.PRODUCT
                }
                
                for item in direct_items:
                    # ç²å–åˆ†é¡å°æ‡‰çš„çŸ¥è­˜é¡å‹
                    category = item.get('category', 'product')
                    knowledge_type = category_to_type.get(category, KnowledgeType.PRODUCT)
                    
                    await telegram_rag.add_manual_knowledge(
                        knowledge_type=knowledge_type,
                        question=item.get('question', ''),
                        answer=item.get('answer', ''),
                        context=item.get('context', business_desc[:200])
                    )
                    total_items += 1
                print(f"[RAG] âœ“ æˆåŠŸå°å…¥ {total_items} æ¢æ–‡æª”çŸ¥è­˜", file=sys.stderr)
        except Exception as parse_err:
            print(f"[RAG] æ–‡æª”è§£æå¤±æ•—: {parse_err}", file=sys.stderr)
        
        send_progress(1, 6, "è§£ææ–‡æª”å…§å®¹...", total_items)
        
        # Step 2: åˆ†ææ¥­å‹™ï¼ˆAI è£œå……ï¼‰
        send_progress(2, 6, "åˆ†ææ¥­å‹™é¡å‹...", total_items)
        await asyncio.sleep(0.5)
        
        # Step 3: ç”Ÿæˆç”¢å“çŸ¥è­˜ï¼ˆAI è£œå……ï¼‰
        send_progress(3, 6, "ç”Ÿæˆç”¢å“çŸ¥è­˜...", total_items)
        
        # ä½¿ç”¨ AI ç”ŸæˆçŸ¥è­˜
        if ai_auto_chat and hasattr(ai_auto_chat, '_generate_response_with_prompt'):
            product_prompt = f"""æ ¹æ“šä»¥ä¸‹æ¥­å‹™æè¿°ï¼Œç”Ÿæˆ 5 æ¢ç”¢å“çŸ¥è­˜ï¼ˆJSON æ ¼å¼ï¼‰:

æ¥­å‹™æè¿°: {business_desc}
è¡Œæ¥­: {industry}
ç›®æ¨™å®¢æˆ¶: {target_audience}
ä¸»è¦ç”¢å“: {', '.join(key_products) if key_products else 'æœªæŒ‡å®š'}
ç«¶çˆ­å„ªå‹¢: {', '.join(unique_advantages) if unique_advantages else 'æœªæŒ‡å®š'}

è«‹è¿”å› JSON æ ¼å¼:
{{"items": [
  {{"type": "product", "question": "ç”¢å“å•é¡Œ", "answer": "è©³ç´°å›ç­”"}},
  ...
]}}"""
            
            product_response = await ai_auto_chat._generate_response_with_prompt(
                user_id="system",
                user_message=product_prompt,
                custom_prompt="ä½ æ˜¯å°ˆæ¥­çš„æ¥­å‹™çŸ¥è­˜ç”ŸæˆåŠ©æ‰‹ï¼Œæ“…é•·å‰µå»ºéŠ·å”®å’Œå®¢æœçŸ¥è­˜åº«ã€‚è«‹ç”¨ç¹é«”ä¸­æ–‡å›ç­”ã€‚",
                usage_type="knowledge"
            )
            
            # è§£æä¸¦ä¿å­˜
            product_items = self._parse_rag_knowledge_response(product_response)
            for item in product_items:
                await telegram_rag.add_manual_knowledge(
                    knowledge_type=KnowledgeType.PRODUCT,
                    question=item.get('question', ''),
                    answer=item.get('answer', '')
                )
                total_items += 1
        
        send_progress(3, 6, "ç”Ÿæˆç”¢å“çŸ¥è­˜...", total_items)
        
        # Step 4: ç”Ÿæˆå¸¸è¦‹å•ç­”
        send_progress(4, 6, "ç”Ÿæˆå¸¸è¦‹å•ç­”...", total_items)
        
        if ai_auto_chat and hasattr(ai_auto_chat, '_generate_response_with_prompt'):
            faq_prompt = f"""æ ¹æ“šä»¥ä¸‹æ¥­å‹™æè¿°ï¼Œç”Ÿæˆ 5 æ¢å¸¸è¦‹å•ç­”ï¼ˆJSON æ ¼å¼ï¼‰:

æ¥­å‹™æè¿°: {business_desc}

è«‹è¿”å› JSON æ ¼å¼:
{{"items": [
  {{"type": "faq", "question": "å®¢æˆ¶å¸¸è¦‹å•é¡Œ", "answer": "å°ˆæ¥­å›ç­”"}},
  ...
]}}"""
            
            faq_response = await ai_auto_chat._generate_response_with_prompt(
                user_id="system",
                user_message=faq_prompt,
                custom_prompt="ä½ æ˜¯å°ˆæ¥­çš„æ¥­å‹™çŸ¥è­˜ç”ŸæˆåŠ©æ‰‹ã€‚è«‹ç”¨ç¹é«”ä¸­æ–‡å›ç­”ã€‚",
                usage_type="knowledge"
            )
            
            faq_items = self._parse_rag_knowledge_response(faq_response)
            for item in faq_items:
                await telegram_rag.add_manual_knowledge(
                    knowledge_type=KnowledgeType.FAQ,
                    question=item.get('question', ''),
                    answer=item.get('answer', '')
                )
                total_items += 1
        
        send_progress(4, 6, "ç”Ÿæˆå¸¸è¦‹å•ç­”...", total_items)
        
        # Step 5: ç”ŸæˆéŠ·å”®è©±è¡“
        send_progress(5, 6, "ç”ŸæˆéŠ·å”®è©±è¡“...", total_items)
        
        if ai_auto_chat and hasattr(ai_auto_chat, '_generate_response_with_prompt'):
            script_prompt = f"""æ ¹æ“šä»¥ä¸‹æ¥­å‹™æè¿°ï¼Œç”Ÿæˆ 5 æ¢éŠ·å”®è©±è¡“ï¼ˆJSON æ ¼å¼ï¼‰:

æ¥­å‹™æè¿°: {business_desc}
ç«¶çˆ­å„ªå‹¢: {', '.join(unique_advantages) if unique_advantages else 'æœªæŒ‡å®š'}

è«‹è¿”å› JSON æ ¼å¼:
{{"items": [
  {{"type": "script", "question": "å ´æ™¯/è§¸ç™¼", "answer": "è©±è¡“å…§å®¹"}},
  ...
]}}"""
            
            script_response = await ai_auto_chat._generate_response_with_prompt(
                user_id="system",
                user_message=script_prompt,
                custom_prompt="ä½ æ˜¯å°ˆæ¥­çš„éŠ·å”®è©±è¡“å°ˆå®¶ã€‚è«‹ç”¨ç¹é«”ä¸­æ–‡å›ç­”ã€‚",
                usage_type="knowledge"
            )
            
            script_items = self._parse_rag_knowledge_response(script_response)
            for item in script_items:
                await telegram_rag.add_manual_knowledge(
                    knowledge_type=KnowledgeType.SCRIPT,
                    question=item.get('question', ''),
                    answer=item.get('answer', '')
                )
                total_items += 1
        
        send_progress(5, 6, "ç”ŸæˆéŠ·å”®è©±è¡“...", total_items)
        
        # Step 6: ç”Ÿæˆç•°è­°è™•ç†
        send_progress(6, 6, "ç”Ÿæˆç•°è­°è™•ç†...", total_items)
        
        if ai_auto_chat and hasattr(ai_auto_chat, '_generate_response_with_prompt'):
            objection_prompt = f"""æ ¹æ“šä»¥ä¸‹æ¥­å‹™æè¿°ï¼Œç”Ÿæˆ 5 æ¢ç•°è­°è™•ç†è©±è¡“ï¼ˆJSON æ ¼å¼ï¼‰:

æ¥­å‹™æè¿°: {business_desc}

è«‹è¿”å› JSON æ ¼å¼:
{{"items": [
  {{"type": "objection", "question": "å®¢æˆ¶ç•°è­°", "answer": "è™•ç†è©±è¡“"}},
  ...
]}}"""
            
            objection_response = await ai_auto_chat._generate_response_with_prompt(
                user_id="system",
                user_message=objection_prompt,
                custom_prompt="ä½ æ˜¯å°ˆæ¥­çš„ç•°è­°è™•ç†å°ˆå®¶ã€‚è«‹ç”¨ç¹é«”ä¸­æ–‡å›ç­”ã€‚",
                usage_type="knowledge"
            )
            
            objection_items = self._parse_rag_knowledge_response(objection_response)
            for item in objection_items:
                await telegram_rag.add_manual_knowledge(
                    knowledge_type=KnowledgeType.OBJECTION,
                    question=item.get('question', ''),
                    answer=item.get('answer', '')
                )
                total_items += 1
        
        send_progress(6, 6, "å®Œæˆï¼", total_items)
        
        self.send_event("rag-build-complete", {
            "success": True,
            "totalItems": total_items,
            "businessDescription": business_desc
        })
        self.send_log(f"ğŸ§  çŸ¥è­˜å¤§è…¦æ§‹å»ºå®Œæˆï¼Œå…± {total_items} æ¢çŸ¥è­˜", "success")
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("rag-build-complete", {
            "success": False,
            "error": str(e)
        })


async def handle_rag_preview_import(self, payload: Dict[str, Any]):
    """
    ğŸ†• P1-2: é è¦½å°å…¥ - è§£ææ–‡æª”ä½†ä¸å…¥åº«ï¼Œè¿”å›é è¦½çµæœ
    
    è¿”å›çµæ§‹åŒ–çš„çŸ¥è­˜åˆ—è¡¨ï¼Œè®“ç”¨æˆ¶å¯ä»¥ç·¨è¼¯/åˆªé™¤/ç¢ºèª
    """
    import sys
    import uuid
    
    print(f"[Backend] ğŸ§  RAG Preview Import", file=sys.stderr)
    
    try:
        document = payload.get('document', '')
        
        if not document or len(document.strip()) < 10:
            self.send_event("rag-preview-result", {
                "success": False,
                "error": "æ–‡æª”å…§å®¹éçŸ­",
                "items": []
            })
            return
        
        # è§£ææ–‡æª”
        items = self._parse_document_to_knowledge(document)
        
        if not items:
            self.send_event("rag-preview-result", {
                "success": False,
                "error": "æœªèƒ½å¾æ–‡æª”ä¸­è§£æå‡ºæœ‰æ•ˆçŸ¥è­˜",
                "items": []
            })
            return
        
        # ç”Ÿæˆé è¦½ IDï¼ˆç”¨æ–¼å¾ŒçºŒç¢ºèªï¼‰
        preview_id = str(uuid.uuid4())[:8]
        
        # ç‚ºæ¯å€‹é …ç›®æ·»åŠ è‡¨æ™‚ ID
        for i, item in enumerate(items):
            item['temp_id'] = f"{preview_id}_{i}"
            item['selected'] = True  # é»˜èªé¸ä¸­
        
        # å­˜å„²åˆ°è‡¨æ™‚ç·©å­˜
        self._pending_import_items[preview_id] = items
        
        # åˆ†é¡çµ±è¨ˆ
        category_stats = {}
        for item in items:
            cat = item.get('category', 'unknown')
            category_stats[cat] = category_stats.get(cat, 0) + 1
        
        self.send_event("rag-preview-result", {
            "success": True,
            "previewId": preview_id,
            "items": items,
            "totalCount": len(items),
            "categoryStats": category_stats
        })
        
        print(f"[RAG] âœ“ é è¦½ç”ŸæˆæˆåŠŸ: {len(items)} æ¢, ID={preview_id}", file=sys.stderr)
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("rag-preview-result", {
            "success": False,
            "error": str(e),
            "items": []
        })


async def handle_rag_confirm_import(self, payload: Dict[str, Any]):
    """
    ğŸ†• P1-2: ç¢ºèªå°å…¥ - å°‡é¸ä¸­çš„çŸ¥è­˜é …å…¥åº«
    
    ç”¨æˆ¶å¯ä»¥ç·¨è¼¯/åˆªé™¤/èª¿æ•´åˆ†é¡å¾Œç¢ºèªå°å…¥
    """
    import sys
    
    print(f"[Backend] ğŸ§  RAG Confirm Import", file=sys.stderr)
    
    try:
        from telegram_rag_system import telegram_rag, KnowledgeType
        
        preview_id = payload.get('previewId', '')
        selected_items = payload.get('items', [])
        
        if not selected_items:
            # å˜—è©¦å¾ç·©å­˜ç²å–
            cached_items = self._pending_import_items.get(preview_id, [])
            selected_items = [item for item in cached_items if item.get('selected', True)]
        
        if not selected_items:
            self.send_event("rag-import-result", {
                "success": False,
                "error": "æ²’æœ‰é¸ä¸­çš„çŸ¥è­˜é …",
                "importedCount": 0
            })
            return
        
        # åˆ†é¡æ˜ å°„
        category_to_type = {
            'product': KnowledgeType.PRODUCT,
            'price': KnowledgeType.PRODUCT,
            'process': KnowledgeType.SCRIPT,
            'faq': KnowledgeType.FAQ,
            'resource': KnowledgeType.PRODUCT
        }
        
        imported_count = 0
        failed_count = 0
        
        for item in selected_items:
            try:
                category = item.get('category', 'product')
                knowledge_type = category_to_type.get(category, KnowledgeType.PRODUCT)
                
                result = await telegram_rag.add_manual_knowledge(
                    knowledge_type=knowledge_type,
                    question=item.get('question', ''),
                    answer=item.get('answer', ''),
                    context=item.get('context', '')
                )
                
                if result:
                    imported_count += 1
                else:
                    failed_count += 1
                    
            except Exception as item_err:
                print(f"[RAG] å°å…¥é …ç›®å¤±æ•—: {item_err}", file=sys.stderr)
                failed_count += 1
        
        # æ¸…ç†ç·©å­˜
        if preview_id in self._pending_import_items:
            del self._pending_import_items[preview_id]
        
        self.send_event("rag-import-result", {
            "success": True,
            "importedCount": imported_count,
            "failedCount": failed_count
        })
        
        self.send_log(f"ğŸ§  çŸ¥è­˜å°å…¥å®Œæˆ: æˆåŠŸ {imported_count} æ¢, å¤±æ•— {failed_count} æ¢", "success")
        
        print(f"[RAG] âœ“ ç¢ºèªå°å…¥å®Œæˆ: æˆåŠŸ {imported_count}, å¤±æ•— {failed_count}", file=sys.stderr)
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("rag-import-result", {
            "success": False,
            "error": str(e),
            "importedCount": 0
        })


async def handle_rag_import_url(self, payload: Dict[str, Any]):
    """ğŸŒ å¾ URL å°å…¥çŸ¥è­˜"""
    import sys
    print(f"[Backend] ğŸ§  RAG Import URL: {payload}", file=sys.stderr)
    
    try:
        from telegram_rag_system import telegram_rag, KnowledgeType
        import aiohttp
        import re
        
        url = payload.get('url', '')
        
        if not url:
            self.send_event("rag-url-imported", {
                "success": False,
                "error": "URL ä¸èƒ½ç‚ºç©º"
            })
            return
        
        # ğŸ”§ Phase 5: æª¢æŸ¥ AI API Key æ˜¯å¦é…ç½®
        if not ai_auto_chat:
            self.send_event("rag-url-imported", {
                "success": False,
                "error": "AI æœå‹™æœªåˆå§‹åŒ–ï¼Œè«‹å…ˆé…ç½® AI æ¨¡å‹",
                "needsApiKey": True
            })
            return
        
        api_key = getattr(ai_auto_chat, 'api_key', '')
        if not api_key:
            self.send_event("rag-url-imported", {
                "success": False,
                "error": "å°šæœªé…ç½® AI API Keyã€‚è«‹å‰å¾€ã€ŒAI ä¸­å¿ƒã€->ã€Œæ¨¡å‹è¨­å®šã€é…ç½® Gemini æˆ– OpenAI API Key",
                "needsApiKey": True
            })
            return
        
        print(f"[Backend] âœ“ AI API Key å·²é…ç½®ï¼Œé–‹å§‹æŠ“å–ç¶²é : {url}", file=sys.stderr)
        
        # æŠ“å–ç¶²é å…§å®¹
        async with aiohttp.ClientSession() as session:
            async with session.get(url, timeout=30) as response:
                if response.status != 200:
                    raise Exception(f"HTTP {response.status}")
                
                html = await response.text()
        
        print(f"[Backend] âœ“ ç¶²é æŠ“å–æˆåŠŸï¼Œå…§å®¹é•·åº¦: {len(html)}", file=sys.stderr)
        
        # ç°¡å–®çš„ HTML è§£æï¼ˆæå–æ–‡æœ¬ï¼‰
        # ç§»é™¤ script å’Œ style
        html = re.sub(r'<script[^>]*>[\s\S]*?</script>', '', html, flags=re.IGNORECASE)
        html = re.sub(r'<style[^>]*>[\s\S]*?</style>', '', html, flags=re.IGNORECASE)
        # ç§»é™¤ HTML æ¨™ç±¤
        text = re.sub(r'<[^>]+>', '\n', html)
        # æ¸…ç†ç©ºç™½
        text = re.sub(r'\s+', ' ', text).strip()
        
        # æå–æ¨™é¡Œ
        title_match = re.search(r'<title[^>]*>([^<]+)</title>', html, re.IGNORECASE)
        title = title_match.group(1).strip() if title_match else url
        
        print(f"[Backend] âœ“ ç¶²é è§£æå®Œæˆï¼Œæ¨™é¡Œ: {title}, æ–‡å­—é•·åº¦: {len(text)}", file=sys.stderr)
        
        # ä½¿ç”¨ AI æå–çŸ¥è­˜
        items_count = 0
        
        if ai_auto_chat and hasattr(ai_auto_chat, '_generate_response_with_prompt'):
            extract_prompt = f"""å¾ä»¥ä¸‹ç¶²é å…§å®¹ä¸­æå–å¯ç”¨æ–¼å®¢æœå’ŒéŠ·å”®çš„çŸ¥è­˜ï¼Œç”Ÿæˆ JSON æ ¼å¼:

ç¶²é æ¨™é¡Œ: {title}
ç¶²é å…§å®¹ï¼ˆå‰2000å­—ï¼‰: {text[:2000]}

è«‹æå–é—œéµçš„ç”¢å“ä¿¡æ¯ã€å¸¸è¦‹å•é¡Œã€æœå‹™èªªæ˜ç­‰ï¼Œè¿”å› JSON æ ¼å¼:
{{"items": [
  {{"type": "product/faq/script", "question": "å•é¡Œæˆ–ä¸»é¡Œ", "answer": "å…§å®¹"}},
  ...
]}}"""
            
            extract_response = await ai_auto_chat._generate_response_with_prompt(
                user_id="system",
                user_message=extract_prompt,
                custom_prompt="ä½ æ˜¯å°ˆæ¥­çš„çŸ¥è­˜æå–åŠ©æ‰‹ï¼Œæ“…é•·å¾ç¶²é å…§å®¹ä¸­æå–çµæ§‹åŒ–çŸ¥è­˜ã€‚è«‹ç”¨ç¹é«”ä¸­æ–‡å›ç­”ã€‚",
                usage_type="knowledge"
            )
            
            items = self._parse_rag_knowledge_response(extract_response)
            
            type_map = {
                'product': KnowledgeType.PRODUCT,
                'faq': KnowledgeType.FAQ,
                'script': KnowledgeType.SCRIPT,
                'qa': KnowledgeType.QA
            }
            
            for item in items:
                kt = type_map.get(item.get('type', 'qa'), KnowledgeType.QA)
                await telegram_rag.add_manual_knowledge(
                    knowledge_type=kt,
                    question=item.get('question', ''),
                    answer=item.get('answer', ''),
                    context=f"ä¾†æº: {url}"
                )
                items_count += 1
        
        self.send_event("rag-url-imported", {
            "success": True,
            "url": url,
            "title": title,
            "itemsCount": items_count
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("rag-url-imported", {
            "success": False,
            "error": str(e)
        })


async def handle_rag_import_document(self, payload: Dict[str, Any]):
    """ğŸ“„ å¾æ–‡æª”å°å…¥çŸ¥è­˜"""
    import sys
    import os
    print(f"[Backend] ğŸ§  RAG Import Document: {payload}", file=sys.stderr)
    
    try:
        from telegram_rag_system import telegram_rag, KnowledgeType
        
        file_path = payload.get('filePath', '')
        file_type = payload.get('fileType', '').lower()
        
        if not os.path.exists(file_path):
            self.send_event("rag-document-imported", {
                "success": False,
                "error": "æ–‡ä»¶ä¸å­˜åœ¨"
            })
            return
        
        text = ""
        
        # è®€å–æ–‡æª”å…§å®¹
        if file_type in ['txt', 'text']:
            with open(file_path, 'r', encoding='utf-8') as f:
                text = f.read()
        elif file_type in ['pdf']:
            # å˜—è©¦ä½¿ç”¨ PyPDF2
            try:
                import PyPDF2
                with open(file_path, 'rb') as f:
                    reader = PyPDF2.PdfReader(f)
                    text = '\n'.join(page.extract_text() for page in reader.pages)
            except ImportError:
                self.send_event("rag-document-imported", {
                    "success": False,
                    "error": "éœ€è¦å®‰è£ PyPDF2 æ‰èƒ½è®€å– PDF"
                })
                return
        elif file_type in ['docx', 'doc']:
            # å˜—è©¦ä½¿ç”¨ python-docx
            try:
                from docx import Document
                doc = Document(file_path)
                text = '\n'.join(para.text for para in doc.paragraphs)
            except ImportError:
                self.send_event("rag-document-imported", {
                    "success": False,
                    "error": "éœ€è¦å®‰è£ python-docx æ‰èƒ½è®€å– Word æ–‡æª”"
                })
                return
        else:
            # å˜—è©¦ä½œç‚ºç´”æ–‡æœ¬è®€å–
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                text = f.read()
        
        if not text.strip():
            self.send_event("rag-document-imported", {
                "success": False,
                "error": "æ–‡æª”å…§å®¹ç‚ºç©º"
            })
            return
        
        # ä½¿ç”¨ AI æå–çŸ¥è­˜
        items_count = 0
        
        if ai_auto_chat and hasattr(ai_auto_chat, '_generate_response_with_prompt'):
            extract_prompt = f"""å¾ä»¥ä¸‹æ–‡æª”å…§å®¹ä¸­æå–å¯ç”¨æ–¼å®¢æœå’ŒéŠ·å”®çš„çŸ¥è­˜ï¼Œç”Ÿæˆ JSON æ ¼å¼:

æ–‡æª”å…§å®¹ï¼ˆå‰3000å­—ï¼‰: {text[:3000]}

è«‹æå–é—œéµä¿¡æ¯ï¼Œè¿”å› JSON æ ¼å¼:
{{"items": [
  {{"type": "product/faq/script", "question": "å•é¡Œæˆ–ä¸»é¡Œ", "answer": "å…§å®¹"}},
  ...
]}}"""
            
            extract_response = await ai_auto_chat._generate_response_with_prompt(
                user_id="system",
                user_message=extract_prompt,
                custom_prompt="ä½ æ˜¯å°ˆæ¥­çš„çŸ¥è­˜æå–åŠ©æ‰‹ã€‚è«‹ç”¨ç¹é«”ä¸­æ–‡å›ç­”ã€‚",
                usage_type="knowledge"
            )
            
            items = self._parse_rag_knowledge_response(extract_response)
            
            type_map = {
                'product': KnowledgeType.PRODUCT,
                'faq': KnowledgeType.FAQ,
                'script': KnowledgeType.SCRIPT,
                'qa': KnowledgeType.QA
            }
            
            for item in items:
                kt = type_map.get(item.get('type', 'qa'), KnowledgeType.QA)
                await telegram_rag.add_manual_knowledge(
                    knowledge_type=kt,
                    question=item.get('question', ''),
                    answer=item.get('answer', ''),
                    context=f"ä¾†æº: {os.path.basename(file_path)}"
                )
                items_count += 1
        
        self.send_event("rag-document-imported", {
            "success": True,
            "fileName": os.path.basename(file_path),
            "itemsCount": items_count
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("rag-document-imported", {
            "success": False,
            "error": str(e)
        })


async def handle_rag_cleanup(self, payload: Dict[str, Any]):
    """æ¸…ç†ä½è³ªé‡çŸ¥è­˜"""
    import sys
    print(f"[Backend] ğŸ§  RAG Cleanup", file=sys.stderr)
    
    try:
        from telegram_rag_system import telegram_rag
        
        min_score = payload.get('minScore', 0.2)
        min_uses = payload.get('minUses', 0)
        days_old = payload.get('daysOld', 30)
        
        deleted = await telegram_rag.cleanup_low_quality_knowledge(
            min_score=min_score,
            min_uses=min_uses,
            days_old=days_old
        )
        
        self.send_event("rag-cleanup-complete", {
            "success": True,
            "deletedCount": deleted
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("rag-cleanup-complete", {
            "success": False,
            "error": str(e)
        })


async def handle_rag_merge_similar(self, payload: Dict[str, Any]):
    """åˆä½µç›¸ä¼¼çŸ¥è­˜"""
    import sys
    print(f"[Backend] ğŸ§  RAG Merge Similar", file=sys.stderr)
    
    try:
        from telegram_rag_system import telegram_rag
        
        threshold = payload.get('similarityThreshold', 0.9)
        
        merged = await telegram_rag.merge_similar_knowledge(
            similarity_threshold=threshold
        )
        
        self.send_event("rag-merge-complete", {
            "success": True,
            "mergedCount": merged
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("rag-merge-complete", {
            "success": False,
            "error": str(e)
        })


# ==================== ğŸ†• çŸ¥è­˜ç¼ºå£å’Œå¥åº·åº¦ ====================

async def handle_rag_get_gaps(self, payload: Dict[str, Any]):
    """ç²å–çŸ¥è­˜ç¼ºå£åˆ—è¡¨ï¼ˆğŸ†• P0: éæ¿¾ + è‡ªå‹•ç”Ÿæˆ AI å»ºè­°ç­”æ¡ˆï¼‰"""
    import sys
    print(f"[Backend] ğŸ§  RAG Get Gaps", file=sys.stderr)
    
    try:
        from telegram_rag_system import telegram_rag
        
        status = payload.get('status', 'pending')
        limit = payload.get('limit', 20)
        min_hits = payload.get('minHits', 1)  # ğŸ†• P0-2: é™ä½é–€æª»
        auto_suggest = payload.get('autoSuggest', True)  # ğŸ†• é»˜èªè‡ªå‹•ç”Ÿæˆå»ºè­°
        
        gaps = await telegram_rag.get_knowledge_gaps(
            status=status,
            limit=limit,
            min_hits=min_hits
        )
        
        # ğŸ†• P0-3: éæ¿¾ç³»çµ± promptï¼ˆéçœŸå¯¦ç”¨æˆ¶å•é¡Œï¼‰
        system_keywords = [
            'æ ¹æ“šä»¥ä¸‹', 'ç”Ÿæˆ 5 æ¢', 'æ¥­å‹™æè¿°:', 'JSON æ ¼å¼',
            'æ ¹æ“šä»¥ä¸‹æ¥­å‹™æè¿°', 'ç”Ÿæˆ5æ¢', 'ï¼ˆJSON', 'æ¡äº§å“çŸ¥è¯†',
            'æ¢ç”¢å“çŸ¥è­˜', 'æ¡é”€å”®è¯æœ¯', 'æ¢éŠ·å”®è©±è¡“'
        ]
        
        filtered_gaps = []
        for gap in gaps:
            query = gap.get('query', '')
            # è·³éç³»çµ± prompt
            is_system_prompt = any(kw in query for kw in system_keywords)
            if is_system_prompt:
                print(f"[RAG] éæ¿¾ç³»çµ± prompt: {query[:50]}...", file=sys.stderr)
                continue
            # è·³ééé•·çš„å…§å®¹ï¼ˆè¶…é 500 å­—çš„å¯èƒ½æ˜¯æ–‡æª”è€Œéå•é¡Œï¼‰
            if len(query) > 500:
                print(f"[RAG] éæ¿¾éé•·å…§å®¹: {len(query)} å­—", file=sys.stderr)
                continue
            filtered_gaps.append(gap)
        
        gaps = filtered_gaps
        print(f"[RAG] éæ¿¾å¾Œå‰©é¤˜ {len(gaps)} æ¢ç¼ºå£", file=sys.stderr)
        
        # ğŸ†• P0: ç‚ºæ¯å€‹ç¼ºå£è‡ªå‹•ç”Ÿæˆ AI å»ºè­°ç­”æ¡ˆ
        if auto_suggest and gaps and ai_auto_chat:
            print(f"[RAG] ğŸ¤– ç‚º {len(gaps)} å€‹çŸ¥è­˜ç¼ºå£ç”Ÿæˆ AI å»ºè­°...", file=sys.stderr)
            
            for gap in gaps:
                # è·³éå·²æœ‰å»ºè­°çš„
                if gap.get('suggested_answer'):
                    continue
                
                query = gap.get('query', '')
                if not query:
                    continue
                
                try:
                    # ä½¿ç”¨ AI ç”Ÿæˆå»ºè­°ç­”æ¡ˆ
                    prompt = f"""æ ¹æ“šä»¥ä¸‹å®¢æˆ¶å•é¡Œï¼Œç”Ÿæˆä¸€å€‹å°ˆæ¥­ã€å‹å¥½çš„å›ç­”ï¼š

å•é¡Œï¼š{query}

è¦æ±‚ï¼š
1. å›ç­”è¦ç°¡æ½”å¯¦ç”¨ï¼ˆ50-150å­—ï¼‰
2. èªæ°£å‹å¥½å°ˆæ¥­
3. å¦‚æœæ˜¯è©¢å•åƒ¹æ ¼/è²»ç‡ï¼Œå¯ä»¥èªªã€Œç§èŠè©³è«‡ã€æˆ–ã€Œçœ‹é‡å„ªæƒ ã€
4. å¦‚æœä¸ç¢ºå®šï¼Œçµ¦å‡ºé€šç”¨ä½†æœ‰åƒ¹å€¼çš„å›ç­”"""

                    suggested = await ai_auto_chat._generate_response_with_prompt(
                        user_id="system",
                        user_message=prompt,
                        custom_prompt="ä½ æ˜¯å°ˆæ¥­çš„å®¢æœè©±è¡“å°ˆå®¶ã€‚è«‹ç”¨ç¹é«”ä¸­æ–‡å›ç­”ã€‚",
                        usage_type="knowledge"
                    )
                    
                    if suggested:
                        gap['suggested_answer'] = suggested
                        gap['ai_generated'] = True
                        print(f"[RAG] âœ“ å·²ç‚ºã€Œ{query[:20]}...ã€ç”Ÿæˆå»ºè­°", file=sys.stderr)
                    else:
                        # æä¾›å‚™ç”¨ç­”æ¡ˆ
                        gap['suggested_answer'] = f"æ„Ÿè¬æ‚¨çš„è©¢å•ï¼é—œæ–¼ã€Œ{query[:30]}ã€ï¼Œè«‹ç§èŠæˆ‘è©³ç´°äº†è§£ï¼Œæˆ‘å€‘æœƒç‚ºæ‚¨æä¾›å°ˆæ¥­çš„è§£ç­”å’Œæ–¹æ¡ˆã€‚"
                        gap['ai_generated'] = False
                        
                except Exception as gen_err:
                    print(f"[RAG] âš ï¸ ç”Ÿæˆå»ºè­°å¤±æ•—: {gen_err}", file=sys.stderr)
                    gap['suggested_answer'] = f"æ„Ÿè¬æ‚¨çš„è©¢å•ï¼é—œæ–¼ã€Œ{query[:30]}ã€ï¼Œæˆ‘å€‘ç¨å¾Œç‚ºæ‚¨è§£ç­”ã€‚"
                    gap['ai_generated'] = False
        
        self.send_event("rag-gaps-list", {
            "success": True,
            "gaps": gaps,
            "count": len(gaps)
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("rag-gaps-list", {
            "success": False,
            "error": str(e),
            "gaps": []
        })


async def handle_rag_resolve_gap(self, payload: Dict[str, Any]):
    """è§£æ±ºçŸ¥è­˜ç¼ºå£"""
    import sys
    print(f"[Backend] ğŸ§  RAG Resolve Gap: {payload}", file=sys.stderr)
    
    try:
        from telegram_rag_system import telegram_rag
        
        gap_id = payload.get('gapId')
        knowledge_type = payload.get('knowledgeType', 'faq')
        question = payload.get('question', '')
        answer = payload.get('answer', '')
        
        knowledge_id = await telegram_rag.resolve_gap(
            gap_id=gap_id,
            knowledge_type=knowledge_type,
            question=question,
            answer=answer
        )
        
        self.send_event("rag-gap-resolved", {
            "success": knowledge_id is not None,
            "gapId": gap_id,
            "knowledgeId": knowledge_id
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("rag-gap-resolved", {
            "success": False,
            "error": str(e)
        })


async def handle_rag_ignore_gap(self, payload: Dict[str, Any]):
    """å¿½ç•¥çŸ¥è­˜ç¼ºå£"""
    import sys
    print(f"[Backend] ğŸ§  RAG Ignore Gap", file=sys.stderr)
    
    try:
        from telegram_rag_system import telegram_rag
        
        gap_id = payload.get('gapId')
        success = await telegram_rag.ignore_gap(gap_id)
        
        self.send_event("rag-gap-ignored", {
            "success": success,
            "gapId": gap_id
        })
        
    except Exception as e:
        self.send_event("rag-gap-ignored", {
            "success": False,
            "error": str(e)
        })


async def handle_rag_delete_gap(self, payload: Dict[str, Any]):
    """ğŸ†• P0: åˆªé™¤å–®æ¢çŸ¥è­˜ç¼ºå£ï¼ˆç„¡éœ€ç¢ºèªï¼‰"""
    import sys
    print(f"[Backend] ğŸ§  RAG Delete Gap: {payload}", file=sys.stderr)
    
    try:
        gap_id = payload.get('gapId')
        
        if not gap_id:
            self.send_event("rag-gap-deleted", {
                "success": False,
                "error": "ç¼ºå°‘ gapId"
            })
            return
        
        # ç›´æ¥å¾æ•¸æ“šåº«åˆªé™¤
        await db._connection.execute(
            "DELETE FROM rag_knowledge_gaps WHERE id = ?",
            (gap_id,)
        )
        await db._connection.commit()
        
        self.send_event("rag-gap-deleted", {
            "success": True,
            "gapId": gap_id
        })
        
        print(f"[RAG] âœ“ å·²åˆªé™¤ç¼ºå£ ID={gap_id}", file=sys.stderr)
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("rag-gap-deleted", {
            "success": False,
            "error": str(e)
        })


async def handle_rag_delete_gaps_batch(self, payload: Dict[str, Any]):
    """ğŸ†• P0: æ‰¹é‡åˆªé™¤çŸ¥è­˜ç¼ºå£"""
    import sys
    print(f"[Backend] ğŸ§  RAG Delete Gaps Batch", file=sys.stderr)
    
    try:
        gap_ids = payload.get('gapIds', [])
        
        if not gap_ids:
            self.send_event("rag-gaps-deleted", {
                "success": False,
                "error": "æ²’æœ‰è¦åˆªé™¤çš„ç¼ºå£",
                "deletedCount": 0
            })
            return
        
        # æ‰¹é‡åˆªé™¤
        placeholders = ','.join(['?' for _ in gap_ids])
        await db._connection.execute(
            f"DELETE FROM rag_knowledge_gaps WHERE id IN ({placeholders})",
            gap_ids
        )
        await db._connection.commit()
        
        self.send_event("rag-gaps-deleted", {
            "success": True,
            "deletedCount": len(gap_ids)
        })
        
        print(f"[RAG] âœ“ æ‰¹é‡åˆªé™¤ {len(gap_ids)} æ¢ç¼ºå£", file=sys.stderr)
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("rag-gaps-deleted", {
            "success": False,
            "error": str(e),
            "deletedCount": 0
        })


async def handle_rag_cleanup_duplicate_gaps(self, payload: Dict[str, Any]):
    """ğŸ†• P0: æ·±åº¦æ¸…ç†çŸ¥è­˜ç¼ºå£ï¼ˆé‡è¤‡ + ç³»çµ± prompt + åƒåœ¾æ•¸æ“šï¼‰"""
    import sys
    print(f"[Backend] ğŸ§  RAG Cleanup Duplicate Gaps", file=sys.stderr)
    
    try:
        total_deleted = 0
        stats = {'duplicates': 0, 'system_prompts': 0, 'too_long': 0, 'too_short': 0}
        
        # 1. æ¸…ç†é‡è¤‡æ•¸æ“š
        cursor = await db._connection.execute("""
            SELECT query_hash, COUNT(*) as cnt 
            FROM rag_knowledge_gaps 
            GROUP BY query_hash 
            HAVING cnt > 1
        """)
        duplicates = await cursor.fetchall()
        
        for row in duplicates:
            query_hash = row['query_hash']
            
            # ä¿ç•™ hit_count æœ€é«˜çš„é‚£æ¢ï¼Œåˆªé™¤å…¶ä»–
            await db._connection.execute("""
                DELETE FROM rag_knowledge_gaps 
                WHERE query_hash = ? 
                AND id NOT IN (
                    SELECT id FROM rag_knowledge_gaps 
                    WHERE query_hash = ? 
                    ORDER BY hit_count DESC 
                    LIMIT 1
                )
            """, (query_hash, query_hash))
            
            deleted = row['cnt'] - 1
            total_deleted += deleted
            stats['duplicates'] += deleted
        
        await db._connection.commit()
        
        # 2. ğŸ†• P0: åˆªé™¤ç³»çµ± promptï¼ˆæ›´å…¨é¢çš„åŒ¹é…ï¼‰
        system_patterns = [
            # ğŸ†• æœ€å¸¸è¦‹çš„ç³»çµ± prompt æ¨¡å¼ï¼ˆç²¾ç¢ºåŒ¹é…ï¼‰
            'æ ¹æ“šä»¥ä¸‹å®¢æˆ¶å•é¡Œï¼Œç”Ÿæˆä¸€å€‹å°ˆæ¥­%',
            'æ ¹æ®ä»¥ä¸‹å®¢æˆ·é—®é¢˜ï¼Œç”Ÿæˆä¸€ä¸ªä¸“ä¸š%',
            'æ ¹æ“šä»¥ä¸‹å®¢æˆ¶å•é¡Œ%ç”Ÿæˆ%',
            'æ ¹æ®ä»¥ä¸‹å®¢æˆ·é—®é¢˜%ç”Ÿæˆ%',
            # AI ç”Ÿæˆ prompt
            'æ ¹æ“šä»¥ä¸‹æ¥­å‹™æè¿°%',
            'æ ¹æ®ä»¥ä¸‹ä¸šåŠ¡æè¿°%',
            'æ ¹æ“šä»¥ä¸‹%ç”Ÿæˆ%',
            'æ ¹æ®ä»¥ä¸‹%ç”Ÿæˆ%',
            '%ç”Ÿæˆ 5 æ¢%',
            '%ç”Ÿæˆ5æ¢%',
            '%ç”Ÿæˆ 5 æ¡%',
            '%ç”Ÿæˆ5æ¡%',
            'æ¥­å‹™æè¿°:%',
            'æ¥­å‹™æè¿°ï¼š%',
            'ä¸šåŠ¡æè¿°:%',
            'ä¸šåŠ¡æè¿°ï¼š%',
            'JSON æ ¼å¼%',
            'ï¼ˆJSON æ ¼å¼ï¼‰%',
            '(JSON æ ¼å¼)%',
            '%æ¢ç”¢å“çŸ¥è­˜%',
            '%æ¡äº§å“çŸ¥è¯†%',
            '%æ¢éŠ·å”®è©±è¡“%',
            '%æ¡é”€å”®è¯æœ¯%',
            '%æ¢å¸¸è¦‹å•ç­”%',
            '%æ¡å¸¸è§é—®ç­”%',
            # AI å›è¦†æ ¼å¼
            '%è¦æ±‚ï¼š%å›ç­”è¦ç°¡æ½”%',
            '%è¦æ±‚:%å›ç­”è¦ç®€æ´%',
            '%èªæ°£å‹å¥½å°ˆæ¥­%',
            '%è¯­æ°”å‹å¥½ä¸“ä¸š%',
            '%ç§èŠè©³è«‡%',
            # ç³»çµ±æŒ‡ä»¤
            'ä½ æ˜¯å°ˆæ¥­çš„%',
            'ä½ æ˜¯ä¸“ä¸šçš„%',
            '%è«‹ç”¨ç¹é«”ä¸­æ–‡%',
            '%è¯·ç”¨ç®€ä½“ä¸­æ–‡%',
            '%è«‹ç”¨ç¹é«”%',
            '%è¯·ç”¨ç®€ä½“%',
            # ğŸ†• æ›´å¤š AI æŒ‡ä»¤é—œéµè©
            '%ç‚ºä»¥ä¸‹å®¢æˆ¶å•é¡Œç”Ÿæˆ%',
            '%ä¸ºä»¥ä¸‹å®¢æˆ·é—®é¢˜ç”Ÿæˆ%',
            'ç‚ºä»¥ä¸‹%ç”Ÿæˆ%',
            'ä¸ºä»¥ä¸‹%ç”Ÿæˆ%',
            '%å°ˆæ¥­ã€å‹å¥½çš„å›ç­”%',
            '%ä¸“ä¸šã€å‹å¥½çš„å›ç­”%',
            '%é©åˆå®¢æœä½¿ç”¨%',
            '%é€‚åˆå®¢æœä½¿ç”¨%',
        ]
        
        for pattern in system_patterns:
            cursor = await db._connection.execute(
                "DELETE FROM rag_knowledge_gaps WHERE query LIKE ?",
                (pattern,)
            )
            deleted = cursor.rowcount
            total_deleted += deleted
            stats['system_prompts'] += deleted
        
        await db._connection.commit()
        
        # 3. ğŸ†• P0: åˆªé™¤éé•·å…§å®¹ï¼ˆè¶…é 300 å­—ï¼‰
        cursor = await db._connection.execute(
            "DELETE FROM rag_knowledge_gaps WHERE LENGTH(query) > 300"
        )
        deleted = cursor.rowcount
        total_deleted += deleted
        stats['too_long'] = deleted
        
        # 4. ğŸ†• P0: åˆªé™¤éçŸ­å…§å®¹ï¼ˆå°‘æ–¼ 3 å­—ï¼‰
        cursor = await db._connection.execute(
            "DELETE FROM rag_knowledge_gaps WHERE LENGTH(query) < 3"
        )
        deleted = cursor.rowcount
        total_deleted += deleted
        stats['too_short'] = deleted
        
        await db._connection.commit()
        
        # 5. ç™¼é€çµæœ
        self.send_event("rag-duplicates-cleaned", {
            "success": True,
            "deletedCount": total_deleted,
            "stats": stats
        })
        
        print(f"[RAG] ğŸ§¹ æ¸…ç†å®Œæˆ: é‡è¤‡={stats['duplicates']}, ç³»çµ±prompt={stats['system_prompts']}, éé•·={stats['too_long']}, éçŸ­={stats['too_short']}", file=sys.stderr)
        self.send_log(f"ğŸ§¹ æ¸…ç†å®Œæˆ: åˆªé™¤ {total_deleted} æ¢ç„¡æ•ˆç¼ºå£", "success")
        print(f"[RAG] âœ“ æ¸…ç†é‡è¤‡ç¼ºå£å®Œæˆ: åˆªé™¤ {total_deleted} æ¢", file=sys.stderr)
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("rag-duplicates-cleaned", {
            "success": False,
            "error": str(e),
            "deletedCount": 0
        })


async def handle_rag_suggest_gap_answer(self, payload: Dict[str, Any]):
    """ç‚ºçŸ¥è­˜ç¼ºå£ç”Ÿæˆ AI å»ºè­°ç­”æ¡ˆ"""
    import sys
    print(f"[Backend] ğŸ§  RAG Suggest Gap Answer: {payload}", file=sys.stderr)
    
    try:
        gap_id = payload.get('gapId')
        query = payload.get('query', '')
        
        # ä½¿ç”¨ AI ç”Ÿæˆå»ºè­°
        suggested_answer = ""
        if ai_auto_chat and hasattr(ai_auto_chat, '_generate_response_with_prompt'):
            prompt = f"""ç‚ºä»¥ä¸‹å®¢æˆ¶å•é¡Œç”Ÿæˆä¸€å€‹å°ˆæ¥­ã€å‹å¥½çš„å›ç­”ï¼š

å•é¡Œï¼š{query}

è«‹æä¾›ä¸€å€‹ç°¡æ½”ä½†å®Œæ•´çš„å›ç­”ï¼Œé©åˆå®¢æœä½¿ç”¨ã€‚"""
            
            suggested_answer = await ai_auto_chat._generate_response_with_prompt(
                user_id="system",
                user_message=prompt,
                custom_prompt="ä½ æ˜¯å°ˆæ¥­çš„å®¢æœè©±è¡“å°ˆå®¶ï¼Œè«‹ç”¨ç¹é«”ä¸­æ–‡å›ç­”ã€‚",
                usage_type="knowledge"
            )
        else:
            suggested_answer = f"æ„Ÿè¬æ‚¨çš„è©¢å•ã€‚é—œæ–¼ã€Œ{query[:30]}...ã€ï¼Œæˆ‘å€‘çš„å›ç­”æ˜¯..."
        
        self.send_event("rag-gap-suggestion", {
            "success": True,
            "gapId": gap_id,
            "suggestedAnswer": suggested_answer
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("rag-gap-suggestion", {
            "success": False,
            "error": str(e)
        })


async def handle_rag_get_health_report(self, payload: Dict[str, Any]):
    """ç²å–çŸ¥è­˜åº«å¥åº·åº¦å ±å‘Š"""
    import sys
    print(f"[Backend] ğŸ§  RAG Get Health Report", file=sys.stderr)
    
    try:
        from telegram_rag_system import telegram_rag
        
        report = await telegram_rag.get_health_report()
        
        self.send_event("rag-health-report", {
            "success": True,
            "report": report
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("rag-health-report", {
            "success": False,
            "error": str(e)
        })


# ==================== ğŸ†• çŸ¥è­˜ç®¡ç† API ====================

async def handle_rag_get_all_knowledge(self, payload: Dict[str, Any]):
    """ğŸ†• ç²å–æ‰€æœ‰çŸ¥è­˜åˆ—è¡¨"""
    import sys
    print(f"[Backend] ğŸ§  RAG Get All Knowledge", file=sys.stderr)
    
    try:
        cursor = await db._connection.execute("""
            SELECT id, knowledge_type, question, answer, context, 
                   success_score, use_count, feedback_positive, feedback_negative,
                   is_active, created_at, updated_at
            FROM rag_knowledge
            WHERE is_active = 1
            ORDER BY created_at DESC
            LIMIT 500
        """)
        rows = await cursor.fetchall()
        
        knowledge = []
        for row in rows:
            knowledge.append({
                'id': row['id'],
                'type': row['knowledge_type'],
                'question': row['question'],
                'answer': row['answer'],
                'context': row['context'],
                'successScore': row['success_score'],
                'useCount': row['use_count'],
                'feedbackPositive': row['feedback_positive'],
                'feedbackNegative': row['feedback_negative'],
                'isActive': row['is_active'],
                'createdAt': row['created_at'],
                'updatedAt': row['updated_at']
            })
        
        self.send_event("rag-all-knowledge", {
            "success": True,
            "knowledge": knowledge,
            "count": len(knowledge)
        })
        
        print(f"[RAG] âœ“ ç²å–çŸ¥è­˜åˆ—è¡¨: {len(knowledge)} æ¢", file=sys.stderr)
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("rag-all-knowledge", {
            "success": False,
            "error": str(e),
            "knowledge": []
        })


async def handle_rag_add_knowledge(self, payload: Dict[str, Any]):
    """ğŸ†• æ‰‹å‹•æ·»åŠ çŸ¥è­˜"""
    import sys
    print(f"[Backend] ğŸ§  RAG Add Knowledge: {payload}", file=sys.stderr)
    
    try:
        from telegram_rag_system import telegram_rag, KnowledgeType
        
        knowledge_type = payload.get('type', 'qa')
        question = payload.get('question', '')
        answer = payload.get('answer', '')
        
        if not question or not answer:
            raise ValueError("å•é¡Œå’Œç­”æ¡ˆä¸èƒ½ç‚ºç©º")
        
        # ä½¿ç”¨ RAG ç³»çµ±æ·»åŠ çŸ¥è­˜
        knowledge_id = await telegram_rag.add_manual_knowledge(
            knowledge_type=KnowledgeType(knowledge_type),
            question=question,
            answer=answer
        )
        
        self.send_event("rag-knowledge-added", {
            "success": True,
            "id": knowledge_id
        })
        
        self.send_log(f"âœ… æ·»åŠ çŸ¥è­˜æˆåŠŸ", "success")
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("rag-knowledge-added", {
            "success": False,
            "error": str(e)
        })


async def handle_rag_update_knowledge(self, payload: Dict[str, Any]):
    """ğŸ†• æ›´æ–°çŸ¥è­˜"""
    import sys
    print(f"[Backend] ğŸ§  RAG Update Knowledge: {payload}", file=sys.stderr)
    
    try:
        knowledge_id = payload.get('id')
        answer = payload.get('answer')
        
        if not knowledge_id or not answer:
            raise ValueError("ID å’Œç­”æ¡ˆä¸èƒ½ç‚ºç©º")
        
        await db._connection.execute("""
            UPDATE rag_knowledge
            SET answer = ?, updated_at = CURRENT_TIMESTAMP
            WHERE id = ?
        """, (answer, knowledge_id))
        await db._connection.commit()
        
        self.send_event("rag-knowledge-updated", {
            "success": True,
            "id": knowledge_id
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("rag-knowledge-updated", {
            "success": False,
            "error": str(e)
        })


async def handle_rag_delete_knowledge(self, payload: Dict[str, Any]):
    """ğŸ†• åˆªé™¤å–®æ¢çŸ¥è­˜"""
    import sys
    print(f"[Backend] ğŸ§  RAG Delete Knowledge: {payload}", file=sys.stderr)
    
    try:
        knowledge_id = payload.get('id')
        
        if not knowledge_id:
            raise ValueError("ID ä¸èƒ½ç‚ºç©º")
        
        # è»Ÿåˆªé™¤
        await db._connection.execute("""
            UPDATE rag_knowledge SET is_active = 0 WHERE id = ?
        """, (knowledge_id,))
        await db._connection.commit()
        
        self.send_event("rag-knowledge-deleted", {
            "success": True,
            "id": knowledge_id
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("rag-knowledge-deleted", {
            "success": False,
            "error": str(e)
        })


async def handle_rag_delete_knowledge_batch(self, payload: Dict[str, Any]):
    """ğŸ†• æ‰¹é‡åˆªé™¤çŸ¥è­˜"""
    import sys
    print(f"[Backend] ğŸ§  RAG Delete Knowledge Batch: {payload}", file=sys.stderr)
    
    try:
        ids = payload.get('ids', [])
        
        if not ids:
            raise ValueError("IDs ä¸èƒ½ç‚ºç©º")
        
        # è»Ÿåˆªé™¤
        placeholders = ','.join(['?' for _ in ids])
        await db._connection.execute(
            f"UPDATE rag_knowledge SET is_active = 0 WHERE id IN ({placeholders})",
            ids
        )
        await db._connection.commit()
        
        self.send_event("rag-knowledge-batch-deleted", {
            "success": True,
            "deletedCount": len(ids)
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("rag-knowledge-batch-deleted", {
            "success": False,
            "error": str(e)
        })


async def handle_rag_start_guided_build(self, payload: Dict[str, Any]):
    """ğŸ†• é–‹å§‹å¼•å°å¼å¤šè¼ªæ§‹å»º"""
    import sys
    print(f"[Backend] ğŸ§  RAG Start Guided Build: {payload}", file=sys.stderr)
    
    try:
        step = payload.get('step', 1)
        answers = payload.get('answers', {})
        industry = payload.get('industry', '')
        
        # æ ¹æ“šæ­¥é©Ÿè¿”å›ä¸åŒå•é¡Œ
        questions_by_step = {
            1: {
                'step': 1,
                'totalSteps': 5,
                'title': 'æ¥­å‹™é¡å‹',
                'question': 'æ‚¨çš„ä¸»è¦æ¥­å‹™æ˜¯ï¼Ÿ',
                'type': 'select',
                'options': [
                    {'id': 'payment', 'label': 'ğŸ’³ è·¨å¢ƒæ”¯ä»˜/å…Œæ›'},
                    {'id': 'ecommerce', 'label': 'ğŸ›’ é›»å•†é›¶å”®'},
                    {'id': 'education', 'label': 'ğŸ“– åœ¨ç·šæ•™è‚²'},
                    {'id': 'finance', 'label': 'ğŸ’° é‡‘èç†è²¡'},
                    {'id': 'service', 'label': 'ğŸ”§ æœå‹™è«®è©¢'},
                    {'id': 'other', 'label': 'ğŸ”¹ å…¶ä»–'}
                ]
            },
            2: {
                'step': 2,
                'totalSteps': 5,
                'title': 'æ ¸å¿ƒå„ªå‹¢',
                'question': 'æ‚¨çš„ä¸»è¦ç«¶çˆ­å„ªå‹¢æ˜¯ï¼Ÿ(å¯å¤šé¸)',
                'type': 'multiselect',
                'options': self._get_advantages_by_industry(answers.get('step1', 'other'))
            },
            3: {
                'step': 3,
                'totalSteps': 5,
                'title': 'ç”¢å“/æœå‹™',
                'question': 'è«‹æè¿°æ‚¨çš„ä¸»è¦ç”¢å“æˆ–æœå‹™ï¼š',
                'type': 'textarea',
                'placeholder': 'ä¾‹å¦‚ï¼šUSDT å…Œæ›äººæ°‘å¹£ï¼Œæ”¯æŒå¾®ä¿¡ã€æ”¯ä»˜å¯¶æ”¶æ¬¾...'
            },
            4: {
                'step': 4,
                'totalSteps': 5,
                'title': 'å¸¸è¦‹å•é¡Œ',
                'question': 'å®¢æˆ¶æœ€å¸¸å•çš„å•é¡Œæœ‰å“ªäº›ï¼Ÿ(æ¯è¡Œä¸€å€‹)',
                'type': 'textarea',
                'placeholder': 'å¤šä¹…åˆ°è³¬ï¼Ÿ\næ‰‹çºŒè²»å¤šå°‘ï¼Ÿ\nå®‰å…¨å—ï¼Ÿ',
                'suggestions': self._get_faq_suggestions(answers.get('step1', 'other'))
            },
            5: {
                'step': 5,
                'totalSteps': 5,
                'title': 'å°è©±é¢¨æ ¼',
                'question': 'æ‚¨å¸Œæœ› AI çš„å°è©±é¢¨æ ¼æ˜¯ï¼Ÿ',
                'type': 'select',
                'options': [
                    {'id': 'professional', 'label': 'ğŸ‘” å°ˆæ¥­æ­£å¼'},
                    {'id': 'friendly', 'label': 'ğŸ˜Š è¦ªåˆ‡å‹å¥½'},
                    {'id': 'efficient', 'label': 'âš¡ ç°¡æ½”é«˜æ•ˆ'},
                    {'id': 'enthusiastic', 'label': 'ğŸ‰ ç†±æƒ…ç©æ¥µ'}
                ]
            }
        }
        
        if step <= 5:
            # è¿”å›ç•¶å‰æ­¥é©Ÿçš„å•é¡Œ
            self.send_event("rag-guided-question", {
                "success": True,
                **questions_by_step.get(step, questions_by_step[1])
            })
        else:
            # æ‰€æœ‰å•é¡Œå›ç­”å®Œç•¢ï¼Œé–‹å§‹ç”Ÿæˆ
            await self._generate_knowledge_from_guided_answers(answers)
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("rag-guided-question", {
            "success": False,
            "error": str(e)
        })


async def handle_get_rag_context(self, payload: Dict[str, Any]):
    """Get RAG context for AI prompt"""
    try:
        query = payload.get('query', '')
        max_chunks = payload.get('maxChunks', 3)
        max_tokens = payload.get('maxTokens', 2000)
        
        search_engine = get_knowledge_search_engine()
        context = await search_engine.build_rag_context(
            query=query,
            max_chunks=max_chunks,
            max_tokens=max_tokens
        )
        
        # Also get relevant media
        media = await search_engine.find_relevant_media(query, limit=3)
        
        self.send_event("rag-context", {
            "success": True,
            "context": context,
            "relevantMedia": media
        })
    except Exception as e:
        self.send_event("rag-context", {
            "success": False,
            "error": str(e)
        })


# ==================== Telegram RAG Handlers ====================

async def handle_init_rag_system(self):
    """åˆå§‹åŒ– Telegram RAG ç³»çµ±"""
    try:
        from telegram_rag_system import telegram_rag
        from chat_history_indexer import chat_indexer
        
        # åˆå§‹åŒ– RAG ç³»çµ± - ğŸ”§ Phase 1 å„ªåŒ–ï¼šé»˜èªç¦ç”¨ç¥ç¶“ç¶²çµ¡åµŒå…¥
        await telegram_rag.initialize(use_chromadb=True, use_neural=False)
        
        # åˆå§‹åŒ–ç´¢å¼•æœå‹™
        await chat_indexer.initialize()
        
        # å•Ÿå‹•å¾Œå°ç´¢å¼•
        await chat_indexer.start_background_indexing()
        
        self.send_log("âœ“ Telegram RAG ç³»çµ±åˆå§‹åŒ–å®Œæˆ", "success")
        self.send_event("rag-initialized", {"success": True})
        
    except Exception as e:
        self.send_log(f"RAG ç³»çµ±åˆå§‹åŒ–å¤±æ•—: {e}", "error")
        self.send_event("rag-initialized", {
            "success": False,
            "error": str(e)
        })


async def handle_get_rag_stats(self):
    """ç²å– RAG ç³»çµ±çµ±è¨ˆ"""
    try:
        from telegram_rag_system import telegram_rag
        from chat_history_indexer import chat_indexer
        
        rag_stats = await telegram_rag.get_statistics()
        indexer_stats = await chat_indexer.get_indexing_statistics()
        
        self.send_event("rag-stats", {
            "success": True,
            "rag": rag_stats,
            "indexer": indexer_stats
        })
        
    except Exception as e:
        self.send_event("rag-stats", {
            "success": False,
            "error": str(e)
        })


async def handle_search_rag(self, payload: Dict[str, Any]):
    """æœç´¢ RAG çŸ¥è­˜åº«"""
    try:
        from telegram_rag_system import telegram_rag, KnowledgeType
        
        query = payload.get('query', '')
        limit = payload.get('limit', 5)
        knowledge_type = payload.get('knowledgeType')
        
        # è½‰æ›çŸ¥è­˜é¡å‹
        kt = None
        if knowledge_type:
            try:
                kt = KnowledgeType(knowledge_type)
            except:
                pass
        
        results = await telegram_rag.search(query, limit=limit, knowledge_type=kt)
        
        # æ ¼å¼åŒ–çµæœ
        formatted_results = []
        for r in results:
            formatted_results.append({
                'id': r.item.id,
                'type': r.item.knowledge_type.value,
                'question': r.item.question,
                'answer': r.item.answer,
                'successScore': r.item.success_score,
                'useCount': r.item.use_count,
                'similarity': r.similarity,
                'source': r.source
            })
        
        self.send_event("rag-search-result", {
            "success": True,
            "query": query,
            "results": formatted_results
        })
        
    except Exception as e:
        self.send_event("rag-search-result", {
            "success": False,
            "error": str(e)
        })


async def handle_trigger_rag_learning(self, payload: Dict[str, Any]):
    """è§¸ç™¼ RAG å­¸ç¿’"""
    try:
        from telegram_rag_system import telegram_rag, ConversationOutcome
        from chat_history_indexer import chat_indexer
        
        user_id = payload.get('userId')
        account_phone = payload.get('accountPhone', '')
        outcome = payload.get('outcome', 'unknown')
        
        if user_id:
            # å­¸ç¿’ç‰¹å®šç”¨æˆ¶çš„å°è©±
            await chat_indexer.on_conversation_ended(
                user_id=user_id,
                account_phone=account_phone,
                outcome=outcome
            )
            
            self.send_event("rag-learning-triggered", {
                "success": True,
                "userId": user_id
            })
        else:
            # æ‰¹é‡è™•ç†å¾…ç´¢å¼•çš„å°è©±
            result = await chat_indexer.index_pending_conversations()
            
            self.send_event("rag-learning-triggered", {
                "success": True,
                "conversationsProcessed": result.get('conversations_processed', 0),
                "knowledgeExtracted": result.get('knowledge_extracted', 0)
            })
        
    except Exception as e:
        self.send_event("rag-learning-triggered", {
            "success": False,
            "error": str(e)
        })


async def handle_add_rag_knowledge(self, payload: Dict[str, Any]):
    """æ‰‹å‹•æ·»åŠ  RAG çŸ¥è­˜"""
    try:
        from telegram_rag_system import telegram_rag, KnowledgeType
        
        knowledge_type = payload.get('type', 'qa')
        question = payload.get('question', '')
        answer = payload.get('answer', '')
        context = payload.get('context', '')
        
        # è½‰æ›é¡å‹
        try:
            kt = KnowledgeType(knowledge_type)
        except:
            kt = KnowledgeType.QA
        
        knowledge_id = await telegram_rag.add_manual_knowledge(
            knowledge_type=kt,
            question=question,
            answer=answer,
            context=context
        )
        
        self.send_event("rag-knowledge-added", {
            "success": True,
            "knowledgeId": knowledge_id
        })
        
    except Exception as e:
        self.send_event("rag-knowledge-added", {
            "success": False,
            "error": str(e)
        })


async def handle_rag_feedback(self, payload: Dict[str, Any]):
    """è¨˜éŒ„ RAG çŸ¥è­˜åé¥‹"""
    try:
        from telegram_rag_system import telegram_rag
        
        knowledge_id = payload.get('knowledgeId')
        is_positive = payload.get('isPositive', True)
        feedback_text = payload.get('feedbackText', '')
        
        await telegram_rag.record_feedback(
            knowledge_id=knowledge_id,
            is_positive=is_positive,
            feedback_text=feedback_text
        )
        
        self.send_event("rag-feedback-recorded", {
            "success": True,
            "knowledgeId": knowledge_id
        })
        
    except Exception as e:
        self.send_event("rag-feedback-recorded", {
            "success": False,
            "error": str(e)
        })


async def handle_cleanup_rag_knowledge(self, payload: Dict[str, Any]):
    """æ¸…ç† RAG çŸ¥è­˜åº«"""
    try:
        from telegram_rag_system import telegram_rag
        
        min_score = payload.get('minScore', 0.2)
        days_old = payload.get('daysOld', 30)
        merge_similar = payload.get('mergeSimilar', True)
        
        result = {
            'deleted': 0,
            'merged': 0
        }
        
        # æ¸…ç†ä½è³ªé‡çŸ¥è­˜
        result['deleted'] = await telegram_rag.cleanup_low_quality_knowledge(
            min_score=min_score,
            days_old=days_old
        )
        
        # åˆä½µç›¸ä¼¼çŸ¥è­˜
        if merge_similar:
            result['merged'] = await telegram_rag.merge_similar_knowledge()
        
        self.send_log(f"RAG çŸ¥è­˜åº«æ¸…ç†å®Œæˆ: åˆªé™¤ {result['deleted']} æ¢, åˆä½µ {result['merged']} æ¢", "success")
        
        self.send_event("rag-cleanup-complete", {
            "success": True,
            **result
        })
        
    except Exception as e:
        self.send_event("rag-cleanup-complete", {
            "success": False,
            "error": str(e)
        })


async def handle_get_ollama_models(self, payload: Dict[str, Any]):
    """ç²å– Ollama å¯ç”¨æ¨¡å‹åˆ—è¡¨"""
    try:
        import aiohttp
        
        endpoint = payload.get('endpoint', 'http://localhost:11434')
        
        async with aiohttp.ClientSession() as session:
            async with session.get(f"{endpoint}/api/tags", timeout=aiohttp.ClientTimeout(total=10)) as resp:
                if resp.status == 200:
                    data = await resp.json()
                    models = [model['name'] for model in data.get('models', [])]
                    
                    self.send_log(f"ğŸ¦™ Ollama æ¨¡å‹åˆ—è¡¨: {models}", "info")
                    self.send_event("ollama-models", {
                        "success": True,
                        "models": models
                    })
                else:
                    raise Exception(f"Ollama API è¿”å› {resp.status}")
                    
    except Exception as e:
        self.send_log(f"âŒ ç²å– Ollama æ¨¡å‹å¤±æ•—: {e}", "error")
        self.send_event("ollama-models", {
            "success": False,
            "error": str(e)
        })


async def handle_test_ollama_connection(self, payload: Dict[str, Any]):
    """æ¸¬è©¦ Ollama é€£æ¥"""
    try:
        import aiohttp
        
        endpoint = payload.get('endpoint', 'http://localhost:11434')
        
        async with aiohttp.ClientSession() as session:
            async with session.get(f"{endpoint}/api/version", timeout=aiohttp.ClientTimeout(total=5)) as resp:
                if resp.status == 200:
                    data = await resp.json()
                    version = data.get('version', 'unknown')
                    
                    self.send_log(f"ğŸ¦™ Ollama é€£æ¥æˆåŠŸ (ç‰ˆæœ¬: {version})", "success")
                    self.send_event("local-ai-test-result", {
                        "success": True,
                        "message": f"Ollama é€£æ¥æˆåŠŸ (v{version})"
                    })
                else:
                    raise Exception(f"é€£æ¥å¤±æ•—: HTTP {resp.status}")
                    
    except Exception as e:
        self.send_log(f"âŒ Ollama é€£æ¥å¤±æ•—: {e}", "error")
        self.send_event("local-ai-test-result", {
            "success": False,
            "error": str(e)
        })


async def handle_ollama_generate(self, payload: Dict[str, Any]):
    """ä½¿ç”¨ Ollama ç”Ÿæˆæ–‡æœ¬"""
    try:
        import aiohttp
        
        endpoint = payload.get('endpoint', 'http://localhost:11434')
        model = payload.get('model', 'qwen2:7b')
        prompt = payload.get('prompt', '')
        system = payload.get('system', '')
        
        if not prompt:
            raise ValueError("prompt ä¸èƒ½ç‚ºç©º")
        
        request_data = {
            "model": model,
            "prompt": prompt,
            "stream": False
        }
        
        if system:
            request_data["system"] = system
        
        async with aiohttp.ClientSession() as session:
            async with session.post(
                f"{endpoint}/api/generate",
                json=request_data,
                timeout=aiohttp.ClientTimeout(total=60)
            ) as resp:
                if resp.status == 200:
                    data = await resp.json()
                    response = data.get('response', '')
                    
                    self.send_event("ollama-response", {
                        "success": True,
                        "response": response,
                        "model": model
                    })
                else:
                    raise Exception(f"ç”Ÿæˆå¤±æ•—: HTTP {resp.status}")
                    
    except Exception as e:
        self.send_log(f"âŒ Ollama ç”Ÿæˆå¤±æ•—: {e}", "error")
        self.send_event("ollama-response", {
            "success": False,
            "error": str(e)
        })

