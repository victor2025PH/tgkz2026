"""
Extracted handler implementations: ai_team
Auto-generated by refactor_main.py
"""
import json
import sys
import time
import asyncio
import traceback
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from service_context import get_service_context
from database import db

from service_locator import ai_auto_chat
# All handlers receive (self, payload) where self is BackendService instance.
# They are called via: await handler_impl(self, payload)
# Inside, use self.db, self.send_event(), self.telegram_manager, etc.
# This is a transitional pattern - later, replace self.xxx with ctx.xxx


async def handle_get_customer_state(self, payload: Dict[str, Any]):
    """ğŸ†• ç²å–å®¢æˆ¶ç‹€æ…‹ï¼ˆAI è‡ªä¸»å¼•æ“ï¼‰"""
    user_id = payload.get('userId', '')
    
    try:
        if ai_auto_chat and ai_auto_chat.autonomous_engine:
            state = await ai_auto_chat.autonomous_engine.get_customer_state(user_id)
            if state:
                from dataclasses import asdict
                state_dict = asdict(state)
                # è½‰æ›æšèˆ‰ç‚ºå­—ç¬¦ä¸²
                state_dict['conversion_stage'] = state.conversion_stage.value
                state_dict['customer_style'] = state.customer_style.value
                self.send_event("customer-state", {
                    "success": True,
                    "state": state_dict
                })
            else:
                self.send_event("customer-state", {
                    "success": True,
                    "state": None
                })
        else:
            self.send_event("customer-state", {
                "success": False,
                "error": "AI è‡ªä¸»å¼•æ“æœªåˆå§‹åŒ–"
            })
    except Exception as e:
        print(f"[Backend] Error getting customer state: {e}", file=sys.stderr)
        self.send_event("customer-state", {
            "success": False,
            "error": str(e)
        })


async def handle_get_smart_system_stats(self, payload: Dict[str, Any]):
    """ğŸ†• ç²å–æ™ºèƒ½ç³»çµ±çµ±è¨ˆ"""
    stats = {
        'memories': 0,
        'tags': 0,
        'emotions': 0,
        'workflows': 0,
        'followups': 0,
        'knowledge': 0
    }
    
    try:
        # è¨˜æ†¶çµ±è¨ˆ
        try:
            result = await db.fetch_one("SELECT COUNT(*) as count FROM conversation_memories")
            stats['memories'] = result['count'] if result else 0
        except:
            pass
        
        # æ¨™ç±¤çµ±è¨ˆ
        try:
            result = await db.fetch_one("SELECT COUNT(*) as count FROM customer_tags")
            stats['tags'] = result['count'] if result else 0
        except:
            pass
        
        # æƒ…ç·’çµ±è¨ˆ
        try:
            result = await db.fetch_one("SELECT COUNT(*) as count FROM emotion_records")
            stats['emotions'] = result['count'] if result else 0
        except:
            pass
        
        # å·¥ä½œæµçµ±è¨ˆ
        try:
            result = await db.fetch_one("SELECT COUNT(*) as count FROM workflow_executions")
            stats['workflows'] = result['count'] if result else 0
        except:
            pass
        
        # è·Ÿé€²ä»»å‹™çµ±è¨ˆ
        try:
            result = await db.fetch_one("SELECT COUNT(*) as count FROM followup_tasks WHERE status = 'pending'")
            stats['followups'] = result['count'] if result else 0
        except:
            pass
        
        # çŸ¥è­˜å­¸ç¿’çµ±è¨ˆ
        try:
            result = await db.fetch_one("SELECT COUNT(*) as count FROM learned_knowledge")
            stats['knowledge'] = result['count'] if result else 0
        except:
            pass
        
        self.send_event("smart-system-stats", stats)
        print(f"[Backend] Smart system stats: {stats}", file=sys.stderr)
        
    except Exception as e:
        print(f"[Backend] Error getting smart system stats: {e}", file=sys.stderr)
        self.send_event("smart-system-stats", stats)



async def handle_ai_team_pause_execution(self, payload: Dict[str, Any]):
    """æš«åœ AI åœ˜éšŠåŸ·è¡Œ"""
    executor = self.get_ai_team_executor()
    execution_id = payload.get('executionId')
    executor.pause_execution(execution_id)


async def handle_ai_team_resume_execution(self, payload: Dict[str, Any]):
    """æ¢å¾© AI åœ˜éšŠåŸ·è¡Œ"""
    executor = self.get_ai_team_executor()
    execution_id = payload.get('executionId')
    executor.resume_execution(execution_id)


async def handle_ai_team_stop_execution(self, payload: Dict[str, Any]):
    """åœæ­¢ AI åœ˜éšŠåŸ·è¡Œ"""
    executor = self.get_ai_team_executor()
    execution_id = payload.get('executionId')
    executor.stop_execution(execution_id)


async def handle_ai_team_add_targets(self, payload: Dict[str, Any]):
    """æ·»åŠ ç›®æ¨™ç”¨æˆ¶åˆ° AI åœ˜éšŠéšŠåˆ—"""
    import sys
    targets = payload.get('targets', [])
    print(f"[AITeam] æ·»åŠ  {len(targets)} å€‹ç›®æ¨™ç”¨æˆ¶", file=sys.stderr)
    self.send_log(f"ğŸ¯ å·²æ·»åŠ  {len(targets)} å€‹ç›®æ¨™ç”¨æˆ¶åˆ° AI éŠ·å”®éšŠåˆ—", "info")


async def handle_ai_team_start_execution(self, payload: Dict[str, Any]):
    """å•Ÿå‹• AI åœ˜éšŠåŸ·è¡Œï¼ˆæ”¯æŒåŠ‡æœ¬/ç„¡åŠ‡æœ¬/æ··åˆæ¨¡å¼ï¼‰"""
    import sys
    
    try:
        execution_id = payload.get('executionId')
        goal = payload.get('goal', '')
        intent = payload.get('intent', {})
        strategy = payload.get('strategy', {})
        roles = payload.get('roles', [])
        mode = payload.get('mode', 'hybrid')  # scripted / scriptless / hybrid
        account_matches = payload.get('accountMatches', [])
        scriptless_config = payload.get('scriptlessConfig', {})
        analysis_interval = payload.get('analysisInterval', 10)
        target_users = payload.get('targetUsers', [])  # ğŸ†• ç›®æ¨™ç”¨æˆ¶åˆ—è¡¨
        
        print(f"[AITeam] å•Ÿå‹•åŸ·è¡Œ: {execution_id}, æ¨¡å¼: {mode}", file=sys.stderr)
        print(f"[AITeam] ç›®æ¨™: {goal}", file=sys.stderr)
        print(f"[AITeam] è§’è‰²æ•¸é‡: {len(roles)}, å¸³è™ŸåŒ¹é…: {len(account_matches)}, ç›®æ¨™ç”¨æˆ¶: {len(target_users)}", file=sys.stderr)
        
        # å­˜å„²åŸ·è¡Œç‹€æ…‹
        if not hasattr(self, '_ai_team_executions'):
            self._ai_team_executions = {}
        
        self._ai_team_executions[execution_id] = {
            'id': execution_id,
            'goal': goal,
            'intent': intent,
            'strategy': strategy,
            'roles': roles,
            'mode': mode,
            'account_matches': account_matches,
            'scriptless_config': scriptless_config,
            'analysis_interval': analysis_interval,
            'target_users': target_users,  # ğŸ†• ä¿å­˜ç›®æ¨™ç”¨æˆ¶
            'current_target_index': 0,     # ğŸ†• ç•¶å‰è™•ç†çš„ç›®æ¨™ç”¨æˆ¶ç´¢å¼•
            'status': 'running',
            'message_count': 0,
            'response_count': 0,
            'current_phase': 0,
            'message_history': [],  # ğŸ†• æ¶ˆæ¯æ­·å²
            'created_at': datetime.now().isoformat()
        }
        
        target_info = f"ï¼Œç›®æ¨™ {len(target_users)} äºº" if target_users else ""
        self.send_log(f"ğŸš€ AI åœ˜éšŠé–‹å§‹åŸ·è¡Œ: {goal[:30]}...{target_info}", "info")
        self.send_event("ai-team:execution-started", {
            "executionId": execution_id,
            "mode": mode,
            "roleCount": len(roles),
            "targetCount": len(target_users)
        })
        
        # ğŸ”§ Phase 3 ä¿®å¾©ï¼šç¢ºä¿ç§èŠè¼ªè©¢å™¨é‹è¡Œä»¥æ¥æ”¶ç›®æ¨™ç”¨æˆ¶å›è¦†
        await self._ensure_private_poller_running(account_matches)
        
        # æ ¹æ“šæ¨¡å¼å•Ÿå‹•åŸ·è¡Œ
        if mode == 'scriptless':
            # ç„¡åŠ‡æœ¬æ¨¡å¼ï¼šç­‰å¾…å‰ç«¯è§¸ç™¼æ¶ˆæ¯ç”Ÿæˆ
            self.send_log(f"ğŸ“ ç„¡åŠ‡æœ¬æ¨¡å¼å·²å°±ç·’ï¼Œç­‰å¾…å°è©±é–‹å§‹...", "info")
        else:
            # åŠ‡æœ¬æˆ–æ··åˆæ¨¡å¼ï¼šæŒ‰éšæ®µåŸ·è¡Œ
            asyncio.create_task(self._execute_scripted_phase(execution_id))
        
    except Exception as e:
        print(f"[AITeam] Start execution error: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("ai-team:execution-error", {
            "executionId": payload.get('executionId'),
            "error": str(e)
        })


    # TODO: å¯¦ç¾å…·é«”çš„éšæ®µæ¶ˆæ¯ç™¼é€é‚è¼¯
    # é€™è£¡å¯ä»¥èˆ‡ script_engine æ•´åˆ

async def handle_ai_team_adjust_strategy(self, payload: Dict[str, Any]):
    """èª¿æ•´ AI åœ˜éšŠç­–ç•¥ï¼ˆå‹•æ…‹åˆ†æè§¸ç™¼ï¼‰"""
    import sys
    
    try:
        execution_id = payload.get('executionId')
        adjustment = payload.get('adjustment', {})
        
        print(f"[AITeam] èª¿æ•´ç­–ç•¥: {execution_id}", file=sys.stderr)
        print(f"[AITeam] èª¿æ•´å‹•ä½œ: {adjustment.get('action')}, åŸå› : {adjustment.get('reason')}", file=sys.stderr)
        
        execution = self._ai_team_executions.get(execution_id) if hasattr(self, '_ai_team_executions') else None
        if not execution:
            return
        
        action = adjustment.get('action')
        
        if action == 'advance_phase':
            # æ¨é€²éšæ®µ
            new_phase = adjustment.get('newPhase', execution.get('current_phase', 0) + 1)
            execution['current_phase'] = new_phase
            asyncio.create_task(self._execute_scripted_phase(execution_id))
            
        elif action == 'switch_role':
            # åˆ‡æ›è§’è‰²
            new_role = adjustment.get('newRole')
            self.send_event("ai-team:role-switched", {
                "executionId": execution_id,
                "newRole": new_role,
                "reason": adjustment.get('reason')
            })
            
        elif action == 'activate_atmosphere':
            # æ´»èºæ°£æ°›
            self.send_log("ğŸ’¬ å¼•å…¥æ´»èºè§’è‰²å¸¶å‹•æ°£æ°›...", "info")
            
        elif action == 'handle_objection':
            # è™•ç†ç•°è­°
            self.send_log("ğŸ¯ å¼•å…¥å°ˆå®¶è™•ç†å®¢æˆ¶é¡§æ…®...", "info")
        
        self.send_event("ai-team:strategy-adjusted", {
            "executionId": execution_id,
            "adjustment": adjustment
        })
        
    except Exception as e:
        print(f"[AITeam] Adjust strategy error: {e}", file=sys.stderr)


async def handle_ai_team_generate_scriptless_message(self, payload: Dict[str, Any]):
    """ç„¡åŠ‡æœ¬æ¨¡å¼ï¼šAI è‡ªä¸»ç”Ÿæˆå°è©±"""
    import sys
    
    try:
        execution_id = payload.get('executionId')
        role_id = payload.get('roleId')
        role_name = payload.get('roleName', '')
        role_personality = payload.get('rolePersonality', '')
        role_speaking_style = payload.get('roleSpeakingStyle', '')
        prompt = payload.get('prompt', '')
        context = payload.get('context', {})
        
        print(f"[AITeam] ç„¡åŠ‡æœ¬ç”Ÿæˆæ¶ˆæ¯: {role_name}", file=sys.stderr)
        
        # ä½¿ç”¨ AI ç”Ÿæˆæ¶ˆæ¯
        generated_content = await self._generate_ai_message(
            role_name=role_name,
            role_personality=role_personality,
            role_speaking_style=role_speaking_style,
            prompt=prompt,
            context=context
        )
        
        if generated_content:
            self.send_event("ai-team:scriptless-message-generated", {
                "executionId": execution_id,
                "roleId": role_id,
                "content": generated_content,
                "reasoning": f"æ ¹æ“š {context.get('currentStage', 'å°è©±')} éšæ®µè‡ªå‹•ç”Ÿæˆ"
            })
        else:
            self.send_event("ai-team:scriptless-message-generated", {
                "executionId": execution_id,
                "roleId": role_id,
                "content": None,
                "error": "ç”Ÿæˆå¤±æ•—"
            })
        
    except Exception as e:
        print(f"[AITeam] Generate scriptless message error: {e}", file=sys.stderr)
        self.send_event("ai-team:scriptless-message-generated", {
            "executionId": payload.get('executionId'),
            "content": None,
            "error": str(e)
        })


async def handle_ai_team_send_scriptless_message(self, payload: Dict[str, Any]):
    """ç™¼é€ç„¡åŠ‡æœ¬æ¨¡å¼ç”Ÿæˆçš„æ¶ˆæ¯åˆ°ç›®æ¨™ç”¨æˆ¶"""
    import sys
    
    try:
        execution_id = payload.get('executionId')
        role_id = payload.get('roleId')
        content = payload.get('content')
        target_user_id = payload.get('targetUserId')  # å¯é¸ï¼šæŒ‡å®šç›®æ¨™ç”¨æˆ¶
        
        execution = self._ai_team_executions.get(execution_id) if hasattr(self, '_ai_team_executions') else None
        if not execution:
            print(f"[AITeam] æœªæ‰¾åˆ°åŸ·è¡Œ {execution_id}", file=sys.stderr)
            return
        
        # æ‰¾åˆ°å°æ‡‰çš„å¸³è™Ÿ
        account_match = next(
            (m for m in execution.get('account_matches', []) if m.get('roleId') == role_id),
            None
        )
        
        if not account_match:
            print(f"[AITeam] æœªæ‰¾åˆ°è§’è‰² {role_id} å°æ‡‰çš„å¸³è™Ÿ", file=sys.stderr)
            return
        
        account_id = account_match.get('accountId')
        account_phone = account_match.get('accountPhone')
        
        # ğŸ†• ç²å–ç›®æ¨™ç”¨æˆ¶
        target_users = execution.get('target_users', [])
        current_target_index = execution.get('current_target_index', 0)
        
        if target_user_id:
            # ä½¿ç”¨æŒ‡å®šçš„ç›®æ¨™ç”¨æˆ¶
            target_user = next((u for u in target_users if str(u.get('id')) == str(target_user_id) or str(u.get('telegramId')) == str(target_user_id)), None)
        elif target_users and current_target_index < len(target_users):
            # ä½¿ç”¨ç•¶å‰ç´¢å¼•çš„ç›®æ¨™ç”¨æˆ¶
            target_user = target_users[current_target_index]
        else:
            target_user = None
        
        send_success = False
        
        if target_user:
            telegram_id = target_user.get('telegramId') or target_user.get('id')
            target_name = target_user.get('firstName') or target_user.get('username') or telegram_id
            
            print(f"[AITeam] æº–å‚™ç™¼é€æ¶ˆæ¯åˆ° {target_name} (ID: {telegram_id}), ä½¿ç”¨å¸³è™Ÿ {account_phone}", file=sys.stderr)
            
            # å¯¦éš›ç™¼é€æ¶ˆæ¯ï¼ˆå¸¶æ“¬äººåŒ–å»¶é²ï¼‰
            try:
                # ğŸ”§ ä¿®å¾©: ä½¿ç”¨æ­£ç¢ºçš„å®¢æˆ¶ç«¯ç²å–æ–¹å¼
                client = None
                if account_phone and account_phone in self.telegram_manager.clients:
                    client = self.telegram_manager.clients[account_phone]
                
                if client and client.is_connected:
                    # ğŸ†• æ“¬äººåŒ–å»¶é²ï¼šæ¨¡æ“¬æ‰“å­—æ™‚é–“
                    import random
                    typing_delay = self._calculate_typing_delay(content)
                    
                    # ç™¼é€ã€Œæ­£åœ¨è¼¸å…¥ã€ç‹€æ…‹
                    try:
                        from pyrogram.raw.functions.messages import SetTyping
                        from pyrogram.raw.types import SendMessageTypingAction
                        await client.invoke(
                            SetTyping(
                                peer=await client.resolve_peer(int(telegram_id)),
                                action=SendMessageTypingAction()
                            )
                        )
                    except Exception as typing_err:
                        print(f"[AITeam] ç™¼é€è¼¸å…¥ç‹€æ…‹å¤±æ•—: {typing_err}", file=sys.stderr)
                    
                    # ç­‰å¾…æ‰“å­—å»¶é²
                    self.send_log(f"âŒ¨ï¸ æ­£åœ¨è¼¸å…¥... ({typing_delay:.1f}ç§’)", "info")
                    await asyncio.sleep(typing_delay)
                    
                    # ç™¼é€ç§èŠæ¶ˆæ¯
                    await client.send_message(int(telegram_id), content)
                    send_success = True
                    
                    # è¨˜éŒ„æ¶ˆæ¯æ­·å²
                    if 'message_history' not in execution:
                        execution['message_history'] = []
                    execution['message_history'].append({
                        'role': account_match.get('roleName'),
                        'content': content,
                        'targetUser': target_name,
                        'timestamp': datetime.now().isoformat(),
                        'isFromCustomer': False
                    })
                    
                    self.send_log(f"ğŸ“¤ [{account_match.get('roleName')}] â†’ {target_name}: {content[:30]}...", "success")
                else:
                    self.send_log(f"âš ï¸ å¸³è™Ÿ {account_phone} æœªé€£æ¥", "warning")
            except Exception as send_error:
                print(f"[AITeam] ç™¼é€æ¶ˆæ¯å¤±æ•—: {send_error}", file=sys.stderr)
                self.send_log(f"âŒ ç™¼é€å¤±æ•—: {str(send_error)[:50]}", "error")
        else:
            print(f"[AITeam] ç„¡ç›®æ¨™ç”¨æˆ¶ï¼Œæ¶ˆæ¯åƒ…è¨˜éŒ„", file=sys.stderr)
            # åƒ…è¨˜éŒ„æ¶ˆæ¯ï¼ˆç”¨æ–¼æ¼”ç¤ºæˆ–æ¸¬è©¦ï¼‰
            self.send_log(f"ğŸ“ [{account_match.get('roleName')}] (æ¨¡æ“¬): {content[:50]}...", "info")
        
        # æ›´æ–°çµ±è¨ˆ
        execution['message_count'] = execution.get('message_count', 0) + 1
        
        self.send_event("ai-team:message-sent", {
            "executionId": execution_id,
            "roleId": role_id,
            "content": content,
            "totalSent": execution['message_count'],
            "targetUser": target_user.get('firstName') if target_user else None,
            "success": send_success
        })
        
    except Exception as e:
        print(f"[AITeam] Send scriptless message error: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()


async def handle_ai_team_conversion_signal(self, payload: Dict[str, Any]):
    """è™•ç†è½‰åŒ–ä¿¡è™Ÿ"""
    import sys
    
    try:
        execution_id = payload.get('executionId')
        signal = payload.get('signal', '')
        recommended_role = payload.get('recommendedRole', 'sales_expert')
        
        print(f"[AITeam] æª¢æ¸¬åˆ°è½‰åŒ–ä¿¡è™Ÿ: {signal}", file=sys.stderr)
        
        execution = self._ai_team_executions.get(execution_id) if hasattr(self, '_ai_team_executions') else None
        if not execution:
            return
        
        # è¨˜éŒ„è½‰åŒ–ä¿¡è™Ÿ
        if 'conversion_signals' not in execution:
            execution['conversion_signals'] = []
        
        execution['conversion_signals'].append({
            'signal': signal,
            'timestamp': datetime.now().isoformat(),
            'recommended_role': recommended_role
        })
        
        self.send_log(f"ğŸ¯ è½‰åŒ–ä¿¡è™Ÿ: {signal[:50]}...", "success")
        
        # é€šçŸ¥å‰ç«¯åˆ‡æ›è§’è‰²
        self.send_event("ai-team:conversion-signal-detected", {
            "executionId": execution_id,
            "signal": signal,
            "recommendedRole": recommended_role,
            "action": "switch_to_closer"
        })
        
    except Exception as e:
        print(f"[AITeam] Conversion signal error: {e}", file=sys.stderr)


async def handle_ai_team_customer_reply(self, payload: Dict[str, Any]):
    """
    è™•ç†ç›®æ¨™å®¢æˆ¶çš„å›è¦†ï¼ˆå®¢æˆ¶å›è¦†è‡ªå‹•ç›£è½ï¼‰
    ç•¶æ”¶åˆ°ç§ä¿¡æ™‚æª¢æŸ¥æ˜¯å¦ç‚º AI åœ˜éšŠåŸ·è¡Œä»»å‹™çš„ç›®æ¨™ç”¨æˆ¶
    """
    import sys
    
    try:
        user_id = str(payload.get('userId', ''))
        username = payload.get('username', '')
        first_name = payload.get('firstName', '')
        text = payload.get('text', '')
        phone = payload.get('phone', '')
        
        # ğŸ”§ Phase 3 èª¿è©¦ï¼šè¨˜éŒ„æ”¶åˆ°çš„ç§èŠæ¶ˆæ¯
        print(f"[AITeam] ğŸ“¨ æ”¶åˆ°ç§èŠæ¶ˆæ¯: userId={user_id}, username={username}, text={text[:50] if text else 'empty'}...", file=sys.stderr)
        
        if not user_id:
            print(f"[AITeam] âš ï¸ è·³éï¼šuserId ç‚ºç©º", file=sys.stderr)
            return
        
        if not hasattr(self, '_ai_team_executions'):
            print(f"[AITeam] âš ï¸ è·³éï¼šæ²’æœ‰åŸ·è¡Œä¸­çš„ä»»å‹™ (_ai_team_executions æœªåˆå§‹åŒ–)", file=sys.stderr)
            return
        
        if len(self._ai_team_executions) == 0:
            print(f"[AITeam] âš ï¸ è·³éï¼šæ²’æœ‰åŸ·è¡Œä¸­çš„ä»»å‹™ (åˆ—è¡¨ç‚ºç©º)", file=sys.stderr)
            return
        
        print(f"[AITeam] ğŸ” æª¢æŸ¥ {len(self._ai_team_executions)} å€‹åŸ·è¡Œä»»å‹™...", file=sys.stderr)
        
        # éæ­·æ‰€æœ‰åŸ·è¡Œä¸­çš„ä»»å‹™ï¼Œæª¢æŸ¥æ˜¯å¦ç‚ºç›®æ¨™ç”¨æˆ¶
        found_match = False
        for execution_id, execution in self._ai_team_executions.items():
            exec_status = execution.get('status', 'unknown')
            if exec_status != 'running':
                print(f"[AITeam]   - ä»»å‹™ {execution_id}: ç‹€æ…‹={exec_status} (è·³é)", file=sys.stderr)
                continue
            
            target_users = execution.get('target_users', [])
            print(f"[AITeam]   - ä»»å‹™ {execution_id}: running, ç›®æ¨™ç”¨æˆ¶={len(target_users)} å€‹", file=sys.stderr)
            
            # ğŸ”§ èª¿è©¦ï¼šåˆ—å‡ºç›®æ¨™ç”¨æˆ¶çš„ ID
            for u in target_users:
                u_telegram_id = str(u.get('telegramId', ''))
                u_id = str(u.get('id', ''))
                u_name = u.get('firstName') or u.get('username') or 'unknown'
                print(f"[AITeam]     - ç›®æ¨™: {u_name}, telegramId={u_telegram_id}, id={u_id}", file=sys.stderr)
            
            # æª¢æŸ¥ç™¼é€è€…æ˜¯å¦ç‚ºç›®æ¨™ç”¨æˆ¶
            is_target = any(
                str(u.get('telegramId')) == user_id or str(u.get('id')) == user_id
                for u in target_users
            )
            
            if not is_target:
                print(f"[AITeam]     âŒ userId {user_id} ä¸åœ¨ç›®æ¨™ç”¨æˆ¶åˆ—è¡¨ä¸­", file=sys.stderr)
                continue
            
            found_match = True
            print(f"[AITeam] ğŸ¯ ç›®æ¨™ç”¨æˆ¶å›è¦†ï¼åŸ·è¡ŒID: {execution_id}, ç”¨æˆ¶: {first_name or username}", file=sys.stderr)
            
            # è¨˜éŒ„å®¢æˆ¶å›è¦†åˆ°æ¶ˆæ¯æ­·å²
            if 'message_history' not in execution:
                execution['message_history'] = []
            
            execution['message_history'].append({
                'role': 'customer',
                'content': text,
                'userId': user_id,
                'username': username,
                'firstName': first_name,
                'timestamp': datetime.now().isoformat(),
                'isFromCustomer': True
            })
            
            # æ›´æ–°çµ±è¨ˆ
            execution['response_count'] = execution.get('response_count', 0) + 1
            
            # ç™¼é€äº‹ä»¶é€šçŸ¥å‰ç«¯
            self.send_event("ai-team:customer-reply", {
                "executionId": execution_id,
                "userId": user_id,
                "username": username,
                "firstName": first_name,
                "text": text,
                "totalResponses": execution['response_count'],
                "messageCount": len(execution.get('message_history', []))
            })
            
            self.send_log(f"ğŸ’¬ å®¢æˆ¶å›è¦† [{first_name or username}]: {text[:50]}...", "success")
            
            # ğŸ†• æª¢æŸ¥æ˜¯å¦éœ€è¦è‡ªå‹•è§¸ç™¼ä¸‹ä¸€è¼ª AI å°è©±
            mode = execution.get('mode', 'hybrid')
            if mode in ['scriptless', 'hybrid']:
                # é€šçŸ¥å‰ç«¯ç”Ÿæˆä¸‹ä¸€æ¢æ¶ˆæ¯
                self.send_event("ai-team:trigger-next-message", {
                    "executionId": execution_id,
                    "customerMessage": text,
                    "customerId": user_id,
                    "customerName": first_name or username
                })
            
            # åªè™•ç†ç¬¬ä¸€å€‹åŒ¹é…çš„åŸ·è¡Œä»»å‹™
            break
            
    except Exception as e:
        print(f"[AITeam] Customer reply handling error: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()


async def handle_ai_team_send_manual_message(self, payload: Dict[str, Any]):
    """
    è™•ç†æ‰‹å‹•ä»‹å…¥ç™¼é€çš„æ¶ˆæ¯
    ç•¶ç”¨æˆ¶åœ¨æ‰‹å‹•æ¨¡å¼ä¸‹ç™¼é€æ¶ˆæ¯æ™‚èª¿ç”¨
    """
    import sys
    
    try:
        execution_id = payload.get('executionId')
        role_id = payload.get('roleId')
        role_name = payload.get('roleName', 'Unknown')
        content = payload.get('content', '')
        target_user_id = payload.get('targetUserId')
        
        if not execution_id or not content:
            return
        
        execution = self._ai_team_executions.get(execution_id)
        if not execution:
            self.send_log(f"æ‰¾ä¸åˆ°åŸ·è¡Œä»»å‹™: {execution_id}", "warning")
            return
        
        # æŸ¥æ‰¾ç›®æ¨™ç”¨æˆ¶å’Œå°æ‡‰å¸³è™Ÿ
        target_users = execution.get('target_users', [])
        account_matches = execution.get('account_matches', [])
        
        # ğŸ”§ ä¿®å¾©: æŸ¥æ‰¾è§’è‰²å°æ‡‰çš„å¸³è™Ÿï¼ˆåŒæ™‚ç²å– phoneï¼‰
        account_id = None
        account_phone = None
        for match in account_matches:
            if match.get('roleId') == role_id:
                account_id = match.get('accountId')
                account_phone = match.get('accountPhone')
                break
        
        if not account_id:
            # ä½¿ç”¨ç¬¬ä¸€å€‹å¯ç”¨å¸³è™Ÿ
            if account_matches:
                account_id = account_matches[0].get('accountId')
                account_phone = account_matches[0].get('accountPhone')
        
        # æŸ¥æ‰¾ç›®æ¨™ç”¨æˆ¶çš„ Telegram ID
        telegram_id = None
        target_name = "æœªçŸ¥ç”¨æˆ¶"
        
        if target_user_id:
            for user in target_users:
                if str(user.get('id')) == str(target_user_id) or str(user.get('telegramId')) == str(target_user_id):
                    telegram_id = user.get('telegramId') or user.get('id')
                    target_name = user.get('firstName') or user.get('username') or str(telegram_id)
                    break
        
        if not telegram_id and target_users:
            current_idx = execution.get('current_target_index', 0)
            if current_idx < len(target_users):
                user = target_users[current_idx]
                telegram_id = user.get('telegramId') or user.get('id')
                target_name = user.get('firstName') or user.get('username') or str(telegram_id)
        
        send_success = False
        
        if telegram_id and account_phone:
            try:
                # ğŸ”§ ä¿®å¾©: ä½¿ç”¨æ­£ç¢ºçš„å®¢æˆ¶ç«¯ç²å–æ–¹å¼
                client = None
                if account_phone in self.telegram_manager.clients:
                    client = self.telegram_manager.clients[account_phone]
                
                if client and client.is_connected:
                    # æ“¬äººåŒ–å»¶é²
                    typing_delay = self._calculate_typing_delay(content)
                    
                    # ç™¼é€ã€Œæ­£åœ¨è¼¸å…¥ã€ç‹€æ…‹
                    try:
                        from pyrogram.raw.functions.messages import SetTyping
                        from pyrogram.raw.types import SendMessageTypingAction
                        await client.invoke(
                            SetTyping(
                                peer=await client.resolve_peer(int(telegram_id)),
                                action=SendMessageTypingAction()
                            )
                        )
                    except Exception:
                        pass
                    
                    import asyncio
                    await asyncio.sleep(typing_delay)
                    
                    # ç™¼é€æ¶ˆæ¯
                    await client.send_message(int(telegram_id), content)
                    send_success = True
                    
                    self.send_log(f"ğŸ–ï¸ æ‰‹å‹•æ¶ˆæ¯ [{role_name}] â†’ {target_name}: {content[:30]}...", "success")
                    
            except Exception as send_err:
                print(f"[AITeam] æ‰‹å‹•æ¶ˆæ¯ç™¼é€å¤±æ•—: {send_err}", file=sys.stderr)
                self.send_log(f"æ‰‹å‹•æ¶ˆæ¯ç™¼é€å¤±æ•—: {send_err}", "error")
        
        # è¨˜éŒ„åˆ°æ¶ˆæ¯æ­·å²
        message_history = execution.get('message_history', [])
        message_history.append({
            'role': role_name,
            'content': content,
            'timestamp': datetime.now().isoformat(),
            'isFromCustomer': False,
            'isManual': True  # æ¨™è¨˜ç‚ºæ‰‹å‹•æ¶ˆæ¯
        })
        execution['message_history'] = message_history
        
        # æ›´æ–°çµ±è¨ˆ
        execution['message_count'] = execution.get('message_count', 0) + 1
        
        # ç™¼é€äº‹ä»¶
        self.send_event("ai-team:manual-message-sent", {
            "executionId": execution_id,
            "roleId": role_id,
            "roleName": role_name,
            "content": content,
            "targetUserId": telegram_id,
            "success": send_success
        })
        
    except Exception as e:
        print(f"[AITeam] Manual message error: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()


async def handle_ai_team_send_private_message(self, payload: Dict[str, Any]):
    """
    ğŸ†• P0: è™•ç† AI åœ˜éšŠè‡ªå‹•ç§èŠç™¼é€
    è‡ªå‹•ç™¼é€ç§èŠæ¶ˆæ¯çµ¦ç›®æ¨™ç”¨æˆ¶
    """
    import sys
    
    try:
        execution_id = payload.get('executionId')
        account_id = payload.get('accountId')
        account_phone = payload.get('accountPhone')
        role_id = payload.get('roleId')
        role_name = payload.get('roleName', 'AI')
        target_user_id = payload.get('targetUserId')
        target_user_name = payload.get('targetUserName', 'User')
        content = payload.get('content', '')
        is_first_touch = payload.get('isFirstTouch', False)
        
        if not execution_id or not content or not target_user_id:
            self.send_log("ç§èŠç™¼é€åƒæ•¸ä¸å®Œæ•´", "warning")
            return
        
        print(f"[AITeam] ğŸš€ ç™¼é€ç§èŠ: {role_name} â†’ {target_user_name}", file=sys.stderr)
        self.send_log(f"ğŸš€ é–‹å§‹ç§èŠè§¸é”: {role_name} â†’ {target_user_name}", "info")
        
        send_success = False
        
        # ç²å–å®¢æˆ¶ç«¯ä¸¦ç™¼é€
        try:
            # ğŸ”§ ä¿®å¾©: ä½¿ç”¨æ­£ç¢ºçš„å®¢æˆ¶ç«¯ç²å–æ–¹å¼
            client = None
            if account_phone and account_phone in self.telegram_manager.clients:
                client = self.telegram_manager.clients[account_phone]
            
            if client and client.is_connected:
                # æ“¬äººåŒ–å»¶é²
                typing_delay = self._calculate_typing_delay(content)
                
                # ç™¼é€ã€Œæ­£åœ¨è¼¸å…¥ã€ç‹€æ…‹
                try:
                    from pyrogram.raw.functions.messages import SetTyping
                    from pyrogram.raw.types import SendMessageTypingAction
                    await client.invoke(
                        SetTyping(
                            peer=await client.resolve_peer(str(target_user_id)),
                            action=SendMessageTypingAction()
                        )
                    )
                except Exception as typing_err:
                    print(f"[AITeam] è¼¸å…¥ç‹€æ…‹ç™¼é€å¤±æ•—: {typing_err}", file=sys.stderr)
                
                # ç­‰å¾…æ‰“å­—å»¶é²
                self.send_log(f"âŒ¨ï¸ æ­£åœ¨è¼¸å…¥... ({typing_delay:.1f}ç§’)", "info")
                await asyncio.sleep(typing_delay)
                
                # ç™¼é€æ¶ˆæ¯
                # å˜—è©¦å¤šç¨®æ–¹å¼è§£æç”¨æˆ¶ ID
                try:
                    # å¦‚æœæ˜¯ç´”æ•¸å­—ï¼Œç›´æ¥ä½¿ç”¨
                    if str(target_user_id).isdigit():
                        await client.send_message(int(target_user_id), content)
                    else:
                        # å¯èƒ½æ˜¯ username
                        await client.send_message(str(target_user_id), content)
                    send_success = True
                except Exception as send_err:
                    print(f"[AITeam] ç™¼é€å¤±æ•—ï¼Œå˜—è©¦ä½¿ç”¨ username: {send_err}", file=sys.stderr)
                    # å˜—è©¦ä½œç‚º username
                    try:
                        await client.send_message(f"@{target_user_id}", content)
                        send_success = True
                    except Exception as retry_err:
                        print(f"[AITeam] é‡è©¦ä¹Ÿå¤±æ•—: {retry_err}", file=sys.stderr)
                
                if send_success:
                    log_prefix = "ğŸ¯ é¦–æ¬¡è§¸é”" if is_first_touch else "ğŸ’¬ æ¶ˆæ¯ç™¼é€"
                    self.send_log(f"{log_prefix} [{role_name}] â†’ {target_user_name}: {content[:30]}...", "success")
            else:
                self.send_log(f"å¸³è™Ÿ {account_phone} æœªé€£æ¥ï¼Œç„¡æ³•ç™¼é€", "error")
                
        except Exception as client_err:
            print(f"[AITeam] å®¢æˆ¶ç«¯éŒ¯èª¤: {client_err}", file=sys.stderr)
            self.send_log(f"ç™¼é€å¤±æ•—: {client_err}", "error")
        
        # è¨˜éŒ„åˆ°åŸ·è¡Œç‹€æ…‹
        if hasattr(self, '_ai_team_executions') and execution_id in self._ai_team_executions:
            execution = self._ai_team_executions[execution_id]
            message_history = execution.get('message_history', [])
            message_history.append({
                'role': role_name,
                'content': content,
                'timestamp': datetime.now().isoformat(),
                'isFromCustomer': False,
                'isFirstTouch': is_first_touch,
                'targetUserId': target_user_id
            })
            execution['message_history'] = message_history
            execution['message_count'] = execution.get('message_count', 0) + 1
        
        # ç™¼é€äº‹ä»¶
        self.send_event("ai-team:private-message-sent", {
            "executionId": execution_id,
            "roleId": role_id,
            "roleName": role_name,
            "targetUserId": target_user_id,
            "targetUserName": target_user_name,
            "content": content,
            "success": send_success,
            "isFirstTouch": is_first_touch
        })
        
    except Exception as e:
        print(f"[AITeam] Private message error: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()


async def handle_ai_team_request_suggestion(self, payload: Dict[str, Any]):
    """
    è™•ç† AI å»ºè­°è«‹æ±‚ï¼ˆæ‰‹å‹•æ¨¡å¼ä¸‹ç‚ºç”¨æˆ¶æä¾›ä¸‹ä¸€æ­¥å»ºè­°ï¼‰
    """
    import sys
    
    try:
        execution_id = payload.get('executionId')
        message_history = payload.get('messageHistory', [])
        current_stage = payload.get('currentStage', 'contact')
        
        if not execution_id:
            return
        
        execution = self._ai_team_executions.get(execution_id)
        if not execution:
            return
        
        # æ§‹å»º AI è«‹æ±‚
        goal = execution.get('goal', '')
        
        # æ ¼å¼åŒ–æ¶ˆæ¯æ­·å²
        history_text = ""
        for msg in message_history[-10:]:
            sender = "å®¢æˆ¶" if msg.get('isFromCustomer') else msg.get('role', 'AI')
            history_text += f"ã€{sender}ã€‘: {msg.get('content', '')}\n"
        
        # AI æç¤ºè©
        prompt = f"""ä½ æ˜¯ä¸€å€‹éŠ·å”®å°ˆå®¶ï¼Œæ­£åœ¨å¹«åŠ©ç”¨æˆ¶é€²è¡Œå®¢æˆ¶è½‰åŒ–ã€‚

ç‡ŸéŠ·ç›®æ¨™ï¼š{goal}
ç•¶å‰éšæ®µï¼š{current_stage}

æœ€è¿‘å°è©±ï¼š
{history_text}

è«‹åŸºæ–¼ä»¥ä¸Šå°è©±ï¼Œçµ¦å‡ºä¸‹ä¸€æ¢æœ€ä½³å›è¦†çš„å»ºè­°ã€‚è¦æ±‚ï¼š
1. è‡ªç„¶ã€å‹å¥½ï¼Œä¸è¦å¤ªéŠ·å”®åŒ–
2. æ¨é€²åˆ°ä¸‹ä¸€å€‹è½‰åŒ–éšæ®µ
3. ç°¡çŸ­ï¼ˆ1-2å¥è©±ï¼‰
4. å¦‚æœå®¢æˆ¶è¡¨ç¾å‡ºèˆˆè¶£ï¼Œå¯ä»¥é©ç•¶æ¨é€²
5. å¦‚æœå®¢æˆ¶æœ‰ç–‘æ…®ï¼Œå…ˆè§£æ±ºç–‘æ…®

ç›´æ¥è¼¸å‡ºå»ºè­°çš„å›è¦†å…§å®¹ï¼Œä¸è¦è§£é‡‹ï¼š"""

        # èª¿ç”¨ AI ç”Ÿæˆå»ºè­°
        suggestion = await self._generate_ai_suggestion(prompt)
        
        if suggestion:
            self.send_event("ai-team:suggestion-update", {
                "executionId": execution_id,
                "suggestion": suggestion
            })
        
    except Exception as e:
        print(f"[AITeam] Suggestion request error: {e}", file=sys.stderr)


# ==================== AI åœ˜éšŠéšŠåˆ—ç®¡ç† ====================

async def handle_ai_team_user_completed(self, payload: Dict[str, Any]):
    """æ¨™è¨˜ç•¶å‰ç”¨æˆ¶è™•ç†å®Œæˆï¼Œæº–å‚™è™•ç†ä¸‹ä¸€å€‹"""
    import sys
    try:
        execution_id = payload.get('executionId')
        user_id = payload.get('userId')
        result = payload.get('result', 'completed')  # completed, converted, skipped
        
        print(f"[AITeam] ç”¨æˆ¶ {user_id} è™•ç†å®Œæˆ: {result}", file=sys.stderr)
        
        # æ›´æ–°æ•¸æ“šåº«è¨˜éŒ„
        await db.execute("""
            UPDATE unified_contacts 
            SET last_contact_at = CURRENT_TIMESTAMP,
                funnel_stage = CASE WHEN ? = 'converted' THEN 'converted' ELSE funnel_stage END
            WHERE telegram_user_id = ?
        """, (result, user_id))
        
        # ç™¼é€å®Œæˆäº‹ä»¶
        self.send_event("ai-team:user-completed", {
            "executionId": execution_id,
            "userId": user_id,
            "result": result
        })
        
    except Exception as e:
        print(f"[AITeam] User completed error: {e}", file=sys.stderr)


async def handle_ai_team_queue_completed(self, payload: Dict[str, Any]):
    """æ•´å€‹éšŠåˆ—è™•ç†å®Œæˆ"""
    import sys
    try:
        execution_id = payload.get('executionId')
        stats = payload.get('stats', {})
        
        print(f"[AITeam] éšŠåˆ—å®Œæˆ: {execution_id}", file=sys.stderr)
        print(f"[AITeam] çµ±è¨ˆ: ç™¼é€={stats.get('sent', 0)}, å›è¦†={stats.get('replied', 0)}, è½‰åŒ–={stats.get('converted', 0)}", file=sys.stderr)
        
        self.send_log(f"âœ… AI åœ˜éšŠåŸ·è¡Œå®Œæˆ: ç™¼é€ {stats.get('sent', 0)} æ¢ï¼Œå›è¦† {stats.get('replied', 0)} æ¢", "success")
        
        self.send_event("ai-team:execution-completed", {
            "executionId": execution_id,
            "stats": stats
        })
        
    except Exception as e:
        print(f"[AITeam] Queue completed error: {e}", file=sys.stderr)


async def handle_ai_team_next_user(self, payload: Dict[str, Any]):
    """é–‹å§‹è™•ç†ä¸‹ä¸€å€‹ç›®æ¨™ç”¨æˆ¶"""
    import sys
    try:
        execution_id = payload.get('executionId')
        next_user = payload.get('nextUser')
        
        if not next_user:
            print(f"[AITeam] éšŠåˆ—å·²ç©ºï¼Œæ²’æœ‰ä¸‹ä¸€å€‹ç”¨æˆ¶", file=sys.stderr)
            return
        
        user_id = next_user.get('id') or next_user.get('userId')
        username = next_user.get('username', 'Unknown')
        
        print(f"[AITeam] é–‹å§‹è™•ç†ä¸‹ä¸€ç”¨æˆ¶: {username} ({user_id})", file=sys.stderr)
        
        self.send_event("ai-team:next-user-started", {
            "executionId": execution_id,
            "userId": user_id,
            "username": username
        })
        
    except Exception as e:
        print(f"[AITeam] Next user error: {e}", file=sys.stderr)

