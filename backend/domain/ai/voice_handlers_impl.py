"""
Extracted handler implementations: voice
Auto-generated by refactor_main.py
"""
import json
import sys
import time
import asyncio
import traceback
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from service_context import get_service_context

import os
# All handlers receive (self, payload) where self is BackendService instance.
# They are called via: await handler_impl(self, payload)
# Inside, use self.db, self.send_event(), self.telegram_manager, etc.
# This is a transitional pattern - later, replace self.xxx with ctx.xxx


async def handle_text_to_speech(self, payload: Dict[str, Any]):
    """Convert text to speech using TTS service"""
    endpoint = payload.get('endpoint', getattr(self, 'ai_settings', {}).get('ttsEndpoint', 'http://localhost:9881'))
    text = payload.get('text', '')
    voice = payload.get('voice', '')
    
    try:
        import aiohttp
        
        # GPT-SoVITS API format
        request_data = {
            "text": text,
            "text_language": "zh",
            "ref_audio_path": voice if voice else None
        }
        
        async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:
            async with session.post(f"{endpoint}/", json=request_data) as response:
                if response.status == 200:
                    audio_data = await response.read()
                    import base64
                    audio_base64 = base64.b64encode(audio_data).decode('utf-8')
                    
                    self.send_event("tts-result", {
                        "success": True,
                        "audio": audio_base64,
                        "format": "wav"
                    })
                else:
                    error_text = await response.text()
                    self.send_event("tts-result", {
                        "success": False,
                        "error": f"TTS 服務返回 {response.status}: {error_text}"
                    })
                    
    except Exception as e:
        self.send_event("tts-result", {
            "success": False,
            "error": str(e)
        })


async def handle_speech_to_text(self, payload: Dict[str, Any]):
    """Convert speech to text using STT service"""
    endpoint = payload.get('endpoint', getattr(self, 'ai_settings', {}).get('sttEndpoint', 'http://localhost:9000'))
    audio_data = payload.get('audio', '')  # Base64 encoded audio
    
    try:
        import aiohttp
        import base64
        
        # Decode audio
        audio_bytes = base64.b64decode(audio_data)
        
        # Create form data for Whisper API
        data = aiohttp.FormData()
        data.add_field('file', audio_bytes, filename='audio.wav', content_type='audio/wav')
        
        async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:
            async with session.post(f"{endpoint}/transcribe", data=data) as response:
                if response.status == 200:
                    result = await response.json()
                    transcribed_text = result.get('text', '')
                    
                    self.send_event("stt-result", {
                        "success": True,
                        "text": transcribed_text
                    })
                else:
                    error_text = await response.text()
                    self.send_event("stt-result", {
                        "success": False,
                        "error": f"STT 服務返回 {response.status}: {error_text}"
                    })
                    
    except Exception as e:
        self.send_event("stt-result", {
            "success": False,
            "error": str(e)
        })


# ==================== Voice Clone Handlers ====================

async def handle_upload_voice_sample(self, payload: Dict[str, Any]):
    """Upload and save a voice sample for cloning"""
    name = payload.get('name', 'unnamed')
    audio_data = payload.get('audioData', '')
    file_name = payload.get('fileName', 'audio.wav')
    file_type = payload.get('fileType', 'audio/wav')
    
    try:
        import base64
        import os
        
        # Create voice samples directory
        voice_dir = os.path.join(os.path.dirname(__file__), 'voice_samples')
        os.makedirs(voice_dir, exist_ok=True)
        
        # Generate unique filename
        import time
        unique_name = f"{int(time.time())}_{file_name}"
        file_path = os.path.join(voice_dir, unique_name)
        
        # Decode and save audio
        audio_bytes = base64.b64decode(audio_data)
        with open(file_path, 'wb') as f:
            f.write(audio_bytes)
        
        self.send_event("voice-sample-uploaded", {
            "success": True,
            "voiceId": str(int(time.time())),
            "name": name,
            "audioPath": unique_name,
            "filePath": file_path
        })
        self.send_log(f"✓ 聲音樣本已保存: {name}", "success")
        
    except Exception as e:
        self.send_event("voice-sample-uploaded", {
            "success": False,
            "error": str(e)
        })
        self.send_log(f"✗ 保存聲音樣本失敗: {str(e)}", "error")


async def handle_delete_voice_sample(self, payload: Dict[str, Any]):
    """Delete a voice sample"""
    voice_id = payload.get('voiceId', '')
    
    try:
        import os
        
        # Find and delete the file
        voice_dir = os.path.join(os.path.dirname(__file__), 'voice_samples')
        
        # Try to find the file by ID (timestamp prefix)
        for filename in os.listdir(voice_dir):
            if filename.startswith(voice_id):
                file_path = os.path.join(voice_dir, filename)
                os.remove(file_path)
                self.send_event("voice-sample-deleted", {"success": True, "voiceId": voice_id})
                self.send_log(f"✓ 聲音樣本已刪除", "success")
                return
        
        self.send_event("voice-sample-deleted", {"success": True, "voiceId": voice_id})
        
    except Exception as e:
        self.send_event("voice-sample-deleted", {
            "success": False,
            "error": str(e)
        })


async def handle_preview_voice_sample(self, payload: Dict[str, Any]):
    """Preview a voice sample (send audio data back)"""
    voice_id = payload.get('voiceId', '')
    audio_path = payload.get('audioPath', '')
    
    try:
        import os
        import base64
        
        voice_dir = os.path.join(os.path.dirname(__file__), 'voice_samples')
        file_path = os.path.join(voice_dir, audio_path)
        
        if os.path.exists(file_path):
            with open(file_path, 'rb') as f:
                audio_data = base64.b64encode(f.read()).decode('utf-8')
            
            self.send_event("voice-sample-preview", {
                "success": True,
                "voiceId": voice_id,
                "audio": audio_data
            })
        else:
            self.send_event("voice-sample-preview", {
                "success": False,
                "error": "音頻文件不存在"
            })
            
    except Exception as e:
        self.send_event("voice-sample-preview", {
            "success": False,
            "error": str(e)
        })


async def handle_generate_cloned_voice(self, payload: Dict[str, Any]):
    """Generate speech using a cloned voice via remote TTS service"""
    endpoint = payload.get('endpoint', '')
    text = payload.get('text', '')
    voice_id = payload.get('voiceId', '')
    audio_path = payload.get('audioPath', '')
    
    try:
        import aiohttp
        import base64
        import os
        
        # Read the reference audio file
        voice_dir = os.path.join(os.path.dirname(__file__), 'voice_samples')
        ref_audio_path = os.path.join(voice_dir, audio_path)
        
        if not os.path.exists(ref_audio_path):
            self.send_event("cloned-voice-generated", {
                "success": False,
                "error": "參考音頻文件不存在"
            })
            return
        
        # Read reference audio
        with open(ref_audio_path, 'rb') as f:
            ref_audio_data = base64.b64encode(f.read()).decode('utf-8')
        
        # GPT-SoVITS API format
        request_data = {
            "text": text,
            "text_language": "zh",
            "refer_wav_base64": ref_audio_data,
            "prompt_text": "",  # Can be set to reference text if available
            "prompt_language": "zh"
        }
        
        async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=180)) as session:
            # Try different endpoint formats
            endpoints_to_try = [
                f"{endpoint}/",
                f"{endpoint}/tts",
                f"{endpoint}/api/tts",
                f"{endpoint}/v1/audio/speech"
            ]
            
            for api_url in endpoints_to_try:
                try:
                    async with session.post(api_url, json=request_data) as response:
                        if response.status == 200:
                            content_type = response.headers.get('Content-Type', '')
                            
                            if 'audio' in content_type or 'octet-stream' in content_type:
                                # Binary audio response
                                audio_data = await response.read()
                                audio_base64 = base64.b64encode(audio_data).decode('utf-8')
                                
                                self.send_event("cloned-voice-generated", {
                                    "success": True,
                                    "audio": audio_base64,
                                    "format": "wav"
                                })
                                self.send_log(f"✓ 使用克隆聲音生成語音成功", "success")
                                return
                            else:
                                # JSON response (might contain URL or base64)
                                result = await response.json()
                                if 'audio' in result:
                                    self.send_event("cloned-voice-generated", {
                                        "success": True,
                                        "audio": result['audio'],
                                        "format": result.get('format', 'wav')
                                    })
                                    self.send_log(f"✓ 使用克隆聲音生成語音成功", "success")
                                    return
                except Exception as e:
                    continue
            
            self.send_event("cloned-voice-generated", {
                "success": False,
                "error": "無法連接到 TTS 服務或所有端點都失敗"
            })
            self.send_log(f"✗ TTS 生成失敗: 無法連接到服務", "error")
                    
    except Exception as e:
        self.send_event("cloned-voice-generated", {
            "success": False,
            "error": str(e)
        })
        self.send_log(f"✗ 克隆聲音生成失敗: {str(e)}", "error")


async def handle_list_voice_samples(self):
    """List all saved voice samples"""
    try:
        import os
        
        voice_dir = os.path.join(os.path.dirname(__file__), 'voice_samples')
        
        if not os.path.exists(voice_dir):
            self.send_event("voice-samples-list", {"success": True, "samples": []})
            return
        
        samples = []
        for filename in os.listdir(voice_dir):
            file_path = os.path.join(voice_dir, filename)
            if os.path.isfile(file_path):
                stat = os.stat(file_path)
                samples.append({
                    "id": filename.split('_')[0],
                    "name": '_'.join(filename.split('_')[1:]).rsplit('.', 1)[0],
                    "audioPath": filename,
                    "size": stat.st_size,
                    "createdAt": stat.st_ctime
                })
        
        self.send_event("voice-samples-list", {
            "success": True,
            "samples": samples
        })
        
    except Exception as e:
        self.send_event("voice-samples-list", {
            "success": False,
            "error": str(e)
        })

