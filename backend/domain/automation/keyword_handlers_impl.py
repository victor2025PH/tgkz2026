"""
Extracted handler implementations: keywords
Auto-generated by refactor_main.py
"""
import json
import sys
import time
import asyncio
import traceback
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from service_context import get_service_context
from database import db

from error_handler import handle_error, AppError, ErrorType
from validators import validate_keyword, KeywordValidator, ValidationError
# All handlers receive (self, payload) where self is BackendService instance.
# They are called via: await handler_impl(self, payload)
# Inside, use self.db, self.send_event(), self.telegram_manager, etc.
# This is a transitional pattern - later, replace self.xxx with ctx.xxx


async def handle_get_keyword_sets(self):
    """Áç≤ÂèñÊâÄÊúâÈóúÈçµË©ûÈõÜÂàóË°®
    
    üîß ‰øÆÂæ©ÔºöÂêåÊôÇÂæû JSON Â≠óÊÆµÂíå keywords ÈóúËÅØË°®ËÆÄÂèñ‰∏¶Âêà‰Ωµ
    üîß Ê†ºÂºèÔºöÂêåÊôÇÂåÖÂê´ 'keyword' Âíå 'text' Â≠óÊÆµ
    """
    import sys
    try:
        rows = await db.fetch_all('SELECT * FROM keyword_sets ORDER BY created_at DESC')
        
        keyword_sets = []
        for row in rows:
            row_dict = dict(row) if hasattr(row, 'keys') else {
                'id': row[0], 'name': row[1], 'description': row[2], 
                'keywords': row[3], 'match_mode': row[4] if len(row) > 4 else 'fuzzy',
                'is_active': row[5] if len(row) > 5 else 1
            }
            
            set_id = row_dict['id']
            formatted_keywords = []
            seen_texts = set()
            
            # ========== ‰æÜÊ∫ê 1: Âæû JSON Â≠óÊÆµËß£Êûê ==========
            keywords_raw = row_dict.get('keywords', '[]')
            try:
                if isinstance(keywords_raw, str):
                    json_keywords = json.loads(keywords_raw) if keywords_raw else []
                else:
                    json_keywords = keywords_raw or []
            except:
                json_keywords = []
            
            for i, kw in enumerate(json_keywords):
                if isinstance(kw, dict):
                    text = kw.get('text', kw.get('keyword', ''))
                elif isinstance(kw, str):
                    text = kw
                else:
                    continue
                
                if text and text not in seen_texts:
                    seen_texts.add(text)
                    formatted_keywords.append({
                        'id': kw.get('id', f"kw-{set_id}-{i}") if isinstance(kw, dict) else f"kw-{set_id}-{i}",
                        'keyword': text,  # üîß ÂåπÈÖçÂô®‰ΩøÁî®
                        'text': text,     # üîß ÂâçÁ´ØÈ°ØÁ§∫
                        'isRegex': kw.get('isRegex', False) if isinstance(kw, dict) else False,
                        'matchCount': kw.get('matchCount', 0) if isinstance(kw, dict) else 0
                    })
            
            # ========== ‰æÜÊ∫ê 2: Âæû keywords ÈóúËÅØË°®ËÆÄÂèñÔºàËàäÊï∏ÊìöÔºâ ==========
            try:
                table_keywords = await db.fetch_all(
                    'SELECT * FROM keywords WHERE keyword_set_id = ?',
                    (set_id,)
                )
                for j, tk in enumerate(table_keywords):
                    tk_dict = dict(tk) if hasattr(tk, 'keys') else {
                        'id': tk[0], 'keyword_set_id': tk[1], 'keyword': tk[2],
                        'match_type': tk[3] if len(tk) > 3 else 'contains'
                    }
                    text = tk_dict.get('keyword', '')
                    if text and text not in seen_texts:
                        seen_texts.add(text)
                        formatted_keywords.append({
                            'id': f"kw-table-{tk_dict.get('id', j)}",
                            'keyword': text,
                            'text': text,
                            'isRegex': tk_dict.get('match_type') == 'regex',
                            'matchCount': 0
                        })
            except Exception as table_err:
                # keywords Ë°®ÂèØËÉΩ‰∏çÂ≠òÂú®ÊàñÂá∫ÈåØÔºåÂøΩÁï•
                print(f"[Backend] Note: keywords table read failed for set {set_id}: {table_err}", file=sys.stderr)
            
            # ÊßãÂª∫ÂâçÁ´ØÈúÄË¶ÅÁöÑÊ†ºÂºè
            keyword_set = {
                'id': str(set_id),
                'name': row_dict.get('name', ''),
                'description': row_dict.get('description', ''),
                'keywords': formatted_keywords,
                'matchMode': row_dict.get('match_mode', 'fuzzy'),
                'isActive': bool(row_dict.get('is_active', 1)),
                'totalMatches': sum(kw.get('matchCount', 0) for kw in formatted_keywords)
            }
            keyword_sets.append(keyword_set)
        
        print(f"[Backend] Returning {len(keyword_sets)} keyword sets", file=sys.stderr)
        for ks in keyword_sets:
            kw_texts = [k.get('text', k.get('keyword', '')) for k in ks.get('keywords', [])]
            print(f"[Backend]   - {ks.get('name')}: {len(ks.get('keywords', []))} keywords: {kw_texts}", file=sys.stderr)
        try:
            from core.tenant_filter import get_owner_user_id
            owner_id = get_owner_user_id() or ""
        except Exception:
            owner_id = ""
        self.send_event("get-keyword-sets-result", {"keywordSets": keyword_sets, "owner_user_id": owner_id})
        
    except Exception as e:
        import traceback
        print(f"[Backend] Error getting keyword sets: {e}", file=sys.stderr)
        print(traceback.format_exc(), file=sys.stderr)
        self.send_log(f"‚ùå Áç≤ÂèñÈóúÈçµË©ûÈõÜÂ§±Êïó: {e}", "error")
        self.send_event("get-keyword-sets-result", {"keywordSets": [], "error": str(e)})


async def handle_save_keyword_set(self, payload: Dict[str, Any]):
    """‰øùÂ≠òÈóúÈçµË©ûÈõÜÔºàÈÅá database is locked ÊôÇËá™ÂãïÈáçË©¶Ôºå‰∏¶ÂêëÁî®Êà∂Â±ïÁ§∫ÂèãÂ•ΩÊèêÁ§∫Ôºâ"""
    import sys
    import asyncio
    print(f"[Backend] ========== handle_save_keyword_set ==========", file=sys.stderr)
    print(f"[Backend] Payload: {payload}", file=sys.stderr)

    def _is_lock_error(e: Exception) -> bool:
        s = str(e).lower()
        return "locked" in s or "busy" in s or "sqlite_busy" in s

    try:
        set_id = payload.get('id')
        name = payload.get('name', '').strip()
        description = payload.get('description', '')
        keywords = payload.get('keywords', [])
        is_active = payload.get('isActive', True)
        match_mode = payload.get('matchMode', 'fuzzy')

        print(f"[Backend] set_id={set_id}, name={name}, keywords_count={len(keywords)}, match_mode={match_mode}", file=sys.stderr)

        if not name:
            self.send_event("save-keyword-set-result", {
                "success": False,
                "error": "Ë©ûÈõÜÂêçÁ®±‰∏çËÉΩÁÇ∫Á©∫"
            })
            return

        keywords_list = []
        for k in keywords:
            if isinstance(k, dict):
                text = k.get('text', k.get('keyword', ''))
                keywords_list.append({
                    'text': text,
                    'keyword': text,
                    'isRegex': k.get('isRegex', False)
                })
            elif isinstance(k, str):
                keywords_list.append({'text': k, 'keyword': k, 'isRegex': False})
        keywords_json = json.dumps(keywords_list, ensure_ascii=False)
        print(f"[Backend] keywords_json: {keywords_json}", file=sys.stderr)

        last_error = None
        for attempt in range(3):
            try:
                if set_id:
                    print(f"[Backend] Updating existing set id={set_id}", file=sys.stderr)
                    await db.execute(
                        """UPDATE keyword_sets 
                           SET name=?, description=?, keywords=?, match_mode=?, is_active=?, updated_at=CURRENT_TIMESTAMP
                           WHERE id=?""",
                        (name, description, keywords_json, match_mode, 1 if is_active else 0, set_id)
                    )
                else:
                    print(f"[Backend] Creating new set", file=sys.stderr)
                    try:
                        from core.tenant_filter import get_owner_user_id
                        _ks_owner = get_owner_user_id()
                    except ImportError:
                        _ks_owner = 'local_user'
                    set_id = await db.execute_insert(
                        """INSERT INTO keyword_sets (name, description, keywords, match_mode, is_active, owner_user_id)
                           VALUES (?, ?, ?, ?, ?, ?)""",
                        (name, description, keywords_json, match_mode, 1 if is_active else 0, _ks_owner)
                    )
                    print(f"[Backend] New set created with id={set_id}", file=sys.stderr)
                break
            except Exception as e:
                last_error = e
                if _is_lock_error(e) and attempt < 2:
                    wait = 0.3 * (attempt + 1)
                    print(f"[Backend] save_keyword_set lock retry {attempt + 1}/3 in {wait}s: {e}", file=sys.stderr)
                    await asyncio.sleep(wait)
                else:
                    raise
        else:
            if last_error:
                raise last_error

        self.send_event("save-keyword-set-result", {"success": True, "id": set_id})
        self.send_log(f"‚úÖ Â∑≤‰øùÂ≠òÈóúÈçµË©ûÈõÜ: {name} ({len(keywords_list)} ÂÄãÈóúÈçµË©û)", "success")
        await self.handle_get_keyword_sets()

    except Exception as e:
        self.send_log(f"‚ùå ‰øùÂ≠òÈóúÈçµË©ûÈõÜÂ§±Êïó: {e}", "error")
        err_msg = str(e)
        if _is_lock_error(e):
            err_msg = "Á≥ªÁµ±ÁπÅÂøôÔºåË´ãÁ®çÂæåÂÜçË©¶"
        self.send_event("save-keyword-set-result", {
            "success": False,
            "error": err_msg
        })


async def handle_delete_keyword_set(self, payload: Dict[str, Any]):
    """Âà™Èô§ÈóúÈçµË©ûÈõÜ"""
    try:
        set_id = payload.get('id')
        
        if not set_id:
            self.send_event("delete-keyword-set-result", {
                "success": False,
                "error": "Áº∫Â∞ëË©ûÈõÜ ID"
            })
            return
        
        await db.execute("DELETE FROM keyword_sets WHERE id=?", (set_id,))
        
        self.send_event("delete-keyword-set-result", {"success": True})
        self.send_log(f"üóëÔ∏è Â∑≤Âà™Èô§ÈóúÈçµË©ûÈõÜ ID: {set_id}", "success")
        
        # Âà∑Êñ∞ÂàóË°®
        await self.handle_get_keyword_sets()
        
    except Exception as e:
        self.send_log(f"‚ùå Âà™Èô§ÈóúÈçµË©ûÈõÜÂ§±Êïó: {e}", "error")
        self.send_event("delete-keyword-set-result", {
            "success": False,
            "error": str(e)
        })


async def handle_bind_keyword_set(self, payload: Dict[str, Any]):
    """Á∂ÅÂÆöÈóúÈçµË©ûÈõÜÂà∞Áæ§ÁµÑ"""
    import json
    import sys
    
    print(f"[Backend] ========== handle_bind_keyword_set ==========", file=sys.stderr)
    print(f"[Backend] Payload: {payload}", file=sys.stderr)
    
    try:
        group_id = payload.get('groupId')
        keyword_set_id = payload.get('keywordSetId')
        
        print(f"[Backend] group_id={group_id}, keyword_set_id={keyword_set_id}", file=sys.stderr)
        
        if not group_id or not keyword_set_id:
            self.send_log("‚ùå Á∂ÅÂÆöÂ§±Êïó: Áº∫Â∞ëÁæ§ÁµÑ ID ÊàñË©ûÈõÜ ID", "error")
            self.send_event("bind-keyword-set-result", {"success": False, "error": "Áº∫Â∞ëÂèÉÊï∏"})
            return
        
        # Áç≤ÂèñÁï∂ÂâçÁæ§ÁµÑÁöÑÁ∂ÅÂÆöË©ûÈõÜÂàóË°®
        result = await db.fetch_one(
            "SELECT id, keyword_set_ids FROM monitored_groups WHERE id=?", (group_id,)
        )
        
        print(f"[Backend] Current group data: {result}", file=sys.stderr)
        
        if not result:
            self.send_log(f"‚ùå Êâæ‰∏çÂà∞Áæ§ÁµÑ ID: {group_id}", "error")
            self.send_event("bind-keyword-set-result", {"success": False, "error": "Áæ§ÁµÑ‰∏çÂ≠òÂú®"})
            return
        
        current_ids = []
        try:
            raw_ids = result.get('keyword_set_ids') or '[]'
            current_ids = json.loads(raw_ids) if isinstance(raw_ids, str) else raw_ids
            if not isinstance(current_ids, list):
                current_ids = []
        except Exception as parse_err:
            print(f"[Backend] Parse error: {parse_err}", file=sys.stderr)
            current_ids = []
        
        print(f"[Backend] Current keyword_set_ids: {current_ids}", file=sys.stderr)
        
        # Ê∑ªÂä†Êñ∞Ë©ûÈõÜÔºàÈÅøÂÖçÈáçË§áÔºåÁµ±‰∏ÄÁî®Êï¥Êï∏Ôºâ
        keyword_set_id_int = int(keyword_set_id)
        if keyword_set_id_int not in current_ids:
            current_ids.append(keyword_set_id_int)
            
            # Êõ¥Êñ∞Êï∏ÊìöÂ∫´
            new_ids_json = json.dumps(current_ids)
            print(f"[Backend] Updating to: {new_ids_json}", file=sys.stderr)
            
            await db.execute(
                "UPDATE monitored_groups SET keyword_set_ids=?, updated_at=CURRENT_TIMESTAMP WHERE id=?",
                (new_ids_json, group_id)
            )
            
            self.send_log(f"‚úÖ Â∑≤Á∂ÅÂÆöË©ûÈõÜ {keyword_set_id} Âà∞Áæ§ÁµÑ {group_id}", "success")
        else:
            self.send_log(f"‚ÑπÔ∏è Ë©ûÈõÜ {keyword_set_id} Â∑≤Á∂ìÁ∂ÅÂÆöÂà∞Áæ§ÁµÑ {group_id}", "info")
        
        # ÈÄöÁü•ÂâçÁ´ØÊõ¥Êñ∞‰∏¶Âà∑Êñ∞Áæ§ÁµÑÂàóË°®
        self.send_event("bind-keyword-set-result", {
            "success": True, 
            "groupId": group_id, 
            "keywordSetId": keyword_set_id,
            "currentKeywordSetIds": current_ids
        })
        
        # Âà∑Êñ∞Áæ§ÁµÑÂàóË°®
        await self.handle_get_monitored_groups()
        
    except Exception as e:
        import traceback
        print(f"[Backend] Error: {traceback.format_exc()}", file=sys.stderr)
        self.send_log(f"‚ùå Á∂ÅÂÆöË©ûÈõÜÂ§±Êïó: {e}", "error")
        self.send_event("bind-keyword-set-result", {"success": False, "error": str(e)})


async def handle_unbind_keyword_set(self, payload: Dict[str, Any]):
    """Ëß£Á∂ÅÈóúÈçµË©ûÈõÜ"""
    import json
    import sys
    
    print(f"[Backend] ========== handle_unbind_keyword_set ==========", file=sys.stderr)
    print(f"[Backend] Payload: {payload}", file=sys.stderr)
    
    try:
        group_id = payload.get('groupId')
        keyword_set_id = payload.get('keywordSetId')
        
        if not group_id or not keyword_set_id:
            self.send_log("‚ùå Ëß£Á∂ÅÂ§±Êïó: Áº∫Â∞ëÁæ§ÁµÑ ID ÊàñË©ûÈõÜ ID", "error")
            self.send_event("unbind-keyword-set-result", {"success": False, "error": "Áº∫Â∞ëÂèÉÊï∏"})
            return
        
        # Áç≤ÂèñÁï∂ÂâçÁæ§ÁµÑÁöÑÁ∂ÅÂÆöË©ûÈõÜÂàóË°®
        result = await db.fetch_one(
            "SELECT id, keyword_set_ids FROM monitored_groups WHERE id=?", (group_id,)
        )
        
        if not result:
            self.send_log(f"‚ùå Êâæ‰∏çÂà∞Áæ§ÁµÑ ID: {group_id}", "error")
            self.send_event("unbind-keyword-set-result", {"success": False, "error": "Áæ§ÁµÑ‰∏çÂ≠òÂú®"})
            return
        
        current_ids = []
        try:
            raw_ids = result.get('keyword_set_ids') or '[]'
            current_ids = json.loads(raw_ids) if isinstance(raw_ids, str) else raw_ids
            if not isinstance(current_ids, list):
                current_ids = []
        except:
            current_ids = []
        
        # ÁßªÈô§Ë©ûÈõÜÔºàÁµ±‰∏ÄÁî®Êï¥Êï∏ÊØîËºÉÔºâ
        keyword_set_id_int = int(keyword_set_id)
        current_ids = [x for x in current_ids if int(x) != keyword_set_id_int]
        
        # Êõ¥Êñ∞Êï∏ÊìöÂ∫´
        new_ids_json = json.dumps(current_ids)
        print(f"[Backend] Updating to: {new_ids_json}", file=sys.stderr)
        
        await db.execute(
            "UPDATE monitored_groups SET keyword_set_ids=?, updated_at=CURRENT_TIMESTAMP WHERE id=?",
            (new_ids_json, group_id)
        )
        
        self.send_log(f"‚úÖ Â∑≤ÂæûÁæ§ÁµÑ {group_id} Ëß£Á∂ÅË©ûÈõÜ {keyword_set_id}", "success")
        
        # ÈÄöÁü•ÂâçÁ´ØÊõ¥Êñ∞
        self.send_event("unbind-keyword-set-result", {
            "success": True, 
            "groupId": group_id, 
            "keywordSetId": keyword_set_id,
            "currentKeywordSetIds": current_ids
        })
        
        # Âà∑Êñ∞Áæ§ÁµÑÂàóË°®
        await self.handle_get_monitored_groups()
        
    except Exception as e:
        import traceback
        print(f"[Backend] Error: {traceback.format_exc()}", file=sys.stderr)
        self.send_log(f"‚ùå Ëß£Á∂ÅË©ûÈõÜÂ§±Êïó: {e}", "error")
        self.send_event("unbind-keyword-set-result", {"success": False, "error": str(e)})


async def handle_add_keyword_set(self, payload: Dict[str, Any]):
    """Handle add-keyword-set command"""
    try:
        name = payload.get('name')
        
        if not name:
            error_msg = "ÈóúÈçµË©ûÈõÜÂêçÁ®±‰∏çËÉΩÁÇ∫Á©∫"
            self.send_log(error_msg, "error")
            self.send_event("keyword-set-error", {
                "success": False,
                "error": error_msg,
                "name": name
            })
            return
        
        # Validate keyword set name
        is_valid, error = KeywordValidator.validate_keyword_set_name(name)
        if not is_valid:
            self.send_log(f"È©óË≠âÈåØË™§: {error}", "error")
            self.send_event("keyword-set-validation-error", {
                "errors": [error],
                "name": name
            })
            self.send_event("keyword-set-error", {
                "success": False,
                "error": error,
                "name": name
            })
            handle_error(
                AppError(ErrorType.VALIDATION_ERROR, error, {"name": name}),
                {"command": "add-keyword-set", "payload": payload}
            )
            return
        
        # Check if keyword set already exists
        try:
            existing_sets = await db.get_all_keyword_sets()
            for existing_set in existing_sets:
                if existing_set.get('name') == name:
                    error_msg = f"ÈóúÈçµË©ûÈõÜ '{name}' Â∑≤Â≠òÂú®"
                    self.send_log(error_msg, "error")
                    self.send_event("keyword-set-error", {
                        "success": False,
                        "error": error_msg,
                        "name": name
                    })
                    return
        except Exception as check_err:
            import sys
            print(f"[Backend] Error checking existing keyword sets: {check_err}", file=sys.stderr)
            # Continue anyway, let the database handle the uniqueness constraint
        
        # Add keyword set
        try:
            keyword_set_id = await db.add_keyword_set(name)
            await db.add_log(f"ÈóúÈçµË©ûÈõÜ '{name}' Â∑≤Ê∑ªÂä†", "success")
            self.send_log(f"ÈóúÈçµË©ûÈõÜ '{name}' Ê∑ªÂä†ÊàêÂäü (ID: {keyword_set_id})", "success")
            self._invalidate_cache("keyword_sets")
            await self.send_keyword_sets_update()
            # Send success event
            self.send_event("keyword-set-error", {
                "success": True,
                "message": f"ÈóúÈçµË©ûÈõÜ '{name}' Ê∑ªÂä†ÊàêÂäü",
                "keywordSetId": keyword_set_id,
                "name": name
            })
        except Exception as db_err:
            import sys
            import traceback
            error_str = str(db_err).lower()
            error_details = traceback.format_exc()
            print(f"[Backend] Database error adding keyword set: {error_details}", file=sys.stderr)
            
            # Check for specific database errors
            if "unique" in error_str or "already exists" in error_str:
                error_msg = f"ÈóúÈçµË©ûÈõÜ '{name}' Â∑≤Â≠òÂú®"
            elif "database" in error_str and ("locked" in error_str or "corrupt" in error_str or "malformed" in error_str):
                error_msg = f"Êï∏ÊìöÂ∫´ÈåØË™§ÔºöÊï∏ÊìöÂ∫´ÂèØËÉΩÂ∑≤ÊêçÂ£ûÔºåË´ã‰ΩøÁî® rebuild_database.py ÈáçÂª∫Êï∏ÊìöÂ∫´"
            elif "no such table" in error_str:
                error_msg = f"Êï∏ÊìöÂ∫´ÈåØË™§ÔºöÈóúÈçµË©ûÈõÜË°®‰∏çÂ≠òÂú®ÔºåË´ãÈáçÂª∫Êï∏ÊìöÂ∫´"
            else:
                error_msg = f"Ê∑ªÂä†ÈóúÈçµË©ûÈõÜÂ§±Êïó: {str(db_err)}"
            
            self.send_log(error_msg, "error")
            await db.add_log(f"Ê∑ªÂä†ÈóúÈçµË©ûÈõÜÂ§±Êïó: {error_msg}", "error")
            self.send_event("keyword-set-error", {
                "success": False,
                "error": error_msg,
                "name": name,
                "details": str(db_err)
            })
    
    except ValidationError as e:
        self.send_log(f"È©óË≠âÈåØË™§: {e.message}", "error")
        self.send_event("keyword-set-validation-error", {
            "errors": [e.message],
            "field": e.field
        })
        self.send_event("keyword-set-error", {
            "success": False,
            "error": e.message,
            "field": e.field
        })
    except Exception as e:
        import sys
        import traceback
        error_details = traceback.format_exc()
        error_msg = f"Ê∑ªÂä†ÈóúÈçµË©ûÈõÜÊôÇÁôºÁîüÊú™Áü•ÈåØË™§: {str(e)}"
        print(f"[Backend] Unexpected error adding keyword set: {error_details}", file=sys.stderr)
        self.send_log(error_msg, "error")
        self.send_event("keyword-set-error", {
            "success": False,
            "error": error_msg,
            "details": str(e)
        })
        handle_error(e, {"command": "add-keyword-set", "payload": payload})


async def handle_remove_keyword_set(self, payload: Dict[str, Any]):
    """Handle remove-keyword-set command - idempotent operation"""
    import sys
    try:
        set_id = payload.get('id')
        
        if set_id is None:
            error_msg = "ÈóúÈçµË©ûÈõÜ ID ‰∏çËÉΩÁÇ∫Á©∫"
            print(f"[Backend] Remove keyword set error: {error_msg}", file=sys.stderr)
            self.send_log(error_msg, "error")
            self.send_event("keyword-set-error", {
                "success": False,
                "error": error_msg
            })
            return
        
        print(f"[Backend] Removing keyword set with ID: {set_id}", file=sys.stderr)
        
        # Delete from database (idempotent - won't error if already deleted)
        await db.remove_keyword_set(set_id)
        print(f"[Backend] Keyword set {set_id} delete operation completed", file=sys.stderr)
        
        # Invalidate cache and send update
        self._invalidate_cache("keyword_sets")
        print(f"[Backend] Cache invalidated, sending keyword sets update...", file=sys.stderr)
        
        await self.send_keyword_sets_update()
        print(f"[Backend] Keyword sets update sent", file=sys.stderr)
        
        # Send success event (always success since delete is idempotent)
        self.send_event("keyword-set-error", {
            "success": True,
            "message": f"ÈóúÈçµË©ûÈõÜ {set_id} Âà™Èô§ÊàêÂäü"
        })
    
    except Exception as e:
        import traceback
        error_details = traceback.format_exc()
        error_msg = f"Âà™Èô§ÈóúÈçµË©ûÈõÜÂ§±Êïó: {str(e)}"
        print(f"[Backend] Error removing keyword set: {error_details}", file=sys.stderr)
        self.send_log(error_msg, "error")
        self.send_event("keyword-set-error", {
            "success": False,
            "error": error_msg,
            "details": str(e)
        })


async def handle_add_keyword(self, payload: Dict[str, Any]):
    """Handle add-keyword command"""
    try:
        set_id = payload.get('setId')
        keyword = payload.get('keyword')
        is_regex = payload.get('isRegex', False)
        
        # Validate keyword
        is_valid, error = validate_keyword(keyword, is_regex)
        if not is_valid:
            self.send_log(f"Validation error: {error}", "error")
            self.send_event("keyword-validation-error", {
                "errors": [error],
                "keyword": keyword,
                "is_regex": is_regex
            })
            handle_error(
                AppError(ErrorType.VALIDATION_ERROR, error, {"keyword": keyword, "is_regex": is_regex}),
                {"command": "add-keyword", "payload": payload}
            )
            return
        
        # Ê™¢Êü•ÈóúÈçµË©ûÊòØÂê¶Â∑≤Â≠òÂú®
        existing_keywords = await db.get_keywords_by_set(set_id)
        keyword_exists = any(
            k.get('keyword') == keyword and k.get('isRegex') == is_regex 
            for k in existing_keywords
        )
        
        if keyword_exists:
            self.send_log(f"Keyword '{keyword}' already exists in set {set_id}", "warning")
            # ‰ªçÁÑ∂ÁôºÈÄÅÊõ¥Êñ∞‰∫ã‰ª∂‰ª•Á¢∫‰øùÂâçÁ´ØÁãÄÊÖãÂêåÊ≠•
            await self.send_keyword_sets_update()
            return
        
        keyword_id = await db.add_keyword(set_id, keyword, is_regex)
        await db.add_log(f"Keyword '{keyword}' added to set {set_id}", "success")
        self._invalidate_cache("keyword_sets")
        await self.send_keyword_sets_update()
    
    except ValidationError as e:
        self.send_log(f"Validation error: {e.message}", "error")
        self.send_event("keyword-validation-error", {
            "errors": [e.message],
            "field": e.field
        })
    except Exception as e:
        self.send_log(f"Error adding keyword: {str(e)}", "error")
        handle_error(e, {"command": "add-keyword", "payload": payload})


async def handle_remove_keyword(self, payload: Dict[str, Any]):
    """Handle remove-keyword command"""
    try:
        keyword_id = payload.get('keywordId')
        set_id = payload.get('setId')
        
        if not keyword_id:
            self.send_log("Error: keywordId is required", "error")
            return
        
        await db.remove_keyword(keyword_id)
        await db.add_log(f"Keyword {keyword_id} removed", "success")
        
        # Á¢∫‰øùÁôºÈÄÅÊõ¥Êñ∞‰∫ã‰ª∂
        self._invalidate_cache("keyword_sets")
        await self.send_keyword_sets_update()
    
    except Exception as e:
        self.send_log(f"Error removing keyword: {str(e)}", "error")
        # Âç≥‰ΩøÁôºÁîüÈåØË™§Ôºå‰πüÁôºÈÄÅÊõ¥Êñ∞‰∫ã‰ª∂‰ª•Á¢∫‰øùÂâçÁ´ØÁãÄÊÖãÂêåÊ≠•
        try:
            await self.send_keyword_sets_update()
        except:
            pass

