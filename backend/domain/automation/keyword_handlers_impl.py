"""
Extracted handler implementations: keywords
Auto-generated by refactor_main.py
"""
import json
import sys
import time
import asyncio
import traceback
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from service_context import get_service_context
from database import db

from error_handler import handle_error, AppError, ErrorType
from validators import validate_keyword, KeywordValidator, ValidationError
# All handlers receive (self, payload) where self is BackendService instance.
# They are called via: await handler_impl(self, payload)
# Inside, use self.db, self.send_event(), self.telegram_manager, etc.
# This is a transitional pattern - later, replace self.xxx with ctx.xxx


async def handle_get_keyword_sets(self):
    """ç²å–æ‰€æœ‰é—œéµè©é›†åˆ—è¡¨
    
    ğŸ”§ ä¿®å¾©ï¼šåŒæ™‚å¾ JSON å­—æ®µå’Œ keywords é—œè¯è¡¨è®€å–ä¸¦åˆä½µ
    ğŸ”§ æ ¼å¼ï¼šåŒæ™‚åŒ…å« 'keyword' å’Œ 'text' å­—æ®µ
    """
    import sys
    try:
        rows = await db.fetch_all('SELECT * FROM keyword_sets ORDER BY created_at DESC')
        
        keyword_sets = []
        for row in rows:
            row_dict = dict(row) if hasattr(row, 'keys') else {
                'id': row[0], 'name': row[1], 'description': row[2], 
                'keywords': row[3], 'match_mode': row[4] if len(row) > 4 else 'fuzzy',
                'is_active': row[5] if len(row) > 5 else 1
            }
            
            set_id = row_dict['id']
            formatted_keywords = []
            seen_texts = set()
            
            # ========== ä¾†æº 1: å¾ JSON å­—æ®µè§£æ ==========
            keywords_raw = row_dict.get('keywords', '[]')
            try:
                if isinstance(keywords_raw, str):
                    json_keywords = json.loads(keywords_raw) if keywords_raw else []
                else:
                    json_keywords = keywords_raw or []
            except:
                json_keywords = []
            
            for i, kw in enumerate(json_keywords):
                if isinstance(kw, dict):
                    text = kw.get('text', kw.get('keyword', ''))
                elif isinstance(kw, str):
                    text = kw
                else:
                    continue
                
                if text and text not in seen_texts:
                    seen_texts.add(text)
                    formatted_keywords.append({
                        'id': kw.get('id', f"kw-{set_id}-{i}") if isinstance(kw, dict) else f"kw-{set_id}-{i}",
                        'keyword': text,  # ğŸ”§ åŒ¹é…å™¨ä½¿ç”¨
                        'text': text,     # ğŸ”§ å‰ç«¯é¡¯ç¤º
                        'isRegex': kw.get('isRegex', False) if isinstance(kw, dict) else False,
                        'matchCount': kw.get('matchCount', 0) if isinstance(kw, dict) else 0
                    })
            
            # ========== ä¾†æº 2: å¾ keywords é—œè¯è¡¨è®€å–ï¼ˆèˆŠæ•¸æ“šï¼‰ ==========
            try:
                table_keywords = await db.fetch_all(
                    'SELECT * FROM keywords WHERE keyword_set_id = ?',
                    (set_id,)
                )
                for j, tk in enumerate(table_keywords):
                    tk_dict = dict(tk) if hasattr(tk, 'keys') else {
                        'id': tk[0], 'keyword_set_id': tk[1], 'keyword': tk[2],
                        'match_type': tk[3] if len(tk) > 3 else 'contains'
                    }
                    text = tk_dict.get('keyword', '')
                    if text and text not in seen_texts:
                        seen_texts.add(text)
                        formatted_keywords.append({
                            'id': f"kw-table-{tk_dict.get('id', j)}",
                            'keyword': text,
                            'text': text,
                            'isRegex': tk_dict.get('match_type') == 'regex',
                            'matchCount': 0
                        })
            except Exception as table_err:
                # keywords è¡¨å¯èƒ½ä¸å­˜åœ¨æˆ–å‡ºéŒ¯ï¼Œå¿½ç•¥
                print(f"[Backend] Note: keywords table read failed for set {set_id}: {table_err}", file=sys.stderr)
            
            # æ§‹å»ºå‰ç«¯éœ€è¦çš„æ ¼å¼
            keyword_set = {
                'id': str(set_id),
                'name': row_dict.get('name', ''),
                'description': row_dict.get('description', ''),
                'keywords': formatted_keywords,
                'matchMode': row_dict.get('match_mode', 'fuzzy'),
                'isActive': bool(row_dict.get('is_active', 1)),
                'totalMatches': sum(kw.get('matchCount', 0) for kw in formatted_keywords)
            }
            keyword_sets.append(keyword_set)
        
        print(f"[Backend] Returning {len(keyword_sets)} keyword sets", file=sys.stderr)
        for ks in keyword_sets:
            kw_texts = [k.get('text', k.get('keyword', '')) for k in ks.get('keywords', [])]
            print(f"[Backend]   - {ks.get('name')}: {len(ks.get('keywords', []))} keywords: {kw_texts}", file=sys.stderr)
        
        self.send_event("get-keyword-sets-result", {"keywordSets": keyword_sets})
        
    except Exception as e:
        import traceback
        print(f"[Backend] Error getting keyword sets: {e}", file=sys.stderr)
        print(traceback.format_exc(), file=sys.stderr)
        self.send_log(f"âŒ ç²å–é—œéµè©é›†å¤±æ•—: {e}", "error")
        self.send_event("get-keyword-sets-result", {"keywordSets": [], "error": str(e)})


async def handle_save_keyword_set(self, payload: Dict[str, Any]):
    """ä¿å­˜é—œéµè©é›†"""
    import sys
    print(f"[Backend] ========== handle_save_keyword_set ==========", file=sys.stderr)
    print(f"[Backend] Payload: {payload}", file=sys.stderr)
    
    try:
        set_id = payload.get('id')
        name = payload.get('name', '').strip()
        description = payload.get('description', '')
        keywords = payload.get('keywords', [])
        is_active = payload.get('isActive', True)
        match_mode = payload.get('matchMode', 'fuzzy')  # ğŸ”§ æ–°å¢ï¼šç²å–åŒ¹é…æ¨¡å¼
        
        print(f"[Backend] set_id={set_id}, name={name}, keywords_count={len(keywords)}, match_mode={match_mode}", file=sys.stderr)
        
        if not name:
            self.send_event("save-keyword-set-result", {
                "success": False,
                "error": "è©é›†åç¨±ä¸èƒ½ç‚ºç©º"
            })
            return
        
        # ğŸ”§ å°‡é—œéµè©åˆ—è¡¨è½‰ç‚º JSON å­—ç¬¦ä¸²ï¼ˆä¿å­˜å®Œæ•´å°è±¡ï¼ŒåŒ…å« text å’Œ keyword å­—æ®µï¼‰
        keywords_list = []
        for k in keywords:
            if isinstance(k, dict):
                text = k.get('text', k.get('keyword', ''))
                keywords_list.append({
                    'text': text,
                    'keyword': text,  # ğŸ”§ åŒæ™‚ä¿å­˜ keyword å­—æ®µä¾›åŒ¹é…å™¨ä½¿ç”¨
                    'isRegex': k.get('isRegex', False)
                })
            elif isinstance(k, str):
                keywords_list.append({
                    'text': k,
                    'keyword': k,
                    'isRegex': False
                })
        
        keywords_json = json.dumps(keywords_list, ensure_ascii=False)
        
        print(f"[Backend] keywords_json: {keywords_json}", file=sys.stderr)
        
        if set_id:
            # æ›´æ–°ç¾æœ‰è©é›†
            print(f"[Backend] Updating existing set id={set_id}", file=sys.stderr)
            await db.execute(
                """UPDATE keyword_sets 
                   SET name=?, description=?, keywords=?, match_mode=?, is_active=?, updated_at=CURRENT_TIMESTAMP
                   WHERE id=?""",
                (name, description, keywords_json, match_mode, 1 if is_active else 0, set_id)
            )
        else:
            # å‰µå»ºæ–°è©é›†
            print(f"[Backend] Creating new set", file=sys.stderr)
            cursor = await db.execute_insert(
                """INSERT INTO keyword_sets (name, description, keywords, match_mode, is_active)
                   VALUES (?, ?, ?, ?, ?)""",
                (name, description, keywords_json, match_mode, 1 if is_active else 0)
            )
            set_id = cursor
            print(f"[Backend] New set created with id={set_id}", file=sys.stderr)
        
        self.send_event("save-keyword-set-result", {"success": True, "id": set_id})
        self.send_log(f"âœ… å·²ä¿å­˜é—œéµè©é›†: {name} ({len(keywords_list)} å€‹é—œéµè©)", "success")
        
        # åˆ·æ–°åˆ—è¡¨
        await self.handle_get_keyword_sets()
        
    except Exception as e:
        self.send_log(f"âŒ ä¿å­˜é—œéµè©é›†å¤±æ•—: {e}", "error")
        self.send_event("save-keyword-set-result", {
            "success": False,
            "error": str(e)
        })


async def handle_delete_keyword_set(self, payload: Dict[str, Any]):
    """åˆªé™¤é—œéµè©é›†"""
    try:
        set_id = payload.get('id')
        
        if not set_id:
            self.send_event("delete-keyword-set-result", {
                "success": False,
                "error": "ç¼ºå°‘è©é›† ID"
            })
            return
        
        await db.execute("DELETE FROM keyword_sets WHERE id=?", (set_id,))
        
        self.send_event("delete-keyword-set-result", {"success": True})
        self.send_log(f"ğŸ—‘ï¸ å·²åˆªé™¤é—œéµè©é›† ID: {set_id}", "success")
        
        # åˆ·æ–°åˆ—è¡¨
        await self.handle_get_keyword_sets()
        
    except Exception as e:
        self.send_log(f"âŒ åˆªé™¤é—œéµè©é›†å¤±æ•—: {e}", "error")
        self.send_event("delete-keyword-set-result", {
            "success": False,
            "error": str(e)
        })


async def handle_bind_keyword_set(self, payload: Dict[str, Any]):
    """ç¶å®šé—œéµè©é›†åˆ°ç¾¤çµ„"""
    import json
    import sys
    
    print(f"[Backend] ========== handle_bind_keyword_set ==========", file=sys.stderr)
    print(f"[Backend] Payload: {payload}", file=sys.stderr)
    
    try:
        group_id = payload.get('groupId')
        keyword_set_id = payload.get('keywordSetId')
        
        print(f"[Backend] group_id={group_id}, keyword_set_id={keyword_set_id}", file=sys.stderr)
        
        if not group_id or not keyword_set_id:
            self.send_log("âŒ ç¶å®šå¤±æ•—: ç¼ºå°‘ç¾¤çµ„ ID æˆ–è©é›† ID", "error")
            self.send_event("bind-keyword-set-result", {"success": False, "error": "ç¼ºå°‘åƒæ•¸"})
            return
        
        # ç²å–ç•¶å‰ç¾¤çµ„çš„ç¶å®šè©é›†åˆ—è¡¨
        result = await db.fetch_one(
            "SELECT id, keyword_set_ids FROM monitored_groups WHERE id=?", (group_id,)
        )
        
        print(f"[Backend] Current group data: {result}", file=sys.stderr)
        
        if not result:
            self.send_log(f"âŒ æ‰¾ä¸åˆ°ç¾¤çµ„ ID: {group_id}", "error")
            self.send_event("bind-keyword-set-result", {"success": False, "error": "ç¾¤çµ„ä¸å­˜åœ¨"})
            return
        
        current_ids = []
        try:
            raw_ids = result.get('keyword_set_ids') or '[]'
            current_ids = json.loads(raw_ids) if isinstance(raw_ids, str) else raw_ids
            if not isinstance(current_ids, list):
                current_ids = []
        except Exception as parse_err:
            print(f"[Backend] Parse error: {parse_err}", file=sys.stderr)
            current_ids = []
        
        print(f"[Backend] Current keyword_set_ids: {current_ids}", file=sys.stderr)
        
        # æ·»åŠ æ–°è©é›†ï¼ˆé¿å…é‡è¤‡ï¼Œçµ±ä¸€ç”¨æ•´æ•¸ï¼‰
        keyword_set_id_int = int(keyword_set_id)
        if keyword_set_id_int not in current_ids:
            current_ids.append(keyword_set_id_int)
            
            # æ›´æ–°æ•¸æ“šåº«
            new_ids_json = json.dumps(current_ids)
            print(f"[Backend] Updating to: {new_ids_json}", file=sys.stderr)
            
            await db.execute(
                "UPDATE monitored_groups SET keyword_set_ids=?, updated_at=CURRENT_TIMESTAMP WHERE id=?",
                (new_ids_json, group_id)
            )
            
            self.send_log(f"âœ… å·²ç¶å®šè©é›† {keyword_set_id} åˆ°ç¾¤çµ„ {group_id}", "success")
        else:
            self.send_log(f"â„¹ï¸ è©é›† {keyword_set_id} å·²ç¶“ç¶å®šåˆ°ç¾¤çµ„ {group_id}", "info")
        
        # é€šçŸ¥å‰ç«¯æ›´æ–°ä¸¦åˆ·æ–°ç¾¤çµ„åˆ—è¡¨
        self.send_event("bind-keyword-set-result", {
            "success": True, 
            "groupId": group_id, 
            "keywordSetId": keyword_set_id,
            "currentKeywordSetIds": current_ids
        })
        
        # åˆ·æ–°ç¾¤çµ„åˆ—è¡¨
        await self.handle_get_monitored_groups()
        
    except Exception as e:
        import traceback
        print(f"[Backend] Error: {traceback.format_exc()}", file=sys.stderr)
        self.send_log(f"âŒ ç¶å®šè©é›†å¤±æ•—: {e}", "error")
        self.send_event("bind-keyword-set-result", {"success": False, "error": str(e)})


async def handle_unbind_keyword_set(self, payload: Dict[str, Any]):
    """è§£ç¶é—œéµè©é›†"""
    import json
    import sys
    
    print(f"[Backend] ========== handle_unbind_keyword_set ==========", file=sys.stderr)
    print(f"[Backend] Payload: {payload}", file=sys.stderr)
    
    try:
        group_id = payload.get('groupId')
        keyword_set_id = payload.get('keywordSetId')
        
        if not group_id or not keyword_set_id:
            self.send_log("âŒ è§£ç¶å¤±æ•—: ç¼ºå°‘ç¾¤çµ„ ID æˆ–è©é›† ID", "error")
            self.send_event("unbind-keyword-set-result", {"success": False, "error": "ç¼ºå°‘åƒæ•¸"})
            return
        
        # ç²å–ç•¶å‰ç¾¤çµ„çš„ç¶å®šè©é›†åˆ—è¡¨
        result = await db.fetch_one(
            "SELECT id, keyword_set_ids FROM monitored_groups WHERE id=?", (group_id,)
        )
        
        if not result:
            self.send_log(f"âŒ æ‰¾ä¸åˆ°ç¾¤çµ„ ID: {group_id}", "error")
            self.send_event("unbind-keyword-set-result", {"success": False, "error": "ç¾¤çµ„ä¸å­˜åœ¨"})
            return
        
        current_ids = []
        try:
            raw_ids = result.get('keyword_set_ids') or '[]'
            current_ids = json.loads(raw_ids) if isinstance(raw_ids, str) else raw_ids
            if not isinstance(current_ids, list):
                current_ids = []
        except:
            current_ids = []
        
        # ç§»é™¤è©é›†ï¼ˆçµ±ä¸€ç”¨æ•´æ•¸æ¯”è¼ƒï¼‰
        keyword_set_id_int = int(keyword_set_id)
        current_ids = [x for x in current_ids if int(x) != keyword_set_id_int]
        
        # æ›´æ–°æ•¸æ“šåº«
        new_ids_json = json.dumps(current_ids)
        print(f"[Backend] Updating to: {new_ids_json}", file=sys.stderr)
        
        await db.execute(
            "UPDATE monitored_groups SET keyword_set_ids=?, updated_at=CURRENT_TIMESTAMP WHERE id=?",
            (new_ids_json, group_id)
        )
        
        self.send_log(f"âœ… å·²å¾ç¾¤çµ„ {group_id} è§£ç¶è©é›† {keyword_set_id}", "success")
        
        # é€šçŸ¥å‰ç«¯æ›´æ–°
        self.send_event("unbind-keyword-set-result", {
            "success": True, 
            "groupId": group_id, 
            "keywordSetId": keyword_set_id,
            "currentKeywordSetIds": current_ids
        })
        
        # åˆ·æ–°ç¾¤çµ„åˆ—è¡¨
        await self.handle_get_monitored_groups()
        
    except Exception as e:
        import traceback
        print(f"[Backend] Error: {traceback.format_exc()}", file=sys.stderr)
        self.send_log(f"âŒ è§£ç¶è©é›†å¤±æ•—: {e}", "error")
        self.send_event("unbind-keyword-set-result", {"success": False, "error": str(e)})


async def handle_add_keyword_set(self, payload: Dict[str, Any]):
    """Handle add-keyword-set command"""
    try:
        name = payload.get('name')
        
        if not name:
            error_msg = "é—œéµè©é›†åç¨±ä¸èƒ½ç‚ºç©º"
            self.send_log(error_msg, "error")
            self.send_event("keyword-set-error", {
                "success": False,
                "error": error_msg,
                "name": name
            })
            return
        
        # Validate keyword set name
        is_valid, error = KeywordValidator.validate_keyword_set_name(name)
        if not is_valid:
            self.send_log(f"é©—è­‰éŒ¯èª¤: {error}", "error")
            self.send_event("keyword-set-validation-error", {
                "errors": [error],
                "name": name
            })
            self.send_event("keyword-set-error", {
                "success": False,
                "error": error,
                "name": name
            })
            handle_error(
                AppError(ErrorType.VALIDATION_ERROR, error, {"name": name}),
                {"command": "add-keyword-set", "payload": payload}
            )
            return
        
        # Check if keyword set already exists
        try:
            existing_sets = await db.get_all_keyword_sets()
            for existing_set in existing_sets:
                if existing_set.get('name') == name:
                    error_msg = f"é—œéµè©é›† '{name}' å·²å­˜åœ¨"
                    self.send_log(error_msg, "error")
                    self.send_event("keyword-set-error", {
                        "success": False,
                        "error": error_msg,
                        "name": name
                    })
                    return
        except Exception as check_err:
            import sys
            print(f"[Backend] Error checking existing keyword sets: {check_err}", file=sys.stderr)
            # Continue anyway, let the database handle the uniqueness constraint
        
        # Add keyword set
        try:
            keyword_set_id = await db.add_keyword_set(name)
            await db.add_log(f"é—œéµè©é›† '{name}' å·²æ·»åŠ ", "success")
            self.send_log(f"é—œéµè©é›† '{name}' æ·»åŠ æˆåŠŸ (ID: {keyword_set_id})", "success")
            self._invalidate_cache("keyword_sets")
            await self.send_keyword_sets_update()
            # Send success event
            self.send_event("keyword-set-error", {
                "success": True,
                "message": f"é—œéµè©é›† '{name}' æ·»åŠ æˆåŠŸ",
                "keywordSetId": keyword_set_id,
                "name": name
            })
        except Exception as db_err:
            import sys
            import traceback
            error_str = str(db_err).lower()
            error_details = traceback.format_exc()
            print(f"[Backend] Database error adding keyword set: {error_details}", file=sys.stderr)
            
            # Check for specific database errors
            if "unique" in error_str or "already exists" in error_str:
                error_msg = f"é—œéµè©é›† '{name}' å·²å­˜åœ¨"
            elif "database" in error_str and ("locked" in error_str or "corrupt" in error_str or "malformed" in error_str):
                error_msg = f"æ•¸æ“šåº«éŒ¯èª¤ï¼šæ•¸æ“šåº«å¯èƒ½å·²æå£ï¼Œè«‹ä½¿ç”¨ rebuild_database.py é‡å»ºæ•¸æ“šåº«"
            elif "no such table" in error_str:
                error_msg = f"æ•¸æ“šåº«éŒ¯èª¤ï¼šé—œéµè©é›†è¡¨ä¸å­˜åœ¨ï¼Œè«‹é‡å»ºæ•¸æ“šåº«"
            else:
                error_msg = f"æ·»åŠ é—œéµè©é›†å¤±æ•—: {str(db_err)}"
            
            self.send_log(error_msg, "error")
            await db.add_log(f"æ·»åŠ é—œéµè©é›†å¤±æ•—: {error_msg}", "error")
            self.send_event("keyword-set-error", {
                "success": False,
                "error": error_msg,
                "name": name,
                "details": str(db_err)
            })
    
    except ValidationError as e:
        self.send_log(f"é©—è­‰éŒ¯èª¤: {e.message}", "error")
        self.send_event("keyword-set-validation-error", {
            "errors": [e.message],
            "field": e.field
        })
        self.send_event("keyword-set-error", {
            "success": False,
            "error": e.message,
            "field": e.field
        })
    except Exception as e:
        import sys
        import traceback
        error_details = traceback.format_exc()
        error_msg = f"æ·»åŠ é—œéµè©é›†æ™‚ç™¼ç”ŸæœªçŸ¥éŒ¯èª¤: {str(e)}"
        print(f"[Backend] Unexpected error adding keyword set: {error_details}", file=sys.stderr)
        self.send_log(error_msg, "error")
        self.send_event("keyword-set-error", {
            "success": False,
            "error": error_msg,
            "details": str(e)
        })
        handle_error(e, {"command": "add-keyword-set", "payload": payload})


async def handle_remove_keyword_set(self, payload: Dict[str, Any]):
    """Handle remove-keyword-set command - idempotent operation"""
    import sys
    try:
        set_id = payload.get('id')
        
        if set_id is None:
            error_msg = "é—œéµè©é›† ID ä¸èƒ½ç‚ºç©º"
            print(f"[Backend] Remove keyword set error: {error_msg}", file=sys.stderr)
            self.send_log(error_msg, "error")
            self.send_event("keyword-set-error", {
                "success": False,
                "error": error_msg
            })
            return
        
        print(f"[Backend] Removing keyword set with ID: {set_id}", file=sys.stderr)
        
        # Delete from database (idempotent - won't error if already deleted)
        await db.remove_keyword_set(set_id)
        print(f"[Backend] Keyword set {set_id} delete operation completed", file=sys.stderr)
        
        # Invalidate cache and send update
        self._invalidate_cache("keyword_sets")
        print(f"[Backend] Cache invalidated, sending keyword sets update...", file=sys.stderr)
        
        await self.send_keyword_sets_update()
        print(f"[Backend] Keyword sets update sent", file=sys.stderr)
        
        # Send success event (always success since delete is idempotent)
        self.send_event("keyword-set-error", {
            "success": True,
            "message": f"é—œéµè©é›† {set_id} åˆªé™¤æˆåŠŸ"
        })
    
    except Exception as e:
        import traceback
        error_details = traceback.format_exc()
        error_msg = f"åˆªé™¤é—œéµè©é›†å¤±æ•—: {str(e)}"
        print(f"[Backend] Error removing keyword set: {error_details}", file=sys.stderr)
        self.send_log(error_msg, "error")
        self.send_event("keyword-set-error", {
            "success": False,
            "error": error_msg,
            "details": str(e)
        })


async def handle_add_keyword(self, payload: Dict[str, Any]):
    """Handle add-keyword command"""
    try:
        set_id = payload.get('setId')
        keyword = payload.get('keyword')
        is_regex = payload.get('isRegex', False)
        
        # Validate keyword
        is_valid, error = validate_keyword(keyword, is_regex)
        if not is_valid:
            self.send_log(f"Validation error: {error}", "error")
            self.send_event("keyword-validation-error", {
                "errors": [error],
                "keyword": keyword,
                "is_regex": is_regex
            })
            handle_error(
                AppError(ErrorType.VALIDATION_ERROR, error, {"keyword": keyword, "is_regex": is_regex}),
                {"command": "add-keyword", "payload": payload}
            )
            return
        
        # æª¢æŸ¥é—œéµè©æ˜¯å¦å·²å­˜åœ¨
        existing_keywords = await db.get_keywords_by_set(set_id)
        keyword_exists = any(
            k.get('keyword') == keyword and k.get('isRegex') == is_regex 
            for k in existing_keywords
        )
        
        if keyword_exists:
            self.send_log(f"Keyword '{keyword}' already exists in set {set_id}", "warning")
            # ä»ç„¶ç™¼é€æ›´æ–°äº‹ä»¶ä»¥ç¢ºä¿å‰ç«¯ç‹€æ…‹åŒæ­¥
            await self.send_keyword_sets_update()
            return
        
        keyword_id = await db.add_keyword(set_id, keyword, is_regex)
        await db.add_log(f"Keyword '{keyword}' added to set {set_id}", "success")
        self._invalidate_cache("keyword_sets")
        await self.send_keyword_sets_update()
    
    except ValidationError as e:
        self.send_log(f"Validation error: {e.message}", "error")
        self.send_event("keyword-validation-error", {
            "errors": [e.message],
            "field": e.field
        })
    except Exception as e:
        self.send_log(f"Error adding keyword: {str(e)}", "error")
        handle_error(e, {"command": "add-keyword", "payload": payload})


async def handle_remove_keyword(self, payload: Dict[str, Any]):
    """Handle remove-keyword command"""
    try:
        keyword_id = payload.get('keywordId')
        set_id = payload.get('setId')
        
        if not keyword_id:
            self.send_log("Error: keywordId is required", "error")
            return
        
        await db.remove_keyword(keyword_id)
        await db.add_log(f"Keyword {keyword_id} removed", "success")
        
        # ç¢ºä¿ç™¼é€æ›´æ–°äº‹ä»¶
        self._invalidate_cache("keyword_sets")
        await self.send_keyword_sets_update()
    
    except Exception as e:
        self.send_log(f"Error removing keyword: {str(e)}", "error")
        # å³ä½¿ç™¼ç”ŸéŒ¯èª¤ï¼Œä¹Ÿç™¼é€æ›´æ–°äº‹ä»¶ä»¥ç¢ºä¿å‰ç«¯ç‹€æ…‹åŒæ­¥
        try:
            await self.send_keyword_sets_update()
        except:
            pass

