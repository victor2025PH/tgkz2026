"""
Extracted handler implementations: monitoring
Auto-generated by refactor_main.py
"""
import json
import sys
import time
import asyncio
import traceback
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from service_context import get_service_context

from database import db
import re
from service_locator import (
    ai_auto_chat,
    auto_funnel,
    connection_monitor,
    group_join_service,
    group_search_service,
    private_message_handler,
    private_message_poller
)
# All handlers receive (self, payload) where self is BackendService instance.
# They are called via: await handler_impl(self, payload)
# Inside, use self.db, self.send_event(), self.telegram_manager, etc.
# This is a transitional pattern - later, replace self.xxx with ctx.xxx

async def handle_start_monitoring(self):
    """Handle start-monitoring command with Pyrogram"""
    import sys  # åœ¨å‡½æ•¸é–‹é ­å°å…¥ï¼Œé¿å… UnboundLocalError
    print("[Backend] ğŸš€ handle_start_monitoring called", file=sys.stderr)
    
    try:
        if self.is_monitoring:
            self.send_log("Monitoring is already running", "warning")
            # ğŸ”§ P0ä¿®å¾©: å³ä½¿å·²åœ¨ç›£æ§ä¸­ï¼Œä¹Ÿç™¼é€ç‹€æ…‹åŒæ­¥äº‹ä»¶
            self.send_event("monitoring-status-changed", True)
            self.send_event("monitoring-started", {"success": True, "message": "ç›£æ§å·²åœ¨é‹è¡Œä¸­"})
            return {"success": True, "message": "ç›£æ§å·²åœ¨é‹è¡Œä¸­", "isMonitoring": True}
        
        # ========== å®Œæ•´é…ç½®æª¢æŸ¥ ==========
        self.send_log("æ­£åœ¨æª¢æŸ¥ç›£æ§é…ç½®...", "info")
        print("[Backend] æ­£åœ¨æª¢æŸ¥ç›£æ§é…ç½®...", file=sys.stderr)
        
        try:
            config_check = await self.check_monitoring_configuration()
            print(f"[Backend] é…ç½®æª¢æŸ¥çµæœ: passed={config_check.get('passed')}", file=sys.stderr)
        except Exception as check_error:
            import sys
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_log(f"é…ç½®æª¢æŸ¥æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(check_error)}", "error")
            self.send_event("monitoring-start-failed", {
                "reason": "exception",
                "message": f"é…ç½®æª¢æŸ¥æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(check_error)}"
            })
            return {"success": False, "error": str(check_error), "isMonitoring": False}
        
        # ç™¼é€é…ç½®æª¢æŸ¥å ±å‘Šåˆ°å‰ç«¯
        self.send_event("monitoring-config-check", config_check)
        
        # é¡¯ç¤ºæª¢æŸ¥çµæœ
        for info in config_check.get("info", []):
            self.send_log(info, "info")
        
        for warning in config_check.get("warnings", []):
            self.send_log(f"âš  {warning['message']}", "warning")
        
        for issue in config_check.get("critical_issues", []):
            self.send_log(f"âœ— {issue['message']}", "error")
        
        # å¦‚æœæœ‰åš´é‡å•é¡Œï¼Œé˜»æ­¢å•Ÿå‹•
        if not config_check.get("passed", False):
            error_msg = "é…ç½®æª¢æŸ¥æœªé€šéï¼Œç„¡æ³•å•Ÿå‹•ç›£æ§ã€‚è«‹ä¿®å¾©ä¸Šè¿°å•é¡Œã€‚"
            self.send_log(error_msg, "error")
            self.send_event("monitoring-start-failed", {
                "reason": "config_check_failed",
                "message": "é…ç½®æª¢æŸ¥æœªé€šéï¼Œè«‹ä¿®å¾©å•é¡Œå¾Œé‡è©¦",
                "issues": config_check.get("critical_issues", []),
                "warnings": config_check.get("warnings", [])
            })
            print(f"[Backend] âŒ é…ç½®æª¢æŸ¥æœªé€šé: {config_check.get('critical_issues')}", file=sys.stderr)
            return {"success": False, "error": error_msg, "issues": config_check.get("critical_issues", []), "isMonitoring": False}
        
        # å¦‚æœæ²’æœ‰ç™¼é€èƒ½åŠ›ï¼Œçµ¦å‡ºè­¦å‘Šä½†ç¹¼çºŒ
        if not config_check.get("summary", {}).get("can_send_messages", False):
            self.send_log("âš  è­¦å‘Šï¼šç›£æ§å¯ä»¥é‹è¡Œï¼Œä½†æ²’æœ‰å¯ç”¨çš„ç™¼é€é…ç½®ã€‚Lead å°‡è¢«æ•ç²ä½†ä¸æœƒè‡ªå‹•ç™¼é€æ¶ˆæ¯ã€‚", "warning")
        
        # å¾é…ç½®æª¢æŸ¥ä¸­ç²å–æ•¸æ“š
        accounts = await db.get_all_accounts()
        listener_accounts = [a for a in accounts if a.get('role') == 'Listener' and a.get('status') == 'Online']
        monitored_groups = await db.get_all_monitored_groups()
        keyword_sets = await db.get_all_keyword_sets()
        
        # ========== æ–°å¢ï¼šæª¢æŸ¥ç›£æ§è™Ÿæ˜¯å¦å·²åŠ å…¥ç¾¤çµ„ ==========
        group_urls = [g.get('url') for g in monitored_groups if g.get('url')]
        self.send_log(f"æ­£åœ¨æª¢æŸ¥ {len(listener_accounts)} å€‹ç›£æ§è³¬è™Ÿå° {len(group_urls)} å€‹ç¾¤çµ„çš„æˆå“¡ç‹€æ…‹...", "info")
        
        # Check membership for all listener accounts
        all_membership_reports = []
        groups_needing_join = []  # Groups that need to be joined
        groups_accessible = []    # Groups that are accessible
        groups_cannot_join = []   # Groups that cannot be joined with reasons
        
        for account in listener_accounts:
            phone = account.get('phone')
            try:
                report = await self.telegram_manager.check_all_groups_membership(phone, group_urls)
                all_membership_reports.append(report)
                
                # Collect groups that are accessible (already member)
                for group_info in report.get("member_of", []):
                    if group_info["url"] not in [g["url"] for g in groups_accessible]:
                        groups_accessible.append(group_info)
                
                # Collect groups that need joining
                for group_info in report.get("can_join", []):
                    if group_info["url"] not in [g["url"] for g in groups_needing_join]:
                        groups_needing_join.append(group_info)
                
                # Collect groups that cannot be joined with reasons
                for group_info in report.get("cannot_join", []):
                    if group_info["url"] not in [g["url"] for g in groups_cannot_join]:
                        groups_cannot_join.append(group_info)
                
            except Exception as e:
                import sys
                print(f"[Backend] Error checking membership for {phone}: {e}", file=sys.stderr)
        
        # Send status report to frontend
        status_report = {
            "total_groups": len(group_urls),
            "accessible_groups": len(groups_accessible),
            "groups_needing_join": len(groups_needing_join),
            "groups_cannot_join": len(groups_cannot_join),
            "accessible_list": groups_accessible,
            "needing_join_list": groups_needing_join,
            "cannot_join_list": groups_cannot_join,
            "accounts_checked": len(listener_accounts)
        }
        
        self.send_event("monitoring-status-report", status_report)
        
        # Log status
        if groups_accessible:
            accessible_names = [g.get("title", g.get("url", "Unknown")) for g in groups_accessible[:3]]
            self.send_log(f"âœ“ å¯ç›£æ§ç¾¤çµ„: {len(groups_accessible)} å€‹ ({', '.join(accessible_names)}{'...' if len(groups_accessible) > 3 else ''})", "success")
        
        if groups_needing_join:
            needing_names = [g.get("url", "Unknown") for g in groups_needing_join[:3]]
            self.send_log(f"âš  éœ€è¦åŠ å…¥: {len(groups_needing_join)} å€‹ç¾¤çµ„ ({', '.join(needing_names)}{'...' if len(groups_needing_join) > 3 else ''})", "warning")
        
        # é¡¯ç¤ºç„¡æ³•åŠ å…¥çš„ç¾¤çµ„åŠåŸå› 
        if groups_cannot_join:
            for group_info in groups_cannot_join:
                reason = group_info.get("reason", "æœªçŸ¥åŸå› ")
                self.send_log(f"âœ— ç„¡æ³•åŠ å…¥ {group_info.get('url')}: {reason}", "error")
        
        # If no groups are accessible, try to auto-join
        if not groups_accessible and groups_needing_join:
            self.send_log(f"ç›£æ§è™ŸæœªåŠ å…¥ä»»ä½•ç¾¤çµ„ï¼Œæ­£åœ¨å˜—è©¦è‡ªå‹•åŠ å…¥ {len(groups_needing_join)} å€‹ç¾¤çµ„...", "info")
            # The start_monitoring will try to join groups automatically
        
        # If no groups can be monitored even after potential joins
        if not groups_accessible and not groups_needing_join:
            # ç”Ÿæˆè©³ç´°çš„éŒ¯èª¤ä¿¡æ¯
            error_details = []
            for g in groups_cannot_join:
                error_details.append(f"{g.get('url')}: {g.get('reason', 'æœªçŸ¥åŸå› ')}")
            
            error_message = "ç„¡æ³•å•Ÿå‹•ç›£æ§: ç›£æ§è™Ÿç„¡æ³•è¨ªå•ä»»ä½•ç¾¤çµ„ã€‚"
            if error_details:
                error_message += f"\nè©³æƒ…: {'; '.join(error_details)}"
            
            self.send_log(error_message, "error")
            self.send_event("monitoring-start-failed", {
                "reason": "no_accessible_groups",
                "message": "ç„¡æ³•å•Ÿå‹•ç›£æ§: ç›£æ§è™Ÿç„¡æ³•è¨ªå•ä»»ä½•ç¾¤çµ„ã€‚è«‹ç¢ºä¿ç›£æ§è™Ÿå·²åŠ å…¥è¦ç›£æ§çš„ç¾¤çµ„ã€‚",
                "cannot_join_list": groups_cannot_join
            })
            print(f"[Backend] âŒ ç„¡æ³•è¨ªå•ä»»ä½•ç¾¤çµ„", file=sys.stderr)
            return {"success": False, "error": error_message, "reason": "no_accessible_groups", "isMonitoring": False}
        
        # ========== çµæŸæ–°å¢ ==========
        
        # Start monitoring for each account
        async def on_lead_captured(lead_data):
            """Callback when a lead is captured - optimized with batch query"""
            try:
                # Batch check: get lead and DNC status in one query
                existing_lead, is_dnc = await db.check_lead_and_dnc(lead_data['user_id'])
                
                if is_dnc:
                    return
                
                should_greet = False  # æ˜¯å¦æ‡‰è©²ç™¼é€å•å€™
                
                if existing_lead:
                    # Update existing lead
                    lead_id = existing_lead['id']
                    await db.add_interaction(
                        lead_id,
                        'Keyword Matched',
                        f"Matched keyword: {lead_data['triggered_keyword']}"
                    )
                    
                    # ç¢ºä¿ user_profile å­˜åœ¨ï¼ˆç”¨æ–¼æ¼æ–—çµ±è¨ˆï¼‰
                    user_id_str = str(lead_data['user_id'])
                    existing_profile = await db.get_user_profile(user_id_str)
                    if not existing_profile:
                        await db._connection.execute("""
                            INSERT INTO user_profiles 
                            (user_id, username, first_name, last_name, funnel_stage, interest_level, created_at)
                            VALUES (?, ?, ?, ?, 'new', 1, CURRENT_TIMESTAMP)
                        """, (
                            user_id_str,
                            lead_data.get('username', ''),
                            lead_data.get('first_name', ''),
                            lead_data.get('last_name', '')
                        ))
                        await db._connection.commit()
                    
                    # æª¢æŸ¥æ˜¯å¦å·²ç¶“å•å€™éæ­¤ç”¨æˆ¶ï¼ˆæª¢æŸ¥ç‹€æ…‹ï¼‰
                    lead_status = existing_lead.get('status', 'New')
                    if lead_status == 'New':
                        # é‚„æ²’æœ‰è¯ç¹«éï¼Œæ‡‰è©²ç™¼é€å•å€™
                        should_greet = True
                        self.send_log(f"ğŸ“Œ ç¾æœ‰ Lead @{lead_data.get('username')} å°šæœªå•å€™ï¼Œå°‡ç™¼é€å•å€™", "info")
                else:
                    # Create new lead - å„ªå…ˆä½¿ç”¨ source_group_urlï¼ˆç¾¤çµ„ URLï¼‰
                    source_group_value = lead_data.get('source_group_url') or lead_data.get('source_group')
                    lead_id = await db.add_lead({
                        'userId': lead_data['user_id'],
                        'username': lead_data.get('username'),
                        'firstName': lead_data.get('first_name'),
                        'lastName': lead_data.get('last_name'),
                        'sourceGroup': source_group_value,  # å­˜å„² URL è€Œä¸æ˜¯ chat_id
                        'triggeredKeyword': lead_data['triggered_keyword'],
                        'onlineStatus': lead_data.get('online_status', 'Unknown')
                    })
                    
                    # é€²è¡Œæ„åœ–è©•åˆ†
                    from intent_scorer import score_lead_intent
                    message_text = lead_data.get('message_text', lead_data.get('triggered_keyword', ''))
                    intent_result = await score_lead_intent(message_text)
                    
                    # æ›´æ–° Lead çš„æ„åœ–åˆ†æ•¸
                    await db.update_lead(lead_id, {
                        'intent_score': intent_result['score'],
                        'intent_level': intent_result['level']
                    })
                    
                    self.send_log(f"ğŸ“Š æ„åœ–è©•åˆ†: {intent_result['score']}åˆ† ({intent_result['level']})", "info")
                    
                    # Send event with properly formatted data for frontend
                    import datetime
                    self.send_event("lead-captured", {
                        "id": lead_id,
                        "userId": lead_data['user_id'],
                        "username": lead_data.get('username') or '',
                        "firstName": lead_data.get('first_name') or '',
                        "lastName": lead_data.get('last_name') or '',
                        "sourceGroup": source_group_value,  # ä½¿ç”¨ URL
                        "triggeredKeyword": lead_data['triggered_keyword'],
                        "timestamp": lead_data.get('timestamp') or datetime.datetime.now().isoformat(),
                        "status": "New",
                        "onlineStatus": lead_data.get('online_status', 'Unknown'),
                        "interactionHistory": [],
                        "doNotContact": False,
                        "intentScore": intent_result['score'],
                        "intentLevel": intent_result['level'],
                        "intentSuggestions": intent_result['suggestions']
                    })
                    
                    self.send_log(f"âœ“ æ–°æ½›åœ¨å®¢æˆ¶å·²æ•ç²: @{lead_data.get('username') or lead_data.get('first_name')}", "success")
                    await db.add_log(f"New lead captured: {lead_data.get('username') or lead_data.get('first_name')}", "success")
                    
                    # åŒæ­¥åˆ° user_profiles è¡¨ï¼ˆç”¨æ–¼æ¼æ–—çµ±è¨ˆï¼‰
                    user_id_str = str(lead_data['user_id'])
                    existing_profile = await db.get_user_profile(user_id_str)
                    if not existing_profile:
                        await db._connection.execute("""
                            INSERT INTO user_profiles 
                            (user_id, username, first_name, last_name, funnel_stage, interest_level, created_at)
                            VALUES (?, ?, ?, ?, 'new', 1, CURRENT_TIMESTAMP)
                        """, (
                            user_id_str,
                            lead_data.get('username', ''),
                            lead_data.get('first_name', ''),
                            lead_data.get('last_name', '')
                        ))
                        await db._connection.commit()
                        self.send_log(f"ğŸ“Š å·²å‰µå»ºç”¨æˆ¶è³‡æ–™: @{lead_data.get('username')}", "info")
                    
                    # æ–° Lead ç¸½æ˜¯ç™¼é€å•å€™
                    should_greet = True
                
                # AI Auto Chat: Handle greeting (for new leads or existing leads not yet contacted)
                if should_greet:
                    await self._handle_ai_auto_greeting(lead_data, lead_id)
                
                # åŸ·è¡ŒåŒ¹é…çš„è§¸ç™¼è¦å‰‡ï¼ˆæ–°ç³»çµ±ï¼‰
                await self.execute_matching_trigger_rules(lead_id, lead_data)
                
                # Check for matching campaigns and execute them (èˆŠç³»çµ±ï¼Œä¿æŒå…¼å®¹)
                await self.execute_matching_campaigns(lead_id, lead_data)
            
            except Exception as e:
                import sys
                import traceback
                error_details = traceback.format_exc()
                error_msg = f"Error processing captured lead: {str(e)}\n{error_details}"
                print(f"[Backend] Error in lead_callback: {error_msg}", file=sys.stderr)
                self.send_log(f"è™•ç†æ½›åœ¨å®¢æˆ¶æ™‚å‡ºéŒ¯: {str(e)}", "error")
                # è¨˜éŒ„è©³ç´°éŒ¯èª¤åˆ°æ•¸æ“šåº«
                await db.add_log(f"Lead callback error: {str(e)}", "error")
        
        # Start monitoring for each listener account
        successful_starts = 0
        failed_accounts = []
        
        for account in listener_accounts:
            phone = account.get('phone')
            group_urls = [g.get('url') for g in monitored_groups]
            keyword_sets_list = [
                {
                    "id": ks.get('id'),
                    "keywords": ks.get('keywords', [])
                }
                for ks in keyword_sets
            ]
            
            try:
                import sys
                print(f"[Backend] Attempting to start monitoring for account {phone}", file=sys.stderr)
                print(f"[Backend] Group URLs: {group_urls}", file=sys.stderr)
                print(f"[Backend] Keyword sets count: {len(keyword_sets_list)}", file=sys.stderr)
                
                # å˜—è©¦å•Ÿå‹•ç›£æ§
                result = await self.telegram_manager.start_monitoring(
                    phone=phone,
                    group_urls=group_urls,
                    keyword_sets=keyword_sets_list,
                    on_lead_captured=on_lead_captured
                )
                
                print(f"[Backend] start_monitoring result for {phone}: {result} (type: {type(result)})", file=sys.stderr)
                
                # æª¢æŸ¥æ˜¯å¦æˆåŠŸå•Ÿå‹•ï¼ˆstart_monitoring è¿”å› True è¡¨ç¤ºæˆåŠŸï¼‰
                if result is True:
                    successful_starts += 1
                    print(f"[Backend] âœ“ Successfully started monitoring for {phone}", file=sys.stderr)
                    
                    # è¨˜éŒ„ç›£æ§çš„ç¾¤çµ„ä¿¡æ¯
                    if hasattr(self.telegram_manager, 'monitoring_info') and phone in self.telegram_manager.monitoring_info:
                        monitoring_info = self.telegram_manager.monitoring_info[phone]
                        monitored_urls = monitoring_info.get('group_urls', [])
                        if monitored_urls:
                            self.send_log(f"è³¬æˆ¶ {phone} æˆåŠŸå•Ÿå‹•ç›£æ§ï¼Œç›£æ§ç¾¤çµ„: {', '.join(monitored_urls)}", "success")
                    
                    # å•Ÿå‹•ç€è¦½è¡Œç‚ºæ¨¡æ“¬å¾Œå°ä»»å‹™ï¼ˆè¡Œç‚ºæ¨¡æ“¬ï¼‰
                    try:
                        await self._start_browsing_simulation(account.get('id'), phone, group_urls)
                    except Exception as sim_error:
                        self.send_log(f"å•Ÿå‹•è¡Œç‚ºæ¨¡æ“¬å¤±æ•— ({phone}): {str(sim_error)}", "warning")
                else:
                    failed_accounts.append(phone)
                    print(f"[Backend] âœ— Failed to start monitoring for {phone}, result: {result}", file=sys.stderr)
                    self.send_log(f"è³¬æˆ¶ {phone} ç›£æ§å•Ÿå‹•å¤±æ•—ï¼ˆè¿”å›å€¼: {result}ï¼‰", "warning")
            
            except Exception as account_error:
                failed_accounts.append(phone)
                import sys
                import traceback
                print(f"[Backend] âœ— Exception starting monitoring for {phone}: {account_error}", file=sys.stderr)
                traceback.print_exc(file=sys.stderr)
                self.send_log(f"è³¬æˆ¶ {phone} ç›£æ§å•Ÿå‹•å¤±æ•—: {str(account_error)}", "error")
        
        # åªæœ‰åœ¨è‡³å°‘ä¸€å€‹è³¬æˆ¶æˆåŠŸå•Ÿå‹•ç›£æ§æ™‚ï¼Œæ‰è¨­ç½®å…¨å±€ç›£æ§ç‹€æ…‹
        if successful_starts > 0:
            self.is_monitoring = True
            # Save monitoring state to database
            await db.set_monitoring_active(True)
            self.send_event("monitoring-status-changed", True)
            
            success_message = f"ç›£æ§å·²å•Ÿå‹•ï¼š{successful_starts} å€‹è³¬æˆ¶æ­£åœ¨ç›£æ§"
            if failed_accounts:
                success_message += f"ï¼Œ{len(failed_accounts)} å€‹è³¬æˆ¶å•Ÿå‹•å¤±æ•—"
            
            await db.add_log(success_message, "success")
            self.send_log(success_message, "success")
            
            # ç‚ºæ‰€æœ‰åœ¨ç·šå¸³è™Ÿè¨»å†Šç§ä¿¡è™•ç†å™¨ï¼ˆç¢ºä¿ AI å¯ä»¥å›å¾©ç”¨æˆ¶ç§ä¿¡ï¼‰
            all_accounts = await db.get_all_accounts()
            online_clients = {}
            for acc in all_accounts:
                if acc.get('status') == 'Online':
                    acc_phone = acc.get('phone')
                    acc_role = acc.get('role', 'Unassigned')
                    try:
                        await self.telegram_manager.register_private_message_handler(
                            phone=acc_phone,
                            account_role=acc_role
                        )
                        print(f"[Backend] âœ“ å·²ç‚ºå¸³è™Ÿ {acc_phone} è¨»å†Šç§ä¿¡è™•ç†å™¨", file=sys.stderr)
                        
                        # æ”¶é›†åœ¨ç·šå®¢æˆ¶ç«¯ç”¨æ–¼è¼ªè©¢
                        client = self.telegram_manager.get_client(acc_phone)
                        if client:
                            online_clients[acc_phone] = client
                    except Exception as e:
                        print(f"[Backend] âœ— è¨»å†Šç§ä¿¡è™•ç†å™¨å¤±æ•— ({acc_phone}): {e}", file=sys.stderr)
            
            # å•Ÿå‹•ç§ä¿¡è¼ªè©¢æœå‹™ï¼ˆé›™é‡ä¿éšªæ©Ÿåˆ¶ï¼‰
            if online_clients:
                try:
                    # ğŸ†• åŒ…è£ event_callback ä»¥æ”¯æŒ AI åœ˜éšŠç›®æ¨™ç”¨æˆ¶ç›£è¯
                    def wrapped_event_callback(event_name: str, payload: Any):
                        self.send_event(event_name, payload)
                        # å¦‚æœæ˜¯ç§ä¿¡äº‹ä»¶ï¼Œæª¢æŸ¥æ˜¯å¦ç‚º AI åœ˜éšŠç›®æ¨™ç”¨æˆ¶
                        if event_name == "private-message-received":
                            asyncio.create_task(self.handle_ai_team_customer_reply(payload))
                    
                    private_message_poller.event_callback = wrapped_event_callback
                    await private_message_poller.start_polling(online_clients)
                    self.send_log(f"ğŸ”„ ç§ä¿¡è¼ªè©¢æœå‹™å·²å•Ÿå‹•ï¼Œç›£æ§ {len(online_clients)} å€‹å¸³è™Ÿ", "success")
                except Exception as poller_err:
                    print(f"[Backend] âœ— å•Ÿå‹•ç§ä¿¡è¼ªè©¢æœå‹™å¤±æ•—: {poller_err}", file=sys.stderr)
                    self.send_log(f"ç§ä¿¡è¼ªè©¢æœå‹™å•Ÿå‹•å¤±æ•—: {poller_err}", "warning")
            
            # ğŸ”§ P0ä¿®å¾©: ç™¼é€ monitoring-started äº‹ä»¶
            self.send_event("monitoring-started", {
                "success": True,
                "message": success_message,
                "successfulAccounts": successful_starts,
                "failedAccounts": len(failed_accounts)
            })
            print(f"[Backend] âœ… ç›£æ§å•Ÿå‹•æˆåŠŸ: {success_message}", file=sys.stderr)
            return {"success": True, "message": success_message, "isMonitoring": True, "successfulAccounts": successful_starts}
        else:
            # æ‰€æœ‰è³¬æˆ¶éƒ½å¤±æ•—ï¼Œä¸è¨­ç½®ç›£æ§ç‹€æ…‹
            self.is_monitoring = False
            await db.set_monitoring_active(False)
            self.send_event("monitoring-status-changed", False)
            
            error_message = "ç›£æ§å•Ÿå‹•å¤±æ•—ï¼šæ‰€æœ‰ç›£è½è³¬æˆ¶éƒ½ç„¡æ³•å•Ÿå‹•ç›£æ§"
            if failed_accounts:
                error_message += f"ã€‚å¤±æ•—çš„è³¬æˆ¶ï¼š{', '.join(failed_accounts)}"
            
            self.send_event("monitoring-start-failed", {
                "reason": "all_accounts_failed",
                "message": error_message,
                "failed_accounts": failed_accounts
            })
            await db.add_log(error_message, "error")
            self.send_log(error_message, "error")
            print(f"[Backend] âŒ æ‰€æœ‰è³¬æˆ¶å•Ÿå‹•å¤±æ•—: {error_message}", file=sys.stderr)
            return {"success": False, "error": error_message, "reason": "all_accounts_failed", "isMonitoring": False}
    
    except Exception as e:
        # ç™¼ç”Ÿç•°å¸¸æ™‚ï¼Œç¢ºä¿ç›£æ§ç‹€æ…‹ç‚º False
        import traceback
        self.is_monitoring = False
        await db.set_monitoring_active(False)
        self.send_event("monitoring-status-changed", False)
        self.send_log(f"å•Ÿå‹•ç›£æ§æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}", "error")
        self.send_event("monitoring-start-failed", {
            "reason": "exception",
            "message": f"å•Ÿå‹•ç›£æ§æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}"
        })
        print(f"[Backend] âŒ å•Ÿå‹•ç›£æ§ç•°å¸¸: {str(e)}", file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        return {"success": False, "error": str(e), "reason": "exception", "isMonitoring": False}

async def handle_stop_monitoring(self):
    """Handle stop-monitoring command"""
    try:
        self.is_monitoring = False
        # Save monitoring state to database
        await db.set_monitoring_active(False)
        
        # Stop monitoring for all listener accounts (keeps connection, just removes handlers)
        accounts = await db.get_all_accounts()
        listener_accounts = [a for a in accounts if a.get('role') == 'Listener']
        
        stopped_count = 0
        for account in listener_accounts:
            phone = account.get('phone')
            try:
                # Use stop_monitoring to just remove handlers without disconnecting
                await self.telegram_manager.stop_monitoring(phone)
                stopped_count += 1
            except Exception as stop_error:
                self.send_log(f"åœæ­¢ç›£æ§æ™‚ç™¼ç”ŸéŒ¯èª¤ ({phone}): {str(stop_error)}", "warning")
        
        self.send_event("monitoring-status-changed", False)
        # ğŸ”§ P0ä¿®å¾©: ç™¼é€ monitoring-stopped äº‹ä»¶
        self.send_event("monitoring-stopped", {"success": True, "stoppedCount": stopped_count})
        await db.add_log(f"Monitoring stopped for {stopped_count} account(s)", "info")
        self.send_log(f"ç›£æ§å·²åœæ­¢ï¼š{stopped_count} å€‹è³¬æˆ¶", "info")
        print(f"[Backend] âœ… ç›£æ§å·²åœæ­¢: {stopped_count} å€‹è³¬æˆ¶", file=sys.stderr)
        return {"success": True, "message": f"ç›£æ§å·²åœæ­¢ï¼š{stopped_count} å€‹è³¬æˆ¶", "isMonitoring": False}
    
    except Exception as e:
        self.send_log(f"Error stopping monitoring: {str(e)}", "error")
        return {"success": False, "error": str(e), "isMonitoring": self.is_monitoring}

async def handle_one_click_start(self, payload: Dict[str, Any] = None):
    """
    ä¸€éµå•Ÿå‹• v3.0ï¼šä¸¦è¡Œå„ªåŒ–ç‰ˆæœ¬
    - ä¸¦è¡Œé€£æ¥å¸³è™Ÿï¼ˆæœ€å¤š 3 å€‹åŒæ™‚ï¼‰
    - ä¸¦è¡ŒåŠ å…¥ç¾¤çµ„ï¼ˆæœ€å¤š 5 å€‹åŒæ™‚ï¼‰
    - å„ªåŒ–çš„éŒ¯èª¤è™•ç†å’Œé€²åº¦é¡¯ç¤º
    """
    import sys
    import time as time_module
    
    start_time = time_module.time()
    print(f"[Backend] === ä¸€éµå•Ÿå‹• v3.0 é–‹å§‹ ===", file=sys.stderr)
    
    # ğŸ†• å•Ÿç”¨æ—¥èªŒæ‰¹é‡æ¨¡å¼ï¼Œæ¸›å°‘ IPC èª¿ç”¨
    self.start_log_batch_mode()
    
    results = {
        'accounts': {'success': 0, 'failed': 0, 'total': 0, 'details': []},
        'monitoring': {'success': False, 'message': '', 'groups': 0},
        'ai': {'success': False, 'message': ''},
        'overall_success': False,
        'timing': {}  # ğŸ†• æ·»åŠ æ™‚é–“çµ±è¨ˆ
    }
    
    try:
        # === æ­¥é©Ÿ 0: é æª¢æŸ¥ ===
        step_start = time_module.time()
        self.send_event("one-click-start-progress", {
            "step": "precheck",
            "message": "ğŸ” æ­£åœ¨é€²è¡Œé æª¢æŸ¥... (é è¨ˆ 1 ç§’)",
            "progress": 5,
            "estimated_seconds": 1
        })
        
        accounts = await db.get_all_accounts()
        results['accounts']['total'] = len(accounts)
        
        if not accounts:
            self.send_event("one-click-start-progress", {
                "step": "error",
                "message": "âŒ æ²’æœ‰é…ç½®ä»»ä½•å¸³è™Ÿ",
                "progress": 100
            })
            results['monitoring']['message'] = "æ²’æœ‰é…ç½®å¸³è™Ÿ"
            self.send_event("one-click-start-result", results)
            return
        
        # === æ­¥é©Ÿ 1: å¼·åˆ¶é©—è­‰ä¸¦é‡æ–°é€£æ¥æ‰€æœ‰å¸³è™Ÿ ===
        results['timing']['precheck'] = time_module.time() - step_start
        step_start = time_module.time()
        
        # é ä¼°æ™‚é–“ï¼šæ¯å€‹å¸³è™Ÿç´„ 2-5 ç§’ï¼Œä¸¦è¡Œè™•ç† 3 å€‹
        estimated_account_time = max(5, len(accounts) * 3 // 3)  # ä¸¦è¡Œå„ªåŒ–
        self.send_event("one-click-start-progress", {
            "step": "accounts",
            "message": f"ğŸ”‘ æ­£åœ¨ä¸¦è¡Œé€£æ¥ {len(accounts)} å€‹å¸³è™Ÿ... (é è¨ˆ {estimated_account_time} ç§’)",
            "progress": 10,
            "estimated_seconds": estimated_account_time
        })
        
        # ğŸ†• å„ªåŒ–ï¼šå®šç¾©å–®å€‹å¸³è™Ÿé€£æ¥å‡½æ•¸
        async def connect_single_account(account: dict) -> dict:
            """é€£æ¥å–®å€‹å¸³è™Ÿï¼Œè¿”å›çµæœ"""
            phone = account.get('phone')
            account_id = account.get('id')
            api_id = account.get('apiId')
            api_hash = account.get('apiHash')
            
            account_result = {
                'phone': phone,
                'success': False,
                'message': ''
            }
            
            try:
                if not api_id or not api_hash:
                    account_result['message'] = "æœªé…ç½® API"
                    return account_result
                
                # æª¢æŸ¥å¯¦éš›å®¢æˆ¶ç«¯ç‹€æ…‹
                client = self.telegram_manager.get_client(phone)
                is_actually_connected = False
                
                if client:
                    try:
                        is_actually_connected = client.is_connected
                    except:
                        is_actually_connected = False
                
                # å¦‚æœå®¢æˆ¶ç«¯ä¸å­˜åœ¨æˆ–æœªé€£æ¥ï¼Œå¼·åˆ¶é‡æ–°ç™»å…¥
                if not client or not is_actually_connected:
                    login_result = await self.telegram_manager.login_account(
                        phone=phone,
                        api_id=api_id,
                        api_hash=api_hash
                    )
                    
                    if login_result.get('success') or login_result.get('status') == 'Online':
                        try:
                            client = self.telegram_manager.get_client(phone)
                            if client and client.is_connected:
                                me = await client.get_me()
                                if me:
                                    account_result['success'] = True
                                    account_result['message'] = f"å·²é€£æ¥ (@{me.username or me.first_name})"
                                    await db.update_account(account_id, {"status": "Online"})
                                else:
                                    raise Exception("get_me() è¿”å›ç©º")
                            else:
                                raise Exception("å®¢æˆ¶ç«¯æœªæ­£ç¢ºé€£æ¥")
                        except Exception as verify_err:
                            account_result['message'] = f"é©—è­‰å¤±æ•—: {verify_err}"
                            await db.update_account(account_id, {"status": "Offline"})
                    else:
                        if login_result.get('status') == 'Code Required':
                            account_result['message'] = "éœ€è¦é©—è­‰ç¢¼"
                        else:
                            account_result['message'] = login_result.get('error', 'ç™»å…¥å¤±æ•—')
                        await db.update_account(account_id, {"status": "Offline"})
                else:
                    # å®¢æˆ¶ç«¯å·²é€£æ¥ï¼Œé©—è­‰æœƒè©±
                    try:
                        me = await client.get_me()
                        if me:
                            account_result['success'] = True
                            account_result['message'] = f"å·²åœ¨ç·š (@{me.username or me.first_name})"
                        else:
                            raise Exception("æœƒè©±ç„¡æ•ˆ")
                    except Exception:
                        try:
                            await client.disconnect()
                        except:
                            pass
                        
                        login_result = await self.telegram_manager.login_account(
                            phone=phone, api_id=api_id, api_hash=api_hash
                        )
                        
                        if login_result.get('success') or login_result.get('status') == 'Online':
                            account_result['success'] = True
                            account_result['message'] = "é‡æ–°é€£æ¥æˆåŠŸ"
                            await db.update_account(account_id, {"status": "Online"})
                        else:
                            account_result['message'] = "é‡é€£å¤±æ•—"
                            await db.update_account(account_id, {"status": "Offline"})
                
            except Exception as acc_err:
                account_result['message'] = str(acc_err)
                try:
                    await db.update_account(account_id, {"status": "Offline"})
                except:
                    pass
            
            return account_result
        
        # ğŸ†• ä¸¦è¡Œé€£æ¥å¸³è™Ÿï¼ˆé™åˆ¶ä¸¦ç™¼æ•¸ç‚º 3ï¼Œé¿å…éè¼‰ï¼‰
        semaphore = asyncio.Semaphore(3)
        completed_count = 0
        
        async def connect_with_progress(account: dict) -> dict:
            nonlocal completed_count
            async with semaphore:
                result = await connect_single_account(account)
                completed_count += 1
                
                # æ›´æ–°é€²åº¦
                progress = 10 + int(completed_count / len(accounts) * 25)
                status_icon = "âœ“" if result['success'] else "âœ—"
                self.send_event("one-click-start-progress", {
                    "step": "account_connecting",
                    "message": f"ğŸ”‘ {status_icon} {result['phone']} ({completed_count}/{len(accounts)})",
                    "progress": progress
                })
                
                log_type = "success" if result['success'] else "warning"
                self.send_log(f"{status_icon} {result['phone']}: {result['message']}", log_type)
                
                return result
        
        print(f"[Backend] Connecting {len(accounts)} accounts in parallel (max 3 concurrent)...", file=sys.stderr)
        
        # ä½¿ç”¨ gather ä¸¦è¡Œé€£æ¥
        tasks = [connect_with_progress(acc) for acc in accounts]
        account_results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # è™•ç†çµæœ
        for i, result in enumerate(account_results):
            if isinstance(result, Exception):
                result = {
                    'phone': accounts[i].get('phone'),
                    'success': False,
                    'message': str(result)
                }
            
            if result.get('success'):
                results['accounts']['success'] += 1
            else:
                results['accounts']['failed'] += 1
            
            results['accounts']['details'].append(result)
        
        results['timing']['accounts'] = time_module.time() - step_start
        self.send_event("one-click-start-progress", {
            "step": "accounts_done",
            "message": f"âœ… å¸³è™Ÿé€£æ¥: {results['accounts']['success']}/{results['accounts']['total']} (ç”¨æ™‚ {results['timing']['accounts']:.1f}ç§’)",
            "progress": 40,
            "elapsed_seconds": results['timing']['accounts']
        })
        
        # å¦‚æœæ²’æœ‰æˆåŠŸé€£æ¥çš„å¸³è™Ÿï¼Œåœæ­¢
        if results['accounts']['success'] == 0:
            self.send_event("one-click-start-progress", {
                "step": "error",
                "message": "âŒ æ²’æœ‰æˆåŠŸé€£æ¥çš„å¸³è™Ÿï¼Œç„¡æ³•å•Ÿå‹•ç›£æ§",
                "progress": 100
            })
            results['monitoring']['message'] = "æ²’æœ‰å¯ç”¨å¸³è™Ÿ"
            self.send_event("one-click-start-result", results)
            return
        
        # === æ­¥é©Ÿ 1.5: è‡ªå‹•åŠ å…¥ç¾¤çµ„ ===
        step_start = time_module.time()
        
        results['groups'] = {
            'success': [],
            'pending': [],
            'failed': []
        }
        
        try:
            groups = await db.get_all_groups()
            if groups:
                # é ä¼°æ™‚é–“ï¼šä¸¦è¡Œè™•ç†ï¼Œæ¯ 5 å€‹ç¾¤çµ„ç´„ 3 ç§’
                estimated_group_time = max(3, len(groups) * 2 // 5)
                self.send_event("one-click-start-progress", {
                    "step": "groups",
                    "message": f"ğŸ‘¥ æ­£åœ¨ä¸¦è¡Œæª¢æŸ¥ {len(groups)} å€‹ç¾¤çµ„... (é è¨ˆ {estimated_group_time} ç§’)",
                    "progress": 42,
                    "estimated_seconds": estimated_group_time
                })
                # æ‰¾åˆ°ä¸€å€‹å¯ç”¨çš„ç›£æ§å¸³è™Ÿ
                listener_account = None
                for acc in results['accounts']['details']:
                    if acc.get('success'):
                        listener_account = acc.get('phone')
                        break
                
                if listener_account:
                    client = self.telegram_manager.get_client(listener_account)
                    if client and client.is_connected:
                        # è¨­ç½®äº‹ä»¶å›èª¿
                        group_join_service.event_callback = self.send_event
                        
                        # æ‰¹é‡åŠ å…¥ç¾¤çµ„
                        group_urls = [g.get('url') for g in groups if g.get('url')]
                        self.send_log(f"ğŸ”„ æª¢æŸ¥ {len(group_urls)} å€‹ç¾¤çµ„...", "info")
                        
                        join_report = await group_join_service.join_multiple_groups(
                            client=client,
                            group_urls=group_urls,
                            delay_between=1.5,
                            auto_verify=True
                        )
                        
                        results['groups']['success'] = join_report['success']
                        results['groups']['pending'] = join_report['pending']
                        results['groups']['failed'] = join_report['failed']
                        
                        # é¡¯ç¤ºè©³ç´°çµæœ
                        success_count = len(join_report['success'])
                        pending_count = len(join_report['pending'])
                        failed_count = len(join_report['failed'])
                        
                        if success_count > 0:
                            self.send_log(f"âœ“ æˆåŠŸåŠ å…¥/å·²åœ¨ {success_count} å€‹ç¾¤çµ„", "success")
                        if pending_count > 0:
                            self.send_log(f"â³ {pending_count} å€‹ç¾¤çµ„ç­‰å¾…å¯©æ‰¹", "info")
                        if failed_count > 0:
                            for fail in join_report['failed']:
                                self.send_log(f"âœ— {fail['url']}: {fail['error']}", "warning")
                    else:
                        self.send_log("âš  æ²’æœ‰å¯ç”¨å®¢æˆ¶ç«¯æª¢æŸ¥ç¾¤çµ„", "warning")
                else:
                    self.send_log("âš  æ²’æœ‰å¯ç”¨å¸³è™Ÿæª¢æŸ¥ç¾¤çµ„", "warning")
            else:
                self.send_log("â„¹ æ²’æœ‰é…ç½®ç›£æ§ç¾¤çµ„", "info")
        except Exception as group_err:
            self.send_log(f"ç¾¤çµ„æª¢æŸ¥éŒ¯èª¤: {group_err}", "warning")
        
        results['timing']['groups'] = time_module.time() - step_start
        self.send_event("one-click-start-progress", {
            "step": "groups_done",
            "message": f"âœ… ç¾¤çµ„æª¢æŸ¥å®Œæˆ: {len(results['groups']['success'])} å€‹å¯ç”¨ (ç”¨æ™‚ {results['timing']['groups']:.1f}ç§’)",
            "progress": 48,
            "elapsed_seconds": results['timing']['groups']
        })
        
        # === æ­¥é©Ÿ 1.8: æª¢æŸ¥æ´»å‹•ï¼ˆCampaignsï¼‰é…ç½® ===
        self.send_event("one-click-start-progress", {
            "step": "campaigns_check",
            "message": "ğŸ“‹ æ­£åœ¨æª¢æŸ¥æ´»å‹•é…ç½®...",
            "progress": 49
        })
        
        # === æ­¥é©Ÿ 1.8: æª¢æŸ¥éŸ¿æ‡‰é…ç½®ï¼ˆè§¸ç™¼è¦å‰‡ + AI èŠå¤©ï¼‰===
        results['response_config'] = {
            'trigger_rules': {'total': 0, 'active': 0},
            'ai_chat': {'enabled': False, 'mode': 'semi'},
            'campaigns': {'total': 0, 'active': 0},
            'warnings': [],
            'valid': False,
            'source': None  # 'trigger_rules' | 'ai_chat' | 'campaigns' | None
        }
        
        try:
            # 1. æª¢æŸ¥è§¸ç™¼è¦å‰‡
            trigger_rules = await db.get_all_trigger_rules()
            active_rules = [r for r in trigger_rules if r.get('is_active', False)]
            results['response_config']['trigger_rules'] = {
                'total': len(trigger_rules),
                'active': len(active_rules)
            }
            
            # 2. æª¢æŸ¥ AI è‡ªå‹•èŠå¤©è¨­ç½®
            ai_settings = await db.get_ai_settings()
            ai_enabled = ai_settings.get('auto_chat_enabled', 0) == 1 if ai_settings else False
            ai_mode = ai_settings.get('auto_chat_mode', 'semi') if ai_settings else 'semi'
            results['response_config']['ai_chat'] = {
                'enabled': ai_enabled,
                'mode': ai_mode
            }
            
            # 3. æª¢æŸ¥èˆŠç‰ˆ Campaignï¼ˆå‘å¾Œå…¼å®¹ï¼‰
            campaigns = await db.get_all_campaigns()
            active_campaigns = [c for c in campaigns if c.get('isActive') or c.get('is_active')]
            results['response_config']['campaigns'] = {
                'total': len(campaigns),
                'active': len(active_campaigns)
            }
            
            # åˆ¤æ–·éŸ¿æ‡‰é…ç½®æ˜¯å¦æœ‰æ•ˆï¼ˆä»»ä¸€é …æ»¿è¶³å³å¯ï¼‰
            if len(active_rules) > 0:
                results['response_config']['valid'] = True
                results['response_config']['source'] = 'trigger_rules'
                self.send_log(f"âœ“ éŸ¿æ‡‰é…ç½®: {len(active_rules)} æ¢è§¸ç™¼è¦å‰‡æ´»èº", "success")
            elif ai_enabled:
                results['response_config']['valid'] = True
                results['response_config']['source'] = 'ai_chat'
                mode_text = 'å…¨è‡ªå‹•' if ai_mode == 'full' else 'åŠè‡ªå‹•'
                self.send_log(f"âœ“ éŸ¿æ‡‰é…ç½®: AI è‡ªå‹•èŠå¤©å·²å•Ÿç”¨ï¼ˆ{mode_text}æ¨¡å¼ï¼‰", "success")
            elif len(active_campaigns) > 0:
                results['response_config']['valid'] = True
                results['response_config']['source'] = 'campaigns'
                self.send_log(f"âœ“ éŸ¿æ‡‰é…ç½®: {len(active_campaigns)} å€‹æ´»å‹•é…ç½®", "success")
            else:
                results['response_config']['warnings'].append("âš ï¸ æœªé…ç½®éŸ¿æ‡‰æ–¹å¼ï¼ˆè§¸ç™¼è¦å‰‡/AIèŠå¤©/æ´»å‹•ï¼‰")
                self.send_log("âš  æœªé…ç½®éŸ¿æ‡‰æ–¹å¼ï¼ŒåŒ¹é…çš„æ¶ˆæ¯å°‡åªè¨˜éŒ„ä¸å›è¦†", "warning")
                self.send_log("ğŸ’¡ å»ºè­°ï¼šå‰å¾€ã€Œè§¸ç™¼è¦å‰‡ã€é é¢é…ç½®ï¼Œæˆ–å•Ÿç”¨ AI è‡ªå‹•èŠå¤©", "info")
            
        except Exception as resp_err:
            results['response_config']['warnings'].append(f"æª¢æŸ¥éŸ¿æ‡‰é…ç½®æ™‚å‡ºéŒ¯: {resp_err}")
            self.send_log(f"âš  éŸ¿æ‡‰é…ç½®æª¢æŸ¥éŒ¯èª¤: {resp_err}", "warning")
        
        # å‘å¾Œå…¼å®¹ï¼šä¿ç•™ campaigns å­—æ®µï¼ˆåˆä½µè§¸ç™¼è¦å‰‡å’ŒèˆŠç‰ˆæ´»å‹•ï¼‰
        trigger_total = results['response_config']['trigger_rules']['total']
        trigger_active = results['response_config']['trigger_rules']['active']
        campaign_total = results['response_config']['campaigns']['total']
        campaign_active = results['response_config']['campaigns']['active']
        
        results['campaigns'] = {
            'total': trigger_total + campaign_total,
            'active': trigger_active + campaign_active,
            'warnings': results['response_config']['warnings'],
            'valid': results['response_config']['valid']
        }
        
        # === æ­¥é©Ÿ 2: å•Ÿç”¨ AI è‡ªå‹•èŠå¤©ï¼ˆå…ˆæ–¼ç›£æ§ï¼Œè®“é…ç½®æª¢æŸ¥èƒ½çœ‹åˆ° AI ç‹€æ…‹ï¼‰===
        self.send_event("one-click-start-progress", {
            "step": "ai",
            "message": "ğŸ¤– æ­£åœ¨å•Ÿç”¨ AI...",
            "progress": 50
        })
        
        try:
            # æ›´æ–°ç‚ºå•Ÿç”¨ç‹€æ…‹å’Œå…¨è‡ªå‹•æ¨¡å¼
            await db.update_ai_settings({
                'auto_chat_enabled': 1,
                'auto_chat_mode': 'full',
                'auto_greeting': 1
            })
            
            # é‡æ–°è¼‰å…¥ AI è¨­ç½®åˆ°å…§å­˜
            await ai_auto_chat.initialize()
            
            # æª¢æŸ¥ AI ç«¯é»æ˜¯å¦å·²é…ç½®
            ai_endpoint = ai_auto_chat.local_ai_endpoint
            if ai_endpoint:
                self.send_log(f"âœ“ AI ç«¯é»: {ai_endpoint}", "success")
            else:
                self.send_log("âš  AI ç«¯é»æœªé…ç½®ï¼Œå°‡ä½¿ç”¨å‚™ç”¨å›è¦†", "warning")
            
            results['ai']['success'] = True
            results['ai']['message'] = f"AI å…¨è‡ªå‹•æ¨¡å¼å·²å•Ÿç”¨" + (f" (ç«¯é»: {ai_endpoint[:30]}...)" if ai_endpoint else " (å‚™ç”¨å›è¦†)")
            self.send_log("âœ“ AI è‡ªå‹•èŠå¤©å·²å•Ÿç”¨ (å…¨è‡ªå‹•æ¨¡å¼)", "success")
            
            # ç™¼é€ AI è¨­ç½®æ›´æ–°äº‹ä»¶
            self.send_event("ai-settings-updated", {
                'auto_chat_enabled': True,
                'auto_chat_mode': 'full',
                'auto_greeting': True
            })
        except Exception as ai_err:
            results['ai']['message'] = str(ai_err)
            self.send_log(f"âœ— AI å•Ÿç”¨éŒ¯èª¤: {ai_err}", "error")
        
        self.send_event("one-click-start-progress", {
            "step": "ai_done",
            "message": f"{'âœ…' if results['ai']['success'] else 'âŒ'} {results['ai']['message']}",
            "progress": 60
        })
        
        # === æ­¥é©Ÿ 3: å•Ÿå‹•ç›£æ§ï¼ˆåœ¨ AI å•Ÿç”¨ä¹‹å¾Œï¼Œé…ç½®æª¢æŸ¥èƒ½æ­£ç¢ºé¡¯ç¤º AI ç‹€æ…‹ï¼‰===
        self.send_event("one-click-start-progress", {
            "step": "monitoring",
            "message": "ğŸ“¡ æ­£åœ¨å•Ÿå‹•ç›£æ§...",
            "progress": 65
        })
        
        try:
            await self.handle_start_monitoring()
            if self.is_monitoring:
                results['monitoring']['success'] = True
                results['monitoring']['message'] = "ç›£æ§å·²å•Ÿå‹•"
                
                # çµ±è¨ˆç›£æ§çš„ç¾¤çµ„æ•¸
                groups = await db.get_all_groups()
                results['monitoring']['groups'] = len(groups)
            else:
                results['monitoring']['message'] = "ç›£æ§å•Ÿå‹•å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¾¤çµ„é…ç½®"
        except Exception as mon_err:
            results['monitoring']['message'] = str(mon_err)
            self.send_log(f"âœ— ç›£æ§å•Ÿå‹•éŒ¯èª¤: {mon_err}", "error")
        
        self.send_event("one-click-start-progress", {
            "step": "monitoring_done",
            "message": f"{'âœ…' if results['monitoring']['success'] else 'âš ï¸'} {results['monitoring']['message']}",
            "progress": 80
        })
        
        # === æ­¥é©Ÿ 4: å•Ÿå‹•ç§ä¿¡è¼ªè©¢ ===
        self.send_event("one-click-start-progress", {
            "step": "poller",
            "message": "ğŸ“¬ æ­£åœ¨å•Ÿå‹•ç§ä¿¡è¼ªè©¢...",
            "progress": 90
        })
        
        try:
            # æ”¶é›†æ‰€æœ‰åœ¨ç·šå®¢æˆ¶ç«¯
            online_clients = {}
            for acc in results['accounts']['details']:
                if acc.get('success'):
                    phone = acc.get('phone')
                    client = self.telegram_manager.get_client(phone)
                    if client and client.is_connected:
                        online_clients[phone] = client
            
            if online_clients:
                # ğŸ†• åŒ…è£ event_callback ä»¥æ”¯æŒ AI åœ˜éšŠç›®æ¨™ç”¨æˆ¶ç›£è½
                def wrapped_event_callback_v2(event_name: str, payload: Any):
                    self.send_event(event_name, payload)
                    if event_name == "private-message-received":
                        asyncio.create_task(self.handle_ai_team_customer_reply(payload))
                
                private_message_poller.event_callback = wrapped_event_callback_v2
                await private_message_poller.start_polling(online_clients)
                self.send_log(f"âœ“ ç§ä¿¡è¼ªè©¢å·²å•Ÿå‹•ï¼Œç›£æ§ {len(online_clients)} å€‹å¸³è™Ÿ", "success")
            else:
                self.send_log("âš  æ²’æœ‰å¯ç”¨çš„å®¢æˆ¶ç«¯ç”¨æ–¼ç§ä¿¡è¼ªè©¢", "warning")
        except Exception as poller_err:
            self.send_log(f"âœ— ç§ä¿¡è¼ªè©¢å•Ÿå‹•éŒ¯èª¤: {poller_err}", "warning")
        
        # === æ­¥é©Ÿ 5: å•Ÿå‹•é€£æ¥ç›£æ§ ===
        self.send_event("one-click-start-progress", {
            "step": "connection_monitor",
            "message": "ğŸ”„ æ­£åœ¨å•Ÿå‹•é€£æ¥ç›£æ§...",
            "progress": 95
        })
        
        try:
            connection_monitor.set_telegram_manager(self.telegram_manager)
            connection_monitor.event_callback = self.send_event
            await connection_monitor.start(check_interval=60)
            self.send_log("âœ“ é€£æ¥ç›£æ§å·²å•Ÿå‹•ï¼ˆæ¯60ç§’æª¢æŸ¥ï¼‰", "success")
        except Exception as monitor_err:
            self.send_log(f"âš  é€£æ¥ç›£æ§å•Ÿå‹•éŒ¯èª¤: {monitor_err}", "warning")
        
        # === æ­¥é©Ÿ 6: å•Ÿå‹•æ¼æ–—è‡ªå‹•æµè½‰ ===
        self.send_event("one-click-start-progress", {
            "step": "funnel",
            "message": "ğŸ¯ æ­£åœ¨å•Ÿå‹•æ¼æ–—è‡ªå‹•æµè½‰...",
            "progress": 97
        })
        
        results['funnel'] = {
            'success': False,
            'message': ''
        }
        
        try:
            # è¨­ç½®æ¼æ–—ç®¡ç†å™¨å›èª¿
            async def funnel_send_callback(target_user_id: str, message: str, **kwargs):
                """æ¼æ–—è‡ªå‹•è·Ÿé€²ç™¼é€å›èª¿"""
                # ç²å–ä»»ä¸€åœ¨ç·šå¸³è™Ÿ
                for acc in results['accounts']['details']:
                    if acc.get('success'):
                        phone = acc.get('phone')
                        client = self.telegram_manager.get_client(phone)
                        if client and client.is_connected:
                            try:
                                await client.send_message(int(target_user_id), message)
                                self.send_log(f"[AutoFunnel] å·²ç™¼é€è·Ÿé€²æ¶ˆæ¯çµ¦ {target_user_id}", "info")
                                return True
                            except Exception as send_err:
                                self.send_log(f"[AutoFunnel] ç™¼é€å¤±æ•—: {send_err}", "warning")
                return False
            
            auto_funnel.set_callbacks(
                send_callback=funnel_send_callback,
                log_callback=self.send_log,
                event_callback=self.send_event
            )
            
            # ç¢ºä¿æ¼æ–—ç®¡ç†å™¨å·²å•Ÿå‹•
            if not auto_funnel.is_running:
                await auto_funnel.start()
            
            results['funnel']['success'] = True
            results['funnel']['message'] = "æ¼æ–—è‡ªå‹•æµè½‰å·²å•Ÿç”¨"
            self.send_log("âœ“ æ¼æ–—è‡ªå‹•æµè½‰å·²å•Ÿå‹•ï¼ˆæ¯30åˆ†é˜æª¢æŸ¥è·Ÿé€²ï¼‰", "success")
            
        except Exception as funnel_err:
            results['funnel']['message'] = str(funnel_err)
            self.send_log(f"âš  æ¼æ–—ç®¡ç†å™¨å•Ÿå‹•éŒ¯èª¤: {funnel_err}", "warning")
        
        # === æ­¥é©Ÿ 7: ç”Ÿæˆè¨ºæ–·å ±å‘Š ===
        self.send_event("one-click-start-progress", {
            "step": "diagnosis",
            "message": "ğŸ“Š æ­£åœ¨ç”Ÿæˆè¨ºæ–·å ±å‘Š...",
            "progress": 98
        })
        
        # æ·»åŠ è¨ºæ–·ä¿¡æ¯åˆ°çµæœ
        results['diagnosis'] = {
            'issues': [],
            'recommendations': [],
            'readiness_score': 0
        }
        
        try:
            # è¨ˆç®—æº–å‚™åº¦åˆ†æ•¸
            score = 0
            max_score = 5
            
            # 1. å¸³è™Ÿæª¢æŸ¥ (1åˆ†)
            if results['accounts']['success'] > 0:
                score += 1
            else:
                results['diagnosis']['issues'].append("æ²’æœ‰å¯ç”¨çš„åœ¨ç·šå¸³è™Ÿ")
                results['diagnosis']['recommendations'].append({
                    "action": "accounts",
                    "text": "å‰å¾€å¸³è™Ÿç®¡ç†é é¢æ·»åŠ ä¸¦ç™»å…¥ Telegram å¸³è™Ÿ"
                })
            
            # 2. ç›£æ§æª¢æŸ¥ (1åˆ†)
            if results['monitoring']['success']:
                score += 1
            else:
                results['diagnosis']['issues'].append("ç›£æ§æœå‹™æœªå•Ÿå‹•")
                results['diagnosis']['recommendations'].append({
                    "action": "groups",
                    "text": "ç¢ºä¿å·²é…ç½®ç›£æ§ç¾¤çµ„ï¼Œä¸¦æª¢æŸ¥å¸³è™Ÿæ˜¯å¦å·²åŠ å…¥é€™äº›ç¾¤çµ„"
                })
            
            # 3. AI æª¢æŸ¥ (1åˆ†)
            if results['ai']['success']:
                score += 1
            
            # 4. æ´»å‹•é…ç½®æª¢æŸ¥ (1åˆ†)
            if results['campaigns']['active'] > 0 and not results['campaigns']['warnings']:
                score += 1
            elif results['campaigns']['active'] == 0:
                results['diagnosis']['issues'].append("æ²’æœ‰é…ç½®è§¸ç™¼è¦å‰‡")
                results['diagnosis']['recommendations'].append({
                    "action": "trigger-rules",
                    "text": "åœ¨ã€Œè§¸ç™¼è¦å‰‡ã€é é¢å‰µå»ºè¦å‰‡ï¼Œè¨­ç½®è§¸ç™¼æ¢ä»¶å’ŒéŸ¿æ‡‰å‹•ä½œ"
                })
            elif results['campaigns']['warnings']:
                results['diagnosis']['issues'].append("æ´»å‹•é…ç½®ä¸å®Œæ•´")
            
            # 5. é—œéµè©æª¢æŸ¥ (1åˆ†)
            keyword_sets = await db.get_all_keyword_sets()
            if keyword_sets and any(ks.get('keywords', []) for ks in keyword_sets):
                score += 1
            else:
                results['diagnosis']['issues'].append("æ²’æœ‰é…ç½®é—œéµè©")
                results['diagnosis']['recommendations'].append({
                    "action": "keywords",
                    "text": "åœ¨é—œéµè©ç®¡ç†ä¸­å‰µå»ºé—œéµè©é›†ï¼Œç”¨æ–¼åŒ¹é…ç¾¤çµ„æ¶ˆæ¯"
                })
            
            results['diagnosis']['readiness_score'] = int((score / max_score) * 100)
            
            # æ ¹æ“šåˆ†æ•¸çµ¦å‡ºç¸½é«”å»ºè­°
            if score == max_score:
                results['diagnosis']['summary'] = "ç³»çµ±é…ç½®å®Œç¾ï¼æ‰€æœ‰åŠŸèƒ½å·²å°±ç·’ã€‚"
            elif score >= 4:
                results['diagnosis']['summary'] = "ç³»çµ±åŸºæœ¬å°±ç·’ï¼Œå»ºè­°å®Œå–„å‰©é¤˜é…ç½®ã€‚"
            elif score >= 2:
                results['diagnosis']['summary'] = "éœ€è¦å®Œæˆæ›´å¤šé…ç½®æ‰èƒ½æ­£å¸¸é‹è¡Œã€‚"
            else:
                results['diagnosis']['summary'] = "é…ç½®ä¸å®Œæ•´ï¼Œè«‹æŒ‰å»ºè­°æ­¥é©Ÿå®Œæˆé…ç½®ã€‚"
                
        except Exception as diag_err:
            print(f"[Backend] è¨ºæ–·å ±å‘Šç”ŸæˆéŒ¯èª¤: {diag_err}", file=sys.stderr)
        
        # === å®Œæˆ ===
        results['overall_success'] = (
            results['accounts']['success'] > 0 and
            results['monitoring']['success'] and
            results['ai']['success']
        )
        
        # ğŸ†• è¨ˆç®—ç¸½æ™‚é–“
        total_time = time_module.time() - start_time
        results['timing']['total'] = total_time
        
        # ğŸ†• åœæ­¢æ—¥èªŒæ‰¹é‡æ¨¡å¼ï¼Œåˆ·æ–°æ‰€æœ‰ç·©è¡æ—¥èªŒ
        self.stop_log_batch_mode()
        
        self.send_event("one-click-start-progress", {
            "step": "complete",
            "message": f"ğŸ‰ ä¸€éµå•Ÿå‹•å®Œæˆï¼(ç¸½ç”¨æ™‚ {total_time:.1f} ç§’)" if results['overall_success'] else f"âš ï¸ éƒ¨åˆ†åŠŸèƒ½å•Ÿå‹•å¤±æ•— (ç”¨æ™‚ {total_time:.1f} ç§’)",
            "progress": 100,
            "elapsed_seconds": total_time
        })
        
        self.send_event("one-click-start-result", results)
        
        # ğŸ”§ é—œéµä¿®å¾©ï¼šä¸€éµå•Ÿå‹•å®Œæˆå¾Œç™¼é€ accounts-updated æ›´æ–°å‰ç«¯ç‹€æ…‹
        await self._send_accounts_updated()
        
        # ğŸ”§ P0 ä¿®å¾©ï¼šç¢ºä¿ç™¼é€ monitoring-status-changed äº‹ä»¶åŒæ­¥å‰ç«¯ç‹€æ…‹
        self.send_event("monitoring-status-changed", self.is_monitoring)
        print(f"[Backend] Sent monitoring-status-changed: {self.is_monitoring}", file=sys.stderr)
        
        print(f"[Backend] Sent accounts-updated after one-click start completion in {total_time:.1f}s", file=sys.stderr)
        
        summary = f"ä¸€éµå•Ÿå‹•å®Œæˆ ({total_time:.1f}ç§’) - å¸³è™Ÿ: {results['accounts']['success']}/{results['accounts']['total']}, "
        summary += f"ç›£æ§: {'âœ“' if results['monitoring']['success'] else 'âœ—'}, "
        summary += f"AI: {'âœ“' if results['ai']['success'] else 'âœ—'}"
        
        await db.add_log(summary, "success" if results['overall_success'] else "warning")
        self.send_log(summary, "success" if results['overall_success'] else "warning")
        
    except Exception as e:
        print(f"[Backend] ä¸€éµå•Ÿå‹•éŒ¯èª¤: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
        
        self.send_event("one-click-start-result", {
            **results,
            'error': str(e),
            'overall_success': False
        })
        self.send_log(f"ä¸€éµå•Ÿå‹•å¤±æ•—: {e}", "error")

async def handle_one_click_stop(self):
    """
    ä¸€éµåœæ­¢ï¼šåœæ­¢ç›£æ§ â†’ é—œé–‰ AI
    """
    import sys
    print(f"[Backend] === ä¸€éµåœæ­¢é–‹å§‹ ===", file=sys.stderr)
    
    try:
        # åœæ­¢é€£æ¥ç›£æ§
        try:
            await connection_monitor.stop()
        except:
            pass
        
        # åœæ­¢ç§ä¿¡è¼ªè©¢
        try:
            await private_message_poller.stop_polling()
        except:
            pass
        
        # åœæ­¢ç›£æ§
        await self.handle_stop_monitoring()
        
        # é—œé–‰ AI è‡ªå‹•èŠå¤©
        await db.update_ai_settings({
            'auto_chat_enabled': 0
        })
        
        self.send_event("ai-settings-updated", {
            'auto_chat_enabled': False
        })
        
        self.send_event("one-click-stop-result", {
            'success': True,
            'message': "æ‰€æœ‰æœå‹™å·²åœæ­¢"
        })
        
        # åœæ­¢æ¼æ–—ç®¡ç†å™¨
        try:
            await auto_funnel.stop()
        except:
            pass
        
        self.send_log("ğŸ›‘ ä¸€éµåœæ­¢å®Œæˆï¼šç›£æ§å·²åœæ­¢ï¼ŒAI å·²é—œé–‰ï¼Œé€£æ¥ç›£æ§å·²åœæ­¢ï¼Œæ¼æ–—ç®¡ç†å·²åœæ­¢", "info")
        
    except Exception as e:
        self.send_log(f"ä¸€éµåœæ­¢éŒ¯èª¤: {e}", "error")
        self.send_event("one-click-stop-result", {
            'success': False,
            'error': str(e)
        })

async def handle_get_system_status(self):
    """
    ç²å–ç³»çµ±ç‹€æ…‹ï¼šå¸³è™Ÿã€ç›£æ§ã€AI ç­‰
    """
    try:
        # ç²å–å¸³è™Ÿç‹€æ…‹
        accounts = await db.get_all_accounts()
        online_count = sum(1 for a in accounts if a.get('status') == 'Online')
        
        # ç²å–é—œéµè©é›†
        keyword_sets = await db.get_all_keyword_sets()
        
        # ç²å–ç¾¤çµ„
        groups = await db.get_all_groups()
        
        # ç²å–æ´»å‹•ï¼ˆèˆŠç‰ˆ Campaignsï¼‰
        campaigns = await db.get_all_campaigns()
        active_campaigns = sum(1 for c in campaigns if c.get('isActive') or c.get('is_active'))
        
        # ç²å–è§¸ç™¼è¦å‰‡ï¼ˆæ–°ç³»çµ±ï¼‰
        trigger_rules = await db.get_all_trigger_rules()
        active_rules = sum(1 for r in trigger_rules if r.get('is_active') or r.get('isActive'))
        
        # åˆä½µï¼šç¸½æ•¸ = campaigns + trigger_rules
        total_rules = len(campaigns) + len(trigger_rules)
        active_total = active_campaigns + active_rules
        
        # ç²å– AI è¨­ç½®
        ai_settings = await db.get_ai_settings()
        ai_enabled = ai_settings.get('auto_chat_enabled', 0) == 1 if ai_settings else False
        ai_mode = ai_settings.get('auto_chat_mode', 'semi') if ai_settings else 'semi'
        
        # ç²å–æ¨¡æ¿
        templates = await db.get_all_templates()
        active_templates = sum(1 for t in templates if t.get('isActive'))
        
        status = {
            'accounts': {
                'total': len(accounts),
                'online': online_count,
                'offline': len(accounts) - online_count
            },
            'monitoring': {
                'active': self.is_monitoring,
                'groups': len(groups)
            },
            'ai': {
                'enabled': ai_enabled,
                'mode': ai_mode,
                'endpoint': ai_settings.get('local_ai_endpoint', '') if ai_settings else ''
            },
            'keywords': {
                'sets': len(keyword_sets),
                'total': sum(len(ks.get('keywords', [])) for ks in keyword_sets)
            },
            'campaigns': {
                'total': total_rules,  # åŒ…å« Campaigns + è§¸ç™¼è¦å‰‡
                'active': active_total   # åŒ…å«æ´»èºçš„ Campaigns + è§¸ç™¼è¦å‰‡
            },
            'triggerRules': {
                'total': len(trigger_rules),
                'active': active_rules
            },
            'templates': {
                'total': len(templates),
                'active': active_templates
            },
            'poller': {
                'running': private_message_poller._running if hasattr(private_message_poller, '_running') else False
            }
        }
        
        self.send_event("system-status", status)
        
    except Exception as e:
        import sys
        print(f"[Backend] ç²å–ç³»çµ±ç‹€æ…‹éŒ¯èª¤: {e}", file=sys.stderr)
        self.send_event("system-status", {'error': str(e)})

async def handle_get_monitored_groups(self):
    """ç²å–æ‰€æœ‰ç›£æ§ç¾¤çµ„åˆ—è¡¨ï¼ˆé™„å¸¶å¥åº·ç‹€æ…‹ï¼‰"""
    try:
        groups = await db.get_all_monitored_groups()
        
        # ğŸ”§ Phase4: é™„å¸¶å¥åº·æ‘˜è¦ï¼ˆå¹«åŠ©å‰ç«¯é¡¯ç¤ºé…ç½®é€²åº¦ï¼‰
        health = {
            "totalGroups": len(groups),
            "withKeywords": 0,
            "withAccount": 0,
            "active": 0,
        }
        for g in groups:
            kw_ids = g.get('keyword_set_ids') or g.get('linkedKeywordSets') or []
            if kw_ids and len(kw_ids) > 0:
                health["withKeywords"] += 1
            if g.get('account_phone') or g.get('accountPhone'):
                health["withAccount"] += 1
            if g.get('is_active', True):
                health["active"] += 1
        
        self.send_event("get-groups-result", {"groups": groups, "health": health})
    except Exception as e:
        self.send_log(f"âŒ ç²å–ç›£æ§ç¾¤çµ„å¤±æ•—: {e}", "error")
        self.send_event("get-groups-result", {"groups": [], "error": str(e)})

async def handle_pause_monitoring(self, payload: Dict[str, Any]):
    """æš«åœç›£æ§ç¾¤çµ„"""
    try:
        group_id = payload.get('groupId')
        
        if not group_id:
            return
        
        await db.execute(
            "UPDATE monitored_groups SET is_active=0 WHERE id=?", (group_id,)
        )
        
        self.send_log(f"â¸ï¸ å·²æš«åœç›£æ§ç¾¤çµ„ ID: {group_id}", "info")
        
        # åˆ·æ–°ç¾¤çµ„åˆ—è¡¨
        await self.handle_get_monitored_groups()
        
    except Exception as e:
        self.send_log(f"âŒ æš«åœç›£æ§å¤±æ•—: {e}", "error")

async def handle_resume_monitoring(self, payload: Dict[str, Any]):
    """æ¢å¾©ç›£æ§ç¾¤çµ„"""
    try:
        group_id = payload.get('groupId')
        
        if not group_id:
            return
        
        await db.execute(
            "UPDATE monitored_groups SET is_active=1 WHERE id=?", (group_id,)
        )
        
        self.send_log(f"â–¶ï¸ å·²æ¢å¾©ç›£æ§ç¾¤çµ„ ID: {group_id}", "info")
        
        # åˆ·æ–°ç¾¤çµ„åˆ—è¡¨
        await self.handle_get_monitored_groups()
        
    except Exception as e:
        self.send_log(f"âŒ æ¢å¾©ç›£æ§å¤±æ•—: {e}", "error")

# ==================== Monitoring Status Handlers ====================

async def handle_get_monitoring_status(self):
    """ç²å–ç›£æ§ç‹€æ…‹è©³æƒ…"""
    try:
        accounts = await db.get_all_accounts()
        listener_accounts = [a for a in accounts if a.get('role') == 'Listener']
        sender_accounts = [a for a in accounts if a.get('role') == 'Sender']
        
        # æª¢æŸ¥ç›£æ§å¸³è™Ÿç‹€æ…‹
        monitoring_status = []
        for account in listener_accounts:
            phone = account.get('phone')
            status = account.get('status', 'Offline')
            
            # æª¢æŸ¥æ˜¯å¦æœ‰è¨»å†Šè™•ç†å™¨
            has_handler = phone in self.telegram_manager.message_handlers if hasattr(self.telegram_manager, 'message_handlers') else False
            
            # æª¢æŸ¥ç›£æ§ä¿¡æ¯
            monitoring_info = None
            if hasattr(self.telegram_manager, 'monitoring_info') and phone in self.telegram_manager.monitoring_info:
                info = self.telegram_manager.monitoring_info[phone]
                monitoring_info = {
                    'chatIds': list(info.get('chat_ids', [])),
                    'groupUrls': info.get('group_urls', []),
                    'keywordSetCount': len(info.get('keyword_sets', []))
                }
            
            monitoring_status.append({
                'phone': phone,
                'status': status,
                'hasHandler': has_handler,
                'monitoringInfo': monitoring_info
            })
        
        # æª¢æŸ¥ç™¼é€å¸³è™Ÿç‹€æ…‹
        sender_status = []
        for account in sender_accounts:
            phone = account.get('phone')
            status = account.get('status', 'Offline')
            
            # æª¢æŸ¥æ˜¯å¦æœ‰ç§ä¿¡è™•ç†å™¨
            has_private_handler = False
            if hasattr(private_message_handler, 'private_handlers'):
                has_private_handler = phone in private_message_handler.private_handlers
            
            sender_status.append({
                'phone': phone,
                'status': status,
                'hasPrivateHandler': has_private_handler
            })
        
        # ç²å–ç›£æ§é…ç½®
        monitored_groups = await db.get_all_monitored_groups()
        keyword_sets = await db.get_all_keyword_sets()
        campaigns = await db.get_all_campaigns()
        active_campaigns = [c for c in campaigns if c.get('isActive') or c.get('is_active')]
        
        self.send_event("monitoring-status", {
            "success": True,
            "isMonitoring": self.is_monitoring,
            "listenerAccounts": monitoring_status,
            "senderAccounts": sender_status,
            "monitoredGroups": len(monitored_groups),
            "keywordSets": len(keyword_sets),
            "activeCampaigns": len(active_campaigns),
            "totalCampaigns": len(campaigns)
        })
    except Exception as e:
        self.send_event("monitoring-status", {
            "success": False,
            "error": str(e)
        })

async def handle_check_monitoring_health(self):
    """æª¢æŸ¥ç›£æ§å¥åº·ç‹€æ…‹"""
    try:
        issues = []
        warnings = []
        
        # æª¢æŸ¥ç›£æ§å¸³è™Ÿ
        accounts = await db.get_all_accounts()
        listener_accounts = [a for a in accounts if a.get('role') == 'Listener']
        online_listeners = [a for a in listener_accounts if a.get('status') == 'Online']
        
        if not listener_accounts:
            issues.append("æ²’æœ‰é…ç½®ç›£æ§å¸³è™Ÿï¼ˆListener è§’è‰²ï¼‰")
        elif not online_listeners:
            issues.append(f"æœ‰ {len(listener_accounts)} å€‹ç›£æ§å¸³è™Ÿï¼Œä½†æ²’æœ‰åœ¨ç·šçš„")
        
        # æª¢æŸ¥ç™¼é€å¸³è™Ÿ
        sender_accounts = [a for a in accounts if a.get('role') == 'Sender']
        online_senders = [a for a in sender_accounts if a.get('status') == 'Online']
        
        if not sender_accounts:
            warnings.append("æ²’æœ‰é…ç½®ç™¼é€å¸³è™Ÿï¼ˆSender è§’è‰²ï¼‰")
        elif not online_senders:
            warnings.append(f"æœ‰ {len(sender_accounts)} å€‹ç™¼é€å¸³è™Ÿï¼Œä½†æ²’æœ‰åœ¨ç·šçš„")
        
        # æª¢æŸ¥ç›£æ§é…ç½®
        monitored_groups = await db.get_all_monitored_groups()
        if not monitored_groups:
            issues.append("æ²’æœ‰é…ç½®ç›£æ§ç¾¤çµ„")
        
        keyword_sets = await db.get_all_keyword_sets()
        if not keyword_sets:
            issues.append("æ²’æœ‰é…ç½®é—œéµè©é›†")
        else:
            # æª¢æŸ¥é—œéµè©é›†æ˜¯å¦ç‚ºç©º
            empty_sets = [ks for ks in keyword_sets if not ks.get('keywords')]
            if empty_sets:
                warnings.append(f"æœ‰ {len(empty_sets)} å€‹é—œéµè©é›†ç‚ºç©º")
        
        # æª¢æŸ¥æ´»å‹•é…ç½®
        campaigns = await db.get_all_campaigns()
        active_campaigns = [c for c in campaigns if c.get('isActive') or c.get('is_active')]
        if not active_campaigns:
            warnings.append("æ²’æœ‰å•Ÿç”¨çš„æ´»å‹•ï¼ˆå³ä½¿æ•ç²åˆ° Lead ä¹Ÿä¸æœƒè‡ªå‹•ç™¼é€ï¼‰")
        
        # æª¢æŸ¥è™•ç†å™¨è¨»å†Š
        handler_issues = []
        for account in online_listeners:
            phone = account.get('phone')
            if hasattr(self.telegram_manager, 'message_handlers'):
                if phone not in self.telegram_manager.message_handlers:
                    handler_issues.append(f"ç›£æ§å¸³è™Ÿ {phone} æœªè¨»å†Šç¾¤çµ„æ¶ˆæ¯è™•ç†å™¨")
        
        for account in online_senders:
            phone = account.get('phone')
            if hasattr(private_message_handler, 'private_handlers'):
                if phone not in private_message_handler.private_handlers:
                    handler_issues.append(f"ç™¼é€å¸³è™Ÿ {phone} æœªè¨»å†Šç§ä¿¡è™•ç†å™¨")
        
        if handler_issues:
            issues.extend(handler_issues)
        
        self.send_event("monitoring-health", {
            "success": True,
            "isHealthy": len(issues) == 0,
            "issues": issues,
            "warnings": warnings,
            "summary": {
                "listenerAccounts": len(listener_accounts),
                "onlineListeners": len(online_listeners),
                "senderAccounts": len(sender_accounts),
                "onlineSenders": len(online_senders),
                "monitoredGroups": len(monitored_groups),
                "keywordSets": len(keyword_sets),
                "activeCampaigns": len(active_campaigns)
            }
        })
    except Exception as e:
        self.send_event("monitoring-health", {
            "success": False,
            "error": str(e)
        })

async def handle_analyze_group_link(self, payload: Dict[str, Any]):
    """åˆ†æç¾¤çµ„éˆæ¥"""
    try:
        link = payload.get('link', '').strip()
        
        if not link:
            raise ValueError("éˆæ¥ä¸èƒ½ç‚ºç©º")
        
        self.send_log(f"ğŸ” æ­£åœ¨åˆ†æéˆæ¥: {link}", "info")
        
        # è§£æéˆæ¥
        import re
        username = None
        
        # åŒ¹é… t.me/username æˆ– @username
        patterns = [
            r't\.me/([a-zA-Z0-9_]+)',
            r'@([a-zA-Z0-9_]+)',
            r'^([a-zA-Z0-9_]+)$'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, link)
            if match:
                username = match.group(1)
                break
        
        if not username:
            # å¯èƒ½æ˜¯ç§æœ‰éˆæ¥
            if 't.me/+' in link or 't.me/joinchat' in link:
                self.send_event("link-analysis-complete", {
                    "success": True,
                    "isPrivate": True,
                    "link": link,
                    "message": "é€™æ˜¯ç§æœ‰é‚€è«‹éˆæ¥ï¼Œéœ€è¦åŠ å…¥å¾Œæ‰èƒ½åˆ†æ"
                })
                return
            else:
                raise ValueError("ç„¡æ³•è§£æéˆæ¥æ ¼å¼")
        
        # ç²å–ç¾¤çµ„ä¿¡æ¯
        group_search_service.set_clients(self.telegram_manager.clients)
        phone, client = group_search_service._get_available_client()
        
        if not client:
            raise ValueError("æ²’æœ‰å¯ç”¨çš„å¸³è™Ÿ")
        
        from pyrogram.enums import ChatType
        
        chat = await client.get_chat(username)
        
        if not chat:
            raise ValueError("æ‰¾ä¸åˆ°è©²ç¾¤çµ„")
        
        # åŸºç¤ä¿¡æ¯
        analysis = {
            "success": True,
            "isPrivate": False,
            "basic": {
                "id": str(chat.id),
                "title": chat.title or chat.first_name or username,
                "username": chat.username or "",
                "type": str(chat.type.name) if chat.type else "unknown",
                "memberCount": chat.members_count or 0,
                "description": chat.description or "",
                "isPublic": bool(chat.username),
                "createdAt": chat.date.isoformat() if chat.date else None
            }
        }
        
        self.send_log(f"âœ… åˆ†æå®Œæˆ: {chat.title or username}", "success")
        self.send_event("link-analysis-complete", analysis)
        
    except Exception as e:
        self.send_log(f"âŒ åˆ†æéˆæ¥å¤±æ•—: {e}", "error")
        self.send_event("link-analysis-complete", {
            "success": False,
            "error": str(e)
        })

async def handle_get_group_monitoring_status(self, payload: Dict[str, Any]):
    """ğŸ†• ç²å–ç¾¤çµ„ç›£æ§ç‹€æ…‹"""
    import sys
    group_id = payload.get('groupId')
    telegram_id = payload.get('telegramId')
    
    try:
        from database import db
        await db.connect()
        
        # æª¢æŸ¥ç¾¤çµ„æ˜¯å¦åœ¨ç›£æ§ä¸­
        group = await db.fetch_one(
            "SELECT id, is_active, phone FROM monitored_groups WHERE id = ? OR telegram_id = ?",
            (group_id, str(telegram_id) if telegram_id else '')
        )
        
        is_monitoring = False
        collected_users = 0
        
        if group:
            is_active = group.get('is_active', 0) if hasattr(group, 'get') else 0
            has_phone = bool(group.get('phone', '')) if hasattr(group, 'get') else False
            is_monitoring = bool(is_active) and has_phone and self.is_monitoring
            
            # æŸ¥è©¢å·²æ”¶é›†ç”¨æˆ¶æ•¸
            if telegram_id:
                result = await db.fetch_one(
                    "SELECT COUNT(DISTINCT sender_id) as count FROM chat_history WHERE chat_id = ? AND sender_id IS NOT NULL",
                    (str(telegram_id),)
                )
                if result:
                    collected_users = result['count'] if hasattr(result, '__getitem__') else 0
        
        self.send_event("group-monitoring-status", {
            "groupId": group_id,
            "isMonitoring": is_monitoring,
            "collectedUsers": collected_users
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("group-monitoring-status", {
            "groupId": group_id,
            "isMonitoring": False,
            "collectedUsers": 0
        })

