"""
Extracted handler implementations: triggers
Auto-generated by refactor_main.py
"""
import json
import sys
import time
import asyncio
import traceback
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from service_context import get_service_context
from database import db

# All handlers receive (self, payload) where self is BackendService instance.
# They are called via: await handler_impl(self, payload)
# Inside, use self.db, self.send_event(), self.telegram_manager, etc.
# This is a transitional pattern - later, replace self.xxx with ctx.xxx


# ==================== Trigger Rules Handlers ====================

def _trigger_rule_overlap_hint(rules: List[Dict]) -> None:
    """P2ï¼šç‚ºæ¯æ¢è¦å‰‡é™„åŠ é‡ç–Šæç¤ºï¼ˆç›¸åŒé—œéµè©é›†+åŒä¸€æ¨¡æ¿æ™‚å¯èƒ½é‡è¤‡ç™¼é€ï¼‰ã€‚åŸåœ°ä¿®æ”¹ rulesã€‚"""
    def _kw_set(r):
        ids = r.get('keyword_set_ids') or r.get('keywordSetIds') or []
        return tuple(sorted(ids)) if isinstance(ids, list) else ()
    def _tpl_id(r):
        cfg = r.get('response_config') or r.get('responseConfig') or {}
        if isinstance(cfg, str):
            try:
                cfg = json.loads(cfg)
            except Exception:
                cfg = {}
        return cfg.get('templateId') or cfg.get('template_id')
    for r in rules:
        r['overlapWarning'] = ''
        my_kw = _kw_set(r)
        my_tpl = _tpl_id(r)
        if not my_kw and my_tpl is None:
            continue
        others = [o for o in rules if o.get('id') != r.get('id') and (o.get('is_active') or o.get('isActive'))]
        overlap_names = []
        for o in others:
            if _kw_set(o) == my_kw and _tpl_id(o) == my_tpl:
                overlap_names.append(o.get('name', o.get('id', '')))
        if overlap_names:
            r['overlapWarning'] = f"èˆ‡è¦å‰‡ã€Œ{'ã€ã€Œ'.join(overlap_names[:3])}{'ç­‰' if len(overlap_names) > 3 else ''}ã€ä½¿ç”¨ç›¸åŒé—œéµè©é›†èˆ‡æ¨¡æ¿ï¼ŒåŒä¸€äº‹ä»¶åƒ…æœƒåŸ·è¡Œå„ªå…ˆç´šæœ€é«˜çš„ä¸€æ¢ã€‚"


async def handle_get_trigger_rules(self):
    """ç²å–æ‰€æœ‰è§¸ç™¼è¦å‰‡ã€‚P2ï¼šé™„åŠ  overlapWarning ä¾›å‰ç«¯é¡¯ç¤ºé‡ç–Šæç¤ºã€‚"""
    import sys
    print("[Backend] handle_get_trigger_rules called", file=sys.stderr)
    try:
        rules = await db.get_all_trigger_rules()
        _trigger_rule_overlap_hint(rules)
        print(f"[Backend] Loaded {len(rules)} trigger rules", file=sys.stderr)
        self.send_event("trigger-rules-result", {
            "success": True,
            "rules": rules
        })
        return {"success": True, "rules": rules}
    except Exception as e:
        import traceback
        print(f"[Backend] âŒ Error getting trigger rules: {e}", file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        self.send_log(f"âŒ ç²å–è§¸ç™¼è¦å‰‡å¤±æ•—: {e}", "error")
        self.send_event("trigger-rules-result", {
            "success": False,
            "rules": [],
            "error": str(e)
        })
        return {"success": False, "rules": [], "error": str(e)}


async def handle_get_trigger_rule(self, payload: Dict[str, Any]):
    """ç²å–å–®å€‹è§¸ç™¼è¦å‰‡"""
    try:
        rule_id = payload.get('id')
        if not rule_id:
            self.send_event("trigger-rule-result", {
                "success": False,
                "error": "ç¼ºå°‘è¦å‰‡ ID"
            })
            return
        
        rule = await db.get_trigger_rule(rule_id)
        self.send_event("trigger-rule-result", {
            "success": True,
            "rule": rule
        })
    except Exception as e:
        self.send_log(f"âŒ ç²å–è§¸ç™¼è¦å‰‡å¤±æ•—: {e}", "error")
        self.send_event("trigger-rule-result", {
            "success": False,
            "error": str(e)
        })


async def handle_save_trigger_rule(self, payload: Dict[str, Any]):
    """ä¿å­˜è§¸ç™¼è¦å‰‡ï¼ˆæ–°å¢æˆ–æ›´æ–°ï¼‰"""
    import sys
    print(f"[Backend] handle_save_trigger_rule called with payload: {payload}", file=sys.stderr)
    try:
        rule_id = payload.get('id')
        name = payload.get('name', '')
        
        if not name:
            self.send_event("save-trigger-rule-result", {
                "success": False,
                "error": "è¦å‰‡åç¨±ä¸èƒ½ç‚ºç©º"
            })
            return
        
        if not payload.get('keywordSetIds') or len(payload.get('keywordSetIds', [])) == 0:
            self.send_event("save-trigger-rule-result", {
                "success": False,
                "error": "è«‹è‡³å°‘é¸æ“‡ä¸€å€‹é—œéµè©é›†"
            })
            return
        
        if rule_id:
            # æ›´æ–°ï¼ˆåƒ…å¯æ›´æ–°ç•¶å‰ç”¨æˆ¶çš„è¦å‰‡ï¼‰
            existing = await db.get_trigger_rule(rule_id)
            if not existing:
                self.send_event("save-trigger-rule-result", {
                    "success": False,
                    "error": "ç„¡æ¬Šé™ä¿®æ”¹è©²è¦å‰‡æˆ–è¦å‰‡ä¸å­˜åœ¨"
                })
                return
            success = await db.update_trigger_rule(rule_id, payload)
            if success:
                self.send_log(f"âœ… å·²æ›´æ–°è§¸ç™¼è¦å‰‡: {name}", "success")
                self.send_event("save-trigger-rule-result", {
                    "success": True,
                    "id": rule_id,
                    "message": "è¦å‰‡å·²æ›´æ–°"
                })
            else:
                self.send_event("save-trigger-rule-result", {
                    "success": False,
                    "error": "æ›´æ–°å¤±æ•—"
                })
        else:
            # æ–°å¢
            new_id = await db.add_trigger_rule(payload)
            self.send_log(f"âœ… å·²å‰µå»ºè§¸ç™¼è¦å‰‡: {name}", "success")
            self.send_event("save-trigger-rule-result", {
                "success": True,
                "id": new_id,
                "message": "è¦å‰‡å·²å‰µå»º"
            })
        
        # åˆ·æ–°è¦å‰‡åˆ—è¡¨
        await self.handle_get_trigger_rules()
        
    except Exception as e:
        self.send_log(f"âŒ ä¿å­˜è§¸ç™¼è¦å‰‡å¤±æ•—: {e}", "error")
        self.send_event("save-trigger-rule-result", {
            "success": False,
            "error": str(e)
        })


async def handle_delete_trigger_rule(self, payload: Dict[str, Any]):
    """åˆªé™¤è§¸ç™¼è¦å‰‡"""
    try:
        rule_id = payload.get('id')
        
        if not rule_id:
            self.send_event("delete-trigger-rule-result", {
                "success": False,
                "error": "ç¼ºå°‘è¦å‰‡ ID"
            })
            return
        
        success = await db.delete_trigger_rule(rule_id)
        
        self.send_event("delete-trigger-rule-result", {"success": success})
        
        if success:
            self.send_log(f"ğŸ—‘ï¸ å·²åˆªé™¤è§¸ç™¼è¦å‰‡ ID: {rule_id}", "success")
            await self.handle_get_trigger_rules()
            
    except Exception as e:
        self.send_log(f"âŒ åˆªé™¤è§¸ç™¼è¦å‰‡å¤±æ•—: {e}", "error")
        self.send_event("delete-trigger-rule-result", {
            "success": False,
            "error": str(e)
        })


async def handle_toggle_trigger_rule(self, payload: Dict[str, Any]):
    """å•Ÿç”¨/åœç”¨è§¸ç™¼è¦å‰‡"""
    try:
        rule_id = payload.get('id')
        is_active = payload.get('isActive', True)
        
        if not rule_id:
            self.send_event("toggle-trigger-rule-result", {
                "success": False,
                "error": "ç¼ºå°‘è¦å‰‡ ID"
            })
            return
        
        success = await db.toggle_trigger_rule(rule_id, is_active)
        
        self.send_event("toggle-trigger-rule-result", {"success": success})
        
        if success:
            status = "å•Ÿç”¨" if is_active else "åœç”¨"
            self.send_log(f"âœ… å·²{status}è§¸ç™¼è¦å‰‡ ID: {rule_id}", "success")
            await self.handle_get_trigger_rules()
            
    except Exception as e:
        self.send_log(f"âŒ åˆ‡æ›è§¸ç™¼è¦å‰‡ç‹€æ…‹å¤±æ•—: {e}", "error")
        self.send_event("toggle-trigger-rule-result", {
            "success": False,
            "error": str(e)
        })

