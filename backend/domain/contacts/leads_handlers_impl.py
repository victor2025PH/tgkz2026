"""
Extracted handler implementations: leads
Auto-generated by refactor_main.py
"""
import json
import sys
import time
import asyncio
import traceback
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from service_context import get_service_context

# All handlers receive (self, payload) where self is BackendService instance.
# They are called via: await handler_impl(self, payload)
# Inside, use self.db, self.send_event(), self.telegram_manager, etc.
# This is a transitional pattern - later, replace self.xxx with ctx.xxx


async def handle_update_lead_status(self, payload: Dict[str, Any]):
    """Handle update-lead-status command (å¸¶é›™å‘åŒæ­¥)"""
    try:
        lead_id = payload.get('leadId')
        new_status = payload.get('newStatus')
        await db.update_lead_status(lead_id, new_status)
        await db.add_interaction(lead_id, 'Status Change', f"Status changed to {new_status}")
        await db.add_log(f"Lead {lead_id} status updated to {new_status}", "success")
        await self.send_leads_update()
        
        # ğŸ†• åŒæ­¥åˆ°çµ±ä¸€è¯ç¹«äººè¡¨
        try:
            # ç²å– lead çš„ userId
            lead = await db.get_lead_by_id(lead_id)
            if lead:
                user_id = str(lead.get('userId', lead.get('user_id', '')))
                if user_id:
                    from unified_contacts import get_unified_contacts_manager, LEAD_STATUS_MAPPING
                    manager = get_unified_contacts_manager(db)
                    contact_status = LEAD_STATUS_MAPPING.get(new_status, 'new')
                    await manager.update_status([user_id], contact_status)
                    print(f"[Backend] Synced lead status to unified_contacts: {user_id} -> {contact_status}", file=sys.stderr)
        except Exception as sync_error:
            print(f"[Backend] Warning: Could not sync status to unified_contacts: {sync_error}", file=sys.stderr)
    
    except Exception as e:
        self.send_log(f"Error updating lead status: {str(e)}", "error")


async def handle_get_leads_paginated(self, payload: Dict[str, Any]):
    """ğŸ†• åˆ†é ç²å– Leads æ•¸æ“š"""
    import sys
    try:
        page = payload.get('page', 1)
        page_size = payload.get('pageSize', 50)
        status = payload.get('status')
        search = payload.get('search')
        
        offset = (page - 1) * page_size
        
        result = await db.get_leads_paginated(
            limit=page_size,
            offset=offset,
            status=status,
            search=search
        )
        
        print(f"[Backend] get-leads-paginated: page={page}, pageSize={page_size}, total={result.get('total', 0)}", file=sys.stderr)
        
        self.send_event("leads-paginated", result)
        
    except Exception as e:
        print(f"[Backend] Error getting paginated leads: {e}", file=sys.stderr)
        self.send_event("leads-paginated", {
            'leads': [],
            'total': 0,
            'page': 1,
            'pageSize': 50,
            'hasMore': False,
            'error': str(e)
        })


async def handle_add_lead(self, payload: Dict[str, Any]):
    """Handle add-lead command - å¾æˆå“¡è³‡æ–™åº«æ·»åŠ  Lead"""
    try:
        user_id = payload.get('user_id')
        username = payload.get('username')
        first_name = payload.get('first_name', '')
        last_name = payload.get('last_name', '')
        source_chat_title = payload.get('source_chat_title', '')
        source_chat_id = payload.get('source_chat_id', '')
        notes = payload.get('notes', '')
        
        # æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
        existing_lead = await db.get_lead_by_user_id(user_id)
        if existing_lead:
            self.send_log(f"âš ï¸ Lead @{username or user_id} å·²å­˜åœ¨", "warning")
            self.send_event("add-lead-result", {
                "success": False,
                "error": "Lead å·²å­˜åœ¨",
                "existingLead": existing_lead
            })
            return
        
        # å‰µå»ºæ–°çš„ Lead
        import datetime
        lead_id = await db.add_lead({
            'userId': user_id,
            'username': username,
            'firstName': first_name,
            'lastName': last_name,
            'sourceGroup': source_chat_title,
            'triggeredKeyword': '',
            'onlineStatus': 'Unknown',
            'notes': notes
        })
        
        self.send_log(f"âœ… æˆåŠŸæ·»åŠ  Lead: {first_name or username or user_id}", "success")
        
        # ç™¼é€æˆåŠŸäº‹ä»¶
        self.send_event("add-lead-result", {
            "success": True,
            "leadId": lead_id,
            "lead": {
                "id": lead_id,
                "userId": user_id,
                "username": username,
                "firstName": first_name,
                "lastName": last_name,
                "sourceGroup": source_chat_title,
                "triggeredKeyword": "",
                "timestamp": datetime.datetime.now().isoformat(),
                "status": "New",
                "onlineStatus": "Unknown"
            }
        })
        
        # æ›´æ–° Leads åˆ—è¡¨
        await self.send_leads_update()
        
        # åŒæ™‚æ›´æ–°æˆå“¡è³‡æ–™åº«ä¸­çš„ç‹€æ…‹ï¼ˆæ¨™è¨˜ç‚ºå·²åŠ å…¥æ¼æ–—ï¼‰
        if source_chat_id:
            try:
                await db._connection.execute('''
                    UPDATE extracted_members 
                    SET notes = notes || CASE WHEN notes != '' THEN '\n' ELSE '' END || 'å·²åŠ å…¥éŠ·å”®æ¼æ–—',
                        updated_at = datetime('now')
                    WHERE user_id = ?
                ''', (user_id,))
                await db._connection.commit()
            except Exception as sync_error:
                print(f"[Backend] Warning: Could not sync member status: {sync_error}", file=sys.stderr)
        
        # ğŸ†• åŒæ­¥åˆ°çµ±ä¸€è¯ç¹«äººè¡¨
        try:
            from unified_contacts import get_unified_contacts_manager
            manager = get_unified_contacts_manager(db)
            await manager.sync_from_lead({
                'userId': user_id,
                'username': username,
                'firstName': first_name,
                'lastName': last_name,
                'status': 'New',
                'sourceChatTitle': source_chat_title,
                'sourceChatId': source_chat_id
            })
            print(f"[Backend] Synced new lead to unified_contacts: {user_id}", file=sys.stderr)
        except Exception as sync_error:
            print(f"[Backend] Warning: Could not sync to unified_contacts: {sync_error}", file=sys.stderr)
    
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_log(f"âŒ æ·»åŠ  Lead å¤±æ•—: {str(e)}", "error")
        self.send_event("add-lead-result", {
            "success": False,
            "error": str(e)
        })


async def handle_add_to_dnc(self, payload: Dict[str, Any]):
    """Handle add-to-dnc command"""
    try:
        user_id = payload.get('userId')
        await db.add_to_dnc(user_id)
        await db.add_log(f"User {user_id} added to DNC list", "success")
        await self.send_leads_update()
    
    except Exception as e:
        self.send_log(f"Error adding to DNC: {str(e)}", "error")


async def handle_export_leads_to_excel(self, payload: Dict[str, Any]):
    """Handle export-leads-to-excel command"""
    try:
        from openpyxl import Workbook
        from pathlib import Path
        from datetime import datetime
        
        file_path = payload.get('filePath')
        leads = payload.get('leads', [])
        
        if not file_path:
            self.send_log("No file path provided", "error")
            return
        
        if not leads:
            self.send_log("No leads to export", "warning")
            return
        
        # Create workbook
        workbook = Workbook()
        sheet = workbook.active
        sheet.title = "Leads"
        
        # Write headers
        headers = [
            'ID', 'User ID', 'Username', 'First Name', 'Last Name',
            'Source Group', 'Triggered Keyword', 'Status', 'Online Status',
            'Timestamp', 'Do Not Contact'
        ]
        sheet.append(headers)
        
        # Write data
        for lead in leads:
            row = [
                lead.get('id', ''),
                lead.get('userId', ''),
                lead.get('username', ''),
                lead.get('firstName', ''),
                lead.get('lastName', ''),
                lead.get('sourceGroup', ''),
                lead.get('triggeredKeyword', ''),
                lead.get('status', ''),
                lead.get('onlineStatus', ''),
                lead.get('timestamp', ''),
                'Yes' if lead.get('doNotContact') else 'No'
            ]
            sheet.append(row)
        
        # Auto-adjust column widths
        for column in sheet.columns:
            max_length = 0
            column_letter = column[0].column_letter
            for cell in column:
                try:
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    pass
            adjusted_width = min(max_length + 2, 50)
            sheet.column_dimensions[column_letter].width = adjusted_width
        
        # Save file
        file_path_obj = Path(file_path)
        workbook.save(file_path_obj)
        
        self.send_log(f"Exported {len(leads)} leads to Excel: {file_path}", "success")
        await db.add_log(f"Exported {len(leads)} leads to Excel", "success")
    
    except Exception as e:
        self.send_log(f"Error exporting leads to Excel: {str(e)}", "error")


# ==================== Collected Users Handlers (å»£å‘Šè­˜åˆ¥) ====================

async def handle_get_collected_users(self, payload: Dict[str, Any]):
    """ç²å–æ”¶é›†çš„ç”¨æˆ¶åˆ—è¡¨"""
    import sys
    print("[Backend] handle_get_collected_users called", file=sys.stderr)
    try:
        filters = payload.get('filters', {})
        limit = payload.get('limit', 100)
        offset = payload.get('offset', 0)
        
        users = await db.get_collected_users(filters=filters, limit=limit, offset=offset)
        total = await db.get_collected_users_count(filters=filters)
        
        print(f"[Backend] Returning {len(users)} collected users (total: {total})", file=sys.stderr)
        
        self.send_event("collected-users-result", {
            "success": True,
            "users": users,
            "total": total,
            "limit": limit,
            "offset": offset
        })
    except Exception as e:
        import traceback
        print(f"[Backend] Error getting collected users: {e}", file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        self.send_event("collected-users-result", {
            "success": False,
            "users": [],
            "total": 0,
            "error": str(e)
        })


async def handle_get_collected_users_stats(self):
    """ç²å–æ”¶é›†ç”¨æˆ¶çµ±è¨ˆ"""
    import sys
    print("[Backend] handle_get_collected_users_stats called", file=sys.stderr)
    try:
        stats = await db.get_collected_users_stats()
        print(f"[Backend] Collected users stats: {stats}", file=sys.stderr)
        
        self.send_event("collected-users-stats-result", {
            "success": True,
            "stats": stats
        })
    except Exception as e:
        print(f"[Backend] Error getting collected users stats: {e}", file=sys.stderr)
        self.send_event("collected-users-stats-result", {
            "success": False,
            "stats": {},
            "error": str(e)
        })


async def handle_mark_user_as_ad(self, payload: Dict[str, Any]):
    """æ¨™è¨˜ç”¨æˆ¶ç‚ºå»£å‘Šè™Ÿ"""
    try:
        telegram_id = payload.get('telegramId')
        is_ad = payload.get('isAd', True)
        
        if not telegram_id:
            self.send_event("mark-user-as-ad-result", {
                "success": False,
                "error": "ç¼ºå°‘ç”¨æˆ¶ ID"
            })
            return
        
        success = await db.mark_user_as_ad(telegram_id, is_ad)
        
        if success:
            action = "æ¨™è¨˜ç‚ºå»£å‘Šè™Ÿ" if is_ad else "å–æ¶ˆå»£å‘Šè™Ÿæ¨™è¨˜"
            self.send_log(f"âœ… å·²{action}: {telegram_id}", "success")
        
        self.send_event("mark-user-as-ad-result", {
            "success": success,
            "telegramId": telegram_id,
            "isAd": is_ad
        })
    except Exception as e:
        self.send_log(f"âŒ æ¨™è¨˜ç”¨æˆ¶å¤±æ•—: {e}", "error")
        self.send_event("mark-user-as-ad-result", {
            "success": False,
            "error": str(e)
        })


async def handle_blacklist_user(self, payload: Dict[str, Any]):
    """å°‡ç”¨æˆ¶åŠ å…¥/ç§»å‡ºé»‘åå–®"""
    try:
        telegram_id = payload.get('telegramId')
        blacklist = payload.get('blacklist', True)
        
        if not telegram_id:
            self.send_event("blacklist-user-result", {
                "success": False,
                "error": "ç¼ºå°‘ç”¨æˆ¶ ID"
            })
            return
        
        success = await db.blacklist_user(telegram_id, blacklist)
        
        if success:
            action = "åŠ å…¥é»‘åå–®" if blacklist else "ç§»å‡ºé»‘åå–®"
            self.send_log(f"âœ… å·²{action}: {telegram_id}", "success")
        
        self.send_event("blacklist-user-result", {
            "success": success,
            "telegramId": telegram_id,
            "blacklisted": blacklist
        })
    except Exception as e:
        self.send_log(f"âŒ é»‘åå–®æ“ä½œå¤±æ•—: {e}", "error")
        self.send_event("blacklist-user-result", {
            "success": False,
            "error": str(e)
        })


async def handle_get_user_message_samples(self, payload: Dict[str, Any]):
    """ç²å–ç”¨æˆ¶æ¶ˆæ¯æ¨£æœ¬"""
    try:
        telegram_id = payload.get('telegramId')
        limit = payload.get('limit', 10)
        
        if not telegram_id:
            self.send_event("user-message-samples-result", {
                "success": False,
                "error": "ç¼ºå°‘ç”¨æˆ¶ ID"
            })
            return
        
        samples = await db.get_user_message_samples(telegram_id, limit)
        
        self.send_event("user-message-samples-result", {
            "success": True,
            "telegramId": telegram_id,
            "samples": samples
        })
    except Exception as e:
        self.send_event("user-message-samples-result", {
            "success": False,
            "error": str(e)
        })


async def handle_recalculate_user_risk(self, payload: Dict[str, Any]):
    """é‡æ–°è¨ˆç®—ç”¨æˆ¶é¢¨éšªè©•åˆ†"""
    try:
        telegram_id = payload.get('telegramId')
        
        if not telegram_id:
            self.send_event("recalculate-risk-result", {
                "success": False,
                "error": "ç¼ºå°‘ç”¨æˆ¶ ID"
            })
            return
        
        # ç²å–ç”¨æˆ¶ä¿¡æ¯
        users = await db.get_collected_users({'telegram_id': telegram_id}, limit=1)
        if not users:
            self.send_event("recalculate-risk-result", {
                "success": False,
                "error": "ç”¨æˆ¶ä¸å­˜åœ¨"
            })
            return
        
        user = users[0]
        
        # ç²å–æ¶ˆæ¯æ¨£æœ¬
        messages = await db.get_user_message_samples(telegram_id, limit=10)
        
        # é‡æ–°è¨ˆç®—é¢¨éšª
        from ad_detection_service import ad_detection_service
        result = ad_detection_service.calculate_risk_score(user, messages)
        
        # æ›´æ–°æ•¸æ“šåº«
        await db.update_user_risk_score(
            telegram_id=telegram_id,
            risk_score=result.risk_score,
            risk_factors={'factors': result.risk_factors},
            value_level=result.value_level
        )
        
        self.send_event("recalculate-risk-result", {
            "success": True,
            "telegramId": telegram_id,
            "riskScore": result.risk_score,
            "riskLevel": result.risk_level,
            "valueLevel": result.value_level,
            "isLikelyAd": result.is_likely_ad
        })
        
        self.send_log(f"âœ… å·²é‡æ–°è¨ˆç®—é¢¨éšªè©•åˆ†: {telegram_id} -> {result.risk_score:.2f}", "success")
        
    except Exception as e:
        import traceback
        traceback.print_exc()
        self.send_event("recalculate-risk-result", {
            "success": False,
            "error": str(e)
        })


async def handle_search_leads(self, payload: Dict[str, Any]):
    """å…¨æ–‡æœç´¢ Lead"""
    try:
        from fulltext_search import get_search_engine
        from datetime import datetime as dt
        
        query = payload.get('query', '')
        if not query:
            self.send_event("search-leads", {
                "success": False,
                "error": "æœç´¢æŸ¥è©¢ä¸èƒ½ç‚ºç©º"
            })
            return
        
        status = payload.get('status')
        limit = payload.get('limit', 50)
        offset = payload.get('offset', 0)
        
        # è§£ææ—¥æœŸç¯„åœ
        date_from = None
        date_to = None
        if payload.get('dateFrom'):
            try:
                date_from = dt.fromisoformat(payload['dateFrom'])
            except:
                pass
        if payload.get('dateTo'):
            try:
                date_to = dt.fromisoformat(payload['dateTo'])
            except:
                pass
        
        search_engine = get_search_engine()
        results = await search_engine.search_leads(
            query=query,
            status=status,
            date_from=date_from,
            date_to=date_to,
            limit=limit,
            offset=offset
        )
        
        self.send_event("search-leads", {
            "success": True,
            "query": query,
            "results": results,
            "count": len(results),
            "hasMore": len(results) == limit
        })
    except Exception as e:
        self.send_event("search-leads", {
            "success": False,
            "error": str(e)
        })


async def handle_bulk_update_user_tags(self, payload: Dict[str, Any]):
    """æ‰¹é‡æ›´æ–°ç”¨æˆ¶æ¨™ç±¤"""
    try:
        user_ids = payload.get('userIds', [])
        tags = payload.get('tags', '')
        action = payload.get('action', 'add')  # add, remove, set
        
        if not user_ids:
            raise ValueError("è«‹é¸æ“‡è¦æ›´æ–°çš„ç”¨æˆ¶")
        
        await db.bulk_update_user_tags(user_ids, tags, action)
        
        self.send_log(f"å·²æ›´æ–° {len(user_ids)} å€‹ç”¨æˆ¶çš„æ¨™ç±¤", "success")
        self.send_event("bulk-update-complete", {
            "success": True,
            "type": "tags",
            "count": len(user_ids)
        })
        
    except Exception as e:
        self.send_log(f"æ‰¹é‡æ›´æ–°æ¨™ç±¤å¤±æ•—: {str(e)}", "error")
        self.send_event("bulk-update-complete", {
            "success": False,
            "error": str(e)
        })


# ==================== Batch Operations Handlers ====================

async def handle_batch_update_lead_status(self, payload: Dict[str, Any]):
    """æ‰¹é‡æ›´æ–° Lead ç‹€æ…‹"""
    try:
        lead_ids = payload.get('leadIds', [])
        new_status = payload.get('newStatus')
        
        if not lead_ids:
            self.send_event("batch-operation-result", {
                "success": False,
                "error": "æœªé¸æ“‡ä»»ä½• Lead"
            })
            return
        
        if not new_status:
            self.send_event("batch-operation-result", {
                "success": False,
                "error": "æœªæŒ‡å®šæ–°ç‹€æ…‹"
            })
            return
        
        batch_ops = get_batch_ops()
        if not batch_ops:
            self.send_event("batch-operation-result", {
                "success": False,
                "error": "æ‰¹é‡æ“ä½œç³»çµ±æœªåˆå§‹åŒ–"
            })
            return
        
        result = await batch_ops.batch_update_lead_status(lead_ids, new_status)
        
        if result.get('success'):
            self.send_log(f"æ‰¹é‡æ›´æ–°ç‹€æ…‹å®Œæˆ: {result.get('successCount')}/{len(lead_ids)} æˆåŠŸ", "success")
        else:
            self.send_log(f"æ‰¹é‡æ›´æ–°ç‹€æ…‹å¤±æ•—: {result.get('error')}", "error")
        
        self.send_event("batch-operation-result", result)
        
    except Exception as e:
        self.send_log(f"æ‰¹é‡æ›´æ–°ç‹€æ…‹å¤±æ•—: {str(e)}", "error")
        self.send_event("batch-operation-result", {
            "success": False,
            "error": str(e)
        })


async def handle_batch_add_to_dnc(self, payload: Dict[str, Any]):
    """æ‰¹é‡æ·»åŠ åˆ° DNC åˆ—è¡¨"""
    try:
        lead_ids = payload.get('leadIds', [])
        
        if not lead_ids:
            self.send_event("batch-operation-result", {
                "success": False,
                "error": "æœªé¸æ“‡ä»»ä½• Lead"
            })
            return
        
        batch_ops = get_batch_ops()
        if not batch_ops:
            self.send_event("batch-operation-result", {
                "success": False,
                "error": "æ‰¹é‡æ“ä½œç³»çµ±æœªåˆå§‹åŒ–"
            })
            return
        
        result = await batch_ops.batch_add_to_dnc(lead_ids)
        
        if result.get('success'):
            self.send_log(f"æ‰¹é‡æ·»åŠ åˆ° DNC å®Œæˆ: {result.get('successCount')}/{len(lead_ids)} æˆåŠŸ", "success")
        else:
            self.send_log(f"æ‰¹é‡æ·»åŠ åˆ° DNC å¤±æ•—: {result.get('error')}", "error")
        
        self.send_event("batch-operation-result", result)
        
    except Exception as e:
        self.send_log(f"æ‰¹é‡æ·»åŠ åˆ° DNC å¤±æ•—: {str(e)}", "error")
        self.send_event("batch-operation-result", {
            "success": False,
            "error": str(e)
        })


async def handle_batch_remove_from_dnc(self, payload: Dict[str, Any]):
    """æ‰¹é‡å¾ DNC åˆ—è¡¨ç§»é™¤"""
    try:
        lead_ids = payload.get('leadIds', [])
        
        if not lead_ids:
            self.send_event("batch-operation-result", {
                "success": False,
                "error": "æœªé¸æ“‡ä»»ä½• Lead"
            })
            return
        
        batch_ops = get_batch_ops()
        if not batch_ops:
            self.send_event("batch-operation-result", {
                "success": False,
                "error": "æ‰¹é‡æ“ä½œç³»çµ±æœªåˆå§‹åŒ–"
            })
            return
        
        result = await batch_ops.batch_remove_from_dnc(lead_ids)
        
        if result.get('success'):
            self.send_log(f"æ‰¹é‡å¾ DNC ç§»é™¤å®Œæˆ: {result.get('successCount')}/{len(lead_ids)} æˆåŠŸ", "success")
        else:
            self.send_log(f"æ‰¹é‡å¾ DNC ç§»é™¤å¤±æ•—: {result.get('error')}", "error")
        
        self.send_event("batch-operation-result", result)
        
    except Exception as e:
        self.send_log(f"æ‰¹é‡å¾ DNC ç§»é™¤å¤±æ•—: {str(e)}", "error")
        self.send_event("batch-operation-result", {
            "success": False,
            "error": str(e)
        })


async def handle_batch_delete_leads(self, payload: Dict[str, Any]):
    """æ‰¹é‡åˆªé™¤ Lead"""
    try:
        lead_ids = payload.get('leadIds', [])
        
        self.send_log(f"æ”¶åˆ°æ‰¹é‡åˆªé™¤è«‹æ±‚: {len(lead_ids)} å€‹ Lead, IDs: {lead_ids[:10]}{'...' if len(lead_ids) > 10 else ''}", "info")
        
        if not lead_ids:
            self.send_event("batch-operation-result", {
                "success": False,
                "error": "æœªé¸æ“‡ä»»ä½• Lead"
            })
            return
        
        # ä½¿ç”¨ database çš„ batch_delete_leads æ–¹æ³•
        result = await db.batch_delete_leads(lead_ids)
        
        success_count = result.get('deleted', 0)
        failed = result.get('failed', [])
        
        self.send_log(f"æ‰¹é‡åˆªé™¤å®Œæˆ: {success_count}/{len(lead_ids)} æˆåŠŸ", "success" if success_count > 0 else "warning")
        
        if failed:
            self.send_log(f"åˆªé™¤å¤±æ•—çš„ ID: {failed}", "warning")
        
        # åˆ·æ–° leads åˆ—è¡¨ï¼ˆåŒ…å«ç¸½æ•¸ï¼‰
        data = await db.get_leads_with_total()
        self.send_log(f"åˆ·æ–°å¾Œå‰©é¤˜ {data['total']} å€‹ Leadï¼ˆé¡¯ç¤º {len(data['leads'])} å€‹ï¼‰", "info")
        self.send_event("leads-updated", {"leads": data['leads'], "total": data['total']})
        
        self.send_event("batch-operation-result", {
            "success": success_count > 0,
            "successCount": success_count,
            "failureCount": len(lead_ids) - success_count
        })
        
    except Exception as e:
        self.send_log(f"æ‰¹é‡åˆªé™¤å¤±æ•—: {str(e)}", "error")
        import traceback
        traceback.print_exc()
        self.send_event("batch-operation-result", {
            "success": False,
            "error": str(e)
        })


async def handle_delete_lead(self, payload: Dict[str, Any]):
    """åˆªé™¤å–®å€‹ Lead"""
    try:
        lead_id = payload.get('leadId')
        
        self.send_log(f"æ”¶åˆ°åˆªé™¤è«‹æ±‚: Lead ID = {lead_id}", "info")
        
        if not lead_id:
            self.send_event("lead-deleted", {
                "success": False,
                "error": "æœªæä¾› Lead ID"
            })
            return
        
        result = await db.delete_lead(lead_id)
        
        if result:
            self.send_log(f"âœ“ å·²åˆªé™¤ Lead: {lead_id}", "success")
            # åˆ·æ–° leads åˆ—è¡¨ï¼ˆåŒ…å«ç¸½æ•¸ï¼‰
            data = await db.get_leads_with_total()
            self.send_log(f"åˆ·æ–°å¾Œå‰©é¤˜ {data['total']} å€‹ Leadï¼ˆé¡¯ç¤º {len(data['leads'])} å€‹ï¼‰", "info")
            self.send_event("leads-updated", {"leads": data['leads'], "total": data['total']})
            self.send_event("lead-deleted", {"success": True, "leadId": lead_id})
        else:
            self.send_log(f"âœ— åˆªé™¤ Lead {lead_id} å¤±æ•— (è¨˜éŒ„å¯èƒ½ä¸å­˜åœ¨)", "warning")
            self.send_event("lead-deleted", {"success": False, "error": "åˆªé™¤å¤±æ•— - è¨˜éŒ„å¯èƒ½ä¸å­˜åœ¨"})
            
    except Exception as e:
        self.send_log(f"åˆªé™¤ Lead å¤±æ•—: {str(e)}", "error")
        import traceback
        traceback.print_exc()
        self.send_event("lead-deleted", {"success": False, "error": str(e)})


# ==================== æ™ºèƒ½æ¨¡çµ„ Handlers (Phase B) ====================

async def handle_get_intent_score(self, payload: Dict[str, Any]):
    """ç²å–æ¶ˆæ¯çš„æ„åœ–è©•åˆ†"""
    try:
        from intent_scorer import score_lead_intent
        
        message = payload.get("message", "")
        context = payload.get("context", [])
        
        result = await score_lead_intent(message, context)
        
        self.send_event("intent-score-result", {
            "success": True,
            **result
        })
    except Exception as e:
        print(f"[Backend] Error scoring intent: {e}", file=sys.stderr)
        self.send_event("intent-score-result", {
            "success": False,
            "error": str(e)
        })


async def handle_predict_lead_conversion(self, payload: Dict[str, Any]):
    """é æ¸¬ Lead è½‰åŒ–"""
    try:
        from predictive_analytics import predict_lead_conversion
        
        result = await predict_lead_conversion(
            lead_id=payload.get("leadId", 0),
            intent_score=payload.get("intentScore", 0),
            interaction_count=payload.get("interactionCount", 0),
            days_since_first_contact=payload.get("daysSinceFirstContact", 0),
            days_since_last_contact=payload.get("daysSinceLastContact", 0),
            replied=payload.get("replied", False),
            reply_speed_minutes=payload.get("replySpeedMinutes", 0),
            source_type=payload.get("sourceType", "unknown")
        )
        
        self.send_event("lead-prediction", {
            "success": True,
            **result
        })
    except Exception as e:
        print(f"[Backend] Error predicting lead conversion: {e}", file=sys.stderr)
        self.send_event("lead-prediction", {"success": False, "error": str(e)})


async def handle_get_collected_users_count(self, payload: Dict[str, Any]):
    """ğŸ†• ç²å–å·²æ”¶é›†ç”¨æˆ¶æ•¸é‡"""
    import sys
    group_id = payload.get('groupId')
    source_type = payload.get('sourceType', 'monitoring')
    
    try:
        from database import db
        await db.connect()
        
        # å¾ extracted_members è¡¨æŸ¥è©¢
        result = await db.fetch_one(
            "SELECT COUNT(*) as count FROM extracted_members WHERE source_chat_id = ?",
            (str(group_id),)
        )
        count = result['count'] if result and hasattr(result, '__getitem__') else 0
        
        self.send_event("collected-users-count", {
            "groupId": group_id,
            "count": count
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("collected-users-count", {
            "groupId": group_id,
            "count": 0
        })


# ==================== Unified Contacts Handlers ====================

async def handle_unified_contacts_sync(self, payload: Dict[str, Any]):
    """åŒæ­¥æ‰€æœ‰ä¾†æºæ•¸æ“šåˆ°çµ±ä¸€è¯ç¹«äººè¡¨"""
    import sys
    import traceback
    from unified_contacts import get_unified_contacts_manager
    
    try:
        print(f"[Backend] ========== SYNC UNIFIED CONTACTS START ==========", file=sys.stderr)
        self.send_log("ğŸ”„ é–‹å§‹åŒæ­¥æ•¸æ“š...", "info")
        
        # ğŸ”§ FIX: ç¢ºä¿æ•¸æ“šåº«é€£æ¥
        await db.connect()
        print(f"[Backend] Database connected", file=sys.stderr)
        
        manager = get_unified_contacts_manager(db)
        print(f"[Backend] Manager initialized", file=sys.stderr)
        
        stats = await manager.sync_from_sources()
        print(f"[Backend] Sync completed: {stats}", file=sys.stderr)
        
        self.send_event("unified-contacts:sync-result", {
            "success": True,
            "stats": stats
        })
        self.send_log(f"âœ… åŒæ­¥å®Œæˆ: æ–°å¢ {stats['synced']} æ¢, æ›´æ–° {stats['updated']} æ¢", "success")
        print(f"[Backend] ========== SYNC UNIFIED CONTACTS END ==========", file=sys.stderr)
        
    except Exception as e:
        print(f"[Backend] Unified contacts sync error: {e}", file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        self.send_event("unified-contacts:sync-result", {
            "success": False,
            "error": str(e)
        })
        self.send_log(f"âŒ åŒæ­¥å¤±æ•—: {e}", "error")


async def handle_unified_contacts_get(self, payload: Dict[str, Any]):
    """ç²å–çµ±ä¸€è¯ç¹«äººåˆ—è¡¨"""
    import sys
    from unified_contacts import get_unified_contacts_manager
    
    try:
        print(f"[Backend] Getting unified contacts with payload: {payload}", file=sys.stderr)
        manager = get_unified_contacts_manager(db)
        
        contacts, total = await manager.get_contacts(
            contact_type=payload.get('contactType'),
            source_type=payload.get('sourceType'),
            status=payload.get('status'),
            tags=payload.get('tags'),
            search=payload.get('search'),
            order_by=payload.get('orderBy', 'created_at DESC'),
            limit=payload.get('limit', 100),
            offset=payload.get('offset', 0)
        )
        
        print(f"[Backend] Found {len(contacts)} contacts (total: {total})", file=sys.stderr)
        
        self.send_event("unified-contacts:list", {
            "success": True,
            "contacts": contacts,
            "total": total,
            "limit": payload.get('limit', 100),
            "offset": payload.get('offset', 0)
        })
        
    except Exception as e:
        print(f"[Backend] Get unified contacts error: {e}", file=sys.stderr)
        self.send_event("unified-contacts:list", {
            "success": False,
            "error": str(e),
            "contacts": [],
            "total": 0
        })


async def handle_unified_contacts_stats(self, payload: Dict[str, Any]):
    """ç²å–çµ±ä¸€è¯ç¹«äººçµ±è¨ˆ"""
    import sys
    from unified_contacts import get_unified_contacts_manager
    
    try:
        manager = get_unified_contacts_manager(db)
        stats = await manager.get_stats()
        
        self.send_event("unified-contacts:stats", {
            "success": True,
            "stats": stats
        })
        
    except Exception as e:
        print(f"[Backend] Get unified contacts stats error: {e}", file=sys.stderr)
        self.send_event("unified-contacts:stats", {
            "success": False,
            "error": str(e)
        })


async def handle_unified_contacts_update(self, payload: Dict[str, Any]):
    """æ›´æ–°å–®å€‹è¯ç¹«äºº"""
    import sys
    from unified_contacts import get_unified_contacts_manager
    
    try:
        telegram_id = payload.get('telegramId')
        updates = payload.get('updates', {})
        
        if not telegram_id:
            raise ValueError("Missing telegramId")
        
        manager = get_unified_contacts_manager(db)
        success = await manager.update_contact(telegram_id, updates)
        
        self.send_event("unified-contacts:update-result", {
            "success": success,
            "telegramId": telegram_id
        })
        
    except Exception as e:
        print(f"[Backend] Update unified contact error: {e}", file=sys.stderr)
        self.send_event("unified-contacts:update-result", {
            "success": False,
            "error": str(e)
        })


async def handle_unified_contacts_add_tags(self, payload: Dict[str, Any]):
    """æ‰¹é‡æ·»åŠ æ¨™ç±¤"""
    import sys
    from unified_contacts import get_unified_contacts_manager
    
    try:
        telegram_ids = payload.get('telegramIds', [])
        tags = payload.get('tags', [])
        
        manager = get_unified_contacts_manager(db)
        updated = await manager.add_tags(telegram_ids, tags)
        
        self.send_event("unified-contacts:add-tags-result", {
            "success": True,
            "updated": updated
        })
        self.send_log(f"âœ… å·²ç‚º {updated} å€‹è¯ç¹«äººæ·»åŠ æ¨™ç±¤", "info")
        
    except Exception as e:
        print(f"[Backend] Add tags error: {e}", file=sys.stderr)
        self.send_event("unified-contacts:add-tags-result", {
            "success": False,
            "error": str(e)
        })


async def handle_unified_contacts_update_status(self, payload: Dict[str, Any]):
    """æ‰¹é‡æ›´æ–°ç‹€æ…‹ (å¸¶é›™å‘åŒæ­¥)"""
    import sys
    from unified_contacts import get_unified_contacts_manager
    
    try:
        telegram_ids = payload.get('telegramIds', [])
        status = payload.get('status')
        sync_to_leads = payload.get('syncToLeads', True)  # ğŸ†• æ˜¯å¦åŒæ­¥åˆ° leads
        
        manager = get_unified_contacts_manager(db)
        
        # ğŸ†• ä½¿ç”¨å¸¶åŒæ­¥çš„æ›´æ–°æ–¹æ³•
        result = await manager.update_status_with_sync(telegram_ids, status, sync_to_leads)
        
        self.send_event("unified-contacts:update-status-result", {
            "success": True,
            "updated": result['contacts_updated'],
            "leads_updated": result['leads_updated']  # ğŸ†• è¿”å› leads æ›´æ–°æ•¸
        })
        
        # ğŸ†• å¦‚æœæœ‰åŒæ­¥åˆ° leadsï¼Œé€šçŸ¥å‰ç«¯æ›´æ–° leads åˆ—è¡¨
        if result['leads_updated'] > 0:
            await self.send_leads_update()
        
    except Exception as e:
        print(f"[Backend] Update status error: {e}", file=sys.stderr)
        self.send_event("unified-contacts:update-status-result", {
            "success": False,
            "error": str(e)
        })


async def handle_unified_contacts_delete(self, payload: Dict[str, Any]):
    """
    æ‰¹é‡åˆªé™¤è¯ç¹«äºº
    åŒæ™‚åˆªé™¤è³‡æºä¸­å¿ƒå’Œç™¼é€æ§åˆ¶å°çš„æ•¸æ“šï¼Œç¢ºä¿ä¸€è‡´æ€§
    """
    import sys
    from unified_contacts import get_unified_contacts_manager
    
    try:
        telegram_ids = payload.get('telegramIds', [])
        print(f"[Backend] Deleting {len(telegram_ids)} contacts from resource center", file=sys.stderr)
        
        manager = get_unified_contacts_manager(db)
        result = await manager.delete_contacts(telegram_ids)
        
        # ç™¼é€åˆªé™¤çµæœ
        self.send_event("unified-contacts:delete-result", {
            "success": True,
            "deleted": result.get('unified_deleted', 0),
            "leadsDeleted": result.get('leads_deleted', 0)
        })
        
        # ğŸ†• å¦‚æœæœ‰åˆªé™¤ leadsï¼Œç™¼é€ leads-updated äº‹ä»¶åŒæ­¥ç™¼é€æ§åˆ¶å°
        if result.get('leads_deleted', 0) > 0:
            await self.send_leads_update()
            self.send_log(f"âœ… å·²åˆªé™¤ {result['leads_deleted']} å€‹è¯ç¹«äººï¼ˆè³‡æºä¸­å¿ƒ + ç™¼é€æ§åˆ¶å°ï¼‰", "info")
        else:
            self.send_log(f"âœ… å·²åˆªé™¤ {result.get('unified_deleted', 0)} å€‹è¯ç¹«äºº", "info")
        
    except Exception as e:
        print(f"[Backend] Delete contacts error: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        self.send_event("unified-contacts:delete-result", {
            "success": False,
            "error": str(e)
        })

