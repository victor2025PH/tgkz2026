"""
Extracted handler implementations: members
Auto-generated by refactor_main.py
"""
import json
import sys
import time
import asyncio
import traceback
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from service_context import get_service_context

from database import db
import re
from service_locator import member_extraction_service
# All handlers receive (self, payload) where self is BackendService instance.
# They are called via: await handler_impl(self, payload)
# Inside, use self.db, self.send_event(), self.telegram_manager, etc.
# This is a transitional pattern - later, replace self.xxx with ctx.xxx


# ==================== æˆå“¡æå–è™•ç†å™¨ ====================

async def handle_batch_refresh_member_counts(self, payload: Dict[str, Any]):
    """ğŸ†• æ‰¹é‡åˆ·æ–°ç¾¤çµ„æˆå“¡æ•¸"""
    import sys
    print(f"[Backend] handle_batch_refresh_member_counts called", file=sys.stderr)
    
    groups = payload.get('groups', [])
    if not groups:
        self.send_event("batch-refresh-member-counts-complete", {
            "success": True,
            "total": 0,
            "updated": 0,
            "failed": 0
        })
        return
    
    try:
        # æ‰¾åˆ°å¯ç”¨çš„å®¢æˆ¶ç«¯
        client = None
        for c in self.telegram_manager._clients.values():
            if c and c.is_connected:
                client = c
                break
        
        if not client:
            self.send_event("batch-refresh-member-counts-complete", {
                "success": False,
                "error": "æ²’æœ‰å¯ç”¨çš„åœ¨ç·šå¸³è™Ÿ"
            })
            return
        
        updated_count = 0
        failed_count = 0
        
        for i, group in enumerate(groups):
            try:
                group_id = group.get('id')
                url = group.get('url', '')
                
                # è§£æç¾¤çµ„æ¨™è­˜
                chat_identifier = url
                if url.startswith('https://t.me/'):
                    chat_identifier = url.replace('https://t.me/', '')
                if not chat_identifier.startswith('@') and not chat_identifier.startswith('+'):
                    chat_identifier = f"@{chat_identifier}"
                
                # ç²å–æˆå“¡æ•¸
                chat = await client.get_chat(chat_identifier)
                member_count = chat.members_count or 0
                
                # æ›´æ–°æ•¸æ“šåº«
                if member_count > 0:
                    await db.update_group_member_count(url, member_count)
                    updated_count += 1
                
                # ç™¼é€é€²åº¦
                self.send_event("batch-refresh-member-counts-progress", {
                    "current": i + 1,
                    "total": len(groups),
                    "groupId": str(group_id),
                    "memberCount": member_count
                })
                
                # é¿å…è§¸ç™¼é€Ÿç‡é™åˆ¶
                await asyncio.sleep(0.5)
                
            except Exception as e:
                print(f"[Backend] Error refreshing member count for group {group.get('id')}: {e}", file=sys.stderr)
                failed_count += 1
                
                # ä»ç„¶ç™¼é€é€²åº¦
                self.send_event("batch-refresh-member-counts-progress", {
                    "current": i + 1,
                    "total": len(groups),
                    "groupId": str(group.get('id')),
                    "memberCount": 0
                })
        
        self.send_event("batch-refresh-member-counts-complete", {
            "success": True,
            "total": len(groups),
            "updated": updated_count,
            "failed": failed_count
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc()
        self.send_event("batch-refresh-member-counts-complete", {
            "success": False,
            "error": str(e)
        })


async def handle_get_group_member_count(self, payload: Dict[str, Any]):
    """ğŸ†• ç²å–ç¾¤çµ„æˆå“¡æ•¸ï¼ˆæ”¯æŒé‡æ–°ç²å–ï¼‰"""
    import sys
    print(f"[Backend] handle_get_group_member_count called with payload: {payload}", file=sys.stderr)
    
    group_id = payload.get('groupId')
    url = payload.get('url', '')
    account_phone = payload.get('accountPhone')
    
    try:
        # æ‰¾åˆ°å¯ç”¨çš„å®¢æˆ¶ç«¯
        client = None
        phone = account_phone
        
        if account_phone:
            client = self.telegram_manager.get_client(account_phone)
        
        if not client or not client.is_connected:
            # å˜—è©¦ä½¿ç”¨ä»»æ„åœ¨ç·šå¸³è™Ÿ
            for acc_phone, c in self.telegram_manager._clients.items():
                if c and c.is_connected:
                    client = c
                    phone = acc_phone
                    break
        
        if not client or not client.is_connected:
            self.send_event("group-member-count-result", {
                "success": False,
                "groupId": group_id,
                "error": "æ²’æœ‰å¯ç”¨çš„åœ¨ç·šå¸³è™Ÿ"
            })
            return
        
        # ğŸ”§ ä¿®å¾©ï¼šè§£æç¾¤çµ„æ¨™è­˜ï¼Œæ”¯æŒå¤šç¨®æ ¼å¼
        telegram_id = payload.get('telegramId') or payload.get('telegram_id')
        chat_identifier = None
        
        # å„ªå…ˆä½¿ç”¨ telegram_idï¼ˆæ•¸å­— IDï¼‰
        if telegram_id:
            try:
                chat_identifier = int(telegram_id)
                print(f"[Backend] Using telegram_id: {chat_identifier}", file=sys.stderr)
            except (ValueError, TypeError):
                chat_identifier = None
        
        # å…¶æ¬¡ä½¿ç”¨ url
        if not chat_identifier and url:
            chat_identifier = url
            if url.startswith('https://t.me/'):
                chat_identifier = url.replace('https://t.me/', '')
            if isinstance(chat_identifier, str):
                if chat_identifier.startswith('+'):
                    # ç§æœ‰ç¾¤çµ„é‚€è«‹éˆæ¥
                    chat_identifier = url
                elif chat_identifier and not chat_identifier.startswith('@'):
                    chat_identifier = f"@{chat_identifier}"
        
        if not chat_identifier:
            self.send_event("group-member-count-result", {
                "success": False,
                "groupId": group_id,
                "error": "ç¼ºå°‘ç¾¤çµ„æ¨™è­˜ï¼ˆURL æˆ– Telegram IDï¼‰"
            })
            return
        
        print(f"[Backend] Getting member count for: {chat_identifier}", file=sys.stderr)
        
        # ç²å–ç¾¤çµ„ä¿¡æ¯
        try:
            chat = await client.get_chat(chat_identifier)
            member_count = chat.members_count or 0
            
            print(f"[Backend] Got member count: {member_count}", file=sys.stderr)
            
            # æ›´æ–°æ•¸æ“šåº«
            if member_count > 0:
                await db.update_group_member_count(url, member_count)
            
            self.send_event("group-member-count-result", {
                "success": True,
                "groupId": group_id,
                "memberCount": member_count,
                "chatTitle": chat.title
            })
            
        except Exception as chat_err:
            error_str = str(chat_err).lower()
            if 'not found' in error_str or 'invalid' in error_str:
                error_msg = "ç¾¤çµ„ä¸å­˜åœ¨æˆ–ç„¡æ³•è¨ªå•"
            elif 'banned' in error_str or 'kicked' in error_str:
                error_msg = "å¸³è™Ÿè¢«è¸¢å‡ºè©²ç¾¤çµ„"
            elif 'private' in error_str:
                error_msg = "é€™æ˜¯ç§æœ‰ç¾¤çµ„ï¼Œéœ€è¦é‚€è«‹éˆæ¥"
            else:
                error_msg = f"ç²å–å¤±æ•—ï¼š{str(chat_err)}"
            
            print(f"[Backend] Error getting chat: {chat_err}", file=sys.stderr)
            self.send_event("group-member-count-result", {
                "success": False,
                "groupId": group_id,
                "error": error_msg
            })
            
    except Exception as e:
        import traceback
        traceback.print_exc()
        self.send_event("group-member-count-result", {
            "success": False,
            "groupId": group_id,
            "error": f"ç²å–æˆå“¡æ•¸å¤±æ•—ï¼š{str(e)}"
        })


async def handle_collect_users_from_history_advanced(self, payload: Dict[str, Any]):
    """ğŸ†• å¾æ­·å²æ¶ˆæ¯æ”¶é›†ç”¨æˆ¶ï¼ˆé€²éšç‰ˆï¼Œæ”¯æŒæ›´å¤šé…ç½®ï¼‰"""
    import sys
    from datetime import datetime, timedelta
    print(f"[Backend] handle_collect_users_from_history_advanced: {payload}", file=sys.stderr)
    
    group_id = payload.get('groupId')
    telegram_id = payload.get('telegramId')
    config = payload.get('config', {})
    
    # è§£æé…ç½®
    limit = config.get('limit', 200)
    time_range = config.get('timeRange', '30d')
    min_messages = config.get('minMessages', 1)
    skip_duplicates = config.get('skipDuplicates', True)
    exclude_bots = config.get('excludeBots', True)
    require_username = config.get('requireUsername', False)
    auto_sync = config.get('autoSync', True)
    
    try:
        from database import db
        from config import config
        await db.connect()
        
        chat_id = str(telegram_id) if telegram_id else str(group_id)
        
        # æ§‹å»ºæ™‚é–“æ¢ä»¶
        time_condition = ""
        if time_range == '7d':
            cutoff = (datetime.now() - timedelta(days=7)).isoformat()
            time_condition = f"AND timestamp >= '{cutoff}'"
        elif time_range == '30d':
            cutoff = (datetime.now() - timedelta(days=30)).isoformat()
            time_condition = f"AND timestamp >= '{cutoff}'"
        elif time_range == '90d':
            cutoff = (datetime.now() - timedelta(days=90)).isoformat()
            time_condition = f"AND timestamp >= '{cutoff}'"
        
        # ç™¼é€é€²åº¦æ›´æ–°
        self.send_event("history-collection-progress", {
            "groupId": group_id,
            "current": 0,
            "total": 100,
            "status": "æ­£åœ¨æŸ¥è©¢æ­·å²æ¶ˆæ¯..."
        })
        
        # æ§‹å»ºæŸ¥è©¢
        limit_clause = f"LIMIT {limit}" if limit > 0 else ""
        
        query = f"""
            SELECT 
                sender_id,
                sender_name,
                sender_username,
                COUNT(*) as message_count,
                MAX(timestamp) as last_message_at
            FROM chat_history 
            WHERE chat_id = ? 
              AND sender_id IS NOT NULL 
              AND sender_id != ''
              {time_condition}
            GROUP BY sender_id
            HAVING message_count >= ?
            ORDER BY message_count DESC
            {limit_clause}
        """
        
        results = await db.fetch_all(query, (chat_id, min_messages))
        
        if not results:
            self.send_event("history-collection-result", {
                "groupId": group_id,
                "success": False,
                "error": "æœªæ‰¾åˆ°ç¬¦åˆæ¢ä»¶çš„ç”¨æˆ¶"
            })
            return
        
        total = len(results)
        collected_count = 0
        new_count = 0
        updated_count = 0
        skipped_count = 0
        
        # è³ªé‡çµ±è¨ˆ
        high_activity = 0
        medium_activity = 0
        low_activity = 0
        
        for idx, row in enumerate(results):
            try:
                sender_id = row['sender_id'] if hasattr(row, '__getitem__') else row[0]
                sender_name = row['sender_name'] if hasattr(row, '__getitem__') else row[1]
                sender_username = row['sender_username'] if hasattr(row, '__getitem__') else row[2]
                message_count = row['message_count'] if hasattr(row, '__getitem__') else row[3]
                last_message = row['last_message_at'] if hasattr(row, '__getitem__') else row[4]
                
                if not sender_id:
                    continue
                
                # æª¢æŸ¥æ˜¯å¦éœ€è¦ç”¨æˆ¶å
                if require_username and not sender_username:
                    skipped_count += 1
                    continue
                
                # æª¢æŸ¥æ˜¯å¦æ˜¯æ©Ÿå™¨äººï¼ˆç°¡å–®åˆ¤æ–·ï¼‰
                if exclude_bots:
                    if sender_username and sender_username.lower().endswith('bot'):
                        skipped_count += 1
                        continue
                
                # æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
                if skip_duplicates:
                    existing = await db.fetch_one(
                        "SELECT id FROM collected_users WHERE telegram_id = ?",
                        (str(sender_id),)
                    )
                    if existing:
                        updated_count += 1
                        # æ›´æ–°ç¾æœ‰è¨˜éŒ„
                        await db.execute(
                            """UPDATE collected_users 
                               SET message_count = ?, last_message_at = ?, updated_at = CURRENT_TIMESTAMP
                               WHERE telegram_id = ?""",
                            (message_count, last_message, str(sender_id))
                        )
                        continue
                
                # æ’å…¥æ–°ç”¨æˆ¶
                user_data = {
                    'telegram_id': str(sender_id),
                    'username': sender_username or '',
                    'first_name': sender_name or '',
                    'last_name': '',
                    'source_groups': [chat_id],
                    'collected_by': 'history_scan',
                    'message_count': message_count,
                    'last_message_at': last_message
                }
                
                user_id = await db.upsert_collected_user(user_data)
                collected_count += 1
                if user_id > 0:
                    new_count += 1
                
                # çµ±è¨ˆè³ªé‡
                if message_count >= 10:
                    high_activity += 1
                elif message_count >= 3:
                    medium_activity += 1
                else:
                    low_activity += 1
                
                # ç™¼é€é€²åº¦
                if idx % 10 == 0:
                    self.send_event("history-collection-progress", {
                        "groupId": group_id,
                        "current": idx + 1,
                        "total": total,
                        "status": f"å·²è™•ç† {idx + 1}/{total} ä½ç”¨æˆ¶"
                    })
                    
            except Exception as row_err:
                print(f"[Backend] Error processing row: {row_err}", file=sys.stderr)
                continue
        
        self.send_log(f"âœ… æ­·å²æ¶ˆæ¯æ”¶é›†å®Œæˆ: å…± {collected_count} ä½ç”¨æˆ¶ï¼Œæ–°å¢ {new_count} ä½", "success")
        
        self.send_event("history-collection-result", {
            "groupId": group_id,
            "success": True,
            "result": {
                "success": True,
                "collected": collected_count,
                "newUsers": new_count,
                "updated": updated_count,
                "skipped": skipped_count,
                "quality": {
                    "highActivity": high_activity,
                    "mediumActivity": medium_activity,
                    "lowActivity": low_activity
                }
            }
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_log(f"âŒ æ”¶é›†å¤±æ•—: {str(e)}", "error")
        self.send_event("history-collection-result", {
            "groupId": group_id,
            "success": False,
            "error": str(e)
        })


async def handle_collect_users_from_history(self, payload: Dict[str, Any]):
    """ğŸ†• å¾æ­·å²æ¶ˆæ¯ä¸­æ”¶é›†ç”¨æˆ¶ï¼ˆæ›¿ä»£æˆå“¡æå–ï¼‰"""
    import sys
    print(f"[Backend] ========== handle_collect_users_from_history CALLED ==========", file=sys.stderr)
    
    group_id = payload.get('groupId')
    telegram_id = payload.get('telegramId')
    limit = payload.get('limit', 500)
    
    try:
        from database import db
        await db.connect()
        
        self.send_log(f"ğŸ”„ æ­£åœ¨å¾æ­·å²æ¶ˆæ¯ä¸­æ”¶é›†ç”¨æˆ¶...", "info")
        
        # æŸ¥è©¢ç¾¤çµ„çš„æ­·å²æ¶ˆæ¯ä¸­çš„å”¯ä¸€ç™¼é€è€…
        chat_id = str(telegram_id) if telegram_id else str(group_id)
        
        # å¾ chat_history è¡¨ç²å–å”¯ä¸€ç™¼é€è€…
        query = """
            SELECT DISTINCT 
                sender_id,
                sender_name,
                sender_username,
                COUNT(*) as message_count,
                MAX(timestamp) as last_message_at
            FROM chat_history 
            WHERE chat_id = ? AND sender_id IS NOT NULL AND sender_id != ''
            GROUP BY sender_id
            ORDER BY message_count DESC
            LIMIT ?
        """
        
        results = await db.fetch_all(query, (chat_id, limit))
        
        if not results:
            self.send_log(f"âš ï¸ æœªæ‰¾åˆ°æ­·å²æ¶ˆæ¯ï¼Œè«‹å…ˆé–‹å•Ÿç¾¤çµ„ç›£æ§", "warning")
            self.send_event("collect-from-history-result", {
                "groupId": group_id,
                "success": False,
                "error": "æœªæ‰¾åˆ°æ­·å²æ¶ˆæ¯ï¼Œè«‹å…ˆé–‹å•Ÿç¾¤çµ„ç›£æ§ä¸€æ®µæ™‚é–“",
                "collected": 0,
                "total": 0
            })
            return
        
        # ğŸ”§ Phase8-P1: å¸¶é€²åº¦åé¥‹çš„æ”¶é›†å¾ªç’°
        collected_count = 0
        new_count = 0
        total = len(results)
        
        # åˆå§‹é€²åº¦
        self.send_event("collect-from-history-progress", {
            "groupId": group_id,
            "current": 0,
            "total": total,
            "collected": 0,
            "newUsers": 0,
            "status": f"é–‹å§‹è™•ç† {total} ä½ç”¨æˆ¶..."
        })
        
        for idx, row in enumerate(results):
            try:
                sender_id = row['sender_id'] if hasattr(row, '__getitem__') else row[0]
                sender_name = row['sender_name'] if hasattr(row, '__getitem__') else row[1]
                sender_username = row['sender_username'] if hasattr(row, '__getitem__') else row[2]
                message_count = row['message_count'] if hasattr(row, '__getitem__') else row[3]
                last_message = row['last_message_at'] if hasattr(row, '__getitem__') else row[4]
                
                if not sender_id:
                    continue
                
                user_data = {
                    'telegram_id': str(sender_id),
                    'username': sender_username or '',
                    'first_name': sender_name or '',
                    'last_name': '',
                    'source_groups': [chat_id],
                    'collected_by': 'history_scan',
                    'message_count': message_count,
                    'last_message_at': last_message
                }
                
                user_id = await db.upsert_collected_user(user_data)
                collected_count += 1
                if user_id > 0:
                    new_count += 1
                
                # æ¯ 5 å€‹ç”¨æˆ¶ç™¼é€é€²åº¦æ›´æ–°ï¼ˆæ¯”æ¯ 10 å€‹æ›´ç²¾ç´°ï¼‰
                if (idx + 1) % 5 == 0 or idx == total - 1:
                    self.send_event("collect-from-history-progress", {
                        "groupId": group_id,
                        "current": idx + 1,
                        "total": total,
                        "collected": collected_count,
                        "newUsers": new_count,
                        "status": f"å·²è™•ç† {idx + 1}/{total}"
                    })
                    
            except Exception as row_err:
                print(f"[Backend] Error processing row: {row_err}", file=sys.stderr)
                continue
        
        # ğŸ”§ Phase8-P1-2: æ”¶é›†å®Œæˆå¾Œæ›´æ–°ç·©å­˜çµ±è¨ˆ
        try:
            await db.execute(
                "UPDATE monitored_groups SET cached_user_count = ?, cached_msg_count = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ? OR telegram_id = ?",
                (collected_count, total, group_id, chat_id)
            )
        except Exception:
            pass  # åˆ—å¯èƒ½é‚„æœªæ·»åŠ 
        
        self.send_log(f"âœ… å¾æ­·å²æ¶ˆæ¯æ”¶é›†å®Œæˆ: å…± {collected_count} ä½ç”¨æˆ¶ï¼Œæ–°å¢ {new_count} ä½", "success")
        
        self.send_event("collect-from-history-result", {
            "groupId": group_id,
            "success": True,
            "collected": collected_count,
            "newUsers": new_count,
            "total": len(results)
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_log(f"âŒ æ”¶é›†å¤±æ•—: {str(e)}", "error")
        self.send_event("collect-from-history-result", {
            "groupId": group_id,
            "success": False,
            "error": str(e),
            "collected": 0
        })


async def handle_extract_members(self, payload: Dict[str, Any]):
    """æå–ç¾¤çµ„æˆå“¡"""
    import sys
    print(f"[Backend] ========== handle_extract_members CALLED ==========", file=sys.stderr)
    print(f"[Backend] Payload: {payload}", file=sys.stderr)
    self.send_log("ğŸ“¥ æ”¶åˆ°æˆå“¡æå–è«‹æ±‚", "info")
    
    try:
        # ğŸ”§ FIX: å„ªå…ˆä½¿ç”¨ telegramIdï¼ˆæ•¸å­— IDï¼‰ï¼Œæ”¯æŒç§æœ‰ç¾¤çµ„
        telegram_id = payload.get('telegramId')
        chat_id = payload.get('chatId')
        username = payload.get('username')
        phone = payload.get('phone')
        resource_id = payload.get('resourceId') or payload.get('groupId')
        group_name = payload.get('groupName') or payload.get('groupTitle') or ''
        limit = payload.get('limit', 100)
        
        # ğŸ†• Phase5: æ¯æ—¥æå–é…é¡æª¢æŸ¥ï¼ˆé˜²æ­¢éåº¦ä½¿ç”¨è¢« Telegram å°è™Ÿï¼‰
        DAILY_EXTRACT_LIMIT = 5000  # æ¯æ—¥æœ€å¤šæå– 5000 äºº
        daily_quota = None
        try:
            from database import db as quota_db
            await quota_db.connect()
            today_count_row = await quota_db.fetch_one(
                """SELECT COALESCE(SUM(extracted_count), 0) as total 
                   FROM member_extraction_logs 
                   WHERE status = 'success' AND date(created_at) = date('now')""",
                ()
            )
            today_extracted = 0
            if today_count_row:
                today_extracted = today_count_row.get('total') if hasattr(today_count_row, 'get') else today_count_row[0]
                today_extracted = today_extracted or 0
            
            remaining = max(0, DAILY_EXTRACT_LIMIT - today_extracted)
            daily_quota = {
                "used": today_extracted,
                "limit": DAILY_EXTRACT_LIMIT,
                "remaining": remaining
            }
            
            if remaining <= 0:
                self.send_log(f"âš ï¸ ä»Šæ—¥æå–é…é¡å·²ç”¨å®Œ ({today_extracted}/{DAILY_EXTRACT_LIMIT})", "warning")
                self.send_event("members-extracted", {
                    "resourceId": resource_id,
                    "success": False,
                    "error": f"ä»Šæ—¥æå–é…é¡å·²é”ä¸Šé™ ({DAILY_EXTRACT_LIMIT} äºº)ï¼Œæ˜å¤©å°‡è‡ªå‹•é‡ç½®",
                    "error_code": "E4005_QUOTA_EXCEEDED",
                    "error_details": {
                        "code": "E4005",
                        "reason": f"ä»Šæ—¥å·²æå– {today_extracted} äººï¼Œé”åˆ°æ¯æ—¥ä¸Šé™ {DAILY_EXTRACT_LIMIT}",
                        "suggestion": "è«‹æ˜å¤©å†è©¦ï¼Œæˆ–å‡ç´šå¸³æˆ¶æé«˜é…é¡",
                        "action": "quota_exceeded",
                        "daily_quota": daily_quota
                    },
                    "members": [], "extracted": 0, "total": 0
                })
                return
            
            # è‡ªå‹•é™åˆ¶ limit ä¸è¶…éå‰©é¤˜é…é¡
            if limit > remaining:
                limit = remaining
                self.send_log(f"âš ï¸ å·²èª¿æ•´æå–ä¸Šé™ç‚º {limit}ï¼ˆä»Šæ—¥å‰©é¤˜é…é¡ï¼‰", "info")
                
        except Exception as quota_err:
            print(f"[Backend] Quota check error (non-fatal): {quota_err}", file=sys.stderr)
        
        # ğŸ†• Phase: Payload è‡ªå‹•è£œå…¨ â€” 5 å€‹å‰ç«¯å…¥å£ payload ä¸ä¸€è‡´ï¼Œå¾ DB å¡«å……ç¼ºå¤±å­—æ®µ
        if resource_id and (not telegram_id or not username or not phone):
            try:
                from database import db as _autofill_db
                await _autofill_db.connect()
                full_resource = await _autofill_db.fetch_one(
                    "SELECT telegram_id, username, title, joined_by_phone FROM discovered_resources WHERE id = ?",
                    (resource_id,)
                )
                if full_resource:
                    db_tg_id = full_resource.get('telegram_id') if hasattr(full_resource, 'get') else full_resource[0]
                    db_username = full_resource.get('username') if hasattr(full_resource, 'get') else full_resource[1]
                    db_phone = full_resource.get('joined_by_phone') if hasattr(full_resource, 'get') else full_resource[3]
                    if not telegram_id and db_tg_id:
                        telegram_id = db_tg_id
                    if not username and db_username:
                        username = db_username
                    if not phone and db_phone:
                        phone = db_phone
                    print(f"[Backend] âœ“ Payload auto-filled: telegramId={telegram_id}, username={username}, phone={phone}", file=sys.stderr)
            except Exception as autofill_err:
                print(f"[Backend] Payload auto-fill error: {autofill_err}", file=sys.stderr)
        
        # å¾ filters ç²å–éæ¿¾é¸é …
        filters = payload.get('filters', {})
        filter_bots = filters.get('bots', True) if filters else payload.get('filterBots', True)
        
        # ğŸ”§ ä¿®å¾©ï¼šå„ªå…ˆä½¿ç”¨ onlineStatus å­—ç¬¦ä¸²
        online_status = None
        if filters:
            # å„ªå…ˆä½¿ç”¨æ˜ç¢ºçš„ onlineStatus å­—ç¬¦ä¸²
            online_status = filters.get('onlineStatus')
            
            # å›é€€ï¼šä½¿ç”¨å¸ƒçˆ¾å€¼
            if not online_status:
                if filters.get('online') == True:
                    online_status = 'online'
                elif filters.get('offline') == True:
                    online_status = 'offline'
        
        # é»˜èªå€¼
        if not online_status:
            online_status = 'all'
        
        filter_offline = filters.get('offline', False) if filters else payload.get('filterOffline', False)
        chinese_only = filters.get('chinese', False) if filters else False
        premium_only = filters.get('isPremium', False) if filters else False
        has_username = filters.get('hasUsername', False) if filters else False
        
        print(f"[Backend] Online status filter: {online_status}", file=sys.stderr)
        
        # ğŸ”§ FIX: æ±ºå®šä½¿ç”¨å“ªå€‹ ID
        # å„ªå…ˆç´š: telegramId > æœ‰æ•ˆçš„ username > å¾æ•¸æ“šåº«æŸ¥è©¢
        effective_chat_id = None
        
        # 1. å„ªå…ˆä½¿ç”¨ telegramIdï¼ˆå°ç§æœ‰ç¾¤çµ„æœ‰æ•ˆï¼‰
        if telegram_id and str(telegram_id).lstrip('-').isdigit():
            effective_chat_id = int(telegram_id)
            print(f"[Backend] Using telegramId: {effective_chat_id}", file=sys.stderr)
        
        # 2. å¦‚æœ chatId æ˜¯æ•¸å­— IDï¼Œä½¿ç”¨å®ƒ
        elif chat_id and str(chat_id).lstrip('-').isdigit():
            effective_chat_id = int(chat_id)
            print(f"[Backend] Using numeric chatId: {effective_chat_id}", file=sys.stderr)
        
        # 3. å¦‚æœ chatId æ˜¯æœ‰æ•ˆçš„ usernameï¼ˆä¸æ˜¯é‚€è«‹éˆæ¥æ ¼å¼ï¼‰ï¼Œä½¿ç”¨å®ƒ
        elif chat_id and not str(chat_id).startswith('+'):
            effective_chat_id = chat_id
            print(f"[Backend] Using username chatId: {effective_chat_id}", file=sys.stderr)
        
        # 4. å¾æ•¸æ“šåº«æŸ¥è©¢ telegram_id
        if not effective_chat_id:
            print(f"[Backend] No valid chat_id, trying to fetch from database...", file=sys.stderr)
            if resource_id:
                # å˜—è©¦å¾ monitored_groups è¡¨æŸ¥è©¢
                from database import db
                await db.connect()
                group = await db.fetch_one(
                    "SELECT telegram_id, link FROM monitored_groups WHERE id = ?",
                    (resource_id,)
                )
                if group:
                    db_telegram_id = group.get('telegram_id') if hasattr(group, 'get') else (group[0] if group else None)
                    if db_telegram_id:
                        effective_chat_id = int(db_telegram_id) if str(db_telegram_id).lstrip('-').isdigit() else db_telegram_id
                        print(f"[Backend] Found telegram_id from database: {effective_chat_id}", file=sys.stderr)
        
        print(f"[Backend] extract-members: effective_chat_id={effective_chat_id}, resource_id={resource_id}, limit={limit}", file=sys.stderr)
        print(f"[Backend] Filters: bots={filter_bots}, offline={filter_offline}, chinese={chinese_only}", file=sys.stderr)
        
        if not effective_chat_id:
            self.send_event("members-extracted", {
                "resourceId": resource_id,
                "success": False,
                "error": "ç¾¤çµ„ ID ä¸èƒ½ç‚ºç©ºã€‚å°æ–¼ç§æœ‰ç¾¤çµ„ï¼Œéœ€è¦å…ˆç²å–å…¶ Telegram IDã€‚",
                "error_code": "E4004_NO_CHAT_ID",
                "error_details": {
                    "code": "E4004",
                    "reason": "ç„¡æ³•ç¢ºå®šç¾¤çµ„æ¨™è­˜",
                    "suggestion": "è«‹å…ˆé€šéæœç´¢ç™¼ç¾æˆ–æ‰‹å‹•è¼¸å…¥ç¾¤çµ„éˆæ¥ä¾†ç²å–ç¾¤çµ„ä¿¡æ¯",
                    "action": "go_to_search"
                },
                "members": [],
                "extracted": 0,
                "total": 0
            })
            return
        
        chat_id = effective_chat_id
        
        # ğŸ”§ P0 FIX: å„ªå…ˆä½¿ç”¨å·²åŠ å…¥ç¾¤çµ„çš„å¸³è™Ÿ
        if not phone:
            from database import db
            await db.connect()
            
            # 1. å˜—è©¦å¾ discovered_resources ç²å– joined_by_phone å’Œ joined_at
            # ğŸ”§ P1 å„ªåŒ–ï¼šåŒæ™‚ç²å– joined_at ç”¨æ–¼æ™ºèƒ½å»¶é²
            try:
                resource = None
                joined_at_str = None
                
                # 1a. æŒ‰ resource_id æŸ¥è©¢
                if resource_id:
                    resource = await db.fetch_one(
                        "SELECT joined_by_phone, telegram_id, joined_at FROM discovered_resources WHERE id = ?",
                        (resource_id,)
                    )
                    print(f"[Backend] Query by resource_id={resource_id}: found={resource is not None}", file=sys.stderr)
                
                # 1b. æŒ‰ telegram_id æŸ¥è©¢ â€” ğŸ†• å˜—è©¦å…©ç¨®æ ¼å¼ï¼ˆåŸå§‹ ID + -100 å‰ç¶´ï¼‰
                if not resource and telegram_id:
                    tid_str = str(telegram_id)
                    resource = await db.fetch_one(
                        "SELECT joined_by_phone, telegram_id, joined_at FROM discovered_resources WHERE telegram_id = ?",
                        (tid_str,)
                    )
                    # ğŸ†• å¦‚æœæ²’æ‰¾åˆ°ï¼Œå˜—è©¦ -100 å‰ç¶´ï¼ˆè¶…ç´šç¾¤çµ„ ID æ ¼å¼è½‰æ›ï¼‰
                    if not resource and tid_str.lstrip('-').isdigit():
                        tid_int = int(tid_str)
                        if tid_int > 1000000000:
                            alt_tid = f"-100{tid_int}"
                            resource = await db.fetch_one(
                                "SELECT joined_by_phone, telegram_id, joined_at FROM discovered_resources WHERE telegram_id = ?",
                                (alt_tid,)
                            )
                            if resource:
                                print(f"[Backend] âœ“ Found with -100 prefix: {alt_tid}", file=sys.stderr)
                        elif tid_str.startswith('-100') and len(tid_str) > 4:
                            original_tid = tid_str[4:]
                            resource = await db.fetch_one(
                                "SELECT joined_by_phone, telegram_id, joined_at FROM discovered_resources WHERE telegram_id = ?",
                                (original_tid,)
                            )
                            if resource:
                                print(f"[Backend] âœ“ Found with original ID: {original_tid}", file=sys.stderr)
                    print(f"[Backend] Query by telegram_id={telegram_id}: found={resource is not None}", file=sys.stderr)
                
                # 1c. æŒ‰ username æŸ¥è©¢
                if not resource and username:
                    resource = await db.fetch_one(
                        "SELECT joined_by_phone, telegram_id, joined_at FROM discovered_resources WHERE username = ?",
                        (username.lstrip('@'),)
                    )
                    print(f"[Backend] Query by username={username}: found={resource is not None}", file=sys.stderr)
                
                if resource:
                    joined_phone = resource.get('joined_by_phone') if hasattr(resource, 'get') else resource[0]
                    joined_at_str = resource.get('joined_at') if hasattr(resource, 'get') else (resource[2] if len(resource) > 2 else None)
                    print(f"[Backend] Found joined_by_phone={joined_phone}, joined_at={joined_at_str}", file=sys.stderr)
                    
                    # ğŸ†• Phase3: è‡ªé©æ‡‰æ™ºèƒ½ç­‰å¾… â€” å…ˆå˜—è©¦è§£æç¾¤çµ„ï¼Œå¤±æ•—å†ç­‰å¾…
                    if joined_at_str and joined_phone and joined_phone in self.telegram_manager.clients:
                        try:
                            from datetime import datetime
                            if isinstance(joined_at_str, str):
                                joined_at = datetime.fromisoformat(joined_at_str.replace('Z', '+00:00'))
                            else:
                                joined_at = joined_at_str
                            
                            time_since_join = (datetime.now() - joined_at.replace(tzinfo=None)).total_seconds()
                            
                            # åªåœ¨æœ€è¿‘ 120 ç§’å…§åŠ å…¥çš„ç¾¤çµ„æ‰éœ€è¦æ™ºèƒ½ç­‰å¾…
                            if time_since_join < 120:
                                # å…ˆå˜—è©¦ç›´æ¥è§£æç¾¤çµ„å¯¦é«” â€” å¦‚æœæˆåŠŸèªªæ˜å·²åŒæ­¥
                                test_client = self.telegram_manager.clients.get(joined_phone)
                                if test_client and test_client.is_connected:
                                    try:
                                        test_target = effective_chat_id
                                        test_chat = await test_client.get_chat(test_target)
                                        if test_chat:
                                            # è§£ææˆåŠŸ â€” ç„¡éœ€ç­‰å¾…
                                            self.send_log(f"âœ“ ç¾¤çµ„å·²åŒæ­¥ (åŠ å…¥ {int(time_since_join)}s å‰)", "info")
                                            print(f"[Backend] Smart wait: chat resolved immediately after {int(time_since_join)}s", file=sys.stderr)
                                    except Exception as resolve_err:
                                        resolve_err_str = str(resolve_err)
                                        if 'PEER_ID_INVALID' in resolve_err_str or 'not found' in resolve_err_str.lower():
                                            # è§£æå¤±æ•— â€” éœ€è¦ç­‰å¾…ï¼Œä½†ç”¨è‡ªé©æ‡‰å»¶é²
                                            adaptive_wait = min(max(5, int(15 - time_since_join / 8)), 20)
                                            self.send_log(f"â³ ç¾¤çµ„åŒæ­¥ä¸­ (åŠ å…¥ {int(time_since_join)}s å‰)ï¼Œç­‰å¾… {adaptive_wait}s...", "info")
                                            self.send_event("members-extraction-progress", {
                                                "resourceId": resource_id,
                                                "status": "waiting",
                                                "message": f"ç­‰å¾…ç¾¤çµ„åŒæ­¥ ({adaptive_wait}s)...",
                                                "extracted": 0,
                                                "total": 0
                                            })
                                            await asyncio.sleep(adaptive_wait)
                                            self.send_log(f"âœ“ åŒæ­¥ç­‰å¾…å®Œæˆ", "info")
                                        else:
                                            print(f"[Backend] Smart wait: unexpected error: {resolve_err}", file=sys.stderr)
                        except Exception as dt_err:
                            print(f"[Backend] Error in smart wait: {dt_err}", file=sys.stderr)
                    
                    if joined_phone and joined_phone in self.telegram_manager.clients:
                        phone = joined_phone
                        print(f"[Backend] âœ“ Using joined_by_phone from discovered_resources: {phone}", file=sys.stderr)
                    elif joined_phone:
                        print(f"[Backend] âš  joined_by_phone {joined_phone} not in connected clients", file=sys.stderr)
            except Exception as e:
                print(f"[Backend] Error fetching joined_by_phone: {e}", file=sys.stderr)
            
            # 2. å˜—è©¦å¾ monitored_groups ç²å– phone â€” ğŸ†• å…¼å®¹å…©ç¨® telegram_id æ ¼å¼
            if not phone:
                try:
                    chat_id_str = str(effective_chat_id)
                    # ğŸ†• æ§‹å»ºå¯èƒ½çš„ telegram_id æ ¼å¼åˆ—è¡¨
                    tid_variants = [chat_id_str]
                    if chat_id_str.lstrip('-').isdigit():
                        tid_int = int(chat_id_str)
                        if tid_int > 1000000000:
                            tid_variants.append(f"-100{tid_int}")
                        elif chat_id_str.startswith('-100') and len(chat_id_str) > 4:
                            tid_variants.append(chat_id_str[4:])
                    
                    group = None
                    for tid in tid_variants:
                        group = await db.fetch_one(
                            """SELECT phone FROM monitored_groups 
                               WHERE telegram_id = ? OR link LIKE ?""",
                            (tid, f"%{tid}%")
                        )
                        if group:
                            break
                    
                    # ä¹Ÿå˜—è©¦ç”¨ username åŒ¹é…
                    if not group and username:
                        group = await db.fetch_one(
                            """SELECT phone FROM monitored_groups 
                               WHERE link LIKE ? OR name LIKE ?""",
                            (f"%{username}%", f"%{username}%")
                        )
                    
                    if group:
                        group_phone = group.get('phone') if hasattr(group, 'get') else group[0]
                        if group_phone and group_phone in self.telegram_manager.clients:
                            phone = group_phone
                            print(f"[Backend] âœ“ Using phone from monitored_groups: {phone}", file=sys.stderr)
                except Exception as e:
                    print(f"[Backend] Error fetching phone from monitored_groups: {e}", file=sys.stderr)
            
            # 3. ğŸ†• Phase3: æ™ºèƒ½è§’è‰²å›é€€ â€” å„ªå…ˆ Listener > Explorer > any
            if not phone and self.telegram_manager.clients:
                try:
                    from database import db as _db
                    connected_phones = [p for p, c in self.telegram_manager.clients.items() if c and c.is_connected]
                    if connected_phones:
                        # çµ±ä¸€ä½¿ç”¨ get_all_accountsï¼Œå¤šç§Ÿæˆ¶å®‰å…¨ï¼Œç„¶å¾ŒæŒ‰é€£æ¥ä¸­çš„ phone éæ¿¾
                        all_accounts = await _db.get_all_accounts()
                        accounts = [a for a in all_accounts if a.get('phone') in connected_phones]
                        role_map = {a['phone']: a.get('role', 'Unassigned') for a in accounts} if accounts else {}
                        
                        # å„ªå…ˆ Listenerï¼ˆç›£æ§è™Ÿé€šå¸¸å·²åŠ å…¥ç¾¤çµ„ï¼‰
                        for pref_role in ['Listener', 'Explorer', 'Unassigned', 'Sender']:
                            for p in connected_phones:
                                if role_map.get(p, 'Unassigned') == pref_role:
                                    phone = p
                                    break
                            if phone:
                                break
                except Exception as role_err:
                    print(f"[Backend] Role-based selection failed: {role_err}", file=sys.stderr)
                
                if not phone:
                    phone = list(self.telegram_manager.clients.keys())[0]
                
                role_info = role_map.get(phone, 'æœªçŸ¥') if 'role_map' in locals() else 'æœªçŸ¥'
                print(f"[Backend] âš  Using fallback phone: {phone} (role: {role_info})", file=sys.stderr)
                self.send_log(f"âš ï¸ æœªæ‰¾åˆ°å·²åŠ å…¥ç¾¤çµ„çš„å¸³è™Ÿï¼Œä½¿ç”¨ {phone[:4]}**** (è§’è‰²: {role_info})", "warning")
                self.send_log(f"ğŸ’¡ å¦‚æå–å¤±æ•—ï¼Œè«‹å…ˆä½¿ç”¨è©²å¸³è™ŸåŠ å…¥æ­¤ç¾¤çµ„", "info")
        
        self.send_log(f"ğŸ” é–‹å§‹æå–æˆå“¡: {chat_id} (å¸³è™Ÿ: {phone})", "info")
        
        # è¨­ç½®å®¢æˆ¶ç«¯
        member_extraction_service.set_clients(self.telegram_manager.clients)
        member_extraction_service.set_event_callback(self.send_event)
        
        # ğŸ†• æ¸…é™¤çµæœç·©å­˜ï¼ˆå¼·åˆ¶é‡æ–°æå–ï¼Œä¸è¿”å›èˆŠæ•¸æ“šï¼‰
        member_extraction_service.clear_result_cache(str(chat_id))
        # ä¹Ÿæ¸…é™¤ -100 å‰ç¶´æ ¼å¼çš„ç·©å­˜
        if isinstance(chat_id, int) and chat_id > 0:
            member_extraction_service.clear_result_cache(str(int(f"-100{chat_id}")))
        
        # ğŸ†• é é©—è­‰ï¼šå¿«é€Ÿæª¢æŸ¥å¸³è™Ÿæ˜¯å¦å¯ä»¥è¨ªå•æ­¤ç¾¤çµ„
        pre_check_passed = False
        if phone and phone in self.telegram_manager.clients:
            test_client = self.telegram_manager.clients[phone]
            if test_client and test_client.is_connected:
                try:
                    # å¿«é€Ÿ get_chat é©—è­‰ï¼ˆmember_extraction_service å…§éƒ¨æœƒè™•ç† -100 å‰ç¶´ï¼‰
                    test_target = chat_id
                    try:
                        await test_client.get_chat(test_target)
                        pre_check_passed = True
                    except Exception as pre_err:
                        pre_err_str = str(pre_err)
                        if 'PEER_ID_INVALID' in pre_err_str or 'ChannelInvalid' in pre_err_str:
                            # å˜—è©¦ -100 å‰ç¶´
                            if isinstance(test_target, int) and test_target > 1000000000:
                                try:
                                    alt_target = int(f"-100{test_target}")
                                    await test_client.get_chat(alt_target)
                                    pre_check_passed = True
                                    chat_id = alt_target  # æ›´æ–° chat_id
                                    self.send_log(f"âœ“ ä½¿ç”¨è¶…ç´šç¾¤çµ„ ID æ ¼å¼: {alt_target}", "info")
                                except Exception:
                                    pass
                        elif 'PEER_ID_INVALID' not in pre_err_str:
                            # å…¶ä»–é PeerIdInvalid éŒ¯èª¤ï¼Œå¯èƒ½ä»ç„¶å¯ç”¨
                            pre_check_passed = True
                    
                    if not pre_check_passed:
                        # ç•¶å‰å¸³è™Ÿç„¡æ³•è¨ªå•ï¼Œå˜—è©¦æ‰¾ä¸€å€‹å¯ä»¥çš„
                        self.send_log(f"âš ï¸ å¸³è™Ÿ {phone[:4]}**** ç„¡æ³•è¨ªå•ç¾¤çµ„ï¼Œå˜—è©¦å…¶ä»–å¸³è™Ÿ...", "warning")
                        for alt_phone, alt_client in self.telegram_manager.clients.items():
                            if alt_phone == phone or not alt_client or not alt_client.is_connected:
                                continue
                            try:
                                test_target_2 = chat_id if isinstance(chat_id, int) and chat_id < 0 else (int(f"-100{chat_id}") if isinstance(chat_id, int) and chat_id > 1000000000 else chat_id)
                                await alt_client.get_chat(test_target_2)
                                phone = alt_phone
                                chat_id = test_target_2
                                pre_check_passed = True
                                self.send_log(f"âœ“ åˆ‡æ›åˆ°å¸³è™Ÿ {phone[:4]}**** (å¯è¨ªå•ç¾¤çµ„)", "info")
                                break
                            except Exception:
                                continue
                except Exception as pre_check_err:
                    print(f"[Backend] Pre-check error (non-fatal): {pre_check_err}", file=sys.stderr)
        
        # ç™¼é€é–‹å§‹äº‹ä»¶
        self.send_event("members-extraction-progress", {
            "resourceId": resource_id,
            "status": "starting",
            "extracted": 0,
            "total": 0
        })
        
        # ğŸ†• æ™ºèƒ½é‡è©¦æ©Ÿåˆ¶ â€” ç¾åœ¨æœƒå˜—è©¦ä¸åŒå¸³è™Ÿ + è‡ªå‹• -100 å‰ç¶´ï¼ˆåœ¨ extraction_service å±¤è™•ç†ï¼‰
        MAX_RETRIES = 3
        RETRY_DELAYS = [2, 4, 6]
        result = None
        last_error = None
        tried_phones = {phone}  # è¨˜éŒ„å·²å˜—è©¦çš„å¸³è™Ÿï¼Œé¿å…é‡è¤‡
        current_phone = phone
        
        for attempt in range(MAX_RETRIES):
            try:
                if attempt > 0:
                    self.send_event("members-extraction-progress", {
                        "resourceId": resource_id,
                        "status": "retrying",
                        "message": f"æ­£åœ¨é‡è©¦ ({attempt + 1}/{MAX_RETRIES})...",
                        "extracted": 0,
                        "total": 0
                    })
                    await asyncio.sleep(RETRY_DELAYS[attempt - 1])
                    
                    # ğŸ†• ç¬¬ 2 æ¬¡åŠä¹‹å¾Œï¼šå˜—è©¦åˆ‡æ›åˆ°å…¶ä»–å¸³è™Ÿ
                    if self.telegram_manager.clients:
                        for alt_phone, alt_client in self.telegram_manager.clients.items():
                            if alt_phone not in tried_phones and alt_client and alt_client.is_connected:
                                self.send_log(f"ğŸ”„ åˆ‡æ›å¸³è™Ÿ: {current_phone[:4]}**** â†’ {alt_phone[:4]}****", "info")
                                current_phone = alt_phone
                                tried_phones.add(alt_phone)
                                break
                
                # æå–æˆå“¡ï¼ˆmember_extraction_service å…§éƒ¨å·²è‡ªå‹•è™•ç† -100 å‰ç¶´ï¼‰
                result = await member_extraction_service.extract_members(
                    chat_id=chat_id,
                    phone=current_phone,
                    limit=limit,
                    filter_bots=filter_bots,
                    filter_offline=filter_offline,
                    online_status=online_status,
                    save_to_db=True
                )
                
                if result.get('success'):
                    if attempt > 0:
                        self.send_log(f"âœ“ ç¬¬ {attempt + 1} æ¬¡é‡è©¦æˆåŠŸ (å¸³è™Ÿ: {current_phone[:4]}****)", "success")
                    break
                
                error_code = result.get('error_code', '')
                if error_code in ['PEER_ID_INVALID', 'NOT_PARTICIPANT', 'USER_NOT_PARTICIPANT', 'CHANNEL_PRIVATE']:
                    last_error = result.get('error')
                    print(f"[Backend] Retryable error: {error_code}, attempt {attempt + 1}/{MAX_RETRIES}, phone={current_phone}", file=sys.stderr)
                    
                    if attempt >= MAX_RETRIES - 1:
                        # æ‰€æœ‰é‡è©¦éƒ½å¤±æ•— â€” æä¾›ç²¾ç¢ºçš„éŒ¯èª¤ä¿¡æ¯
                        actual_reason = {
                            'PEER_ID_INVALID': 'ç•¶å‰å¸³è™ŸæœªåŠ å…¥æ­¤ç¾¤çµ„ï¼Œæˆ–ç¾¤çµ„ ID ç„¡æ³•è§£æ',
                            'NOT_PARTICIPANT': 'å¸³è™Ÿä¸æ˜¯æ­¤ç¾¤çµ„çš„æˆå“¡',
                            'USER_NOT_PARTICIPANT': 'å¸³è™Ÿä¸æ˜¯æ­¤ç¾¤çµ„çš„æˆå“¡',
                            'CHANNEL_PRIVATE': 'é€™æ˜¯ç§æœ‰ç¾¤çµ„ï¼Œéœ€è¦å…ˆåŠ å…¥'
                        }.get(error_code, 'å¸³è™Ÿç„¡æ³•è¨ªå•æ­¤ç¾¤çµ„')
                        
                        result['error'] = f"æå–å¤±æ•—ï¼š{actual_reason}"
                        result['error_code'] = 'E4001_NOT_SYNCED'
                        result['error_details'] = {
                            'code': 'E4001',
                            'reason': actual_reason,
                            'suggestion': 'è«‹å…ˆä½¿ç”¨ã€ŒåŠ å…¥ç¾¤çµ„ã€åŠŸèƒ½ï¼Œç¢ºä¿å¸³è™Ÿå·²åŠ å…¥æ­¤ç¾¤çµ„å¾Œå†æå–',
                            'action': 'auto_join',
                            'retry_after_seconds': 10,
                            'attempts': attempt + 1,
                            'tried_phones': list(tried_phones),
                            'can_auto_join': True
                        }
                        break
                else:
                    # å…¶ä»–éŒ¯èª¤ä¸é‡è©¦ â€” é™„åŠ çµæ§‹åŒ–éŒ¯èª¤ç¢¼
                    if not result.get('error_code'):
                        err_msg = result.get('error', '')
                        if 'CHAT_ADMIN_REQUIRED' in err_msg or 'ç®¡ç†å“¡' in err_msg:
                            result['error_code'] = 'E4002_ADMIN_REQUIRED'
                            result['error_details'] = {
                                'code': 'E4002',
                                'reason': 'ç¾¤çµ„é™åˆ¶äº†æˆå“¡åˆ—è¡¨è¨ªå•æ¬Šé™',
                                'suggestion': 'å¯å˜—è©¦ä½¿ç”¨ã€Œç›£æ§ç¾¤çµ„æ¶ˆæ¯ã€æ–¹å¼æ”¶é›†æ´»èºç”¨æˆ¶',
                                'action': 'suggest_monitor'
                            }
                        elif 'FLOOD' in err_msg.upper():
                            actual_wait = 120
                            try:
                                from flood_wait_handler import flood_handler as _fh
                                parsed_wait = _fh.get_wait_time_from_error(Exception(err_msg))
                                if parsed_wait:
                                    actual_wait = parsed_wait
                                    _fh.record_flood_wait(current_phone, actual_wait)
                            except Exception:
                                pass
                            result['error_code'] = 'E4003_RATE_LIMITED'
                            result['error_details'] = {
                                'code': 'E4003',
                                'reason': 'Telegram é€Ÿç‡é™åˆ¶ï¼Œè«‹æ±‚éæ–¼é »ç¹',
                                'suggestion': f'è«‹ç­‰å¾… {actual_wait} ç§’å¾Œå†è©¦',
                                'action': 'retry_later',
                                'retry_after_seconds': actual_wait
                            }
                    break
                    
            except Exception as retry_err:
                last_error = str(retry_err)
                print(f"[Backend] Extraction attempt {attempt + 1} failed: {retry_err}", file=sys.stderr)
                if attempt >= MAX_RETRIES - 1:
                    raise
        
        # å¦‚æœæ‰€æœ‰é‡è©¦éƒ½å¤±æ•—ä¸”æ²’æœ‰çµæœ
        if result is None:
            result = {
                'success': False,
                'error': last_error or 'æå–å¤±æ•—',
                'members': [],
                'extracted': 0
            }
        
        # ğŸ†• Phase2: è‡ªå‹•åŠ å…¥ä¸¦é‡è©¦ â€” ç•¶æ‰€æœ‰å¸³è™Ÿéƒ½è¿”å› PEER_ID_INVALID æ™‚
        if not result.get('success') and result.get('error_code') == 'E4001_NOT_SYNCED':
            can_join = bool(username or (telegram_id and str(telegram_id).lstrip('-').isdigit()))
            if can_join:
                self.send_log(f"ğŸš€ æ‰€æœ‰å¸³è™Ÿå‡ç„¡æ³•è¨ªå•ç¾¤çµ„ï¼Œå˜—è©¦è‡ªå‹•åŠ å…¥...", "info")
                self.send_event("members-extraction-progress", {
                    "resourceId": resource_id,
                    "status": "auto_joining",
                    "message": "å¸³è™ŸæœªåŠ å…¥ç¾¤çµ„ï¼Œæ­£åœ¨è‡ªå‹•åŠ å…¥...",
                    "extracted": 0, "total": 0
                })
                
                try:
                    # æ§‹å»ºåŠ å…¥ URL
                    if username:
                        join_url = f"https://t.me/{username.lstrip('@')}"
                    else:
                        join_url = str(telegram_id)
                    
                    # é¸æ“‡æœ€ä½³å¸³è™ŸåŠ å…¥
                    from domain.groups.handlers_impl import select_best_account
                    join_phone = await select_best_account(self.telegram_manager, db, operation='join')
                    if not join_phone:
                        join_phone = current_phone
                    
                    # åŠ å…¥ç¾¤çµ„
                    join_result = await self.telegram_manager.join_group(join_phone, join_url)
                    
                    if join_result.get('success') or 'already' in str(join_result.get('error', '')).lower():
                        self.send_log(f"âœ… å¸³è™Ÿ {join_phone[:4]}**** å·²åŠ å…¥ç¾¤çµ„", "success")
                        
                        # æ›´æ–° discovered_resources
                        try:
                            from database import db as _join_db
                            await _join_db.connect()
                            if resource_id:
                                tg_id = str(join_result.get('chat_id', '')) or str(telegram_id or '')
                                await _join_db.execute(
                                    """UPDATE discovered_resources 
                                       SET status = 'joined', joined_by_phone = ?, joined_at = CURRENT_TIMESTAMP,
                                           telegram_id = COALESCE(telegram_id, ?)
                                       WHERE id = ?""",
                                    (join_phone, tg_id, resource_id)
                                )
                        except Exception as db_err:
                            print(f"[Backend] Auto-join DB update error: {db_err}", file=sys.stderr)
                        
                        # ç­‰å¾… Telegram åŒæ­¥
                        self.send_log(f"â³ ç­‰å¾… 5 ç§’è®“ Telegram åŒæ­¥...", "info")
                        await asyncio.sleep(5)
                        
                        # æœ€çµ‚é‡è©¦æå–
                        self.send_event("members-extraction-progress", {
                            "resourceId": resource_id,
                            "status": "retrying",
                            "message": "åŠ å…¥æˆåŠŸï¼Œæ­£åœ¨é‡æ–°æå–...",
                            "extracted": 0, "total": 0
                        })
                        
                        final_result = await member_extraction_service.extract_members(
                            chat_id=chat_id,
                            phone=join_phone,
                            limit=limit,
                            filter_bots=filter_bots,
                            filter_offline=filter_offline,
                            online_status=online_status,
                            save_to_db=True
                        )
                        
                        if final_result.get('success'):
                            result = final_result
                            current_phone = join_phone
                            self.send_log(f"âœ… è‡ªå‹•åŠ å…¥å¾Œæå–æˆåŠŸï¼", "success")
                        else:
                            # åŠ å…¥æˆåŠŸä½†æå–ä»å¤±æ•—ï¼Œæ›´æ–°éŒ¯èª¤ä¿¡æ¯
                            result['error'] = f"å·²åŠ å…¥ç¾¤çµ„ä½†æå–ä»å¤±æ•—ï¼š{final_result.get('error', 'æœªçŸ¥éŒ¯èª¤')}"
                            result['error_details']['suggestion'] = 'å¸³è™Ÿå·²æˆåŠŸåŠ å…¥ç¾¤çµ„ï¼Œè«‹ç­‰å¾… 30 ç§’å¾Œæ‰‹å‹•é‡è©¦'
                            result['error_details']['action'] = 'retry_later'
                            result['error_details']['retry_after_seconds'] = 30
                            self.send_log(f"âš ï¸ å·²åŠ å…¥ä½†æå–å¤±æ•—ï¼š{final_result.get('error_code', '')}", "warning")
                    else:
                        join_error = join_result.get('error', 'åŠ å…¥å¤±æ•—')
                        self.send_log(f"âŒ è‡ªå‹•åŠ å…¥å¤±æ•—: {join_error}", "error")
                        result['error_details']['suggestion'] = f'è‡ªå‹•åŠ å…¥å¤±æ•—ï¼ˆ{join_error}ï¼‰ï¼Œè«‹æ‰‹å‹•åŠ å…¥å¾Œé‡è©¦'
                        result['error_details']['can_auto_join'] = False
                        
                except Exception as auto_join_err:
                    print(f"[Backend] Auto-join error: {auto_join_err}", file=sys.stderr)
                    self.send_log(f"âŒ è‡ªå‹•åŠ å…¥ç•°å¸¸: {auto_join_err}", "error")
        
        if result['success']:
            members = result.get('members', [])
            
            # æ‡‰ç”¨é¡å¤–çš„éæ¿¾å™¨
            filtered_members = []
            for member in members:
                # è¯äººéæ¿¾
                if chinese_only:
                    name = (member.get('first_name', '') or '') + (member.get('last_name', '') or '')
                    bio = member.get('bio', '') or ''
                    # æª¢æŸ¥æ˜¯å¦æœ‰ä¸­æ–‡å­—ç¬¦
                    import re
                    if not re.search(r'[\u4e00-\u9fff]', name + bio):
                        continue
                
                # Premium éæ¿¾
                if premium_only and not member.get('is_premium'):
                    continue
                
                # ç”¨æˆ¶åéæ¿¾
                if has_username and not member.get('username'):
                    continue
                
                filtered_members.append(member)
            
            result['members'] = filtered_members
            result['extracted'] = len(filtered_members)
            
            self.send_log(f"âœ… æå–å®Œæˆ: {len(filtered_members)} æˆå“¡ (ç¸½è¨ˆ: {len(members)})", "success")
            
            # ğŸ†• Phase3: å¤§ç¾¤çµ„ä¸Šé™æé†’ â€” Telegram API æœ€å¤šè¿”å› 10,000 æˆå“¡
            total_in_group = result.get('total_members', 0)
            if total_in_group > 10000:
                extracted_count = len(filtered_members)
                self.send_log(
                    f"âš ï¸ æ­¤ç¾¤çµ„æœ‰ {total_in_group:,} æˆå“¡ï¼ŒTelegram é™åˆ¶æœ€å¤šæå– 10,000ã€‚"
                    f"å·²æå– {extracted_count:,}ï¼Œå»ºè­°ä½¿ç”¨ã€Œç›£æ§ç¾¤çµ„æ¶ˆæ¯ã€æ–¹å¼æŒçºŒæ”¶é›†æ´»èºç”¨æˆ¶ã€‚",
                    "warning"
                )
                result['limit_warning'] = {
                    'total_in_group': total_in_group,
                    'api_limit': 10000,
                    'extracted': extracted_count,
                    'suggestion': 'monitor_messages',
                    'message': f'æ­¤ç¾¤çµ„æœ‰ {total_in_group:,} æˆå“¡ï¼ŒTelegram API é™åˆ¶æœ€å¤šæå– 10,000ã€‚å»ºè­°çµåˆã€Œç›£æ§æ¶ˆæ¯ã€æ”¶é›†æ›´å¤šæ´»èºç”¨æˆ¶ã€‚'
                }
            
            # ğŸ†• Phase3: å¢é‡åŒæ­¥åˆ° unified_contactsï¼ˆæ›¿ä»£å…¨è¡¨æƒæï¼‰
            sync_stats = {'new': 0, 'updated': 0, 'duplicate': 0}
            try:
                from unified_contacts import get_unified_contacts_manager
                from database import db as sync_db
                await sync_db.connect()
                manager = get_unified_contacts_manager(sync_db)
                
                # ä½¿ç”¨å¢é‡åŒæ­¥ â€” åªè™•ç†å‰›æå–çš„æˆå“¡ï¼ˆæ€§èƒ½æå‡ 10-100xï¼‰
                chat_title = result.get('chat_title', group_name or '')
                sync_stats = await manager.sync_members_batch(
                    members=filtered_members,
                    source_chat_id=str(chat_id or telegram_id or ''),
                    source_chat_title=chat_title
                )
                print(f"[Backend] Incremental sync: {sync_stats}", file=sys.stderr)
                
                if sync_stats['new'] > 0:
                    self.send_log(f"âœ… è³‡æºä¸­å¿ƒ: æ–°å¢ {sync_stats['new']}ï¼Œæ›´æ–° {sync_stats['updated']}", "info")
                elif sync_stats['updated'] > 0:
                    self.send_log(f"â™»ï¸ è³‡æºä¸­å¿ƒ: æ›´æ–° {sync_stats['updated']} å€‹å·²æœ‰è¯ç¹«äºº", "info")
                
                self.send_event("unified-contacts:updated", {
                    "reason": "extract-members",
                    "new": sync_stats.get('new', 0),
                    "updated": sync_stats.get('updated', 0),
                    "total_extracted": len(filtered_members)
                })
            except Exception as sync_err:
                print(f"[Backend] Incremental sync error: {sync_err}", file=sys.stderr)
            
            # ğŸ†• Phase3: è¨˜éŒ„æå–æ­·å²åˆ° member_extraction_logs
            try:
                from database import db as log_db
                await log_db.connect()
                await log_db.execute('''
                    INSERT INTO member_extraction_logs 
                    (chat_id, chat_title, total_members, extracted_count, online_count, 
                     recently_count, new_count, updated_count, duration_ms, account_phone, status)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    str(chat_id or telegram_id or ''),
                    result.get('chat_title', group_name or ''),
                    result.get('total_members', 0),
                    len(filtered_members),
                    result.get('online_count', 0),
                    result.get('recently_count', 0),
                    sync_stats.get('new', 0),
                    sync_stats.get('updated', 0),
                    0,  # duration_ms â€” å¯å¾ŒçºŒè£œå……
                    current_phone if 'current_phone' in locals() else phone,
                    'success'
                ))
                print(f"[Backend] Extraction log recorded", file=sys.stderr)
            except Exception as log_err:
                print(f"[Backend] Extraction log error: {log_err}", file=sys.stderr)
        else:
            self.send_log(f"âŒ æå–å¤±æ•—: {result['error']}", "error")
        
        # ğŸ†• Phase3: æŸ¥è©¢ä¸Šæ¬¡æå–è¨˜éŒ„ï¼ˆç”¨æ–¼å‰ç«¯é¡¯ç¤ºå¢é‡ä¿¡æ¯ï¼‰
        last_extraction = None
        if result.get('success'):
            try:
                from database import db as hist_db
                await hist_db.connect()
                chat_id_str = str(chat_id or telegram_id or '')
                last_log = await hist_db.fetch_one(
                    """SELECT extracted_count, new_count, created_at 
                       FROM member_extraction_logs 
                       WHERE chat_id = ? AND status = 'success'
                       ORDER BY created_at DESC LIMIT 1 OFFSET 1""",
                    (chat_id_str,)
                )
                if last_log:
                    last_extraction = {
                        "lastCount": last_log.get('extracted_count') if hasattr(last_log, 'get') else last_log[0],
                        "lastNewCount": last_log.get('new_count') if hasattr(last_log, 'get') else last_log[1],
                        "lastTime": last_log.get('created_at') if hasattr(last_log, 'get') else last_log[2]
                    }
            except Exception:
                pass
        
        # ğŸ†• Phase5: æ™ºèƒ½åˆ†æ â€” åˆ†æç¾¤çµ„ç‰¹å¾µä¸¦ç”Ÿæˆå»ºè­°
        insights = None
        if result.get('success') and 'filtered_members' in dir() and filtered_members:
            try:
                import re as _re
                total = len(filtered_members)
                online_cnt = sum(1 for m in filtered_members if m.get('online_status') in ('online', 'recently'))
                premium_cnt = sum(1 for m in filtered_members if m.get('is_premium'))
                username_cnt = sum(1 for m in filtered_members if m.get('username'))
                bot_cnt = sum(1 for m in filtered_members if m.get('is_bot'))
                chinese_cnt = 0
                for m in filtered_members:
                    name = (m.get('first_name', '') or '') + (m.get('last_name', '') or '')
                    if _re.search(r'[\u4e00-\u9fff]', name):
                        chinese_cnt += 1
                
                # è©•ç´šåˆ†å¸ƒ
                level_dist = {'S': 0, 'A': 0, 'B': 0, 'C': 0, 'D': 0}
                for m in filtered_members:
                    lv = m.get('value_level', 'C')
                    if lv in level_dist:
                        level_dist[lv] += 1
                
                high_value = level_dist['S'] + level_dist['A']
                
                # ç”Ÿæˆå»ºè­°
                recommendations = []
                if total > 0:
                    chinese_pct = round(chinese_cnt / total * 100)
                    premium_pct = round(premium_cnt / total * 100)
                    online_pct = round(online_cnt / total * 100)
                    username_pct = round(username_cnt / total * 100)
                    
                    if chinese_pct >= 50:
                        recommendations.append(f"ğŸ‡¨ğŸ‡³ {chinese_pct}% è¯äººç”¨æˆ¶ï¼Œé©åˆä¸­æ–‡å…§å®¹ç‡ŸéŠ·")
                    elif chinese_pct >= 20:
                        recommendations.append(f"ğŸŒ {chinese_pct}% è¯äººç”¨æˆ¶ï¼Œå»ºè­°ä¸­è‹±é›™èªæ¨é€")
                    
                    if premium_pct >= 30:
                        recommendations.append(f"â­ {premium_pct}% Premium ç”¨æˆ¶ï¼Œç¾¤çµ„è³ªé‡è¼ƒé«˜")
                    
                    if online_pct >= 40:
                        recommendations.append(f"ğŸŸ¢ {online_pct}% è¿‘æœŸæ´»èºï¼Œå»ºè­°ç«‹å³ç™¼é€ç‡ŸéŠ·æ¶ˆæ¯")
                    elif online_pct < 15:
                        recommendations.append(f"âš ï¸ åƒ… {online_pct}% è¿‘æœŸæ´»èºï¼Œç¾¤çµ„æ´»èºåº¦è¼ƒä½")
                    
                    if username_pct < 30:
                        recommendations.append(f"ğŸ“› åƒ… {username_pct}% æœ‰ç”¨æˆ¶åï¼Œç§ä¿¡è§¸é”ç‡æœ‰é™")
                    
                    if high_value >= 10:
                        recommendations.append(f"ğŸ’ {high_value} å€‹ S/A ç´šé«˜åƒ¹å€¼ç”¨æˆ¶ï¼Œå»ºè­°å„ªå…ˆè§¸é”")
                    
                    if bot_cnt > total * 0.1:
                        recommendations.append(f"ğŸ¤– {round(bot_cnt / total * 100)}% æ˜¯ Botï¼Œå»ºè­°é–‹å•Ÿæ’é™¤ Bot ç¯©é¸")
                
                insights = {
                    "chinesePercent": round(chinese_cnt / max(total, 1) * 100),
                    "premiumPercent": round(premium_cnt / max(total, 1) * 100),
                    "onlinePercent": round(online_cnt / max(total, 1) * 100),
                    "usernamePercent": round(username_cnt / max(total, 1) * 100),
                    "botPercent": round(bot_cnt / max(total, 1) * 100),
                    "highValueCount": high_value,
                    "valueLevelDistribution": level_dist,
                    "recommendations": recommendations
                }
            except Exception as insight_err:
                print(f"[Backend] Insight analysis error: {insight_err}", file=sys.stderr)
        
        # ç™¼é€å®Œæˆäº‹ä»¶ â€” ğŸ†• Phase5: åŒ…å«æ™ºèƒ½åˆ†æ
        extraction_event = {
            "resourceId": resource_id,
            "telegramId": str(telegram_id) if telegram_id else None,
            "success": result.get('success', False),
            "members": result.get('members', []),
            "extracted": result.get('extracted', 0),
            "total": result.get('total', 0),
            "onlineCount": result.get('online_count', 0),
            "error": result.get('error'),
            "error_code": result.get('error_code'),
            "error_details": result.get('error_details'),
            "limit_warning": result.get('limit_warning'),
            "usedPhone": current_phone if 'current_phone' in locals() else phone,
            "syncStats": {
                "new": sync_stats.get('new', 0) if 'sync_stats' in locals() else 0,
                "updated": sync_stats.get('updated', 0) if 'sync_stats' in locals() else 0,
                "duplicate": sync_stats.get('duplicate', 0) if 'sync_stats' in locals() else 0
            } if result.get('success') else None,
            "lastExtraction": last_extraction,
            # ğŸ†• Phase5: æ™ºèƒ½åˆ†æ
            "insights": insights,
            # ğŸ†• Phase5: é…é¡ä¿¡æ¯
            "dailyQuota": daily_quota if 'daily_quota' in locals() else None
        }
        self.send_event("members-extracted", extraction_event)
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_log(f"âŒ æå–æˆå“¡å¤±æ•—: {e}", "error")
        self.send_event("members-extracted", {
            "resourceId": payload.get('resourceId'),
            "success": False,
            "error": str(e),
            "members": [],
            "extracted": 0,
            "total": 0
        })


async def handle_extract_active_users(self, payload: Dict[str, Any]):
    """
    Phase4: å¾æ¶ˆæ¯æ­·å²ä¸­æå–æ´»èºç”¨æˆ¶
    
    èˆ‡ extract-members äº’è£œçš„æå–æ–¹å¼ï¼š
    - extract-members: ä½¿ç”¨ get_chat_members API (ä¸Šé™ 10,000)
    - extract-active-users: éæ­·æ¶ˆæ¯æ­·å²ï¼Œç™¼ç¾æ´»èºç™¼è¨€è€…
    
    é©ç”¨å ´æ™¯ï¼š
    1. ç¾¤çµ„è¶…é 10,000 æˆå“¡
    2. ç®¡ç†å“¡é™åˆ¶äº†æˆå“¡åˆ—è¡¨
    3. éœ€è¦æŒ‰æ´»èºåº¦ç¯©é¸é«˜åƒ¹å€¼ç”¨æˆ¶
    """
    try:
        resource_id = payload.get('resourceId')
        chat_id = payload.get('chatId') or payload.get('telegramId')
        username = payload.get('username')
        phone = payload.get('phone')
        message_limit = payload.get('messageLimit', 2000)
        
        # æ§‹å»º chat_id
        effective_chat_id = chat_id
        if not effective_chat_id and username:
            effective_chat_id = f"@{username.lstrip('@')}"
        
        if not effective_chat_id:
            self.send_event("active-users-extracted", {
                "resourceId": resource_id,
                "success": False,
                "error": "ç„¡æ³•ç¢ºå®šç¾¤çµ„æ¨™è­˜",
                "members": [],
                "extracted": 0
            })
            return
        
        # ç²å–æ‰‹æ©Ÿè™Ÿ
        if not phone:
            from database import db as _db
            await _db.connect()
            if resource_id:
                resource = await _db.fetch_one(
                    "SELECT joined_by_phone FROM discovered_resources WHERE id = ?",
                    (resource_id,)
                )
                if resource:
                    phone = resource.get('joined_by_phone') if hasattr(resource, 'get') else resource[0]
        
        self.send_log(f"ğŸ” å¾æ¶ˆæ¯æ­·å²ä¸­æå–æ´»èºç”¨æˆ¶: {effective_chat_id}", "info")
        self.send_event("active-users-extraction-progress", {
            "resourceId": resource_id,
            "status": "starting",
            "message": f"é–‹å§‹æƒææœ€è¿‘ {message_limit} æ¢æ¶ˆæ¯..."
        })
        
        # è¨­ç½®å®¢æˆ¶ç«¯
        member_extraction_service.set_clients(self.telegram_manager.clients)
        member_extraction_service.set_event_callback(self.send_event)
        
        result = await member_extraction_service.extract_active_from_history(
            chat_id=effective_chat_id,
            phone=phone,
            message_limit=message_limit,
            save_to_db=True
        )
        
        if result['success']:
            new_users = [m for m in result.get('members', []) if m.get('is_new')]
            self.send_log(
                f"âœ… æ´»èºç”¨æˆ¶æå–å®Œæˆ: æƒæ {result['messages_scanned']} æ¢æ¶ˆæ¯ï¼Œ"
                f"ç™¼ç¾ {result['unique_users']} ç”¨æˆ¶ (æ–°å¢ {len(new_users)})",
                "success"
            )
            
            # è‡ªå‹•åŒæ­¥åˆ°çµ±ä¸€è¯ç¹«äºº
            try:
                from unified_contacts import get_unified_contacts_manager
                from database import db as sync_db
                await sync_db.connect()
                manager = get_unified_contacts_manager(sync_db)
                sync_stats = await manager.sync_from_sources()
                self.send_event("unified-contacts:updated", {
                    "reason": "extract-active-users",
                    "synced": sync_stats.get('synced', 0),
                    "updated": sync_stats.get('updated', 0)
                })
            except Exception as sync_err:
                print(f"[Backend] Auto-sync after active extraction: {sync_err}", file=sys.stderr)
        else:
            self.send_log(f"âŒ æ´»èºç”¨æˆ¶æå–å¤±æ•—: {result.get('error')}", "error")
        
        self.send_event("active-users-extracted", {
            "resourceId": resource_id,
            "success": result.get('success', False),
            "method": "history",
            "members": result.get('members', []),
            "extracted": result.get('extracted', 0),
            "unique_users": result.get('unique_users', 0),
            "messages_scanned": result.get('messages_scanned', 0),
            "new_members": result.get('new_members', 0),
            "error": result.get('error')
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_log(f"âŒ æ´»èºç”¨æˆ¶æå–å¤±æ•—: {e}", "error")
        self.send_event("active-users-extracted", {
            "resourceId": payload.get('resourceId'),
            "success": False,
            "error": str(e),
            "members": [],
            "extracted": 0
        })


async def handle_get_extracted_members(self, payload: Dict[str, Any]):
    """ç²å–å·²æå–çš„æˆå“¡åˆ—è¡¨ - ğŸ†• P3 å„ªåŒ–ï¼šæ”¯æŒå®Œæ•´åˆ†é """
    import time
    start_time = time.time()
    print(f"[Backend] handle_get_extracted_members started, payload: {payload}", file=sys.stderr)
    
    try:
        online_only = payload.get('onlineOnly', False)
        min_value_level = payload.get('minValueLevel')
        source_chat_id = payload.get('sourceChatId')
        not_contacted = payload.get('notContacted', False)
        limit = payload.get('limit', 100)
        offset = payload.get('offset', 0)
        page = payload.get('page', 1)
        page_size = payload.get('pageSize', limit)
        
        # ğŸ†• P3ï¼šæ”¯æŒé ç¢¼æ–¹å¼åˆ†é 
        if page > 1:
            offset = (page - 1) * page_size
            limit = page_size
        
        print(f"[Backend] Fetching members with limit={limit}, offset={offset}...", file=sys.stderr)
        
        # ğŸ†• P3ï¼šç²å–ç¸½æ•¸ï¼ˆç”¨æ–¼åˆ†é ï¼‰
        total_count = await member_extraction_service.count_members_filtered(
            online_only=online_only,
            min_value_level=min_value_level,
            source_chat_id=source_chat_id,
            not_contacted=not_contacted
        )
        
        members = await member_extraction_service.get_members(
            online_only=online_only,
            min_value_level=min_value_level,
            source_chat_id=source_chat_id,
            not_contacted=not_contacted,
            limit=limit,
            offset=offset
        )
        
        elapsed = time.time() - start_time
        print(f"[Backend] Fetched {len(members)} members (total: {total_count}) in {elapsed:.2f}s", file=sys.stderr)
        
        # ğŸ†• P3ï¼šè¿”å›åˆ†é ä¿¡æ¯
        total_pages = (total_count + page_size - 1) // page_size if page_size > 0 else 1
        
        self.send_event("extracted-members-list", {
            "success": True,
            "members": members,
            "count": len(members),
            # ğŸ†• P3ï¼šåˆ†é å…ƒæ•¸æ“š
            "pagination": {
                "total": total_count,
                "page": page,
                "pageSize": page_size,
                "totalPages": total_pages,
                "hasMore": offset + len(members) < total_count
            }
        })
        print(f"[Backend] Sent extracted-members-list event with {len(members)} members", file=sys.stderr)
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_log(f"âŒ ç²å–æˆå“¡åˆ—è¡¨å¤±æ•—: {e}", "error")
        self.send_event("extracted-members-list", {
            "success": False,
            "error": str(e)
        })


async def handle_get_member_stats(self, payload: Dict[str, Any]):
    """ç²å–æˆå“¡çµ±è¨ˆ"""
    try:
        source_chat_id = payload.get('sourceChatId')
        
        stats = await member_extraction_service.count_members(source_chat_id)
        
        self.send_event("member-stats", {
            "success": True,
            **stats
        })
        
    except Exception as e:
        self.send_log(f"âŒ ç²å–æˆå“¡çµ±è¨ˆå¤±æ•—: {e}", "error")
        self.send_event("member-stats", {
            "success": False,
            "error": str(e)
        })


async def handle_get_online_members(self, payload: Dict[str, Any]):
    """ç²å–åœ¨ç·šæˆå“¡"""
    try:
        limit = payload.get('limit', 100)
        
        members = await member_extraction_service.get_online_members(limit)
        
        self.send_event("online-members-list", {
            "success": True,
            "members": members,
            "count": len(members)
        })
        
    except Exception as e:
        self.send_log(f"âŒ ç²å–åœ¨ç·šæˆå“¡å¤±æ•—: {e}", "error")
        self.send_event("online-members-list", {
            "success": False,
            "error": str(e)
        })


async def handle_update_member(self, payload: Dict[str, Any]):
    """æ›´æ–°æˆå“¡ä¿¡æ¯"""
    try:
        user_id = payload.get('userId')
        updates = payload.get('updates', {})
        
        if not user_id:
            raise ValueError("ç”¨æˆ¶ ID ä¸èƒ½ç‚ºç©º")
        
        # æ§‹å»ºæ›´æ–°èªå¥
        set_clauses = []
        params = []
        
        allowed_fields = ['tags', 'notes', 'contacted', 'contacted_at', 'response_status', 'converted', 'value_level']
        
        for field, value in updates.items():
            if field in allowed_fields:
                set_clauses.append(f"{field} = ?")
                params.append(value if not isinstance(value, bool) else (1 if value else 0))
        
        if not set_clauses:
            self.send_event("member-updated", {
                "success": True,
                "userId": user_id,
                "message": "ç„¡éœ€æ›´æ–°"
            })
            return
        
        # æ·»åŠ æ›´æ–°æ™‚é–“
        set_clauses.append("updated_at = ?")
        params.append(datetime.now().isoformat())
        
        # æ·»åŠ  user_id åƒæ•¸
        params.append(user_id)
        
        query = f"UPDATE extracted_members SET {', '.join(set_clauses)} WHERE user_id = ?"
        
        await db.execute(query, tuple(params))
        
        self.send_log(f"âœ… æ›´æ–°æˆå“¡ {user_id} æˆåŠŸ", "success")
        self.send_event("member-updated", {
            "success": True,
            "userId": user_id
        })
        
    except Exception as e:
        self.send_log(f"âŒ æ›´æ–°æˆå“¡å¤±æ•—: {e}", "error")
        self.send_event("member-updated", {
            "success": False,
            "error": str(e)
        })


# ==================== P2 å„ªåŒ–ï¼šçµ±è¨ˆèˆ‡èƒŒæ™¯æå– ====================

async def handle_get_extraction_stats(self, payload: Dict[str, Any]):
    """ç²å–æå–çµ±è¨ˆä¿¡æ¯"""
    import sys
    print(f"[Backend] handle_get_extraction_stats called", file=sys.stderr)
    
    try:
        stats = member_extraction_service.get_stats()
        
        self.send_event("extraction-stats", {
            "success": True,
            **stats
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("extraction-stats", {
            "success": False,
            "error": str(e)
        })


async def handle_start_background_extraction(self, payload: Dict[str, Any]):
    """å•Ÿå‹•èƒŒæ™¯æå–"""
    import sys
    print(f"[Backend] handle_start_background_extraction called: {payload}", file=sys.stderr)
    
    try:
        chat_id = payload.get('chatId') or payload.get('telegramId')
        phone = payload.get('phone')
        limit = payload.get('limit', 100)
        filters = payload.get('filters', {})
        
        if not chat_id:
            raise ValueError("ç¾¤çµ„ ID ä¸èƒ½ç‚ºç©º")
        
        # è¨­ç½®å®¢æˆ¶ç«¯
        member_extraction_service.set_clients(self.telegram_manager.clients)
        member_extraction_service.set_event_callback(self.send_event)
        
        # å•Ÿå‹•èƒŒæ™¯ä»»å‹™
        task_id = await member_extraction_service.start_background_extraction(
            chat_id=chat_id,
            phone=phone,
            limit=limit,
            filter_bots=filters.get('bots', True),
            online_status=filters.get('onlineStatus', 'all')
        )
        
        self.send_log(f"ğŸ”„ èƒŒæ™¯æå–å·²å•Ÿå‹•: {task_id}", "info")
        self.send_event("background-extraction-started", {
            "success": True,
            "taskId": task_id,
            "chatId": chat_id
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_log(f"âŒ å•Ÿå‹•èƒŒæ™¯æå–å¤±æ•—: {e}", "error")
        self.send_event("background-extraction-started", {
            "success": False,
            "error": str(e)
        })


async def handle_clear_extraction_cache(self, payload: Dict[str, Any]):
    """æ¸…é™¤æå–ç·©å­˜"""
    try:
        chat_id = payload.get('chatId')
        member_extraction_service.clear_result_cache(chat_id)
        
        self.send_event("cache-cleared", {
            "success": True,
            "chatId": chat_id
        })
        
    except Exception as e:
        self.send_event("cache-cleared", {
            "success": False,
            "error": str(e)
        })


# ==================== P4 å„ªåŒ–ï¼šæ•¸æ“šå°å‡ºèˆ‡ç®¡ç† ====================

async def handle_export_members(self, payload: Dict[str, Any]):
    """å°å‡ºæˆå“¡æ•¸æ“š"""
    import sys
    print(f"[Backend] handle_export_members called: {payload}", file=sys.stderr)
    
    try:
        format_type = payload.get('format', 'csv')  # csv æˆ– json
        filters = payload.get('filters', {})
        
        if format_type == 'json':
            content = await member_extraction_service.export_members_json(filters)
            filename = f"members_export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        else:
            content = await member_extraction_service.export_members_csv(filters)
            filename = f"members_export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
        
        self.send_log(f"âœ… å°å‡ºå®Œæˆ: {filename}", "success")
        self.send_event("members-exported", {
            "success": True,
            "content": content,
            "filename": filename,
            "format": format_type
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_log(f"âŒ å°å‡ºå¤±æ•—: {e}", "error")
        self.send_event("members-exported", {
            "success": False,
            "error": str(e)
        })


async def handle_join_and_extract(self, payload: Dict[str, Any]):
    """
    ğŸ†• Phase3: ä¸€éµåŠ å…¥ç¾¤çµ„ä¸¦æå–æˆå“¡
    
    å‰ç«¯åªéœ€ç™¼é€ä¸€å€‹å‘½ä»¤ï¼Œå¾Œç«¯è‡ªå‹•å®Œæˆï¼š
    1. åŠ å…¥ç¾¤çµ„
    2. ç­‰å¾… Telegram åŒæ­¥
    3. æå–æˆå“¡
    4. åŒæ­¥åˆ° unified_contacts
    """
    import sys
    print(f"[Backend] handle_join_and_extract called: {list(payload.keys())}", file=sys.stderr)
    
    resource_id = payload.get('resourceId') or payload.get('groupId')
    telegram_id = payload.get('telegramId')
    username = payload.get('username')
    phone = payload.get('phone')
    group_name = payload.get('groupName') or payload.get('groupTitle') or ''
    limit = payload.get('limit', 200)
    
    try:
        # Step 1: æ§‹å»ºåŠ å…¥ URL
        if username:
            join_url = f"https://t.me/{username.lstrip('@')}"
        elif telegram_id:
            join_url = str(telegram_id)
        else:
            self.send_event("members-extracted", {
                "resourceId": resource_id,
                "success": False,
                "error": "ç¼ºå°‘ç¾¤çµ„æ¨™è­˜ï¼ˆusername æˆ– telegramIdï¼‰",
                "members": [], "extracted": 0, "total": 0
            })
            return
        
        # Step 2: é¸æ“‡å¸³è™Ÿ
        if not phone:
            from database import db as _jae_db
            await _jae_db.connect()
            from domain.groups.handlers_impl import select_best_account
            phone = await select_best_account(self.telegram_manager, _jae_db, operation='join')
        
        if not phone:
            self.send_event("members-extracted", {
                "resourceId": resource_id,
                "success": False,
                "error": "æ²’æœ‰å¯ç”¨çš„åœ¨ç·šå¸³è™Ÿ",
                "members": [], "extracted": 0, "total": 0
            })
            return
        
        # Step 3: åŠ å…¥ç¾¤çµ„
        self.send_event("members-extraction-progress", {
            "resourceId": resource_id,
            "status": "joining",
            "message": f"æ­£åœ¨åŠ å…¥ç¾¤çµ„ {group_name or username or ''}...",
            "extracted": 0, "total": 0
        })
        
        join_result = await self.telegram_manager.join_group(phone, join_url)
        
        if not join_result.get('success') and 'already' not in str(join_result.get('error', '')).lower():
            self.send_event("members-extracted", {
                "resourceId": resource_id,
                "success": False,
                "error": f"åŠ å…¥ç¾¤çµ„å¤±æ•—: {join_result.get('error', 'æœªçŸ¥éŒ¯èª¤')}",
                "members": [], "extracted": 0, "total": 0
            })
            return
        
        # Step 4: æ›´æ–°æ•¸æ“šåº«
        actual_chat_id = join_result.get('chat_id', telegram_id)
        try:
            from database import db as _jae_db2
            await _jae_db2.connect()
            if resource_id:
                await _jae_db2.execute(
                    """UPDATE discovered_resources 
                       SET status = 'joined', joined_by_phone = ?, joined_at = CURRENT_TIMESTAMP,
                           telegram_id = COALESCE(telegram_id, ?)
                       WHERE id = ?""",
                    (phone, str(actual_chat_id or ''), resource_id)
                )
        except Exception as db_err:
            print(f"[Backend] join-and-extract DB update error: {db_err}", file=sys.stderr)
        
        self.send_log(f"âœ… å·²åŠ å…¥ç¾¤çµ„ {group_name}", "success")
        
        # Step 5: ç­‰å¾…åŒæ­¥
        self.send_event("members-extraction-progress", {
            "resourceId": resource_id,
            "status": "syncing",
            "message": "å·²åŠ å…¥ç¾¤çµ„ï¼Œç­‰å¾… Telegram åŒæ­¥...",
            "extracted": 0, "total": 0
        })
        import asyncio
        await asyncio.sleep(5)
        
        # Step 6: èª¿ç”¨ extract-membersï¼ˆå¾©ç”¨å·²æœ‰é‚è¼¯ï¼‰
        extract_payload = {
            'resourceId': resource_id,
            'telegramId': str(actual_chat_id or telegram_id or ''),
            'username': username,
            'phone': phone,
            'groupName': group_name,
            'limit': limit,
            'chatId': str(actual_chat_id or telegram_id or '')
        }
        # åˆä½µå‰ç«¯å‚³å…¥çš„é¡å¤–åƒæ•¸ï¼ˆfilters ç­‰ï¼‰
        for key in ['filters', 'autoSave', 'skipDuplicates']:
            if key in payload:
                extract_payload[key] = payload[key]
        
        await handle_extract_members(self, extract_payload)
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_log(f"âŒ åŠ å…¥ä¸¦æå–å¤±æ•—: {e}", "error")
        self.send_event("members-extracted", {
            "resourceId": resource_id,
            "success": False,
            "error": str(e),
            "members": [], "extracted": 0, "total": 0
        })


async def handle_batch_extract_members(self, payload: Dict[str, Any]):
    """
    ğŸ†• Phase4: æ‰¹é‡æå–å¤šå€‹ç¾¤çµ„çš„æˆå“¡
    
    ä¸²è¡ŒåŸ·è¡Œé¿å… FloodWaitï¼Œæ¯å€‹ç¾¤çµ„å®Œæˆå¾Œç™¼é€é€²åº¦äº‹ä»¶ã€‚
    å‰ç«¯å·²æœ‰ openBatchMemberExtractDialog() ç™¼é€æ­¤å‘½ä»¤ã€‚
    """
    import sys
    print(f"[Backend] handle_batch_extract_members called", file=sys.stderr)
    
    resource_ids = payload.get('resourceIds', [])
    limit_per_group = payload.get('limit', 100)
    safe_mode = payload.get('safeMode', True)
    
    if not resource_ids:
        self.send_event("batch-members-extracted", {
            "success": False, "error": "æœªæä¾›ç¾¤çµ„ ID åˆ—è¡¨"
        })
        return
    
    total_groups = len(resource_ids)
    completed = 0
    failed = 0
    total_members = 0
    results = []
    
    self.send_log(f"ğŸš€ é–‹å§‹æ‰¹é‡æå– {total_groups} å€‹ç¾¤çµ„çš„æˆå“¡", "info")
    self.send_event("batch-extraction-progress", {
        "status": "starting",
        "totalGroups": total_groups,
        "completed": 0,
        "currentGroup": "",
        "totalMembers": 0
    })
    
    from database import db as batch_db
    await batch_db.connect()
    
    for i, rid in enumerate(resource_ids):
        try:
            # æŸ¥è©¢ç¾¤çµ„ä¿¡æ¯
            resource = await batch_db.fetch_one(
                "SELECT id, telegram_id, username, title, joined_by_phone, status FROM discovered_resources WHERE id = ?",
                (rid,)
            )
            
            if not resource:
                self.send_log(f"âš ï¸ [{i+1}/{total_groups}] ç¾¤çµ„ ID={rid} ä¸å­˜åœ¨ï¼Œè·³é", "warning")
                failed += 1
                continue
            
            title = resource.get('title') if hasattr(resource, 'get') else resource[3]
            telegram_id = resource.get('telegram_id') if hasattr(resource, 'get') else resource[1]
            username = resource.get('username') if hasattr(resource, 'get') else resource[2]
            phone = resource.get('joined_by_phone') if hasattr(resource, 'get') else resource[4]
            status = resource.get('status') if hasattr(resource, 'get') else resource[5]
            
            self.send_log(f"ğŸ“¦ [{i+1}/{total_groups}] æ­£åœ¨æå–: {title}", "info")
            self.send_event("batch-extraction-progress", {
                "status": "extracting",
                "totalGroups": total_groups,
                "completed": completed,
                "currentGroup": title or str(rid),
                "currentIndex": i + 1,
                "totalMembers": total_members
            })
            
            # æ§‹å»ºæå– payload
            extract_payload = {
                'resourceId': rid,
                'telegramId': telegram_id,
                'username': username,
                'phone': phone,
                'groupName': title,
                'limit': limit_per_group,
                'chatId': telegram_id
            }
            
            # å°æœªåŠ å…¥çš„ç¾¤çµ„ä½¿ç”¨ join-and-extract
            if status not in ('joined', 'monitoring') and (username or telegram_id):
                self.send_log(f"  â†³ æœªåŠ å…¥ï¼Œå˜—è©¦è‡ªå‹•åŠ å…¥...", "info")
                await handle_join_and_extract(self, extract_payload)
            else:
                await handle_extract_members(self, extract_payload)
            
            # çµ±è¨ˆï¼ˆmembers-extracted äº‹ä»¶å·²ç”±ä¸Šé¢çš„å‡½æ•¸ç™¼é€ï¼‰
            completed += 1
            
            # å¾æœ€è¿‘çš„æå–æ—¥èªŒç²å–æœ¬æ¬¡æå–æ•¸é‡
            try:
                last_log = await batch_db.fetch_one(
                    """SELECT extracted_count FROM member_extraction_logs 
                       WHERE chat_id = ? ORDER BY created_at DESC LIMIT 1""",
                    (str(telegram_id or rid),)
                )
                if last_log:
                    cnt = last_log.get('extracted_count') if hasattr(last_log, 'get') else last_log[0]
                    total_members += (cnt or 0)
            except Exception:
                pass
            
            results.append({
                "resourceId": rid,
                "title": title,
                "success": True
            })
            
            # å®‰å…¨æ¨¡å¼ï¼šç¾¤çµ„é–“ç­‰å¾…é¿å… FloodWait
            if safe_mode and i < total_groups - 1:
                wait = 8 if total_groups > 5 else 5
                self.send_log(f"  â†³ ç­‰å¾… {wait}s é¿å…é€Ÿç‡é™åˆ¶...", "info")
                await asyncio.sleep(wait)
                
        except Exception as e:
            failed += 1
            self.send_log(f"âŒ [{i+1}/{total_groups}] {title if 'title' in dir() else rid} å¤±æ•—: {e}", "error")
            results.append({
                "resourceId": rid,
                "title": title if 'title' in dir() else str(rid),
                "success": False,
                "error": str(e)
            })
    
    # ç™¼é€æœ€çµ‚çµæœ
    self.send_log(f"âœ… æ‰¹é‡æå–å®Œæˆ: {completed}/{total_groups} æˆåŠŸï¼Œå…± {total_members} æˆå“¡", "success")
    self.send_event("batch-members-extracted", {
        "success": failed < total_groups,
        "totalGroups": total_groups,
        "completed": completed,
        "failed": failed,
        "totalMembers": total_members,
        "results": results
    })


async def handle_deduplicate_members(self, payload: Dict[str, Any]):
    """å»é‡æˆå“¡æ•¸æ“š"""
    import sys
    print(f"[Backend] handle_deduplicate_members called", file=sys.stderr)
    
    try:
        result = await member_extraction_service.deduplicate_members()
        
        self.send_log(f"âœ… å»é‡å®Œæˆ: åˆä½µ {result['merged']} å€‹ï¼Œåˆªé™¤ {result['deleted']} æ¢", "success")
        self.send_event("members-deduplicated", {
            "success": True,
            **result
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("members-deduplicated", {
            "success": False,
            "error": str(e)
        })

