"""
Extracted handler implementations: members
Auto-generated by refactor_main.py
"""
import json
import sys
import time
import asyncio
import traceback
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from service_context import get_service_context

# All handlers receive (self, payload) where self is BackendService instance.
# They are called via: await handler_impl(self, payload)
# Inside, use self.db, self.send_event(), self.telegram_manager, etc.
# This is a transitional pattern - later, replace self.xxx with ctx.xxx


# ==================== æˆå“¡æå–è™•ç†å™¨ ====================

async def handle_batch_refresh_member_counts(self, payload: Dict[str, Any]):
    """ğŸ†• æ‰¹é‡åˆ·æ–°ç¾¤çµ„æˆå“¡æ•¸"""
    import sys
    print(f"[Backend] handle_batch_refresh_member_counts called", file=sys.stderr)
    
    groups = payload.get('groups', [])
    if not groups:
        self.send_event("batch-refresh-member-counts-complete", {
            "success": True,
            "total": 0,
            "updated": 0,
            "failed": 0
        })
        return
    
    try:
        # æ‰¾åˆ°å¯ç”¨çš„å®¢æˆ¶ç«¯
        client = None
        for c in self.telegram_manager._clients.values():
            if c and c.is_connected:
                client = c
                break
        
        if not client:
            self.send_event("batch-refresh-member-counts-complete", {
                "success": False,
                "error": "æ²’æœ‰å¯ç”¨çš„åœ¨ç·šå¸³è™Ÿ"
            })
            return
        
        updated_count = 0
        failed_count = 0
        
        for i, group in enumerate(groups):
            try:
                group_id = group.get('id')
                url = group.get('url', '')
                
                # è§£æç¾¤çµ„æ¨™è­˜
                chat_identifier = url
                if url.startswith('https://t.me/'):
                    chat_identifier = url.replace('https://t.me/', '')
                if not chat_identifier.startswith('@') and not chat_identifier.startswith('+'):
                    chat_identifier = f"@{chat_identifier}"
                
                # ç²å–æˆå“¡æ•¸
                chat = await client.get_chat(chat_identifier)
                member_count = chat.members_count or 0
                
                # æ›´æ–°æ•¸æ“šåº«
                if member_count > 0:
                    await db.update_group_member_count(url, member_count)
                    updated_count += 1
                
                # ç™¼é€é€²åº¦
                self.send_event("batch-refresh-member-counts-progress", {
                    "current": i + 1,
                    "total": len(groups),
                    "groupId": str(group_id),
                    "memberCount": member_count
                })
                
                # é¿å…è§¸ç™¼é€Ÿç‡é™åˆ¶
                await asyncio.sleep(0.5)
                
            except Exception as e:
                print(f"[Backend] Error refreshing member count for group {group.get('id')}: {e}", file=sys.stderr)
                failed_count += 1
                
                # ä»ç„¶ç™¼é€é€²åº¦
                self.send_event("batch-refresh-member-counts-progress", {
                    "current": i + 1,
                    "total": len(groups),
                    "groupId": str(group.get('id')),
                    "memberCount": 0
                })
        
        self.send_event("batch-refresh-member-counts-complete", {
            "success": True,
            "total": len(groups),
            "updated": updated_count,
            "failed": failed_count
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc()
        self.send_event("batch-refresh-member-counts-complete", {
            "success": False,
            "error": str(e)
        })


async def handle_get_group_member_count(self, payload: Dict[str, Any]):
    """ğŸ†• ç²å–ç¾¤çµ„æˆå“¡æ•¸ï¼ˆæ”¯æŒé‡æ–°ç²å–ï¼‰"""
    import sys
    print(f"[Backend] handle_get_group_member_count called with payload: {payload}", file=sys.stderr)
    
    group_id = payload.get('groupId')
    url = payload.get('url', '')
    account_phone = payload.get('accountPhone')
    
    try:
        # æ‰¾åˆ°å¯ç”¨çš„å®¢æˆ¶ç«¯
        client = None
        phone = account_phone
        
        if account_phone:
            client = self.telegram_manager.get_client(account_phone)
        
        if not client or not client.is_connected:
            # å˜—è©¦ä½¿ç”¨ä»»æ„åœ¨ç·šå¸³è™Ÿ
            for acc_phone, c in self.telegram_manager._clients.items():
                if c and c.is_connected:
                    client = c
                    phone = acc_phone
                    break
        
        if not client or not client.is_connected:
            self.send_event("group-member-count-result", {
                "success": False,
                "groupId": group_id,
                "error": "æ²’æœ‰å¯ç”¨çš„åœ¨ç·šå¸³è™Ÿ"
            })
            return
        
        # ğŸ”§ ä¿®å¾©ï¼šè§£æç¾¤çµ„æ¨™è­˜ï¼Œæ”¯æŒå¤šç¨®æ ¼å¼
        telegram_id = payload.get('telegramId') or payload.get('telegram_id')
        chat_identifier = None
        
        # å„ªå…ˆä½¿ç”¨ telegram_idï¼ˆæ•¸å­— IDï¼‰
        if telegram_id:
            try:
                chat_identifier = int(telegram_id)
                print(f"[Backend] Using telegram_id: {chat_identifier}", file=sys.stderr)
            except (ValueError, TypeError):
                chat_identifier = None
        
        # å…¶æ¬¡ä½¿ç”¨ url
        if not chat_identifier and url:
            chat_identifier = url
            if url.startswith('https://t.me/'):
                chat_identifier = url.replace('https://t.me/', '')
            if isinstance(chat_identifier, str):
                if chat_identifier.startswith('+'):
                    # ç§æœ‰ç¾¤çµ„é‚€è«‹éˆæ¥
                    chat_identifier = url
                elif chat_identifier and not chat_identifier.startswith('@'):
                    chat_identifier = f"@{chat_identifier}"
        
        if not chat_identifier:
            self.send_event("group-member-count-result", {
                "success": False,
                "groupId": group_id,
                "error": "ç¼ºå°‘ç¾¤çµ„æ¨™è­˜ï¼ˆURL æˆ– Telegram IDï¼‰"
            })
            return
        
        print(f"[Backend] Getting member count for: {chat_identifier}", file=sys.stderr)
        
        # ç²å–ç¾¤çµ„ä¿¡æ¯
        try:
            chat = await client.get_chat(chat_identifier)
            member_count = chat.members_count or 0
            
            print(f"[Backend] Got member count: {member_count}", file=sys.stderr)
            
            # æ›´æ–°æ•¸æ“šåº«
            if member_count > 0:
                await db.update_group_member_count(url, member_count)
            
            self.send_event("group-member-count-result", {
                "success": True,
                "groupId": group_id,
                "memberCount": member_count,
                "chatTitle": chat.title
            })
            
        except Exception as chat_err:
            error_str = str(chat_err).lower()
            if 'not found' in error_str or 'invalid' in error_str:
                error_msg = "ç¾¤çµ„ä¸å­˜åœ¨æˆ–ç„¡æ³•è¨ªå•"
            elif 'banned' in error_str or 'kicked' in error_str:
                error_msg = "å¸³è™Ÿè¢«è¸¢å‡ºè©²ç¾¤çµ„"
            elif 'private' in error_str:
                error_msg = "é€™æ˜¯ç§æœ‰ç¾¤çµ„ï¼Œéœ€è¦é‚€è«‹éˆæ¥"
            else:
                error_msg = f"ç²å–å¤±æ•—ï¼š{str(chat_err)}"
            
            print(f"[Backend] Error getting chat: {chat_err}", file=sys.stderr)
            self.send_event("group-member-count-result", {
                "success": False,
                "groupId": group_id,
                "error": error_msg
            })
            
    except Exception as e:
        import traceback
        traceback.print_exc()
        self.send_event("group-member-count-result", {
            "success": False,
            "groupId": group_id,
            "error": f"ç²å–æˆå“¡æ•¸å¤±æ•—ï¼š{str(e)}"
        })


async def handle_collect_users_from_history_advanced(self, payload: Dict[str, Any]):
    """ğŸ†• å¾æ­·å²æ¶ˆæ¯æ”¶é›†ç”¨æˆ¶ï¼ˆé€²éšç‰ˆï¼Œæ”¯æŒæ›´å¤šé…ç½®ï¼‰"""
    import sys
    from datetime import datetime, timedelta
    print(f"[Backend] handle_collect_users_from_history_advanced: {payload}", file=sys.stderr)
    
    group_id = payload.get('groupId')
    telegram_id = payload.get('telegramId')
    config = payload.get('config', {})
    
    # è§£æé…ç½®
    limit = config.get('limit', 200)
    time_range = config.get('timeRange', '30d')
    min_messages = config.get('minMessages', 1)
    skip_duplicates = config.get('skipDuplicates', True)
    exclude_bots = config.get('excludeBots', True)
    require_username = config.get('requireUsername', False)
    auto_sync = config.get('autoSync', True)
    
    try:
        from database import db
        await db.connect()
        
        chat_id = str(telegram_id) if telegram_id else str(group_id)
        
        # æ§‹å»ºæ™‚é–“æ¢ä»¶
        time_condition = ""
        if time_range == '7d':
            cutoff = (datetime.now() - timedelta(days=7)).isoformat()
            time_condition = f"AND timestamp >= '{cutoff}'"
        elif time_range == '30d':
            cutoff = (datetime.now() - timedelta(days=30)).isoformat()
            time_condition = f"AND timestamp >= '{cutoff}'"
        elif time_range == '90d':
            cutoff = (datetime.now() - timedelta(days=90)).isoformat()
            time_condition = f"AND timestamp >= '{cutoff}'"
        
        # ç™¼é€é€²åº¦æ›´æ–°
        self.send_event("history-collection-progress", {
            "groupId": group_id,
            "current": 0,
            "total": 100,
            "status": "æ­£åœ¨æŸ¥è©¢æ­·å²æ¶ˆæ¯..."
        })
        
        # æ§‹å»ºæŸ¥è©¢
        limit_clause = f"LIMIT {limit}" if limit > 0 else ""
        
        query = f"""
            SELECT 
                sender_id,
                sender_name,
                sender_username,
                COUNT(*) as message_count,
                MAX(timestamp) as last_message_at
            FROM chat_history 
            WHERE chat_id = ? 
              AND sender_id IS NOT NULL 
              AND sender_id != ''
              {time_condition}
            GROUP BY sender_id
            HAVING message_count >= ?
            ORDER BY message_count DESC
            {limit_clause}
        """
        
        results = await db.fetch_all(query, (chat_id, min_messages))
        
        if not results:
            self.send_event("history-collection-result", {
                "groupId": group_id,
                "success": False,
                "error": "æœªæ‰¾åˆ°ç¬¦åˆæ¢ä»¶çš„ç”¨æˆ¶"
            })
            return
        
        total = len(results)
        collected_count = 0
        new_count = 0
        updated_count = 0
        skipped_count = 0
        
        # è³ªé‡çµ±è¨ˆ
        high_activity = 0
        medium_activity = 0
        low_activity = 0
        
        for idx, row in enumerate(results):
            try:
                sender_id = row['sender_id'] if hasattr(row, '__getitem__') else row[0]
                sender_name = row['sender_name'] if hasattr(row, '__getitem__') else row[1]
                sender_username = row['sender_username'] if hasattr(row, '__getitem__') else row[2]
                message_count = row['message_count'] if hasattr(row, '__getitem__') else row[3]
                last_message = row['last_message_at'] if hasattr(row, '__getitem__') else row[4]
                
                if not sender_id:
                    continue
                
                # æª¢æŸ¥æ˜¯å¦éœ€è¦ç”¨æˆ¶å
                if require_username and not sender_username:
                    skipped_count += 1
                    continue
                
                # æª¢æŸ¥æ˜¯å¦æ˜¯æ©Ÿå™¨äººï¼ˆç°¡å–®åˆ¤æ–·ï¼‰
                if exclude_bots:
                    if sender_username and sender_username.lower().endswith('bot'):
                        skipped_count += 1
                        continue
                
                # æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
                if skip_duplicates:
                    existing = await db.fetch_one(
                        "SELECT id FROM collected_users WHERE telegram_id = ?",
                        (str(sender_id),)
                    )
                    if existing:
                        updated_count += 1
                        # æ›´æ–°ç¾æœ‰è¨˜éŒ„
                        await db.execute(
                            """UPDATE collected_users 
                               SET message_count = ?, last_message_at = ?, updated_at = CURRENT_TIMESTAMP
                               WHERE telegram_id = ?""",
                            (message_count, last_message, str(sender_id))
                        )
                        continue
                
                # æ’å…¥æ–°ç”¨æˆ¶
                user_data = {
                    'telegram_id': str(sender_id),
                    'username': sender_username or '',
                    'first_name': sender_name or '',
                    'last_name': '',
                    'source_groups': [chat_id],
                    'collected_by': 'history_scan',
                    'message_count': message_count,
                    'last_message_at': last_message
                }
                
                user_id = await db.upsert_collected_user(user_data)
                collected_count += 1
                if user_id > 0:
                    new_count += 1
                
                # çµ±è¨ˆè³ªé‡
                if message_count >= 10:
                    high_activity += 1
                elif message_count >= 3:
                    medium_activity += 1
                else:
                    low_activity += 1
                
                # ç™¼é€é€²åº¦
                if idx % 10 == 0:
                    self.send_event("history-collection-progress", {
                        "groupId": group_id,
                        "current": idx + 1,
                        "total": total,
                        "status": f"å·²è™•ç† {idx + 1}/{total} ä½ç”¨æˆ¶"
                    })
                    
            except Exception as row_err:
                print(f"[Backend] Error processing row: {row_err}", file=sys.stderr)
                continue
        
        self.send_log(f"âœ… æ­·å²æ¶ˆæ¯æ”¶é›†å®Œæˆ: å…± {collected_count} ä½ç”¨æˆ¶ï¼Œæ–°å¢ {new_count} ä½", "success")
        
        self.send_event("history-collection-result", {
            "groupId": group_id,
            "success": True,
            "result": {
                "success": True,
                "collected": collected_count,
                "newUsers": new_count,
                "updated": updated_count,
                "skipped": skipped_count,
                "quality": {
                    "highActivity": high_activity,
                    "mediumActivity": medium_activity,
                    "lowActivity": low_activity
                }
            }
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_log(f"âŒ æ”¶é›†å¤±æ•—: {str(e)}", "error")
        self.send_event("history-collection-result", {
            "groupId": group_id,
            "success": False,
            "error": str(e)
        })


async def handle_collect_users_from_history(self, payload: Dict[str, Any]):
    """ğŸ†• å¾æ­·å²æ¶ˆæ¯ä¸­æ”¶é›†ç”¨æˆ¶ï¼ˆæ›¿ä»£æˆå“¡æå–ï¼‰"""
    import sys
    print(f"[Backend] ========== handle_collect_users_from_history CALLED ==========", file=sys.stderr)
    
    group_id = payload.get('groupId')
    telegram_id = payload.get('telegramId')
    limit = payload.get('limit', 500)
    
    try:
        from database import db
        await db.connect()
        
        self.send_log(f"ğŸ”„ æ­£åœ¨å¾æ­·å²æ¶ˆæ¯ä¸­æ”¶é›†ç”¨æˆ¶...", "info")
        
        # æŸ¥è©¢ç¾¤çµ„çš„æ­·å²æ¶ˆæ¯ä¸­çš„å”¯ä¸€ç™¼é€è€…
        chat_id = str(telegram_id) if telegram_id else str(group_id)
        
        # å¾ chat_history è¡¨ç²å–å”¯ä¸€ç™¼é€è€…
        query = """
            SELECT DISTINCT 
                sender_id,
                sender_name,
                sender_username,
                COUNT(*) as message_count,
                MAX(timestamp) as last_message_at
            FROM chat_history 
            WHERE chat_id = ? AND sender_id IS NOT NULL AND sender_id != ''
            GROUP BY sender_id
            ORDER BY message_count DESC
            LIMIT ?
        """
        
        results = await db.fetch_all(query, (chat_id, limit))
        
        if not results:
            self.send_log(f"âš ï¸ æœªæ‰¾åˆ°æ­·å²æ¶ˆæ¯ï¼Œè«‹å…ˆé–‹å•Ÿç¾¤çµ„ç›£æ§", "warning")
            self.send_event("collect-from-history-result", {
                "groupId": group_id,
                "success": False,
                "error": "æœªæ‰¾åˆ°æ­·å²æ¶ˆæ¯ï¼Œè«‹å…ˆé–‹å•Ÿç¾¤çµ„ç›£æ§ä¸€æ®µæ™‚é–“",
                "collected": 0,
                "total": 0
            })
            return
        
        # å°‡ç™¼é€è€…æ·»åŠ åˆ° collected_users è¡¨
        collected_count = 0
        new_count = 0
        
        for row in results:
            try:
                sender_id = row['sender_id'] if hasattr(row, '__getitem__') else row[0]
                sender_name = row['sender_name'] if hasattr(row, '__getitem__') else row[1]
                sender_username = row['sender_username'] if hasattr(row, '__getitem__') else row[2]
                message_count = row['message_count'] if hasattr(row, '__getitem__') else row[3]
                last_message = row['last_message_at'] if hasattr(row, '__getitem__') else row[4]
                
                if not sender_id:
                    continue
                
                user_data = {
                    'telegram_id': str(sender_id),
                    'username': sender_username or '',
                    'first_name': sender_name or '',
                    'last_name': '',
                    'source_groups': [chat_id],
                    'collected_by': 'history_scan',
                    'message_count': message_count,
                    'last_message_at': last_message
                }
                
                user_id = await db.upsert_collected_user(user_data)
                collected_count += 1
                if user_id > 0:
                    new_count += 1
                    
            except Exception as row_err:
                print(f"[Backend] Error processing row: {row_err}", file=sys.stderr)
                continue
        
        self.send_log(f"âœ… å¾æ­·å²æ¶ˆæ¯æ”¶é›†å®Œæˆ: å…± {collected_count} ä½ç”¨æˆ¶ï¼Œæ–°å¢ {new_count} ä½", "success")
        
        self.send_event("collect-from-history-result", {
            "groupId": group_id,
            "success": True,
            "collected": collected_count,
            "newUsers": new_count,
            "total": len(results)
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_log(f"âŒ æ”¶é›†å¤±æ•—: {str(e)}", "error")
        self.send_event("collect-from-history-result", {
            "groupId": group_id,
            "success": False,
            "error": str(e),
            "collected": 0
        })


async def handle_extract_members(self, payload: Dict[str, Any]):
    """æå–ç¾¤çµ„æˆå“¡"""
    import sys
    print(f"[Backend] ========== handle_extract_members CALLED ==========", file=sys.stderr)
    print(f"[Backend] Payload: {payload}", file=sys.stderr)
    self.send_log("ğŸ“¥ æ”¶åˆ°æˆå“¡æå–è«‹æ±‚", "info")
    
    try:
        # ğŸ”§ FIX: å„ªå…ˆä½¿ç”¨ telegramIdï¼ˆæ•¸å­— IDï¼‰ï¼Œæ”¯æŒç§æœ‰ç¾¤çµ„
        telegram_id = payload.get('telegramId')
        chat_id = payload.get('chatId')
        username = payload.get('username')
        phone = payload.get('phone')
        resource_id = payload.get('resourceId')
        limit = payload.get('limit', 100)
        
        # å¾ filters ç²å–éæ¿¾é¸é …
        filters = payload.get('filters', {})
        filter_bots = filters.get('bots', True) if filters else payload.get('filterBots', True)
        
        # ğŸ”§ ä¿®å¾©ï¼šå„ªå…ˆä½¿ç”¨ onlineStatus å­—ç¬¦ä¸²
        online_status = None
        if filters:
            # å„ªå…ˆä½¿ç”¨æ˜ç¢ºçš„ onlineStatus å­—ç¬¦ä¸²
            online_status = filters.get('onlineStatus')
            
            # å›é€€ï¼šä½¿ç”¨å¸ƒçˆ¾å€¼
            if not online_status:
                if filters.get('online') == True:
                    online_status = 'online'
                elif filters.get('offline') == True:
                    online_status = 'offline'
        
        # é»˜èªå€¼
        if not online_status:
            online_status = 'all'
        
        filter_offline = filters.get('offline', False) if filters else payload.get('filterOffline', False)
        chinese_only = filters.get('chinese', False) if filters else False
        premium_only = filters.get('isPremium', False) if filters else False
        has_username = filters.get('hasUsername', False) if filters else False
        
        print(f"[Backend] Online status filter: {online_status}", file=sys.stderr)
        
        # ğŸ”§ FIX: æ±ºå®šä½¿ç”¨å“ªå€‹ ID
        # å„ªå…ˆç´š: telegramId > æœ‰æ•ˆçš„ username > å¾æ•¸æ“šåº«æŸ¥è©¢
        effective_chat_id = None
        
        # 1. å„ªå…ˆä½¿ç”¨ telegramIdï¼ˆå°ç§æœ‰ç¾¤çµ„æœ‰æ•ˆï¼‰
        if telegram_id and str(telegram_id).lstrip('-').isdigit():
            effective_chat_id = int(telegram_id)
            print(f"[Backend] Using telegramId: {effective_chat_id}", file=sys.stderr)
        
        # 2. å¦‚æœ chatId æ˜¯æ•¸å­— IDï¼Œä½¿ç”¨å®ƒ
        elif chat_id and str(chat_id).lstrip('-').isdigit():
            effective_chat_id = int(chat_id)
            print(f"[Backend] Using numeric chatId: {effective_chat_id}", file=sys.stderr)
        
        # 3. å¦‚æœ chatId æ˜¯æœ‰æ•ˆçš„ usernameï¼ˆä¸æ˜¯é‚€è«‹éˆæ¥æ ¼å¼ï¼‰ï¼Œä½¿ç”¨å®ƒ
        elif chat_id and not str(chat_id).startswith('+'):
            effective_chat_id = chat_id
            print(f"[Backend] Using username chatId: {effective_chat_id}", file=sys.stderr)
        
        # 4. å¾æ•¸æ“šåº«æŸ¥è©¢ telegram_id
        if not effective_chat_id:
            print(f"[Backend] No valid chat_id, trying to fetch from database...", file=sys.stderr)
            if resource_id:
                # å˜—è©¦å¾ monitored_groups è¡¨æŸ¥è©¢
                from database import db
                await db.connect()
                group = await db.fetch_one(
                    "SELECT telegram_id, link FROM monitored_groups WHERE id = ?",
                    (resource_id,)
                )
                if group:
                    db_telegram_id = group.get('telegram_id') if hasattr(group, 'get') else (group[0] if group else None)
                    if db_telegram_id:
                        effective_chat_id = int(db_telegram_id) if str(db_telegram_id).lstrip('-').isdigit() else db_telegram_id
                        print(f"[Backend] Found telegram_id from database: {effective_chat_id}", file=sys.stderr)
        
        print(f"[Backend] extract-members: effective_chat_id={effective_chat_id}, resource_id={resource_id}, limit={limit}", file=sys.stderr)
        print(f"[Backend] Filters: bots={filter_bots}, offline={filter_offline}, chinese={chinese_only}", file=sys.stderr)
        
        if not effective_chat_id:
            raise ValueError("ç¾¤çµ„ ID ä¸èƒ½ç‚ºç©ºã€‚å°æ–¼ç§æœ‰ç¾¤çµ„ï¼Œéœ€è¦å…ˆç²å–å…¶ Telegram IDã€‚")
        
        chat_id = effective_chat_id
        
        # ğŸ”§ P0 FIX: å„ªå…ˆä½¿ç”¨å·²åŠ å…¥ç¾¤çµ„çš„å¸³è™Ÿ
        if not phone:
            from database import db
            await db.connect()
            
            # 1. å˜—è©¦å¾ discovered_resources ç²å– joined_by_phone å’Œ joined_at
            # ğŸ”§ P1 å„ªåŒ–ï¼šåŒæ™‚ç²å– joined_at ç”¨æ–¼æ™ºèƒ½å»¶é²
            try:
                resource = None
                joined_at_str = None
                
                # 1a. æŒ‰ resource_id æŸ¥è©¢
                if resource_id:
                    resource = await db.fetch_one(
                        "SELECT joined_by_phone, telegram_id, joined_at FROM discovered_resources WHERE id = ?",
                        (resource_id,)
                    )
                    print(f"[Backend] Query by resource_id={resource_id}: found={resource is not None}", file=sys.stderr)
                
                # 1b. æŒ‰ telegram_id æŸ¥è©¢
                if not resource and telegram_id:
                    resource = await db.fetch_one(
                        "SELECT joined_by_phone, telegram_id, joined_at FROM discovered_resources WHERE telegram_id = ?",
                        (str(telegram_id),)
                    )
                    print(f"[Backend] Query by telegram_id={telegram_id}: found={resource is not None}", file=sys.stderr)
                
                # 1c. æŒ‰ username æŸ¥è©¢
                if not resource and username:
                    resource = await db.fetch_one(
                        "SELECT joined_by_phone, telegram_id, joined_at FROM discovered_resources WHERE username = ?",
                        (username.lstrip('@'),)
                    )
                    print(f"[Backend] Query by username={username}: found={resource is not None}", file=sys.stderr)
                
                if resource:
                    joined_phone = resource.get('joined_by_phone') if hasattr(resource, 'get') else resource[0]
                    joined_at_str = resource.get('joined_at') if hasattr(resource, 'get') else (resource[2] if len(resource) > 2 else None)
                    print(f"[Backend] Found joined_by_phone={joined_phone}, joined_at={joined_at_str}", file=sys.stderr)
                    
                    # ğŸ†• P1 å„ªåŒ–ï¼šæ™ºèƒ½å»¶é² - å¦‚æœåŠ å…¥æ™‚é–“ä¸åˆ° 30 ç§’ï¼Œè‡ªå‹•ç­‰å¾…
                    if joined_at_str:
                        try:
                            from datetime import datetime
                            if isinstance(joined_at_str, str):
                                joined_at = datetime.fromisoformat(joined_at_str.replace('Z', '+00:00'))
                            else:
                                joined_at = joined_at_str
                            
                            time_since_join = (datetime.now() - joined_at.replace(tzinfo=None)).total_seconds()
                            MIN_WAIT_AFTER_JOIN = 30  # æœ€å°‘ç­‰å¾… 30 ç§’
                            
                            if time_since_join < MIN_WAIT_AFTER_JOIN:
                                wait_time = int(MIN_WAIT_AFTER_JOIN - time_since_join) + 1
                                self.send_log(f"â³ å‰›åŠ å…¥ç¾¤çµ„ ({int(time_since_join)}s)ï¼Œç­‰å¾… Telegram åŒæ­¥ ({wait_time}s)...", "info")
                                self.send_event("members-extraction-progress", {
                                    "resourceId": resource_id,
                                    "status": "waiting",
                                    "message": f"ç­‰å¾…ç¾¤çµ„åŒæ­¥ ({wait_time}s)...",
                                    "extracted": 0,
                                    "total": 0
                                })
                                await asyncio.sleep(wait_time)
                                self.send_log(f"âœ“ åŒæ­¥ç­‰å¾…å®Œæˆï¼Œé–‹å§‹æå–", "info")
                        except Exception as dt_err:
                            print(f"[Backend] Error parsing joined_at: {dt_err}", file=sys.stderr)
                    
                    if joined_phone and joined_phone in self.telegram_manager.clients:
                        phone = joined_phone
                        print(f"[Backend] âœ“ Using joined_by_phone from discovered_resources: {phone}", file=sys.stderr)
                    elif joined_phone:
                        print(f"[Backend] âš  joined_by_phone {joined_phone} not in connected clients", file=sys.stderr)
            except Exception as e:
                print(f"[Backend] Error fetching joined_by_phone: {e}", file=sys.stderr)
            
            # 2. å˜—è©¦å¾ monitored_groups ç²å– phone
            if not phone:
                try:
                    # é€šé telegram_id æˆ– username æŸ¥è©¢
                    chat_id_str = str(effective_chat_id)
                    group = await db.fetch_one(
                        """SELECT phone FROM monitored_groups 
                           WHERE telegram_id = ? OR link LIKE ? OR name LIKE ?""",
                        (chat_id_str, f"%{chat_id_str}%", f"%{username}%" if username else "")
                    )
                    if group:
                        group_phone = group.get('phone') if hasattr(group, 'get') else group[0]
                        if group_phone and group_phone in self.telegram_manager.clients:
                            phone = group_phone
                            print(f"[Backend] âœ“ Using phone from monitored_groups: {phone}", file=sys.stderr)
                except Exception as e:
                    print(f"[Backend] Error fetching phone from monitored_groups: {e}", file=sys.stderr)
            
            # 3. å›é€€ï¼šä½¿ç”¨ç¬¬ä¸€å€‹å¯ç”¨çš„å®¢æˆ¶ç«¯ï¼Œä½†ç™¼å‡ºæ˜ç¢ºè­¦å‘Š
            if not phone and self.telegram_manager.clients:
                phone = list(self.telegram_manager.clients.keys())[0]
                print(f"[Backend] âš  Using default phone (fallback): {phone}", file=sys.stderr)
                self.send_log(f"âš ï¸ æœªæ‰¾åˆ°å·²åŠ å…¥ç¾¤çµ„çš„å¸³è™Ÿï¼Œå˜—è©¦ä½¿ç”¨å¸³è™Ÿ {phone[:4]}****", "warning")
                self.send_log(f"ğŸ’¡ å¦‚æå–å¤±æ•—ï¼Œè«‹å…ˆä½¿ç”¨è©²å¸³è™ŸåŠ å…¥æ­¤ç¾¤çµ„", "info")
        
        self.send_log(f"ğŸ” é–‹å§‹æå–æˆå“¡: {chat_id} (å¸³è™Ÿ: {phone})", "info")
        
        # è¨­ç½®å®¢æˆ¶ç«¯
        member_extraction_service.set_clients(self.telegram_manager.clients)
        member_extraction_service.set_event_callback(self.send_event)
        
        # ç™¼é€é–‹å§‹äº‹ä»¶
        self.send_event("members-extraction-progress", {
            "resourceId": resource_id,
            "status": "starting",
            "extracted": 0,
            "total": 0
        })
        
        # ğŸ†• P0 ä¿®å¾©ï¼šæ™ºèƒ½é‡è©¦æ©Ÿåˆ¶
        MAX_RETRIES = 3
        RETRY_DELAYS = [3, 5, 8]  # æ¯æ¬¡é‡è©¦çš„å»¶é²ç§’æ•¸
        result = None
        last_error = None
        
        for attempt in range(MAX_RETRIES):
            try:
                if attempt > 0:
                    # é‡è©¦å‰ç™¼é€é€²åº¦é€šçŸ¥
                    self.send_event("members-extraction-progress", {
                        "resourceId": resource_id,
                        "status": "retrying",
                        "message": f"æ­£åœ¨é‡è©¦ ({attempt + 1}/{MAX_RETRIES})...",
                        "extracted": 0,
                        "total": 0
                    })
                    self.send_log(f"ğŸ”„ ç¾¤çµ„åŒæ­¥ä¸­ï¼Œ{RETRY_DELAYS[attempt-1]} ç§’å¾Œé‡è©¦ (ç¬¬ {attempt + 1} æ¬¡)...", "info")
                    await asyncio.sleep(RETRY_DELAYS[attempt-1])
                
                # æå–æˆå“¡ - ğŸ”§ ä¿®å¾©ï¼šå‚³é online_status åƒæ•¸
                result = await member_extraction_service.extract_members(
                    chat_id=chat_id,
                    phone=phone,
                    limit=limit,
                    filter_bots=filter_bots,
                    filter_offline=filter_offline,
                    online_status=online_status,  # ğŸ”§ æ·»åŠ åœ¨ç·šç‹€æ…‹éæ¿¾
                    save_to_db=True
                )
                
                # æª¢æŸ¥æ˜¯å¦éœ€è¦é‡è©¦çš„éŒ¯èª¤
                if result.get('success'):
                    break  # æˆåŠŸï¼Œè·³å‡ºé‡è©¦å¾ªç’°
                
                error_code = result.get('error_code', '')
                if error_code in ['PEER_ID_INVALID', 'NOT_PARTICIPANT', 'USER_NOT_PARTICIPANT']:
                    last_error = result.get('error')
                    print(f"[Backend] Retryable error: {error_code}, attempt {attempt + 1}/{MAX_RETRIES}", file=sys.stderr)
                    
                    if attempt < MAX_RETRIES - 1:
                        # é‚„æœ‰é‡è©¦æ©Ÿæœƒï¼Œç¹¼çºŒå¾ªç’°
                        continue
                    else:
                        # æœ€å¾Œä¸€æ¬¡é‡è©¦ä¹Ÿå¤±æ•—
                        result['error'] = f"ç¾¤çµ„åŒæ­¥æœªå®Œæˆã€‚{result.get('error', '')}"
                        result['error_details'] = {
                            'reason': 'å¸³è™Ÿå‰›åŠ å…¥ç¾¤çµ„ï¼ŒTelegram æœå‹™å™¨å°šæœªåŒæ­¥å®Œæˆ',
                            'suggestion': 'è«‹ç­‰å¾… 30 ç§’å¾Œå†è©¦ï¼Œæˆ–é‡æ–°åŠ å…¥ç¾¤çµ„',
                            'attempts': attempt + 1,
                            'can_auto_join': False
                        }
                        break
                else:
                    # å…¶ä»–éŒ¯èª¤ä¸é‡è©¦
                    break
                    
            except Exception as retry_err:
                last_error = str(retry_err)
                print(f"[Backend] Extraction attempt {attempt + 1} failed: {retry_err}", file=sys.stderr)
                if attempt >= MAX_RETRIES - 1:
                    raise
        
        # å¦‚æœæ‰€æœ‰é‡è©¦éƒ½å¤±æ•—ä¸”æ²’æœ‰çµæœ
        if result is None:
            result = {
                'success': False,
                'error': last_error or 'æå–å¤±æ•—',
                'members': [],
                'extracted': 0
            }
        
        if result['success']:
            members = result.get('members', [])
            
            # æ‡‰ç”¨é¡å¤–çš„éæ¿¾å™¨
            filtered_members = []
            for member in members:
                # è¯äººéæ¿¾
                if chinese_only:
                    name = (member.get('first_name', '') or '') + (member.get('last_name', '') or '')
                    bio = member.get('bio', '') or ''
                    # æª¢æŸ¥æ˜¯å¦æœ‰ä¸­æ–‡å­—ç¬¦
                    import re
                    if not re.search(r'[\u4e00-\u9fff]', name + bio):
                        continue
                
                # Premium éæ¿¾
                if premium_only and not member.get('is_premium'):
                    continue
                
                # ç”¨æˆ¶åéæ¿¾
                if has_username and not member.get('username'):
                    continue
                
                filtered_members.append(member)
            
            result['members'] = filtered_members
            result['extracted'] = len(filtered_members)
            
            self.send_log(f"âœ… æå–å®Œæˆ: {len(filtered_members)} æˆå“¡ (ç¸½è¨ˆ: {len(members)})", "success")
            
            # ğŸ†• è‡ªå‹•åŒæ­¥åˆ°çµ±ä¸€è¯ç¹«äººè¡¨
            try:
                from unified_contacts import get_unified_contacts_manager
                from database import db as sync_db  # ğŸ”§ ä¿®å¾©ï¼šç¢ºä¿æ­£ç¢ºå°å…¥
                await sync_db.connect()
                manager = get_unified_contacts_manager(sync_db)
                sync_stats = await manager.sync_from_sources()
                print(f"[Backend] Auto-synced to unified_contacts: {sync_stats}", file=sys.stderr)
                self.send_log(f"âœ… å·²åŒæ­¥åˆ°è³‡æºä¸­å¿ƒ: æ–°å¢ {sync_stats['synced']}ï¼Œæ›´æ–° {sync_stats['updated']}", "info")
            except Exception as sync_err:
                import traceback
                traceback.print_exc(file=sys.stderr)
                print(f"[Backend] Auto-sync error: {sync_err}", file=sys.stderr)
        else:
            self.send_log(f"âŒ æå–å¤±æ•—: {result['error']}", "error")
        
        # ç™¼é€å®Œæˆäº‹ä»¶ - ğŸ”§ ä¿®å¾©ï¼šåŒ…å«è©³ç´°éŒ¯èª¤ä¿¡æ¯
        self.send_event("members-extracted", {
            "resourceId": resource_id,
            "success": result.get('success', False),
            "members": result.get('members', []),
            "extracted": result.get('extracted', 0),
            "total": result.get('total', 0),
            "onlineCount": result.get('online_count', 0),
            "error": result.get('error'),
            "error_code": result.get('error_code'),  # ğŸ†• éŒ¯èª¤ä»£ç¢¼
            "error_details": result.get('error_details')  # ğŸ†• è©³ç´°éŒ¯èª¤ä¿¡æ¯
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_log(f"âŒ æå–æˆå“¡å¤±æ•—: {e}", "error")
        self.send_event("members-extracted", {
            "resourceId": payload.get('resourceId'),
            "success": False,
            "error": str(e),
            "members": [],
            "extracted": 0,
            "total": 0
        })


async def handle_get_extracted_members(self, payload: Dict[str, Any]):
    """ç²å–å·²æå–çš„æˆå“¡åˆ—è¡¨ - ğŸ†• P3 å„ªåŒ–ï¼šæ”¯æŒå®Œæ•´åˆ†é """
    import time
    start_time = time.time()
    print(f"[Backend] handle_get_extracted_members started, payload: {payload}", file=sys.stderr)
    
    try:
        online_only = payload.get('onlineOnly', False)
        min_value_level = payload.get('minValueLevel')
        source_chat_id = payload.get('sourceChatId')
        not_contacted = payload.get('notContacted', False)
        limit = payload.get('limit', 100)
        offset = payload.get('offset', 0)
        page = payload.get('page', 1)
        page_size = payload.get('pageSize', limit)
        
        # ğŸ†• P3ï¼šæ”¯æŒé ç¢¼æ–¹å¼åˆ†é 
        if page > 1:
            offset = (page - 1) * page_size
            limit = page_size
        
        print(f"[Backend] Fetching members with limit={limit}, offset={offset}...", file=sys.stderr)
        
        # ğŸ†• P3ï¼šç²å–ç¸½æ•¸ï¼ˆç”¨æ–¼åˆ†é ï¼‰
        total_count = await member_extraction_service.count_members_filtered(
            online_only=online_only,
            min_value_level=min_value_level,
            source_chat_id=source_chat_id,
            not_contacted=not_contacted
        )
        
        members = await member_extraction_service.get_members(
            online_only=online_only,
            min_value_level=min_value_level,
            source_chat_id=source_chat_id,
            not_contacted=not_contacted,
            limit=limit,
            offset=offset
        )
        
        elapsed = time.time() - start_time
        print(f"[Backend] Fetched {len(members)} members (total: {total_count}) in {elapsed:.2f}s", file=sys.stderr)
        
        # ğŸ†• P3ï¼šè¿”å›åˆ†é ä¿¡æ¯
        total_pages = (total_count + page_size - 1) // page_size if page_size > 0 else 1
        
        self.send_event("extracted-members-list", {
            "success": True,
            "members": members,
            "count": len(members),
            # ğŸ†• P3ï¼šåˆ†é å…ƒæ•¸æ“š
            "pagination": {
                "total": total_count,
                "page": page,
                "pageSize": page_size,
                "totalPages": total_pages,
                "hasMore": offset + len(members) < total_count
            }
        })
        print(f"[Backend] Sent extracted-members-list event with {len(members)} members", file=sys.stderr)
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_log(f"âŒ ç²å–æˆå“¡åˆ—è¡¨å¤±æ•—: {e}", "error")
        self.send_event("extracted-members-list", {
            "success": False,
            "error": str(e)
        })


async def handle_get_member_stats(self, payload: Dict[str, Any]):
    """ç²å–æˆå“¡çµ±è¨ˆ"""
    try:
        source_chat_id = payload.get('sourceChatId')
        
        stats = await member_extraction_service.count_members(source_chat_id)
        
        self.send_event("member-stats", {
            "success": True,
            **stats
        })
        
    except Exception as e:
        self.send_log(f"âŒ ç²å–æˆå“¡çµ±è¨ˆå¤±æ•—: {e}", "error")
        self.send_event("member-stats", {
            "success": False,
            "error": str(e)
        })


async def handle_get_online_members(self, payload: Dict[str, Any]):
    """ç²å–åœ¨ç·šæˆå“¡"""
    try:
        limit = payload.get('limit', 100)
        
        members = await member_extraction_service.get_online_members(limit)
        
        self.send_event("online-members-list", {
            "success": True,
            "members": members,
            "count": len(members)
        })
        
    except Exception as e:
        self.send_log(f"âŒ ç²å–åœ¨ç·šæˆå“¡å¤±æ•—: {e}", "error")
        self.send_event("online-members-list", {
            "success": False,
            "error": str(e)
        })


async def handle_update_member(self, payload: Dict[str, Any]):
    """æ›´æ–°æˆå“¡ä¿¡æ¯"""
    try:
        user_id = payload.get('userId')
        updates = payload.get('updates', {})
        
        if not user_id:
            raise ValueError("ç”¨æˆ¶ ID ä¸èƒ½ç‚ºç©º")
        
        # æ§‹å»ºæ›´æ–°èªå¥
        set_clauses = []
        params = []
        
        allowed_fields = ['tags', 'notes', 'contacted', 'contacted_at', 'response_status', 'converted', 'value_level']
        
        for field, value in updates.items():
            if field in allowed_fields:
                set_clauses.append(f"{field} = ?")
                params.append(value if not isinstance(value, bool) else (1 if value else 0))
        
        if not set_clauses:
            self.send_event("member-updated", {
                "success": True,
                "userId": user_id,
                "message": "ç„¡éœ€æ›´æ–°"
            })
            return
        
        # æ·»åŠ æ›´æ–°æ™‚é–“
        set_clauses.append("updated_at = ?")
        params.append(datetime.now().isoformat())
        
        # æ·»åŠ  user_id åƒæ•¸
        params.append(user_id)
        
        query = f"UPDATE extracted_members SET {', '.join(set_clauses)} WHERE user_id = ?"
        
        await db.execute(query, tuple(params))
        
        self.send_log(f"âœ… æ›´æ–°æˆå“¡ {user_id} æˆåŠŸ", "success")
        self.send_event("member-updated", {
            "success": True,
            "userId": user_id
        })
        
    except Exception as e:
        self.send_log(f"âŒ æ›´æ–°æˆå“¡å¤±æ•—: {e}", "error")
        self.send_event("member-updated", {
            "success": False,
            "error": str(e)
        })


# ==================== P2 å„ªåŒ–ï¼šçµ±è¨ˆèˆ‡èƒŒæ™¯æå– ====================

async def handle_get_extraction_stats(self, payload: Dict[str, Any]):
    """ç²å–æå–çµ±è¨ˆä¿¡æ¯"""
    import sys
    print(f"[Backend] handle_get_extraction_stats called", file=sys.stderr)
    
    try:
        stats = member_extraction_service.get_stats()
        
        self.send_event("extraction-stats", {
            "success": True,
            **stats
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("extraction-stats", {
            "success": False,
            "error": str(e)
        })


async def handle_start_background_extraction(self, payload: Dict[str, Any]):
    """å•Ÿå‹•èƒŒæ™¯æå–"""
    import sys
    print(f"[Backend] handle_start_background_extraction called: {payload}", file=sys.stderr)
    
    try:
        chat_id = payload.get('chatId') or payload.get('telegramId')
        phone = payload.get('phone')
        limit = payload.get('limit', 100)
        filters = payload.get('filters', {})
        
        if not chat_id:
            raise ValueError("ç¾¤çµ„ ID ä¸èƒ½ç‚ºç©º")
        
        # è¨­ç½®å®¢æˆ¶ç«¯
        member_extraction_service.set_clients(self.telegram_manager.clients)
        member_extraction_service.set_event_callback(self.send_event)
        
        # å•Ÿå‹•èƒŒæ™¯ä»»å‹™
        task_id = await member_extraction_service.start_background_extraction(
            chat_id=chat_id,
            phone=phone,
            limit=limit,
            filter_bots=filters.get('bots', True),
            online_status=filters.get('onlineStatus', 'all')
        )
        
        self.send_log(f"ğŸ”„ èƒŒæ™¯æå–å·²å•Ÿå‹•: {task_id}", "info")
        self.send_event("background-extraction-started", {
            "success": True,
            "taskId": task_id,
            "chatId": chat_id
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_log(f"âŒ å•Ÿå‹•èƒŒæ™¯æå–å¤±æ•—: {e}", "error")
        self.send_event("background-extraction-started", {
            "success": False,
            "error": str(e)
        })


async def handle_clear_extraction_cache(self, payload: Dict[str, Any]):
    """æ¸…é™¤æå–ç·©å­˜"""
    try:
        chat_id = payload.get('chatId')
        member_extraction_service.clear_result_cache(chat_id)
        
        self.send_event("cache-cleared", {
            "success": True,
            "chatId": chat_id
        })
        
    except Exception as e:
        self.send_event("cache-cleared", {
            "success": False,
            "error": str(e)
        })


# ==================== P4 å„ªåŒ–ï¼šæ•¸æ“šå°å‡ºèˆ‡ç®¡ç† ====================

async def handle_export_members(self, payload: Dict[str, Any]):
    """å°å‡ºæˆå“¡æ•¸æ“š"""
    import sys
    print(f"[Backend] handle_export_members called: {payload}", file=sys.stderr)
    
    try:
        format_type = payload.get('format', 'csv')  # csv æˆ– json
        filters = payload.get('filters', {})
        
        if format_type == 'json':
            content = await member_extraction_service.export_members_json(filters)
            filename = f"members_export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        else:
            content = await member_extraction_service.export_members_csv(filters)
            filename = f"members_export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
        
        self.send_log(f"âœ… å°å‡ºå®Œæˆ: {filename}", "success")
        self.send_event("members-exported", {
            "success": True,
            "content": content,
            "filename": filename,
            "format": format_type
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_log(f"âŒ å°å‡ºå¤±æ•—: {e}", "error")
        self.send_event("members-exported", {
            "success": False,
            "error": str(e)
        })


async def handle_deduplicate_members(self, payload: Dict[str, Any]):
    """å»é‡æˆå“¡æ•¸æ“š"""
    import sys
    print(f"[Backend] handle_deduplicate_members called", file=sys.stderr)
    
    try:
        result = await member_extraction_service.deduplicate_members()
        
        self.send_log(f"âœ… å»é‡å®Œæˆ: åˆä½µ {result['merged']} å€‹ï¼Œåˆªé™¤ {result['deleted']} æ¢", "success")
        self.send_event("members-deduplicated", {
            "success": True,
            **result
        })
        
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("members-deduplicated", {
            "success": False,
            "error": str(e)
        })

