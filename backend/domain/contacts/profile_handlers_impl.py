"""
Extracted handler implementations: profiles
Auto-generated by refactor_main.py
"""
import json
import sys
import time
import asyncio
import traceback
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from service_context import get_service_context

# All handlers receive (self, payload) where self is BackendService instance.
# They are called via: await handler_impl(self, payload)
# Inside, use self.db, self.send_event(), self.telegram_manager, etc.
# This is a transitional pattern - later, replace self.xxx with ctx.xxx


async def handle_get_user_memories(self, payload: Dict[str, Any]):
    """ğŸ†• Phase1: ç²å–ç”¨æˆ¶è¨˜æ†¶"""
    user_id = payload.get('userId', '')
    current_message = payload.get('message', '')
    
    try:
        from conversation_memory import get_memory_service
        service = get_memory_service()
        
        memories = await service.recall_relevant_memories(user_id, current_message)
        summary = await service.get_conversation_summary(user_id)
        
        self.send_event("user-memories", {
            "success": True,
            "memories": memories,
            "summary": summary
        })
    except Exception as e:
        print(f"[Backend] Error getting user memories: {e}", file=sys.stderr)
        self.send_event("user-memories", {
            "success": False,
            "error": str(e)
        })


async def handle_get_user_tags(self, payload: Dict[str, Any]):
    """ğŸ†• Phase1: ç²å–ç”¨æˆ¶æ¨™ç±¤"""
    user_id = payload.get('userId', '')
    
    try:
        from auto_tagging_service import get_tagging_service
        service = get_tagging_service()
        
        tags = await service.get_user_tags(user_id)
        
        self.send_event("user-tags", {
            "success": True,
            "data": tags
        })
    except Exception as e:
        print(f"[Backend] Error getting user tags: {e}", file=sys.stderr)
        self.send_event("user-tags", {
            "success": False,
            "error": str(e)
        })


async def handle_add_user_tag(self, payload: Dict[str, Any]):
    """ğŸ†• Phase1: æ‰‹å‹•æ·»åŠ ç”¨æˆ¶æ¨™ç±¤"""
    user_id = payload.get('userId', '')
    tag_name = payload.get('tagName', '')
    category = payload.get('category', 'custom')
    
    try:
        from auto_tagging_service import get_tagging_service, TagCategory
        service = get_tagging_service()
        
        cat = TagCategory(category) if category in [e.value for e in TagCategory] else TagCategory.CUSTOM
        await service.add_manual_tag(user_id, tag_name, cat)
        
        self.send_event("user-tag-added", {
            "success": True,
            "tagName": tag_name
        })
        self.send_log(f"å·²ç‚ºç”¨æˆ¶ {user_id} æ·»åŠ æ¨™ç±¤: {tag_name}", "success")
    except Exception as e:
        print(f"[Backend] Error adding user tag: {e}", file=sys.stderr)
        self.send_event("user-tag-added", {
            "success": False,
            "error": str(e)
        })


async def handle_remove_user_tag(self, payload: Dict[str, Any]):
    """ğŸ†• Phase1: ç§»é™¤ç”¨æˆ¶æ¨™ç±¤"""
    user_id = payload.get('userId', '')
    tag_id = payload.get('tagId', '')
    
    try:
        from auto_tagging_service import get_tagging_service
        service = get_tagging_service()
        
        await service.remove_tag(user_id, tag_id)
        
        self.send_event("user-tag-removed", {
            "success": True,
            "tagId": tag_id
        })
    except Exception as e:
        print(f"[Backend] Error removing user tag: {e}", file=sys.stderr)
        self.send_event("user-tag-removed", {
            "success": False,
            "error": str(e)
        })


async def handle_get_users_by_tag(self, payload: Dict[str, Any]):
    """ğŸ†• Phase1: æ ¹æ“šæ¨™ç±¤æŸ¥è©¢ç”¨æˆ¶"""
    tag_name = payload.get('tagName')
    category = payload.get('category')
    intent_level = payload.get('intentLevel')
    
    try:
        from auto_tagging_service import get_tagging_service, TagCategory, IntentLevel
        service = get_tagging_service()
        
        cat = TagCategory(category) if category else None
        level = IntentLevel(intent_level) if intent_level else None
        
        users = await service.get_users_by_tag(tag_name, cat, level)
        
        self.send_event("users-by-tag", {
            "success": True,
            "users": users,
            "count": len(users)
        })
    except Exception as e:
        print(f"[Backend] Error getting users by tag: {e}", file=sys.stderr)
        self.send_event("users-by-tag", {
            "success": False,
            "error": str(e)
        })


async def handle_get_customer_profile(self, payload: Dict[str, Any]):
    """ğŸ†• ç²å–å®¢æˆ¶ç•«åƒï¼ˆæ¨™ç±¤+æ„å‘ï¼‰"""
    user_id = payload.get('userId', '')
    
    try:
        from auto_tagging_service import get_tagging_service
        service = get_tagging_service()
        
        profile = await service.get_customer_profile(user_id)
        
        self.send_event("customer-profile", {
            "success": True,
            "profile": profile
        })
    except Exception as e:
        print(f"[Backend] Error getting customer profile: {e}", file=sys.stderr)
        self.send_event("customer-profile", {
            "success": False,
            "error": str(e)
        })


async def handle_get_emotion_trend(self, payload: Dict[str, Any]):
    """ğŸ†• ç²å–æƒ…ç·’è¶¨å‹¢"""
    user_id = payload.get('userId', '')
    
    try:
        from emotion_analyzer import get_emotion_analyzer
        analyzer = get_emotion_analyzer()
        
        trend = await analyzer.get_emotion_trend(user_id)
        
        self.send_event("emotion-trend", {
            "success": True,
            "trend": trend
        })
    except Exception as e:
        print(f"[Backend] Error getting emotion trend: {e}", file=sys.stderr)
        self.send_event("emotion-trend", {
            "success": False,
            "error": str(e)
        })


async def handle_get_workflow_rules(self, payload: Dict[str, Any]):
    """ğŸ†• ç²å–å·¥ä½œæµè¦å‰‡"""
    try:
        from automation_workflow import get_workflow_engine
        engine = get_workflow_engine()
        
        rules = await engine.get_rules()
        
        self.send_event("workflow-rules", {
            "success": True,
            "rules": rules
        })
    except Exception as e:
        print(f"[Backend] Error getting workflow rules: {e}", file=sys.stderr)
        self.send_event("workflow-rules", {
            "success": False,
            "error": str(e)
        })


async def handle_get_followup_tasks(self, payload: Dict[str, Any]):
    """ğŸ†• ç²å–è·Ÿé€²ä»»å‹™"""
    try:
        from smart_timing_service import get_timing_service
        service = get_timing_service()
        
        tasks = await service.get_pending_followups()
        
        self.send_event("followup-tasks", {
            "success": True,
            "tasks": tasks
        })
    except Exception as e:
        print(f"[Backend] Error getting followup tasks: {e}", file=sys.stderr)
        self.send_event("followup-tasks", {
            "success": False,
            "error": str(e)
        })


async def handle_get_learning_stats(self, payload: Dict[str, Any]):
    """ğŸ†• ç²å–çŸ¥è­˜å­¸ç¿’çµ±è¨ˆ"""
    try:
        from knowledge_learning import get_learning_service
        service = get_learning_service()
        
        stats = await service.get_learning_stats()
        
        self.send_event("learning-stats", {
            "success": True,
            "stats": stats
        })
    except Exception as e:
        print(f"[Backend] Error getting learning stats: {e}", file=sys.stderr)
        self.send_event("learning-stats", {
            "success": False,
            "error": str(e)
        })


async def handle_schedule_followup(self, payload: Dict[str, Any]):
    """ğŸ†• æ‰‹å‹•æ’ç¨‹è·Ÿé€²"""
    user_id = payload.get('userId', '')
    reason = payload.get('reason', 'manual')
    hours = payload.get('hours', 24)
    message = payload.get('message', '')
    
    try:
        from smart_timing_service import get_timing_service, FollowUpReason
        service = get_timing_service()
        
        await service.schedule_followup(
            user_id,
            FollowUpReason(reason) if reason in [e.value for e in FollowUpReason] else FollowUpReason.NO_REPLY,
            hours,
            message
        )
        
        self.send_event("followup-scheduled", {
            "success": True,
            "userId": user_id,
            "hours": hours
        })
        self.send_log(f"å·²ç‚ºç”¨æˆ¶ {user_id} æ’ç¨‹ {hours} å°æ™‚å¾Œè·Ÿé€²", "success")
    except Exception as e:
        print(f"[Backend] Error scheduling followup: {e}", file=sys.stderr)
        self.send_event("followup-scheduled", {
            "success": False,
            "error": str(e)
        })


async def handle_trigger_workflow(self, payload: Dict[str, Any]):
    """ğŸ†• æ‰‹å‹•è§¸ç™¼å·¥ä½œæµ"""
    event_type = payload.get('eventType', 'message_received')
    user_id = payload.get('userId', '')
    event_data = payload.get('data', {})
    
    try:
        from automation_workflow import get_workflow_engine, EventType
        engine = get_workflow_engine()
        
        triggered = await engine.trigger_event(
            EventType(event_type),
            user_id,
            event_data
        )
        
        self.send_event("workflow-triggered", {
            "success": True,
            "triggeredRules": triggered
        })
        if triggered:
            self.send_log(f"å·²è§¸ç™¼ {len(triggered)} å€‹å·¥ä½œæµè¦å‰‡", "success")
    except Exception as e:
        print(f"[Backend] Error triggering workflow: {e}", file=sys.stderr)
        self.send_event("workflow-triggered", {
            "success": False,
            "error": str(e)
        })


async def handle_add_user_tag(self, payload: Dict[str, Any]):
    """æ·»åŠ ç”¨æˆ¶æ¨™ç±¤"""
    try:
        user_id = payload.get('userId', '')
        tag = payload.get('tag', '')
        tag_type = payload.get('tagType', 'custom')
        
        await db._connection.execute("""
            INSERT OR IGNORE INTO user_tags (user_id, tag, tag_type)
            VALUES (?, ?, ?)
        """, (user_id, tag, tag_type))
        await db._connection.commit()
        
        self.send_event("tag-added", {
            "success": True,
            "userId": user_id,
            "tag": tag
        })
    except Exception as e:
        self.send_event("tag-added", {
            "success": False,
            "error": str(e)
        })


async def handle_remove_user_tag(self, payload: Dict[str, Any]):
    """ç§»é™¤ç”¨æˆ¶æ¨™ç±¤"""
    try:
        user_id = payload.get('userId', '')
        tag = payload.get('tag', '')
        
        await db._connection.execute("""
            DELETE FROM user_tags WHERE user_id = ? AND tag = ?
        """, (user_id, tag))
        await db._connection.commit()
        
        self.send_event("tag-removed", {
            "success": True,
            "userId": user_id,
            "tag": tag
        })
    except Exception as e:
        self.send_event("tag-removed", {
            "success": False,
            "error": str(e)
        })


async def handle_get_user_tags(self, payload: Dict[str, Any]):
    """ç²å–ç”¨æˆ¶æ¨™ç±¤"""
    try:
        user_id = payload.get('userId', '')
        
        cursor = await db._connection.execute("""
            SELECT ut.tag, ut.tag_type, ut.confidence, ut.auto_assigned, ut.created_at,
                   td.color, td.description
            FROM user_tags ut
            LEFT JOIN tag_definitions td ON ut.tag = td.tag
            WHERE ut.user_id = ?
        """, (user_id,))
        
        rows = await cursor.fetchall()
        tags = [dict(row) for row in rows]
        
        self.send_event("user-tags", {
            "success": True,
            "userId": user_id,
            "tags": tags
        })
    except Exception as e:
        self.send_event("user-tags", {
            "success": False,
            "error": str(e)
        })

