"""
Extracted handler implementations: groups
Auto-generated by refactor_main.py
"""
import json
import sys
import time
import asyncio
import traceback
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from service_context import get_service_context

from database import db
import re
from error_handler import handle_error, AppError, ErrorType
from validators import validate_group_url, GroupValidator, ValidationError

# ğŸ”§ Phase5: Membership check çµæœç·©å­˜ï¼ˆé¿å…é‡è¤‡ Telegram API èª¿ç”¨ï¼‰
_membership_cache: Dict[str, Dict[str, Any]] = {}  # url -> {"result": ..., "expires": timestamp}
_MEMBERSHIP_CACHE_TTL = 300  # 5 åˆ†é˜
from service_locator import (
    get_group_poller,
    get_init_group_poller,
    group_search_service,
    jiso_search_service,
    resource_discovery
)


async def _get_group_load_map(db_conn) -> Dict[str, int]:
    """ğŸ”§ Phase6-3: ç²å–æ¯å€‹å¸³è™Ÿç¶å®šçš„ç¾¤çµ„æ•¸é‡ï¼ˆè² è¼‰åˆ†ä½ˆï¼‰"""
    try:
        await db_conn.connect()
        rows = await db_conn.fetch_all(
            "SELECT phone, COUNT(*) as cnt FROM monitored_groups "
            "WHERE phone IS NOT NULL AND phone != '' AND is_active = 1 "
            "GROUP BY phone"
        )
        return {r['phone']: r['cnt'] for r in rows} if rows else {}
    except Exception:
        return {}


async def select_best_account(telegram_manager, db_conn, operation: str = 'join', 
                                preferred_role: str = None,
                                exclude_flood_wait: bool = True) -> Optional[str]:
    """
    Phase3+5+6: æ™ºèƒ½å¸³è™Ÿé¸æ“‡ â€” è§’è‰²å„ªå…ˆç´š + FloodWait + è² è¼‰å‡è¡¡
    
    æ“ä½œå„ªå…ˆç´šï¼š
    - join/monitor: å„ªå…ˆ Explorer > Listener > Unassigned > Sender
    - extract: å„ªå…ˆ Listener > Explorer > Unassigned > Sender
    - search: å„ªå…ˆ Explorer > any
    
    Phase5: æ’é™¤ FloodWait å†·å»ä¸­çš„å¸³è™Ÿ
    Phase6-3: åŒè§’è‰²å¸³è™Ÿé–“æŒ‰ç¾¤çµ„è² è¼‰æ•¸é‡é¸æœ€å°‘çš„ï¼ˆè² è¼‰å‡è¡¡ï¼‰
    
    Returns:
        æœ€ä½³å¸³è™Ÿ phone, æˆ– None
    """
    connected = {
        p: c for p, c in telegram_manager.clients.items()
        if c and c.is_connected
    }
    if not connected:
        return None
    
    # Phase5: æ’é™¤ FloodWait å†·å»ä¸­çš„å¸³è™Ÿ
    if exclude_flood_wait:
        try:
            from flood_wait_handler import flood_handler
            available_phones = set()
            cooling_phones = {}
            for phone in connected:
                remaining = flood_handler.get_remaining_cooldown(phone)
                if remaining <= 0:
                    available_phones.add(phone)
                else:
                    cooling_phones[phone] = remaining
            
            if cooling_phones:
                print(
                    f"[SmartSelect] {operation}: æ’é™¤ {len(cooling_phones)} å€‹å†·å»å¸³è™Ÿ "
                    f"[{', '.join(f'{p[:4]}****({r:.0f}s)' for p, r in cooling_phones.items())}]",
                    file=sys.stderr
                )
            
            if available_phones:
                connected = {p: c for p, c in connected.items() if p in available_phones}
            else:
                shortest_phone = min(cooling_phones, key=cooling_phones.get) if cooling_phones else None
                if shortest_phone:
                    print(
                        f"[SmartSelect] æ‰€æœ‰å¸³è™Ÿå†·å»ä¸­ï¼Œé¸æ“‡æœ€å¿«å¯ç”¨: {shortest_phone[:4]}**** ({cooling_phones[shortest_phone]:.0f}s)",
                        file=sys.stderr
                    )
                    return shortest_phone
        except ImportError:
            pass
    
    if len(connected) == 1:
        return list(connected.keys())[0]
    
    # å¾ DB ç²å–è§’è‰²ä¿¡æ¯
    try:
        await db_conn.connect()
        accounts = await db_conn.fetch_all(
            "SELECT phone, role, health_score FROM accounts WHERE phone IN ({}) AND status = 'Online'".format(
                ','.join(['?' for _ in connected])
            ),
            tuple(connected.keys())
        )
        role_map = {a['phone']: a.get('role', 'Unassigned') for a in accounts} if accounts else {}
        health_map = {a['phone']: a.get('health_score', 100) for a in accounts} if accounts else {}
    except Exception:
        role_map = {}
        health_map = {}
    
    # ğŸ”§ Phase6-3: ç²å–æ¯å€‹å¸³è™Ÿçš„ç¾¤çµ„è² è¼‰
    group_load = await _get_group_load_map(db_conn)
    
    # æ ¹æ“šæ“ä½œå®šç¾©è§’è‰²å„ªå…ˆç´š
    if operation in ('join', 'monitor'):
        role_priority = ['Explorer', 'Listener', 'Unassigned', 'Sender']
    elif operation == 'extract':
        role_priority = ['Listener', 'Explorer', 'Unassigned', 'Sender']
    elif operation == 'search':
        role_priority = ['Explorer', 'Unassigned', 'Listener', 'Sender']
    else:
        role_priority = ['Unassigned', 'Listener', 'Explorer', 'Sender']
    
    if preferred_role and preferred_role in role_priority:
        role_priority.remove(preferred_role)
        role_priority.insert(0, preferred_role)
    
    # ğŸ”§ Phase6-3: åŒè§’è‰²å¸³è™Ÿé–“ï¼Œé¸ç¾¤çµ„æ•¸æœ€å°‘ + å¥åº·åˆ†æœ€é«˜çš„
    for role in role_priority:
        candidates = [p for p in connected if role_map.get(p, 'Unassigned') == role]
        if candidates:
            # æŒ‰ (ç¾¤çµ„è² è¼‰å‡åº, å¥åº·åˆ†é™åº) æ’åº
            candidates.sort(key=lambda p: (
                group_load.get(p, 0),              # ç¾¤çµ„æ•¸è¶Šå°‘è¶Šå¥½
                -(health_map.get(p, 100) or 100)   # å¥åº·åˆ†è¶Šé«˜è¶Šå¥½
            ))
            best = candidates[0]
            load_info = group_load.get(best, 0)
            print(
                f"[SmartSelect] {operation}: é¸æ“‡ {best[:4]}**** (role={role}, groups={load_info}, "
                f"health={health_map.get(best, 100):.0f})",
                file=sys.stderr
            )
            return best
    
    return list(connected.keys())[0]


async def get_account_recommendations(telegram_manager, db_conn) -> List[Dict[str, Any]]:
    """
    ğŸ”§ Phase6-3: ç²å–å¸³è™Ÿæ¨è–¦åˆ—è¡¨ï¼ˆå«è² è¼‰å’Œç‹€æ…‹ä¿¡æ¯ï¼‰
    
    ç‚ºå‰ç«¯å¸³è™Ÿé¸æ“‡ UI æä¾›æ•¸æ“šæº
    """
    recommendations = []
    
    try:
        await db_conn.connect()
        accounts = await db_conn.fetch_all(
            "SELECT id, phone, role, status, health_score, username, first_name "
            "FROM accounts ORDER BY id"
        )
        if not accounts:
            return []
        
        group_load = await _get_group_load_map(db_conn)
        
        # FloodWait ç‹€æ…‹
        flood_status = {}
        try:
            from flood_wait_handler import flood_handler
            for a in accounts:
                phone = a['phone']
                remaining = flood_handler.get_remaining_cooldown(phone)
                flood_status[phone] = remaining
        except ImportError:
            pass
        
        # é€£æ¥ç‹€æ…‹
        connected_set = set()
        if hasattr(telegram_manager, 'clients'):
            connected_set = {p for p, c in telegram_manager.clients.items() if c and c.is_connected}
        
        for a in accounts:
            phone = a['phone']
            is_connected = phone in connected_set
            flood_remaining = flood_status.get(phone, 0)
            load = group_load.get(phone, 0)
            health = a.get('health_score', 100) or 100
            
            # è¨ˆç®—ç¶œåˆæ¨è–¦åˆ†æ•¸ (0~100)
            score = 0
            reasons = []
            
            if not is_connected:
                score = 0
                reasons.append('é›¢ç·š')
            else:
                score = 60
                reasons.append('åœ¨ç·š')
                
                # è§’è‰²åŠ åˆ†
                role = a.get('role', 'Unassigned')
                if role in ('Listener', 'Explorer'):
                    score += 15
                    reasons.append(f'è§’è‰²:{role}')
                elif role == 'Unassigned':
                    score += 5
                
                # è² è¼‰æ¸›åˆ†
                if load == 0:
                    score += 15
                    reasons.append('ç„¡ç¾¤çµ„è² è¼‰')
                elif load <= 3:
                    score += 10
                    reasons.append(f'ä½è² è¼‰({load}ç¾¤)')
                elif load <= 8:
                    score += 5
                    reasons.append(f'ä¸­è² è¼‰({load}ç¾¤)')
                else:
                    reasons.append(f'é«˜è² è¼‰({load}ç¾¤)')
                
                # å¥åº·åˆ†åŠ åˆ†
                if health >= 90:
                    score += 10
                elif health >= 70:
                    score += 5
                elif health < 50:
                    score -= 10
                    reasons.append('å¥åº·ä½')
                
                # FloodWait æ¸›åˆ†
                if flood_remaining > 0:
                    score -= 20
                    reasons.append(f'å†·å»ä¸­({flood_remaining:.0f}s)')
            
            recommendations.append({
                'phone': phone,
                'username': a.get('username', ''),
                'firstName': a.get('first_name', ''),
                'role': a.get('role', 'Unassigned'),
                'status': 'connected' if is_connected else a.get('status', 'Offline'),
                'isConnected': is_connected,
                'healthScore': round(health, 1),
                'groupLoad': load,
                'floodWaitRemaining': round(flood_remaining, 0),
                'recommendScore': max(0, min(100, score)),
                'reasons': reasons
            })
        
        # æŒ‰æ¨è–¦åˆ†é™åºæ’åˆ—
        recommendations.sort(key=lambda x: -x['recommendScore'])
        
    except Exception as e:
        print(f"[SmartSelect] ç²å–å¸³è™Ÿæ¨è–¦å¤±æ•—: {e}", file=sys.stderr)
    
    return recommendations
# All handlers receive (self, payload) where self is BackendService instance.
# They are called via: await handler_impl(self, payload)
# Inside, use self.db, self.send_event(), self.telegram_manager, etc.
# This is a transitional pattern - later, replace self.xxx with ctx.xxx

async def handle_create_group(self, payload: Dict[str, Any]):
    """å‰µå»ºæ–°çš„ Telegram ç¾¤çµ„"""
    import sys
    
    try:
        name = payload.get('name', 'æ–°ç¾¤çµ„')
        description = payload.get('description', '')
        group_type = payload.get('type', 'supergroup')
        specified_phone = payload.get('accountPhone')  # å‰ç«¯æŒ‡å®šçš„å¸³è™Ÿ
        
        print(f"[Group] å‰µå»ºç¾¤çµ„: name={name}, type={group_type}, phone={specified_phone}", file=sys.stderr)
        self.send_log(f"ğŸ”¨ æ­£åœ¨å‰µå»ºç¾¤çµ„ã€Œ{name}ã€...", "info")
        
        # ç²å–å¯ç”¨å¸³è™Ÿï¼ˆæª¢æŸ¥ Online ç‹€æ…‹ï¼‰
        accounts = await db.get_all_accounts()
        online_accounts = [a for a in accounts if a.get('status') == 'Online']
        
        print(f"[Group] åœ¨ç·šå¸³è™Ÿ: {[(a.get('phone'), a.get('status')) for a in online_accounts]}", file=sys.stderr)
        
        if not online_accounts:
            self.send_event("create-group-result", {
                "success": False,
                "error": "æ²’æœ‰åœ¨ç·šçš„å¸³è™Ÿï¼Œè«‹å…ˆç™»å…¥å¸³è™Ÿ"
            })
            return
        
        # å„ªå…ˆä½¿ç”¨å‰ç«¯æŒ‡å®šçš„å¸³è™Ÿï¼Œå¦å‰‡ä½¿ç”¨ç¬¬ä¸€å€‹åœ¨ç·šå¸³è™Ÿ
        if specified_phone:
            account = next((a for a in online_accounts if a.get('phone') == specified_phone), None)
            if not account:
                account = online_accounts[0]
        else:
            account = online_accounts[0]
        
        phone = account.get('phone')
        account_name = account.get('firstName', phone)
        
        print(f"[Group] ä½¿ç”¨å¸³è™Ÿ {phone} ({account_name}) å‰µå»ºç¾¤çµ„", file=sys.stderr)
        self.send_log(f"ğŸ“± ä½¿ç”¨å¸³è™Ÿ {account_name} å‰µå»ºç¾¤çµ„...", "info")
        
        # ğŸ”§ P1: ç™¼é€é€²åº¦äº‹ä»¶
        self.send_event("create-group-progress", {
            "step": "connecting",
            "message": f"æ­£åœ¨ä½¿ç”¨å¸³è™Ÿ {account_name} é€£æ¥ Telegram..."
        })
        
        # ç²å–å®¢æˆ¶ç«¯ - å¾ telegram_manager ç²å–
        client = None
        if hasattr(self.telegram_manager, 'clients'):
            # phone å¯èƒ½æœ‰æˆ–æ²’æœ‰ + å‰ç¶´ï¼Œå˜—è©¦å…©ç¨®æ ¼å¼
            client = self.telegram_manager.clients.get(phone)
            if not client and phone.startswith('+'):
                client = self.telegram_manager.clients.get(phone[1:])
            if not client and not phone.startswith('+'):
                client = self.telegram_manager.clients.get(f'+{phone}')
        
        if not client:
            self.send_event("create-group-result", {
                "success": False,
                "error": f"å¸³è™Ÿ {account_name} æœªé€£æ¥ï¼Œè«‹é‡æ–°ç™»å…¥"
            })
            return
        
        # æª¢æŸ¥å®¢æˆ¶ç«¯æ˜¯å¦å·²é€£æ¥
        if not client.is_connected:
            try:
                await client.connect()
            except Exception as conn_err:
                self.send_event("create-group-result", {
                    "success": False,
                    "error": f"ç„¡æ³•é€£æ¥å¸³è™Ÿ {account_name}: {conn_err}"
                })
                return
        
        from pyrogram.types import ChatPrivileges
        
        # ğŸ”§ P1: ç™¼é€é€²åº¦äº‹ä»¶ - é–‹å§‹å‰µå»º
        self.send_event("create-group-progress", {
            "step": "creating",
            "message": f"æ­£åœ¨å‰µå»º{'è¶…ç´š' if group_type == 'supergroup' else 'æ™®é€š'}ç¾¤çµ„ã€Œ{name}ã€..."
        })
        
        if group_type == 'supergroup':
            # å‰µå»ºè¶…ç´šç¾¤çµ„
            print(f"[Group] å‰µå»ºè¶…ç´šç¾¤çµ„...", file=sys.stderr)
            chat = await client.create_supergroup(name, description or "æ­¡è¿åŠ å…¥ï¼")
        else:
            # å‰µå»ºæ™®é€šç¾¤çµ„
            print(f"[Group] å‰µå»ºæ™®é€šç¾¤çµ„...", file=sys.stderr)
            chat = await client.create_group(name, [])
        
        print(f"[Group] ç¾¤çµ„å‰µå»ºæˆåŠŸ: id={chat.id}", file=sys.stderr)
        
        # ç²å–é‚€è«‹é€£çµ
        try:
            invite_link = await client.export_chat_invite_link(chat.id)
        except Exception as link_err:
            print(f"[Group] ç²å–é‚€è«‹é€£çµå¤±æ•—: {link_err}", file=sys.stderr)
            invite_link = f"https://t.me/{chat.username}" if hasattr(chat, 'username') and chat.username else ""
        
        self.send_log(f"âœ… ç¾¤çµ„ã€Œ{name}ã€å‰µå»ºæˆåŠŸï¼", "success")
        
        self.send_event("create-group-result", {
            "success": True,
            "groupId": str(chat.id),
            "groupName": name,
            "groupUrl": invite_link
        })
        
    except Exception as e:
        import traceback
        error_str = str(e)
        print(f"[Group] å‰µå»ºç¾¤çµ„å¤±æ•—: {traceback.format_exc()}", file=sys.stderr)
        
        # æä¾›æ›´å‹å¥½çš„éŒ¯èª¤ä¿¡æ¯
        if 'FLOOD' in error_str.upper():
            friendly_error = "è«‹æ±‚éæ–¼é »ç¹ï¼Œè«‹ç¨å¾Œå†è©¦"
        elif 'PEER_FLOOD' in error_str.upper():
            friendly_error = "å¸³è™Ÿè¢«é™åˆ¶å‰µå»ºç¾¤çµ„ï¼Œè«‹æ›´æ›å¸³è™Ÿæˆ–ç¨å¾Œå†è©¦"
        elif 'AUTH' in error_str.upper():
            friendly_error = "å¸³è™Ÿèªè­‰å¤±æ•—ï¼Œè«‹é‡æ–°ç™»å…¥"
        elif 'TIMEOUT' in error_str.upper() or 'timeout' in error_str.lower():
            friendly_error = "é€£æ¥è¶…æ™‚ï¼Œè«‹æª¢æŸ¥ç¶²çµ¡"
        else:
            friendly_error = error_str
        
        self.send_log(f"âŒ å‰µå»ºç¾¤çµ„å¤±æ•—: {friendly_error}", "error")
        self.send_event("create-group-result", {
            "success": False,
            "error": friendly_error
        })

# ==================== ğŸ”§ ç¾¤èŠå”ä½œï¼šç¾¤çµ„ç®¡ç†æ–¹æ³• ====================

async def handle_group_invite_user(self, payload: Dict[str, Any]):
    """é‚€è«‹ç”¨æˆ¶åŠ å…¥ç¾¤çµ„ï¼ˆç¾¤èŠå”ä½œç”¨ï¼‰"""
    import sys
    
    try:
        group_id = payload.get('groupId')
        inviter_phone = payload.get('inviterPhone')
        target_user_id = payload.get('targetUserId')
        target_username = payload.get('targetUsername')
        
        print(f"[GroupCollab] é‚€è«‹ç”¨æˆ¶: group={group_id}, user={target_user_id or target_username}", file=sys.stderr)
        
        if not group_id or not inviter_phone:
            result = {"success": False, "error": "ç¼ºå°‘å¿…è¦åƒæ•¸"}
            self.send_event("group:invite-user-result", result)
            return result
        
        # ç²å–å®¢æˆ¶ç«¯
        client = self.telegram_manager.clients.get(inviter_phone)
        if not client or not client.is_connected:
            result = {"success": False, "error": f"å¸³è™Ÿ {inviter_phone} æœªé€£æ¥"}
            self.send_event("group:invite-user-result", result)
            return result
        
        # é‚€è«‹ç”¨æˆ¶
        try:
            # ç²å–ç”¨æˆ¶ ID
            if target_username:
                user = await client.get_users(target_username)
                user_id = user.id if hasattr(user, 'id') else user
            elif target_user_id:
                user_id = int(target_user_id)
            else:
                result = {"success": False, "error": "æœªæä¾›ç”¨æˆ¶åæˆ–ç”¨æˆ¶ID"}
                self.send_event("group:invite-user-result", result)
                return result
            
            print(f"[GroupCollab] æº–å‚™é‚€è«‹ç”¨æˆ¶ ID: {user_id} åˆ°ç¾¤çµ„ {group_id}", file=sys.stderr)
            
            # ğŸ”§ P0 ä¿®å¾©: å‚³å…¥ç”¨æˆ¶ ID (int) è€Œé User å°è±¡
            await client.add_chat_members(int(group_id), user_id)
            
            print(f"[GroupCollab] æˆåŠŸé‚€è«‹ç”¨æˆ¶ {target_user_id or target_username}", file=sys.stderr)
            
            # ğŸ†• P0 å„ªåŒ–: è¨˜éŒ„æ“ä½œåˆ°å°è©±è¨˜æ†¶ç³»çµ±
            try:
                from conversation_memory import get_memory_service
                memory_service = get_memory_service()
                await memory_service.record_action(
                    user_id=str(user_id),
                    action_type='group_invite',
                    action_details={
                        'group_id': str(group_id),
                        'group_name': payload.get('groupName', 'VIPæœå‹™ç¾¤'),
                        'invite_method': 'direct'
                    },
                    performed_by=inviter_phone
                )
            except Exception as mem_err:
                print(f"[GroupCollab] è¨˜éŒ„æ“ä½œå¤±æ•—: {mem_err}", file=sys.stderr)
            
            result = {"success": True, "message": "é‚€è«‹æˆåŠŸ", "userId": user_id}
            self.send_event("group:invite-user-result", result)
            return result
            
        except Exception as invite_error:
            error_str = str(invite_error)
            print(f"[GroupCollab] é‚€è«‹å¤±æ•—: {error_str}", file=sys.stderr)
            
            if 'PEER_FLOOD' in error_str.upper():
                result = {"success": False, "error": "PEER_FLOOD:è«‹æ±‚éæ–¼é »ç¹"}
            elif 'USER_PRIVACY' in error_str.upper() or 'PRIVACY' in error_str.upper():
                result = {"success": False, "error": "USER_PRIVACY:ç”¨æˆ¶éš±ç§è¨­ç½®ä¸å…è¨±é‚€è«‹"}
            elif 'USER_NOT_MUTUAL' in error_str.upper():
                result = {"success": False, "error": "USER_NOT_MUTUAL:éœ€è¦å…ˆäº’ç›¸æ·»åŠ å¥½å‹"}
            elif 'USER_ALREADY_PARTICIPANT' in error_str.upper():
                # ç”¨æˆ¶å·²åœ¨ç¾¤ä¸­ï¼Œè¦–ç‚ºæˆåŠŸ
                result = {"success": True, "message": "ç”¨æˆ¶å·²åœ¨ç¾¤çµ„ä¸­"}
                self.send_event("group:invite-user-result", result)
                return result
            else:
                result = {"success": False, "error": error_str}
            
            self.send_event("group:invite-user-result", result)
            return result
                
    except Exception as e:
        import traceback
        print(f"[GroupCollab] é‚€è«‹ç”¨æˆ¶ç•°å¸¸: {traceback.format_exc()}", file=sys.stderr)
        result = {"success": False, "error": str(e)}
        self.send_event("group:invite-user-result", result)
        return result

async def handle_group_add_member(self, payload: Dict[str, Any]):
    """æ·»åŠ æˆå“¡åˆ°ç¾¤çµ„ï¼ˆé‚€è«‹å…¶ä»–å¸³è™Ÿï¼‰"""
    import sys
    
    try:
        group_id = payload.get('groupId')
        adder_phone = payload.get('adderPhone')
        member_phone = payload.get('memberPhone')
        
        print(f"[GroupCollab] æ·»åŠ æˆå“¡: group={group_id}, member={member_phone}", file=sys.stderr)
        
        if not group_id or not adder_phone or not member_phone:
            result = {"success": False, "error": "ç¼ºå°‘å¿…è¦åƒæ•¸"}
            self.send_event("group:add-member-result", result)
            return result
        
        # ç²å–é‚€è«‹è€…å®¢æˆ¶ç«¯
        adder_client = self.telegram_manager.clients.get(adder_phone)
        if not adder_client or not adder_client.is_connected:
            result = {"success": False, "error": f"é‚€è«‹å¸³è™Ÿ {adder_phone} æœªé€£æ¥"}
            self.send_event("group:add-member-result", result)
            return result
        
        # ç²å–è¢«é‚€è«‹è€…å®¢æˆ¶ç«¯ä»¥ç²å–å…¶ Telegram ç”¨æˆ¶ä¿¡æ¯
        member_client = self.telegram_manager.clients.get(member_phone)
        if not member_client or not member_client.is_connected:
            result = {"success": False, "error": f"æˆå“¡å¸³è™Ÿ {member_phone} æœªé€£æ¥"}
            self.send_event("group:add-member-result", result)
            return result
        
        try:
            # ç²å–æˆå“¡çš„ Telegram ç”¨æˆ¶ ID
            member_me = await member_client.get_me()
            member_user_id = member_me.id
            
            # ä½¿ç”¨é‚€è«‹è€…å¸³è™Ÿæ·»åŠ æˆå“¡
            await adder_client.add_chat_members(int(group_id), member_user_id)
            
            print(f"[GroupCollab] æˆåŠŸæ·»åŠ æˆå“¡ {member_phone} (ID: {member_user_id})", file=sys.stderr)
            result = {"success": True, "message": "æ·»åŠ æˆåŠŸ", "memberId": member_user_id}
            self.send_event("group:add-member-result", result)
            return result
            
        except Exception as add_error:
            error_str = str(add_error)
            print(f"[GroupCollab] æ·»åŠ æˆå“¡å¤±æ•—: {error_str}", file=sys.stderr)
            result = {"success": False, "error": error_str}
            self.send_event("group:add-member-result", result)
            return result
            
    except Exception as e:
        import traceback
        print(f"[GroupCollab] æ·»åŠ æˆå“¡ç•°å¸¸: {traceback.format_exc()}", file=sys.stderr)
        result = {"success": False, "error": str(e)}
        self.send_event("group:add-member-result", result)
        return result

async def handle_group_send_msg(self, payload: Dict[str, Any]):
    """åœ¨ç¾¤çµ„ä¸­ç™¼é€æ¶ˆæ¯ï¼ˆç¾¤èŠå”ä½œç”¨ï¼‰"""
    import sys
    
    try:
        group_id = payload.get('groupId')
        sender_phone = payload.get('senderPhone')
        content = payload.get('content')
        role_name = payload.get('roleName', '')
        
        print(f"[GroupCollab] ç™¼é€æ¶ˆæ¯: group={group_id}, sender={sender_phone}, role={role_name}", file=sys.stderr)
        
        if not group_id or not sender_phone or not content:
            return {"success": False, "error": "ç¼ºå°‘å¿…è¦åƒæ•¸"}
        
        # ç²å–å®¢æˆ¶ç«¯
        client = self.telegram_manager.clients.get(sender_phone)
        if not client or not client.is_connected:
            return {"success": False, "error": f"å¸³è™Ÿ {sender_phone} æœªé€£æ¥"}
        
        try:
            # ç™¼é€æ¶ˆæ¯
            message = await client.send_message(int(group_id), content)
            
            print(f"[GroupCollab] æ¶ˆæ¯ç™¼é€æˆåŠŸ: msg_id={message.id}", file=sys.stderr)
            
            # ç™¼é€äº‹ä»¶é€šçŸ¥å‰ç«¯
            self.send_event("group:message-sent", {
                "groupId": group_id,
                "senderPhone": sender_phone,
                "roleName": role_name,
                "content": content,
                "messageId": message.id,
                "timestamp": message.date.isoformat() if message.date else None
            })
            
            return {"success": True, "messageId": message.id}
            
        except Exception as send_error:
            error_str = str(send_error)
            print(f"[GroupCollab] ç™¼é€æ¶ˆæ¯å¤±æ•—: {error_str}", file=sys.stderr)
            return {"success": False, "error": error_str}
            
    except Exception as e:
        import traceback
        print(f"[GroupCollab] ç™¼é€æ¶ˆæ¯ç•°å¸¸: {traceback.format_exc()}", file=sys.stderr)
        return {"success": False, "error": str(e)}

async def handle_group_monitor_messages(self, payload: Dict[str, Any]):
    """
    ğŸ†• Phase 1 é‡æ§‹: ä½¿ç”¨è¼ªè©¢æ¨¡å¼ç›£æ§ç¾¤çµ„æ¶ˆæ¯
    
    Args:
        groupId: ç¾¤çµ„ ID
        roles: è§’è‰²é…ç½®åˆ—è¡¨ [{phone, roleId, roleName, prompt}, ...]
        mainAccountPhone: ä¸»å¸³è™Ÿé›»è©±
    """
    import sys
    
    try:
        group_id = payload.get('groupId')
        roles = payload.get('roles', [])
        main_phone = payload.get('mainAccountPhone')
        
        print(f"[GroupCollab] ğŸš€ å•Ÿå‹•ç¾¤çµ„ç›£æ§ (è¼ªè©¢æ¨¡å¼): group={group_id}, roles={len(roles)}", file=sys.stderr)
        
        if not group_id or not roles:
            return {"success": False, "error": "ç¼ºå°‘ç¾¤çµ„ ID æˆ–è§’è‰²é…ç½®"}
        
        # ğŸ”§ Phase 1: ä½¿ç”¨ç¾¤çµ„è¼ªè©¢å™¨æ›¿ä»£äº‹ä»¶é©…å‹•
        group_poller = get_group_poller()()
        if not group_poller:
            # åˆå§‹åŒ–è¼ªè©¢å™¨
            group_poller = get_init_group_poller()(self.send_event)
            print(f"[GroupCollab] âœ“ å·²åˆå§‹åŒ–ç¾¤çµ„è¼ªè©¢å™¨", file=sys.stderr)
        
        # æ”¶é›†æ‰€æœ‰åœ¨ç·šå®¢æˆ¶ç«¯
        online_clients = {}
        for role in roles:
            phone = role.get('phone')
            client = self.telegram_manager.clients.get(phone)
            if client and client.is_connected:
                online_clients[phone] = client
                print(f"[GroupCollab] âœ“ å¸³è™Ÿ {phone} ({role.get('roleName', 'æœªçŸ¥')}) å·²é€£æ¥", file=sys.stderr)
            else:
                print(f"[GroupCollab] âš  å¸³è™Ÿ {phone} æœªé€£æ¥", file=sys.stderr)
        
        if not online_clients:
            return {"success": False, "error": "æ²’æœ‰å¯ç”¨çš„åœ¨ç·šå¸³è™Ÿ"}
        
        # å•Ÿå‹•ç¾¤çµ„å”ä½œè¼ªè©¢
        result = await group_poller.start_group_collab(
            group_id=group_id,
            roles=roles,
            clients=online_clients,
            main_phone=main_phone
        )
        
        # è¨˜éŒ„æ´»èºçš„å”ä½œï¼ˆå‚™ä»½ï¼‰
        self._active_group_collabs[str(group_id)] = {
            'roles': roles,
            'main_phone': main_phone,
            'started_at': datetime.now().isoformat(),
            'message_count': 0,
            'last_responder': None,
            'polling_mode': True  # æ¨™è¨˜ç‚ºè¼ªè©¢æ¨¡å¼
        }
        
        print(f"[GroupCollab] âœ… ç¾¤çµ„ {group_id} è¼ªè©¢ç›£æ§å·²å•Ÿå‹•", file=sys.stderr)
        
        self.send_event("group:monitoring-started", {
            "groupId": group_id,
            "rolesCount": len(roles),
            "onlineClients": len(online_clients),
            "mode": "polling"
        })
        
        return {"success": True, "message": f"å·²é–‹å§‹è¼ªè©¢ç›£æ§ç¾¤çµ„ {group_id}"}
        
    except Exception as e:
        import traceback
        print(f"[GroupCollab] å•Ÿå‹•ç¾¤çµ„ç›£æ§å¤±æ•—: {traceback.format_exc()}", file=sys.stderr)
        return {"success": False, "error": str(e)}

async def handle_add_group(self, payload: Dict[str, Any]):
    """Handle add-group command. Returns {'success': True/False, 'error': ...} for caller inspection."""
    try:
        url = payload.get('url')
        name = payload.get('name', url)  # Use URL as name if not provided
        keyword_set_ids = payload.get('keywordSetIds', [])
        owner_user_id = payload.get('ownerUserId')
        
        # é…é¡æª¢æŸ¥ï¼šç¾¤çµ„æ•¸é‡
        quota_check = await self.check_quota('groups', 1, owner_user_id)
        if not quota_check.get('allowed', True):
            self.send_quota_exceeded_error('group-added', 'groups', quota_check.get('result', {}))
            return {'success': False, 'error': 'ç¾¤çµ„é…é¡å·²ç”¨å®Œ'}
        
        # Validate group URL
        is_valid, error = validate_group_url(url)
        if not is_valid:
            self.send_log(f"Validation error: {error}", "error")
            self.send_event("group-validation-error", {
                "errors": [error],
                "url": url
            })
            handle_error(
                AppError(ErrorType.VALIDATION_ERROR, error, {"url": url}),
                {"command": "add-group", "payload": payload}
            )
            return {'success': False, 'error': error}
        
        # Validate group name (optional)
        if name:
            is_valid, error = GroupValidator.validate_group_name(name)
            if not is_valid:
                self.send_log(f"Validation error: {error}", "error")
                self.send_event("group-validation-error", {
                    "errors": [error],
                    "name": name
                })
                handle_error(
                    AppError(ErrorType.VALIDATION_ERROR, error, {"name": name}),
                    {"command": "add-group", "payload": payload}
                )
                return {'success': False, 'error': error}
        
        # ========== æ–°å¢ï¼šé æª¢æŸ¥ç›£æ§è™Ÿå…¥ç¾¤ç‹€æ…‹ ==========
        membership_status = None
        
        # ğŸ”§ Phase5: å…ˆæŸ¥ç·©å­˜
        cached = _membership_cache.get(url)
        if cached and cached.get("expires", 0) > time.time():
            membership_status = cached.get("result")
            print(f"[Backend] Membership cache HIT for {url}", file=sys.stderr)
        else:
            accounts = await db.get_all_accounts()
            listener_accounts = [a for a in accounts if a.get('role') == 'Listener' and a.get('status') == 'Online']
            
            if listener_accounts:
                for account in listener_accounts:
                    phone = account.get('phone')
                    try:
                        check_result = await self.telegram_manager.check_group_membership(phone, url)
                        if check_result.get("is_member"):
                            membership_status = {
                                "is_member": True,
                                "account": phone,
                                "chat_title": check_result.get("chat_title"),
                                "members_count": check_result.get("members_count", 0)
                            }
                            members_count = check_result.get("members_count", 0)
                            if members_count > 0:
                                await db.update_group_member_count(url, members_count)
                            break
                        elif check_result.get("can_join"):
                            membership_status = {
                                "is_member": False,
                                "can_join": True,
                                "is_private": check_result.get("is_private", False),
                                "reason": check_result.get("reason")
                            }
                    except Exception as e:
                        print(f"[Backend] Error checking membership for {url}: {e}", file=sys.stderr)
            
            # ğŸ”§ Phase5: å¯«å…¥ç·©å­˜
            if membership_status:
                _membership_cache[url] = {
                    "result": membership_status,
                    "expires": time.time() + _MEMBERSHIP_CACHE_TTL
                }
            
            # æ¸…ç†éæœŸç·©å­˜ï¼ˆé˜²æ­¢å…§å­˜æ´©æ¼ï¼‰
            if len(_membership_cache) > 100:
                now = time.time()
                expired = [k for k, v in _membership_cache.items() if v.get("expires", 0) < now]
                for k in expired:
                    del _membership_cache[k]
        
        # Send membership status event
        if membership_status:
            self.send_event("group-membership-status", {
                "url": url,
                "status": membership_status
            })
            
            if membership_status.get("is_member"):
                self.send_log(f"âœ“ ç›£æ§è™Ÿå·²åœ¨ç¾¤çµ„ä¸­: {membership_status.get('chat_title', url)}", "success")
            elif membership_status.get("can_join"):
                if membership_status.get("is_private"):
                    self.send_log(f"âš  ç›£æ§è™ŸæœªåŠ å…¥æ­¤ç¾¤çµ„ï¼ˆç§æœ‰ç¾¤ï¼‰ï¼Œéœ€è¦æ‰‹å‹•åŠ å…¥: {url}", "warning")
                else:
                    self.send_log(f"â„¹ ç›£æ§è™ŸæœªåŠ å…¥æ­¤ç¾¤çµ„ï¼ˆå…¬é–‹ç¾¤ï¼‰ï¼Œå•Ÿå‹•ç›£æ§æ™‚å°‡è‡ªå‹•åŠ å…¥: {url}", "info")
        else:
            if listener_accounts:
                self.send_log(f"âš  ç„¡æ³•æª¢æŸ¥ç¾¤çµ„æˆå“¡ç‹€æ…‹: {url}", "warning")
            else:
                self.send_log(f"â„¹ æ²’æœ‰åœ¨ç·šç›£æ§è™Ÿï¼Œç„¡æ³•æª¢æŸ¥ç¾¤çµ„ç‹€æ…‹: {url}", "info")
        
        # ========== çµæŸæ–°å¢ ==========
        
        # ä½¿ç”¨å¾ Telegram ç²å–çš„ç¾¤çµ„æ¨™é¡Œï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰
        group_title = name  # é è¨­ä½¿ç”¨å‚³å…¥çš„ nameï¼ˆé€šå¸¸æ˜¯ URLï¼‰
        if membership_status and membership_status.get("chat_title"):
            group_title = membership_status.get("chat_title")
        
        # Check if group already exists
        existing = await db.get_group_by_url(url)
        if existing:
            # Update existing group
            group_id = await db.add_group(url, group_title, keyword_set_ids)
            await db.add_log(f"Group '{group_title}' updated (URL already exists)", "info")
        else:
            # Add new group
            group_id = await db.add_group(url, group_title, keyword_set_ids)
            await db.add_log(f"Group '{group_title}' added", "success")
        await self.send_groups_update()
        return {'success': True, 'group_title': group_title}
    
    except ValidationError as e:
        self.send_log(f"Validation error: {e.message}", "error")
        self.send_event("group-validation-error", {
            "errors": [e.message],
            "field": e.field
        })
        return {'success': False, 'error': e.message}
    except Exception as e:
        self.send_log(f"Error adding group: {str(e)}", "error")
        handle_error(e, {"command": "add-group", "payload": payload})
        return {'success': False, 'error': str(e)}

async def handle_add_monitored_group(self, payload: Dict[str, Any]):
    """
    è™•ç† add-monitored-group å‘½ä»¤
    å¾æœç´¢ç™¼ç¾é é¢ç›´æ¥æ·»åŠ ç¾¤çµ„åˆ°ç›£æ§åˆ—è¡¨
    
    æ”¯æŒå…©ç¨®å ´æ™¯ï¼š
    1. å‚³å…¥ url â†’ èª¿ç”¨ handle_add_group
    2. å‚³å…¥ telegram_id / username â†’ è½‰æ›ç‚º url å¾Œèª¿ç”¨ handle_add_group
    """
    import sys
    print(f"[Backend] handle_add_monitored_group called with payload: {payload}", file=sys.stderr)
    
    try:
        url = payload.get('url') or payload.get('link')
        name = payload.get('name') or payload.get('title')
        telegram_id = payload.get('telegramId') or payload.get('telegram_id')
        username = payload.get('username')
        keyword_set_ids = payload.get('keywordSetIds', [])
        phone = payload.get('phone')
        resource_id = payload.get('resourceId')
        
        # æ§‹å»º URLï¼ˆå¦‚æœæ²’æœ‰ç›´æ¥æä¾›ï¼‰
        if not url:
            if username:
                url = f"https://t.me/{username.lstrip('@')}"
            elif telegram_id:
                url = f"tg://resolve?id={telegram_id}"
            else:
                error_msg = "ç¼ºå°‘ç¾¤çµ„æ¨™è­˜ï¼ˆURLã€username æˆ– telegram_idï¼‰"
                self.send_event("monitored-group-added", {
                    "success": False,
                    "error": error_msg
                })
                self.send_log(f"âŒ {error_msg}", "error")
                return {"success": False, "error": error_msg}
        
        # æ§‹å»º add-group æ ¼å¼çš„ payload
        add_group_payload = {
            'url': url,
            'name': name or url,
            'keywordSetIds': keyword_set_ids,
            'ownerUserId': payload.get('ownerUserId'),
            'phone': phone,
            'telegramId': telegram_id,
        }
        
        # èª¿ç”¨å·²æœ‰çš„ add-group è™•ç†é‚è¼¯
        add_result = await handle_add_group(self, add_group_payload) or {}
        
        # ğŸ”§ Phase2: æ ¹æ“š handle_add_group çš„è¿”å›å€¼æ±ºå®šå¾ŒçºŒæ“ä½œ
        if not add_result.get('success', False):
            error_msg = add_result.get('error', 'æ·»åŠ ç¾¤çµ„å¤±æ•—')
            self.send_log(f"âŒ æ·»åŠ ç›£æ§ç¾¤çµ„å¤±æ•—: {error_msg}", "error")
            self.send_event("monitored-group-added", {
                "success": False,
                "error": error_msg,
                "name": name or url,
                "url": url
            })
            return {"success": False, "error": error_msg}
        
        # âœ… handle_add_group æˆåŠŸ â†’ æ›´æ–° discovered_resources ç‹€æ…‹
        if resource_id or telegram_id or username:
            try:
                from database import db
                await db.connect()
                
                if resource_id:
                    await db.execute(
                        "UPDATE discovered_resources SET status = 'monitoring' WHERE id = ?",
                        (resource_id,)
                    )
                elif telegram_id:
                    await db.execute(
                        "UPDATE discovered_resources SET status = 'monitoring' WHERE telegram_id = ?",
                        (str(telegram_id),)
                    )
                elif username:
                    await db.execute(
                        "UPDATE discovered_resources SET status = 'monitoring' WHERE username = ?",
                        (username.lstrip('@'),)
                    )
                
                # ç™¼é€ç‹€æ…‹æ›´æ–°äº‹ä»¶
                self.send_event("resource-status-updated", {
                    "resourceId": resource_id,
                    "telegramId": telegram_id,
                    "username": username,
                    "newStatus": "monitoring"
                })
                
                # è‡ªå‹•åŒæ­¥åˆ° unified_contacts
                try:
                    from unified_contacts import get_unified_contacts_manager
                    manager = get_unified_contacts_manager(db)
                    await manager.sync_from_sources()
                    self.send_event("unified-contacts:updated", {"reason": "add-monitored-group"})
                except Exception as sync_err:
                    print(f"[Backend] Auto-sync after add-monitored-group failed: {sync_err}", file=sys.stderr)
                    
            except Exception as db_err:
                print(f"[Backend] Error updating resource status: {db_err}", file=sys.stderr)
        
        # ğŸ”§ Phase2: ç™¼é€æ˜ç¢ºçš„æ“ä½œå®Œæˆäº‹ä»¶ï¼ˆåªåœ¨ add_group æˆåŠŸå¾Œï¼‰
        display_name = add_result.get('group_title') or name or url
        self.send_log(f"âœ… å·²å°‡ç¾¤çµ„æ·»åŠ åˆ°ç›£æ§åˆ—è¡¨: {display_name}", "success")
        self.send_event("monitored-group-added", {
            "success": True,
            "name": display_name,
            "url": url,
            "telegramId": telegram_id,
            "username": username
        })
        
        # ğŸ”§ ä¿åº•ï¼šç¢ºä¿å‰ç«¯æ”¶åˆ°æœ€æ–°ç¾¤çµ„åˆ—è¡¨
        await self.send_groups_update()
        
        return {"success": True, "message": f"å·²æ·»åŠ ç›£æ§ç¾¤çµ„: {display_name}"}
        
    except Exception as e:
        import traceback
        print(f"[Backend] Error in handle_add_monitored_group: {traceback.format_exc()}", file=sys.stderr)
        self.send_log(f"âŒ æ·»åŠ ç›£æ§ç¾¤çµ„å¤±æ•—: {str(e)}", "error")
        self.send_event("monitored-group-added", {
            "success": False,
            "error": str(e)
        })
        return {"success": False, "error": str(e)}



# ğŸ”§ Phase2: æœç´¢çµæœå…§å­˜ç·©å­˜ï¼ˆåŒé—œéµè©+æ¸ é“ 5 åˆ†é˜å…§ä¸é‡è¤‡æœç´¢ï¼‰
_search_cache: Dict[str, Any] = {}
_SEARCH_CACHE_TTL = 300  # 5 åˆ†é˜


def _smart_merge_results(self, groups: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    ğŸ”§ Phase3: æ™ºèƒ½å»é‡åˆä½µ â€” å¤šä¾†æºç›¸åŒç¾¤çµ„åˆä½µç‚ºä¸€æ¢è¨˜éŒ„
    
    åˆä½µè¦å‰‡ï¼š
    1. ä»¥ usernameï¼ˆå»é™¤ @ï¼‰ç‚ºä¸»éµåŒ¹é…
    2. ä»¥ telegram_id ç‚ºæ¬¡ç´šåŒ¹é…
    3. ä»¥ title ç²¾ç¢ºåŒ¹é…ç‚ºæœ«ç´šåŒ¹é…ï¼ˆåƒ…ç›¸åŒ source æ™‚ä¸è§¸ç™¼ï¼‰
    4. åˆä½µæ™‚å–æœ€å„ªæ•¸æ“šï¼ˆæœ€å¤§æˆå“¡æ•¸ã€æœ€å®Œæ•´ä¿¡æ¯ã€æœ€é«˜åˆ†æ•¸ï¼‰
    5. è¨˜éŒ„æ‰€æœ‰ä¾†æºåˆ° sources æ•¸çµ„
    """
    # å»ºç«‹ç´¢å¼•: username â†’ index, telegram_id â†’ index
    username_index: Dict[str, int] = {}
    tid_index: Dict[str, int] = {}
    merged: List[Dict[str, Any]] = []
    
    for g in groups:
        uname = (g.get('username') or '').strip().lower().lstrip('@')
        tid = str(g.get('telegram_id') or '').strip()
        source = g.get('source', 'unknown')
        
        # å˜—è©¦æ‰¾åˆ°å·²æœ‰è¨˜éŒ„
        existing_idx = None
        if uname and uname in username_index:
            existing_idx = username_index[uname]
        elif tid and tid in tid_index:
            existing_idx = tid_index[tid]
        
        if existing_idx is not None:
            # åˆä½µåˆ°å·²æœ‰è¨˜éŒ„
            existing = merged[existing_idx]
            existing_sources = existing.get('sources', [existing.get('source', 'unknown')])
            if source not in existing_sources:
                existing_sources.append(source)
            existing['sources'] = existing_sources
            
            # å–æœ€å¤§æˆå“¡æ•¸
            if (g.get('member_count') or 0) > (existing.get('member_count') or 0):
                existing['member_count'] = g['member_count']
            
            # è£œå…¨ç¼ºå¤±å­—æ®µ
            if not existing.get('telegram_id') and g.get('telegram_id'):
                existing['telegram_id'] = g['telegram_id']
                tid_new = str(g['telegram_id']).strip()
                if tid_new:
                    tid_index[tid_new] = existing_idx
            if not existing.get('username') and g.get('username'):
                existing['username'] = g['username']
                uname_new = g['username'].strip().lower().lstrip('@')
                if uname_new:
                    username_index[uname_new] = existing_idx
            if not existing.get('description') and g.get('description'):
                existing['description'] = g['description']
            if not existing.get('link') and g.get('link'):
                existing['link'] = g['link']
            if not existing.get('invite_link') and g.get('invite_link'):
                existing['invite_link'] = g['invite_link']
            
            # å–æœ€é«˜åˆ†æ•¸
            if (g.get('score') or 0) > (existing.get('score') or 0):
                existing['score'] = g['score']
            if (g.get('_relevance_score') or 0) > (existing.get('_relevance_score') or 0):
                existing['_relevance_score'] = g['_relevance_score']
            
            # æ›´æ–°å¯é”æ€§ï¼ˆå–æœ€å„ªï¼‰
            access_order = {'public': 0, 'invite_only': 1, 'id_only': 2, 'unknown': 3}
            if access_order.get(g.get('accessibility'), 3) < access_order.get(existing.get('accessibility'), 3):
                existing['accessibility'] = g['accessibility']
        else:
            # æ–°è¨˜éŒ„
            g['sources'] = [source]
            idx = len(merged)
            merged.append(g)
            
            if uname:
                username_index[uname] = idx
            if tid:
                tid_index[tid] = idx
    
    return merged


async def handle_search_groups(self, payload: Dict[str, Any]):
    """
    ğŸ”§ P0: è™•ç† search-groups å‘½ä»¤ - æœç´¢ Telegram ç¾¤çµ„/é »é“
    
    å‰ç«¯ç™¼é€æ ¼å¼:
    {
        keyword: string,
        sources: string[],  // ['telegram', 'jiso', 'tgstat', 'local']
        account_id: number,
        account_phone: string,
        limit: number
    }
    """
    import sys
    print(f"[Backend] handle_search_groups called with payload: {payload}", file=sys.stderr)
    
    try:
        keyword = payload.get('keyword', '')
        sources = payload.get('sources', ['telegram'])
        account_phone = payload.get('account_phone')
        limit = payload.get('limit', 50)
        force_refresh = payload.get('force_refresh', False)
        
        if not keyword:
            self.send_event("search-results", {
                "success": False,
                "error": "æœç´¢é—œéµè©ä¸èƒ½ç‚ºç©º",
                "groups": []
            })
            return
        
        # ğŸ”§ Phase2: æª¢æŸ¥æœç´¢ç·©å­˜
        cache_key = f"{keyword.lower().strip()}|{'|'.join(sorted(sources))}"
        if not force_refresh and cache_key in _search_cache:
            cached = _search_cache[cache_key]
            age = time.time() - cached.get('timestamp', 0)
            if age < _SEARCH_CACHE_TTL:
                self.send_log(f"ğŸ“‹ å‘½ä¸­æœç´¢ç·©å­˜: {keyword} ({int(age)}s å‰), {len(cached['groups'])} å€‹çµæœ", "info")
                # ç›´æ¥è¿”å›ç·©å­˜çµæœ
                self.send_event("search-results", cached['data'])
                return
            else:
                # ç·©å­˜éæœŸï¼Œåˆªé™¤
                del _search_cache[cache_key]
        
        # ğŸ”§ P0: é¡¯ç¤ºæœç´¢æº
        sources_str = ', '.join(sources) if sources else 'telegram'
        self.send_log(f"ğŸ” é–‹å§‹æœç´¢ç¾¤çµ„: {keyword} (ä¾†æº: {sources_str})", "info")
        
        # ğŸ”§ P0: ç¢ºä¿è¨­ç½® Telegram å®¢æˆ¶ç«¯å’Œäº‹ä»¶å›èª¿
        group_search_service.set_clients(self.telegram_manager.clients)
        group_search_service.set_event_callback(self.send_event)
        jiso_search_service.set_clients(self.telegram_manager.clients)
        jiso_search_service.set_event_callback(self.send_event)
        
        # æª¢æŸ¥æ˜¯å¦æœ‰å¯ç”¨çš„é€£æ¥å¸³è™Ÿ
        connected_clients = {p: c for p, c in self.telegram_manager.clients.items() if c.is_connected}
        if not connected_clients:
            self.send_log("âš ï¸ æ²’æœ‰å·²é€£æ¥çš„å¸³è™Ÿå¯ç”¨æ–¼æœç´¢", "warning")
            self.send_event("search-results", {
                "success": False,
                "error": "æ²’æœ‰å·²é€£æ¥çš„å¸³è™Ÿï¼Œè«‹å…ˆç™»éŒ„å¸³è™Ÿ",
                "groups": []
            })
            return
        
        print(f"[Backend] Available connected clients: {list(connected_clients.keys())}", file=sys.stderr)
        print(f"[Backend] Search sources: {sources}", file=sys.stderr)
        
        # ğŸ”§ P0: æ”¶é›†æ‰€æœ‰æœç´¢çµæœ
        all_groups = []
        seen_ids = set()
        
        # ğŸ”§ P0: æ ¹æ“š sources åƒæ•¸èª¿ç”¨ä¸åŒçš„æœç´¢æœå‹™
        try:
            # æœç´¢æº 1: Telegram å®˜æ–¹ API (telegram, official)
            if any(s in sources for s in ['telegram', 'official']):
                self.send_log("ğŸ“± ä½¿ç”¨ Telegram å®˜æ–¹ API æœç´¢...", "info")
                self.send_event("search-source-status", {"source": "telegram", "status": "searching", "count": 0})
                tg_start = time.time()
                try:
                    telegram_results = await asyncio.wait_for(
                        group_search_service.search_groups(
                            query=keyword,
                            phone=account_phone,
                            limit=limit,
                            search_type='all'
                        ),
                        timeout=30.0
                    )
                    tg_count = 0
                    if telegram_results:
                        for r in telegram_results:
                            tid = str(r.telegram_id) if hasattr(r, 'telegram_id') else str(r.id)
                            if tid not in seen_ids:
                                seen_ids.add(tid)
                                all_groups.append({
                                    "id": r.id if hasattr(r, 'id') else None,
                                    "telegram_id": tid,
                                    "title": r.title if hasattr(r, 'title') else "æœªçŸ¥",
                                    "username": r.username if hasattr(r, 'username') else None,
                                    "description": r.description if hasattr(r, 'description') else None,
                                    "member_count": r.member_count if hasattr(r, 'member_count') else 0,
                                    "type": r.type if hasattr(r, 'type') else "group",
                                    "score": r.score if hasattr(r, 'score') else 0,
                                    "source": "telegram"
                                })
                                tg_count += 1
                        self.send_log(f"ğŸ“± Telegram API æ‰¾åˆ° {len(telegram_results)} å€‹çµæœ", "info")
                        
                        # ğŸ”§ P1: æµå¼è¿”å› - Telegram çµæœå…ˆç™¼é€
                        if all_groups:
                            self.send_event("search-batch", {
                                "success": True,
                                "groups": all_groups.copy(),
                                "source": "telegram",
                                "total": len(all_groups),
                                "isPartial": True,
                                "message": f"å®˜æ–¹æœç´¢æ‰¾åˆ° {len(all_groups)} å€‹çµæœï¼Œæ­£åœ¨ç¹¼çºŒæœç´¢..."
                            })
                    tg_elapsed = int((time.time() - tg_start) * 1000)
                    self.send_event("search-source-status", {"source": "telegram", "status": "completed", "count": tg_count, "elapsed_ms": tg_elapsed})
                except asyncio.TimeoutError:
                    self.send_log("âš ï¸ Telegram API æœç´¢è¶…æ™‚", "warning")
                    self.send_event("search-source-status", {"source": "telegram", "status": "timeout", "count": 0, "elapsed_ms": 30000})
                except Exception as e:
                    self.send_log(f"âš ï¸ Telegram API æœç´¢å¤±æ•—: {e}", "warning")
                    self.send_event("search-source-status", {"source": "telegram", "status": "failed", "count": 0, "error": str(e)})
            
            # æœç´¢æº 2: Jiso ä¸­æ–‡æœç´¢ (jiso, chinese)
            if any(s in sources for s in ['jiso', 'chinese']):
                self.send_log("ğŸ” ä½¿ç”¨æ¥µæœ (Jiso) ä¸­æ–‡æœç´¢...", "info")
                self.send_event("search-source-status", {"source": "jiso", "status": "searching", "count": 0})
                jiso_start = time.time()
                try:
                    # ğŸ”§ P0: å¢åŠ è¶…æ™‚æ™‚é–“åˆ° 90 ç§’ï¼ˆJiso æœç´¢åŒ…å«è©³æƒ…ç²å–ï¼Œéœ€è¦æ›´é•·æ™‚é–“ï¼‰
                    jiso_result = await asyncio.wait_for(
                        jiso_search_service.search(
                            keyword=keyword,
                            phone=account_phone,
                            limit=limit
                        ),
                        timeout=90.0
                    )
                    jiso_duration = time.time() - jiso_start
                    self.send_log(f"ğŸ” æ¥µæœæœç´¢å®Œæˆï¼Œè€—æ™‚: {jiso_duration:.1f}ç§’", "info")
                    
                    # ğŸ”§ P0: æ·»åŠ è©³ç´°æ—¥èªŒ
                    print(f"[Backend] Jiso result success={jiso_result.get('success')}, results_count={len(jiso_result.get('results', []))}", file=sys.stderr)
                    
                    added = 0
                    skipped_dup = 0
                    if jiso_result.get('success') and jiso_result.get('results'):
                        jiso_groups = jiso_result['results']
                        for g in jiso_groups:
                            # ğŸ”§ P0: ä½¿ç”¨å°ˆé–€çš„ dedup_key é€²è¡Œå»é‡
                            dedup_key = g.get('dedup_key', '')
                            username = g.get('username', '')
                            real_telegram_id = g.get('telegram_id')  # å¯èƒ½ç‚º None
                            
                            # å¦‚æœæ²’æœ‰ dedup_keyï¼Œä½¿ç”¨ username æˆ– link ä½œç‚ºå‚™é¸
                            if not dedup_key:
                                if username:
                                    dedup_key = f"@{username}"
                                elif g.get('link'):
                                    dedup_key = g.get('link')
                                else:
                                    dedup_key = f"title:{g.get('title', '')}"
                            
                            if dedup_key and dedup_key not in seen_ids:
                                seen_ids.add(dedup_key)
                                # å¦‚æœæœ‰ username ä¹ŸåŠ å…¥å»é‡é›†åˆ
                                if username and f"@{username}" not in seen_ids:
                                    seen_ids.add(f"@{username}")
                                
                                all_groups.append({
                                    "telegram_id": real_telegram_id,  # ğŸ”§ çœŸå¯¦ IDï¼ˆå¯ç‚º Noneï¼‰
                                    "title": g.get('title', 'æœªçŸ¥'),
                                    "username": username,
                                    "description": g.get('description'),
                                    "member_count": g.get('member_count', 0),
                                    "type": g.get('chat_type') or g.get('type', 'group'),
                                    "score": g.get('score', 0),
                                    "source": "jiso",
                                    "link": g.get('link')
                                })
                                added += 1
                            elif dedup_key:
                                skipped_dup += 1
                        self.send_log(f"ğŸ” æ¥µæœæ‰¾åˆ° {len(jiso_groups)} å€‹çµæœï¼Œæ·»åŠ  {added} å€‹æ–°çµæœï¼ˆè·³é {skipped_dup} å€‹é‡è¤‡ï¼‰", "info")
                        
                        # ğŸ”§ P1: æµå¼è¿”å› - Jiso çµæœè¿½åŠ ç™¼é€
                        if added > 0:
                            self.send_event("search-batch", {
                                "success": True,
                                "groups": all_groups.copy(),
                                "source": "jiso",
                                "total": len(all_groups),
                                "isPartial": True,
                                "message": f"æ¥µæœæ–°å¢ {added} å€‹çµæœï¼Œå…± {len(all_groups)} å€‹"
                            })
                    else:
                        error_msg = jiso_result.get('error', 'ç„¡çµæœ')
                        self.send_log(f"ğŸ” æ¥µæœæœç´¢: {error_msg}", "info")
                    jiso_elapsed = int((time.time() - jiso_start) * 1000)
                    self.send_event("search-source-status", {"source": "jiso", "status": "completed", "count": added, "elapsed_ms": jiso_elapsed})
                except asyncio.TimeoutError:
                    self.send_log("âš ï¸ æ¥µæœæœç´¢è¶…æ™‚", "warning")
                    self.send_event("search-source-status", {"source": "jiso", "status": "timeout", "count": 0, "elapsed_ms": 90000})
                except Exception as e:
                    self.send_log(f"âš ï¸ æ¥µæœæœç´¢å¤±æ•—: {e}", "warning")
                    self.send_event("search-source-status", {"source": "jiso", "status": "failed", "count": 0, "error": str(e)})
            
            # æœç´¢æº 3: æœ¬åœ°è³‡æºåº« (local)
            if 'local' in sources:
                self.send_log("ğŸ“‚ æœç´¢æœ¬åœ°è³‡æºåº«...", "info")
                self.send_event("search-source-status", {"source": "local", "status": "searching", "count": 0})
                local_start = time.time()
                try:
                    # å¾è³‡æºç™¼ç¾æ•¸æ“šåº«æœç´¢
                    local_results = await resource_discovery.search_resources(keyword, limit=limit)
                    local_added = 0
                    if local_results:
                        for r in local_results:
                            tid = str(r.telegram_id) if r.telegram_id else ''
                            if tid and tid not in seen_ids:
                                seen_ids.add(tid)
                                all_groups.append({
                                    "id": r.id,
                                    "telegram_id": tid,
                                    "title": r.title or "æœªçŸ¥",
                                    "username": r.username,
                                    "description": r.description,
                                    "member_count": r.member_count or 0,
                                    "type": r.resource_type or "group",
                                    "score": r.overall_score or 0,
                                    "source": "local"
                                })
                                local_added += 1
                        self.send_log(f"ğŸ“‚ æœ¬åœ°è³‡æºåº«æ‰¾åˆ° {local_added} å€‹çµæœ", "info")
                    local_elapsed = int((time.time() - local_start) * 1000)
                    self.send_event("search-source-status", {"source": "local", "status": "completed", "count": local_added, "elapsed_ms": local_elapsed})
                except Exception as e:
                    self.send_log(f"âš ï¸ æœ¬åœ°æœç´¢å¤±æ•—: {e}", "warning")
                    self.send_event("search-source-status", {"source": "local", "status": "failed", "count": 0, "error": str(e)})
            
            # ğŸ”§ P0: æ·»åŠ è©³ç´°æ—¥èªŒ
            total_before_sort = len(all_groups)
            print(f"[Backend] ğŸ” åˆä½µå¾Œç¸½çµæœæ•¸: {total_before_sort}", file=sys.stderr)
            
            # ğŸ”§ P0: ç›¸é—œæ€§å„ªå…ˆæ’åº - æ¨™é¡ŒåŒ…å«é—œéµè©çš„æ’å‰é¢
            keyword_lower = keyword.lower()
            keywords = [k.strip().lower() for k in keyword.split() if k.strip()]
            
            def calculate_relevance_score(group):
                """è¨ˆç®—ç›¸é—œæ€§åˆ†æ•¸"""
                score = 0
                title = (group.get('title') or '').lower()
                username = (group.get('username') or '').lower()
                description = (group.get('description') or '').lower()
                
                for kw in keywords:
                    # æ¨™é¡ŒåŒ…å«é—œéµè©ï¼š+1000 åˆ†
                    if kw in title:
                        score += 1000
                        # æ¨™é¡Œä»¥é—œéµè©é–‹é ­ï¼šé¡å¤– +500 åˆ†
                        if title.startswith(kw):
                            score += 500
                    # ç”¨æˆ¶ååŒ…å«é—œéµè©ï¼š+800 åˆ†
                    if kw in username:
                        score += 800
                    # æè¿°åŒ…å«é—œéµè©ï¼š+200 åˆ†
                    if kw in description:
                        score += 200
                
                return score
            
            # è¨ˆç®—æ¯å€‹çµæœçš„ç›¸é—œæ€§åˆ†æ•¸
            for g in all_groups:
                g['_relevance_score'] = calculate_relevance_score(g)
            
            # å…ˆæŒ‰ç›¸é—œæ€§æ’åºï¼Œç›¸é—œæ€§ç›¸åŒæ™‚æŒ‰æˆå“¡æ•¸æ’åº
            all_groups.sort(key=lambda x: (x.get('_relevance_score', 0), x.get('member_count', 0)), reverse=True)
            
            # çµ±è¨ˆç›¸é—œæ€§
            highly_relevant = sum(1 for g in all_groups if g.get('_relevance_score', 0) >= 1000)
            self.send_log(f"ğŸ“Š æ’åº: {highly_relevant} å€‹é«˜åº¦ç›¸é—œï¼ˆæ¨™é¡Œå«é—œéµè©ï¼‰", "info")
            
            # ğŸ”§ P0: è»Ÿé™åˆ¶ - æœ€å¤šè¿”å› 500 å€‹ï¼ˆé¿å…å…§å­˜å•é¡Œï¼‰
            MAX_RESULTS = 500
            total_after_limit = min(len(all_groups), MAX_RESULTS)
            all_groups = all_groups[:MAX_RESULTS]
            
            # ğŸ”§ Phase2: æ¨™è¨˜æ¯å€‹çµæœçš„å¯é”æ€§ (accessibility)
            for g in all_groups:
                username = g.get('username', '')
                link = g.get('link', '') or ''
                telegram_id = g.get('telegram_id')
                if username:
                    g['accessibility'] = 'public'
                elif link and ('/+' in link or 'joinchat' in link):
                    g['accessibility'] = 'invite_only'
                elif telegram_id:
                    g['accessibility'] = 'id_only'
                else:
                    g['accessibility'] = 'unknown'
            
            # ğŸ”§ Phase2: è¼•é‡é©—è­‰ Jiso çµæœ â€” å°æœ‰ username çš„çµæœå˜—è©¦ ResolveUsername
            jiso_with_username = [g for g in all_groups if g.get('source') == 'jiso' and g.get('username')]
            if jiso_with_username and connected_clients:
                self.send_log(f"ğŸ” é©—è­‰ {len(jiso_with_username)} å€‹æ¥µæœçµæœçš„å¯é”æ€§...", "info")
                # å–ç¬¬ä¸€å€‹å¯ç”¨ client
                verify_client = None
                for c in connected_clients.values():
                    if c.is_connected:
                        verify_client = c
                        break
                
                if verify_client:
                    validated = 0
                    invalid = 0
                    # é™åˆ¶æœ€å¤šé©—è­‰ 20 å€‹ï¼Œé¿å…å¤ªæ…¢
                    for g in jiso_with_username[:20]:
                        try:
                            chat = await asyncio.wait_for(
                                verify_client.get_chat(g['username']),
                                timeout=3.0
                            )
                            if chat:
                                # é©—è­‰æˆåŠŸ â€” æ›´æ–°çœŸå¯¦æ•¸æ“š
                                if not g.get('telegram_id') and chat.id:
                                    g['telegram_id'] = str(chat.id)
                                if hasattr(chat, 'members_count') and chat.members_count:
                                    g['member_count'] = chat.members_count
                                validated += 1
                        except Exception:
                            # é©—è­‰å¤±æ•— â€” æ¨™è¨˜ç‚º invalid
                            g['accessibility'] = 'unknown'
                            g['_invalid'] = True
                            invalid += 1
                    
                    if validated > 0 or invalid > 0:
                        self.send_log(f"ğŸ” é©—è­‰å®Œæˆ: {validated} æœ‰æ•ˆ, {invalid} ä¸å¯é”", "info")
            
            # ğŸ”§ Phase3: æ™ºèƒ½å»é‡åˆä½µ â€” å¤šä¾†æºåŒç¾¤çµ„åŸºæ–¼ username/telegram_id åˆä½µ
            before_merge = len(all_groups)
            all_groups = self._smart_merge_results(all_groups)
            merged_count = before_merge - len(all_groups)
            if merged_count > 0:
                self.send_log(f"ğŸ”— æ™ºèƒ½å»é‡: åˆä½µ {merged_count} å€‹é‡è¤‡çµæœ ({before_merge} â†’ {len(all_groups)})", "info")
            
            # çµ±è¨ˆå„ä¾†æºçµæœæ•¸
            source_counts = {}
            for g in all_groups:
                # çµ±è¨ˆåˆä½µå¾Œçš„ä¾†æºï¼ˆå¯èƒ½åŒ…å«å¤šä¾†æºï¼‰
                sources_list = g.get('sources', [g.get('source', 'unknown')])
                for src in (sources_list if isinstance(sources_list, list) else [sources_list]):
                    source_counts[src] = source_counts.get(src, 0) + 1
            
            source_summary = ', '.join([f"{k}: {v}" for k, v in source_counts.items()])
            print(f"[Backend] ğŸ” æœ€çµ‚çµæœ: {len(all_groups)} å€‹ ({source_summary})", file=sys.stderr)
            
            # ğŸ†• ä¿å­˜æœç´¢æ­·å²ä¸¦æ¨™è¨˜æ–°/èˆŠçµæœ
            try:
                from search_history_service import get_search_history_service
                search_history = get_search_history_service()
                
                search_start_time = time.time()
                history_result = search_history.save_search_with_results(
                    keyword=keyword,
                    results=all_groups,
                    account_phone=account_phone,
                    sources=sources,
                    duration_ms=(time.time() - search_start_time) * 1000
                )
                
                new_count = history_result.get('new_count', 0)
                existing_count = history_result.get('existing_count', 0)
                
                # æ›´æ–°çµæœæ·»åŠ æ–°/èˆŠæ¨™è¨˜
                updated_groups = history_result.get('results', all_groups)
                for g in updated_groups:
                    g['is_new'] = g.pop('_is_new', False)
                    g['member_change'] = g.pop('_member_change', 0)
                    # æ¸…ç†å…§éƒ¨å­—æ®µ
                    g.pop('_resource_id', None)
                    g.pop('_position', None)
                
                all_groups = updated_groups
                
                self.send_log(f"ğŸ“Š æ­·å²å°æ¯”: ğŸ†• æ–°ç™¼ç¾ {new_count} å€‹ï¼ŒğŸ”„ å·²çŸ¥ {existing_count} å€‹", "info")
                
            except Exception as history_error:
                print(f"[Backend] ä¿å­˜æœç´¢æ­·å²å¤±æ•—: {history_error}", file=sys.stderr)
                # ç¹¼çºŒåŸ·è¡Œï¼Œä¸å½±éŸ¿æœç´¢çµæœè¿”å›
                new_count = 0
                existing_count = len(all_groups)
            
            self.send_log(f"âœ… æœç´¢å®Œæˆ: å…±æ‰¾åˆ° {len(all_groups)} å€‹çµæœ ({source_summary})", "success")
            
            # ğŸ”§ P0-1: èˆ‡ç›£æ§ç¾¤çµ„è¡¨åŒ¹é…ï¼Œæ¨™è¨˜å·²åŠ å…¥ç‹€æ…‹
            try:
                joined_count = 0
                # ç²å–æ‰€æœ‰ç›£æ§ç¾¤çµ„çš„ username å’Œ telegram_id
                monitored_groups_data = await db.fetch_all(
                    "SELECT id, link, name, phone, telegram_id FROM monitored_groups WHERE is_active = 1"
                )
                
                # å»ºç«‹ç´¢å¼•ç”¨æ–¼å¿«é€ŸåŒ¹é…
                monitored_by_username = {}
                monitored_by_telegram_id = {}
                for mg in monitored_groups_data:
                    link = mg.get('link', '') or ''
                    tg_id = str(mg.get('telegram_id', '')) if mg.get('telegram_id') else ''
                    phone = mg.get('phone', '')
                    name = mg.get('name', '')
                    
                    # å¾ link æå– usernameï¼ˆæ ¼å¼: https://t.me/usernameï¼‰
                    if '/t.me/' in link:
                        username = link.split('/t.me/')[-1].strip('/')
                        if username:
                            monitored_by_username[username.lower()] = {'phone': phone, 'name': name}
                    elif link.startswith('@'):
                        username = link[1:]
                        if username:
                            monitored_by_username[username.lower()] = {'phone': phone, 'name': name}
                    
                    # é€šé telegram_id åŒ¹é…
                    if tg_id:
                        monitored_by_telegram_id[tg_id] = {'phone': phone, 'name': name}
                
                # æ¨™è¨˜æœç´¢çµæœä¸­å·²åŠ å…¥çš„ç¾¤çµ„
                for g in all_groups:
                    username = (g.get('username') or '').lower().lstrip('@')
                    tg_id = str(g.get('telegram_id', '')) if g.get('telegram_id') else ''
                    
                    joined_info = None
                    if username and username in monitored_by_username:
                        joined_info = monitored_by_username[username]
                    elif tg_id and tg_id in monitored_by_telegram_id:
                        joined_info = monitored_by_telegram_id[tg_id]
                    
                    if joined_info:
                        g['status'] = 'joined'
                        g['joined_phone'] = joined_info.get('phone', '')
                        joined_count += 1
                    else:
                        g['status'] = 'discovered'
                        g['joined_phone'] = None
                
                if joined_count > 0:
                    self.send_log(f"ğŸ“Š ç‹€æ…‹åŒæ­¥: {joined_count} å€‹ç¾¤çµ„å·²åŠ å…¥ç›£æ§", "info")
                    
            except Exception as sync_err:
                print(f"[Backend] ç›£æ§ç¾¤çµ„ç‹€æ…‹åŒæ­¥å¤±æ•—: {sync_err}", file=sys.stderr)
                # ç¹¼çºŒåŸ·è¡Œï¼Œé»˜èªæ‰€æœ‰ç‚º discovered
                for g in all_groups:
                    if 'status' not in g:
                        g['status'] = 'discovered'
                        g['joined_phone'] = None
            
            result_data = {
                "success": True,
                "keyword": keyword,
                "groups": all_groups,
                "total": len(all_groups),
                "sources": sources,
                "source_counts": source_counts,
                "new_count": new_count,           # ğŸ†• æ–°ç™¼ç¾æ•¸é‡
                "existing_count": existing_count  # ğŸ†• å·²çŸ¥æ•¸é‡
            }
            
            # ğŸ”§ Phase2: å­˜å…¥æœç´¢ç·©å­˜
            _search_cache[cache_key] = {
                'timestamp': time.time(),
                'groups': all_groups,
                'data': result_data
            }
            # æ¸…ç†éæœŸç·©å­˜ï¼ˆé¿å…å…§å­˜æ³„æ¼ï¼‰
            expired = [k for k, v in _search_cache.items() if time.time() - v.get('timestamp', 0) > _SEARCH_CACHE_TTL * 2]
            for k in expired:
                del _search_cache[k]
            
            self.send_event("search-results", result_data)
            
        except asyncio.TimeoutError:
            self.send_log("âš ï¸ æœç´¢è¶…æ™‚", "warning")
            self.send_event("search-results", {
                "success": False,
                "error": "æœç´¢è¶…æ™‚ï¼Œè«‹ç¨å¾Œé‡è©¦",
                "groups": []
            })
            
    except Exception as e:
        import traceback
        print(f"[Backend] search-groups error: {e}", file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        self.send_log(f"âŒ æœç´¢å¤±æ•—: {str(e)}", "error")
        self.send_event("search-results", {
            "success": False,
            "error": str(e),
            "groups": []
        })

async def handle_join_group(self, payload: Dict[str, Any]):
    """Handle join-group command - manually join a group with a specific account"""
    import sys
    print(f"[Backend] handle_join_group called with payload: {payload}", file=sys.stderr)
    
    try:
        phone = payload.get('phone')
        group_url = payload.get('groupUrl')
        
        print(f"[Backend] Extracted phone={phone}, group_url={group_url}", file=sys.stderr)
        
        if not phone or not group_url:
            self.send_log("ç¼ºå°‘å¿…è¦åƒæ•¸ï¼ˆé›»è©±æˆ–ç¾¤çµ„ URLï¼‰", "error")
            self.send_event("group-join-result", {
                "success": False,
                "phone": phone,
                "groupUrl": group_url,
                "error": "ç¼ºå°‘å¿…è¦åƒæ•¸"
            })
            return
        
        self.send_log(f"æ­£åœ¨å˜—è©¦è®“ {phone} åŠ å…¥ç¾¤çµ„ {group_url}...", "info")
        
        # Use telegram manager to join the group
        result = await self.telegram_manager.join_group(phone, group_url)
        
        if result.get("success"):
            if result.get("already_member"):
                self.send_log(f"âœ“ {phone} å·²ç¶“åœ¨ç¾¤çµ„ä¸­: {result.get('chat_title', group_url)}", "success")
            else:
                self.send_log(f"âœ“ {phone} æˆåŠŸåŠ å…¥ç¾¤çµ„: {result.get('chat_title', group_url)}", "success")
            
            # Send success event
            self.send_event("group-join-result", {
                "success": True,
                "phone": phone,
                "groupUrl": group_url,
                "chatTitle": result.get("chat_title"),
                "chatId": result.get("chat_id"),
                "alreadyMember": result.get("already_member", False)
            })
        else:
            error_msg = result.get("error", "æœªçŸ¥éŒ¯èª¤")
            self.send_log(f"âœ— {phone} åŠ å…¥ç¾¤çµ„å¤±æ•—: {error_msg}", "error")
            
            # Send failure event
            self.send_event("group-join-result", {
                "success": False,
                "phone": phone,
                "groupUrl": group_url,
                "error": error_msg
            })
    
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_log(f"åŠ å…¥ç¾¤çµ„æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}", "error")
        self.send_event("group-join-result", {
            "success": False,
            "phone": payload.get('phone'),
            "groupUrl": payload.get('groupUrl'),
            "error": str(e)
        })

async def handle_remove_group(self, payload: Dict[str, Any]):
    """Handle remove-group command - ç§»é™¤ç›£æ§ç¾¤çµ„"""
    try:
        # ğŸ†• æ”¯æŒå¤šç¨®åƒæ•¸åç¨±
        group_id = payload.get('id') or payload.get('groupId')
        
        if not group_id:
            self.send_log("âŒ ç§»é™¤ç¾¤çµ„å¤±æ•—: ç¼ºå°‘ç¾¤çµ„ ID", "error")
            self.send_event("remove-group-result", {"success": False, "error": "ç¼ºå°‘ç¾¤çµ„ ID"})
            return
        
        self.send_log(f"ğŸ—‘ï¸ æ­£åœ¨ç§»é™¤ç›£æ§ç¾¤çµ„: {group_id}", "info")
        
        # å˜—è©¦å¤šç¨®æ–¹å¼åˆªé™¤
        deleted = False
        
        # æ–¹å¼1: æŒ‰ ID åˆªé™¤ï¼ˆå¦‚æœæ˜¯æ•¸å­—ï¼‰
        if isinstance(group_id, int) or (isinstance(group_id, str) and group_id.lstrip('-').isdigit()):
            numeric_id = int(group_id) if isinstance(group_id, str) else group_id
            result = await db.execute('DELETE FROM monitored_groups WHERE id = ?', (numeric_id,))
            if result > 0:
                deleted = True
                self.send_log(f"âœ… å·²æŒ‰ ID åˆªé™¤: {numeric_id}", "success")
        
        # æ–¹å¼2: æŒ‰ telegram_id åˆªé™¤
        if not deleted:
            result = await db.execute('DELETE FROM monitored_groups WHERE telegram_id = ?', (str(group_id),))
            if result > 0:
                deleted = True
                self.send_log(f"âœ… å·²æŒ‰ telegram_id åˆªé™¤: {group_id}", "success")
        
        # æ–¹å¼3: æŒ‰ link åŒ…å«çš„æ¨™è­˜ç¬¦åˆªé™¤
        if not deleted:
            result = await db.execute('DELETE FROM monitored_groups WHERE link LIKE ?', (f'%{group_id}%',))
            if result > 0:
                deleted = True
                self.send_log(f"âœ… å·²æŒ‰ link åˆªé™¤: {group_id}", "success")
        
        # æ–¹å¼4: æŒ‰ name åˆªé™¤
        if not deleted:
            result = await db.execute('DELETE FROM monitored_groups WHERE name = ?', (str(group_id),))
            if result > 0:
                deleted = True
                self.send_log(f"âœ… å·²æŒ‰ name åˆªé™¤: {group_id}", "success")
        
        if deleted:
            await db.add_log(f"ç›£æ§ç¾¤çµ„å·²ç§»é™¤: {group_id}", "success")
            self.send_event("remove-group-result", {"success": True, "groupId": group_id})
        else:
            self.send_log(f"âš ï¸ æœªæ‰¾åˆ°è¦åˆªé™¤çš„ç¾¤çµ„: {group_id}", "warning")
            self.send_event("remove-group-result", {"success": False, "error": "æœªæ‰¾åˆ°ç¾¤çµ„"})
        
        # åˆ·æ–°å‰ç«¯ç¾¤çµ„åˆ—è¡¨
        await self.send_groups_update()
    
    except Exception as e:
        import traceback
        traceback.print_exc()
        self.send_log(f"âŒ ç§»é™¤ç¾¤çµ„å¤±æ•—: {str(e)}", "error")
        self.send_event("remove-group-result", {"success": False, "error": str(e)})

async def handle_leave_group(self, payload: Dict[str, Any]):
    """å¾ Telegram é€€å‡ºç¾¤çµ„"""
    try:
        phone = payload.get('phone')
        group_id = payload.get('groupId')
        resource_id = payload.get('resourceId')
        
        if not phone or not group_id:
            raise ValueError("ç¼ºå°‘å¿…è¦åƒæ•¸ï¼šphone æˆ– groupId")
        
        self.send_log(f"ğŸšª æ­£åœ¨é€€å‡ºç¾¤çµ„: {group_id}", "info")
        
        # ç²å–å¸³è™Ÿçš„ Pyrogram client
        account = next((acc for acc in self.accounts if acc.get('phone') == phone), None)
        if not account:
            raise ValueError(f"æ‰¾ä¸åˆ°å¸³è™Ÿ: {phone}")
        
        client = account.get('client')
        if not client or not client.is_connected:
            raise ValueError(f"å¸³è™Ÿ {phone} æœªé€£æ¥")
        
        try:
            # ä½¿ç”¨ Pyrogram é€€å‡ºç¾¤çµ„
            await client.leave_chat(group_id)
            self.send_log(f"âœ… å·²é€€å‡ºç¾¤çµ„: {group_id}", "success")
        except Exception as leave_error:
            error_msg = str(leave_error)
            if 'not a member' in error_msg.lower() or 'not found' in error_msg.lower():
                self.send_log(f"â„¹ï¸ å¸³è™Ÿä¸åœ¨æ­¤ç¾¤çµ„ä¸­", "info")
            else:
                raise leave_error
        
        # å¾ç›£æ§åˆ—è¡¨ä¸­ç§»é™¤
        try:
            await db.remove_group(group_id)
        except Exception:
            pass  # å¯èƒ½ä¸åœ¨ç›£æ§åˆ—è¡¨ä¸­
        
        # æ›´æ–°è³‡æºç‹€æ…‹ç‚º discovered
        if resource_id:
            try:
                await resource_discovery.db.execute(
                    "UPDATE discovered_resources SET status = 'discovered', joined_by_phone = NULL WHERE id = ?",
                    (resource_id,)
                )
                await resource_discovery.db._connection.commit()
            except Exception as db_error:
                self.send_log(f"æ›´æ–°è³‡æºç‹€æ…‹å¤±æ•—: {db_error}", "warning")
        
        self.send_event("leave-group-complete", {
            "success": True,
            "groupId": group_id,
            "phone": phone
        })
        
        # åˆ·æ–°ç¾¤çµ„åˆ—è¡¨
        await self.send_groups_update()
        
    except Exception as e:
        self.send_log(f"âŒ é€€å‡ºç¾¤çµ„å¤±æ•—: {e}", "error")
        self.send_event("leave-group-complete", {
            "success": False,
            "error": str(e)
        })

async def handle_join_and_monitor_resource(self, payload: Dict[str, Any]):
    """åŠ å…¥ç¾¤çµ„ä¸¦æ·»åŠ åˆ°ç›£æ§"""
    try:
        resource_id = payload.get('resourceId')
        username = payload.get('username')
        telegram_id = payload.get('telegramId')
        title = payload.get('title', '')
        phone = payload.get('phone')  # ğŸ†• å¯é¸æŒ‡å®šå¸³è™Ÿ
        
        if not username and not telegram_id:
            raise ValueError("éœ€è¦ username æˆ– telegramId")
        
        # ğŸ”§ P0: æ§‹å»ºç¾¤çµ„ URL
        if username:
            group_url = f"https://t.me/{username.lstrip('@')}"
        elif telegram_id:
            group_url = str(telegram_id)
        else:
            raise ValueError("éœ€è¦ username æˆ– telegramId")
        
        # ğŸ†• Phase3: æ™ºèƒ½å¸³è™Ÿé¸æ“‡ â€” å„ªå…ˆä½¿ç”¨ Explorer/Listener è§’è‰²
        if not phone:
            phone = await select_best_account(self.telegram_manager, db, operation='join')
            if not phone:
                raise ValueError("æ²’æœ‰å¯ç”¨çš„å·²é€£æ¥å¸³è™Ÿï¼Œè«‹å…ˆé€£æ¥ä¸€å€‹å¸³è™Ÿ")
            self.send_log(f"ğŸ“± æ™ºèƒ½é¸æ“‡å¸³è™Ÿ: {phone[:4]}****", "info")
        
        # ğŸ”§ P0+P5: ä½¿ç”¨å¸³è™Ÿè¼ªæ›åŠ ç¾¤ï¼ˆFloodWait æ™‚è‡ªå‹•åˆ‡æ›å¸³è™Ÿï¼‰
        self.send_log(f"ğŸš€ æ­£åœ¨åŠ å…¥: {title}", "info")
        join_result = await self.telegram_manager.join_group_with_rotation(
            phone, group_url,
            on_rotation_log=lambda msg, level: self.send_log(f"ğŸ”„ {msg}", level)
        )
        
        # å¦‚æœä½¿ç”¨äº†ä¸åŒçš„å¸³è™Ÿï¼Œæ›´æ–° phone
        actual_phone = join_result.get('used_phone', phone)
        if actual_phone != phone:
            self.send_log(f"ğŸ”„ å¸³è™Ÿè¼ªæ›: {phone[:4]}**** â†’ {actual_phone[:4]}****", "info")
            phone = actual_phone
        
        if join_result.get('success'):
            self.send_log(f"âœ… å·²åŠ å…¥ç¾¤çµ„: {title}", "success")
            
            # æ·»åŠ åˆ°ç›£æ§
            self.send_log(f"ğŸ“Š æ­£åœ¨æ·»åŠ ç›£æ§: {title}", "info")
            
            # ç²å–ç¾¤çµ„ä¿¡æ¯æ·»åŠ åˆ°ç›£æ§
            from database import db
            await db.connect()
            
            # ğŸ”§ P0: ç²å–æˆå“¡æ•¸ - ä½¿ç”¨åŠ å…¥æ™‚ä½¿ç”¨çš„å¸³è™Ÿ
            members_count = 0
            chat_telegram_id = None
            resource_type = 'group'
            try:
                # ğŸ”§ P0: å„ªå…ˆä½¿ç”¨åŠ å…¥æ™‚çš„ phone å°æ‡‰çš„å®¢æˆ¶ç«¯
                client = None
                if phone and phone in self.telegram_manager.clients:
                    client = self.telegram_manager.clients[phone]
                    if client and not client.is_connected:
                        client = None
                
                # å›é€€ï¼šæ‰¾ä»»æ„å¯ç”¨çš„å®¢æˆ¶ç«¯
                if not client:
                    for c in self.telegram_manager._clients.values():
                        if c and c.is_connected:
                            client = c
                            break
                
                if client:
                    chat_target = username or telegram_id
                    if chat_target:
                        # ğŸ”§ P0: å˜—è©¦ç²å–èŠå¤©ä¿¡æ¯
                        try:
                            chat_info = await client.get_chat(chat_target)
                            if chat_info:
                                members_count = getattr(chat_info, 'members_count', 0) or 0
                                chat_telegram_id = chat_info.id
                                from pyrogram.enums import ChatType
                                if chat_info.type == ChatType.CHANNEL:
                                    resource_type = 'channel'
                                elif chat_info.type == ChatType.SUPERGROUP:
                                    resource_type = 'supergroup'
                                self.send_log(f"ğŸ“Š ç²å–æˆå“¡æ•¸: {members_count}", "info")
                        except Exception as get_chat_err:
                            import sys
                            print(f"[Backend] get_chat error: {get_chat_err}", file=sys.stderr)
                            # å˜—è©¦ä½¿ç”¨æ•¸å­— ID é‡æ–°ç²å–
                            if telegram_id and str(telegram_id).lstrip('-').isdigit():
                                try:
                                    chat_info = await client.get_chat(int(telegram_id))
                                    if chat_info:
                                        members_count = getattr(chat_info, 'members_count', 0) or 0
                                        chat_telegram_id = chat_info.id
                                        self.send_log(f"ğŸ“Š ä½¿ç”¨ ID ç²å–æˆå“¡æ•¸: {members_count}", "info")
                                except Exception:
                                    pass
            except Exception as chat_err:
                import sys
                print(f"[Backend] Error getting member count: {chat_err}", file=sys.stderr)
            
            # ğŸ”§ P0-FIX: ä½¿ç”¨ç²¾ç¢ºåŒ¹é… + äº‹å‹™åŒ…è£¹æ‰€æœ‰ DB å¯«å…¥
            can_extract = 1 if resource_type != 'channel' else 0
            group_link = f"https://t.me/{username}" if username else str(telegram_id or '')
            
            try:
                await db.begin_transaction()
                
                existing = None
                if chat_telegram_id:
                    existing = await db.fetch_one(
                        "SELECT id FROM monitored_groups WHERE telegram_id = ?",
                        (str(chat_telegram_id),)
                    )
                if not existing and username:
                    existing = await db.fetch_one(
                        "SELECT id FROM monitored_groups WHERE link = ?",
                        (group_link,)
                    )
                
                tg_id_str = str(chat_telegram_id) if chat_telegram_id else None
                
                if not existing:
                    # ğŸ”§ Phase8-P1: åŒ…å« owner_user_id
                    try:
                        from core.tenant_filter import get_owner_user_id
                        _mg_owner = get_owner_user_id()
                    except ImportError:
                        _mg_owner = 'local_user'
                    await db.execute("""
                        INSERT INTO monitored_groups (link, name, phone, keyword_set_ids, is_active, member_count, telegram_id, resource_type, can_extract_members, owner_user_id, created_at)
                        VALUES (?, ?, ?, '[]', 1, ?, ?, ?, ?, ?, datetime('now'))
                    """, (group_link, title, phone, members_count, tg_id_str, resource_type, can_extract, _mg_owner), auto_commit=False)
                    type_label = {'channel': 'é »é“', 'supergroup': 'è¶…ç´šç¾¤', 'group': 'ç¾¤çµ„'}.get(resource_type, 'ç¾¤çµ„')
                    self.send_log(f"âœ… å·²æ·»åŠ åˆ°ç›£æ§: {title} ({type_label}ï¼Œ{members_count} æˆå“¡ï¼Œå¸³è™Ÿ: {phone[:4]}****)", "success")
                else:
                    await db.execute("""
                        UPDATE monitored_groups 
                        SET member_count = ?, telegram_id = COALESCE(telegram_id, ?), phone = COALESCE(phone, ?),
                            resource_type = ?, can_extract_members = ?
                        WHERE id = ?
                    """, (members_count, tg_id_str, phone, resource_type, can_extract, existing['id']), auto_commit=False)
                    self.send_log(f"â„¹ï¸ ç¾¤çµ„å·²åœ¨ç›£æ§åˆ—è¡¨ä¸­ï¼Œå·²æ›´æ–°", "info")
                
                if resource_id:
                    await db.execute(
                        """UPDATE discovered_resources 
                           SET status = 'joined', member_count = ?, resource_type = ?, 
                               joined_by_phone = ?, joined_at = CURRENT_TIMESTAMP,
                               telegram_id = COALESCE(telegram_id, ?)
                           WHERE id = ?""",
                        (members_count, resource_type, phone, tg_id_str, resource_id), auto_commit=False)
                
                await db.commit_transaction()
            except Exception as db_err:
                await db.rollback_transaction()
                raise Exception(f"æ•¸æ“šåº«å¯«å…¥å¤±æ•—: {db_err}")
            
            # ğŸ†• Phase2: è‡ªå‹•åŒæ­¥åˆ° unified_contacts
            try:
                from unified_contacts import get_unified_contacts_manager
                sync_db = db
                manager = get_unified_contacts_manager(sync_db)
                await manager.sync_from_sources()
                self.send_event("unified-contacts:updated", {"reason": "join-and-monitor"})
            except Exception as sync_err:
                import sys as _sys
                print(f"[Backend] Auto-sync after join-and-monitor failed: {sync_err}", file=_sys.stderr)
            
            # ğŸ”§ P0: è¿”å›æ›´å®Œæ•´çš„ä¿¡æ¯çµ¦å‰ç«¯
            self.send_event("join-and-monitor-complete", {
                "success": True,
                "resourceId": resource_id,
                "telegramId": telegram_id,
                "username": username,
                "joined": True,
                "monitored": True,
                "memberCount": members_count,
                "phone": phone,
                "status": "joined"
            })
        else:
            # ğŸ†• ç²å–æ›´å‹å¥½çš„éŒ¯èª¤ä¿¡æ¯
            raw_error = join_result.get('error', 'åŠ å…¥å¤±æ•—')
            raise Exception(raw_error)
            
    except Exception as e:
        # ğŸ†• éŒ¯èª¤ä¿¡æ¯å‹å¥½åŒ–è™•ç†
        error_str = str(e)
        friendly_error = self._get_friendly_join_error(error_str)
        
        self.send_log(f"âŒ åŠ å…¥å¤±æ•—: {friendly_error}", "error")
        self.send_event("join-and-monitor-complete", {
            "success": False,
            "error": friendly_error
        })

async def handle_join_resource(self, payload: Dict[str, Any]):
    """
    åƒ…åŠ å…¥ç¾¤çµ„ï¼ˆä¸æ·»åŠ åˆ°ç›£æ§åˆ—è¡¨ï¼‰
    æ›´æ–° discovered_resources ç‹€æ…‹ + è‡ªå‹•åŒæ­¥åˆ° unified_contacts
    
    èˆ‡ join-and-monitor-resource çš„å€åˆ¥ï¼š
    - ä¸å¯«å…¥ monitored_groups è¡¨
    - ä¸å•Ÿå‹•é—œéµè©ç›£æ§
    - ä½†æœƒæ›´æ–° discovered_resources å’Œ unified_contacts
    """
    import sys
    try:
        resource_id = payload.get('resourceId')
        username = payload.get('username')
        telegram_id = payload.get('telegramId')
        invite_link = payload.get('inviteLink') or payload.get('invite_link')
        title = payload.get('title', '')
        phone = payload.get('phone')
        
        if not username and not telegram_id and not invite_link:
            raise ValueError("éœ€è¦ usernameã€telegramId æˆ– inviteLink")
        
        # ğŸ”§ æ§‹å»ºç¾¤çµ„ URLï¼šå„ªå…ˆ username â†’ invite_link â†’ telegram_id
        if username:
            group_url = f"https://t.me/{username.lstrip('@')}"
        elif invite_link:
            # æ”¯æŒå®Œæ•´ URL æˆ– +hash æ ¼å¼
            if invite_link.startswith('http'):
                group_url = invite_link
            elif invite_link.startswith('+') or invite_link.startswith('joinchat'):
                group_url = f"https://t.me/{invite_link}"
            else:
                group_url = invite_link
            self.send_log(f"ğŸ”— ä½¿ç”¨é‚€è«‹éˆæ¥åŠ å…¥: {group_url[:30]}...", "info")
        elif telegram_id:
            group_url = str(telegram_id)
        else:
            raise ValueError("éœ€è¦ usernameã€telegramId æˆ– inviteLink")
        
        # ğŸ†• Phase3: æ™ºèƒ½å¸³è™Ÿé¸æ“‡
        if not phone:
            phone = await select_best_account(self.telegram_manager, db, operation='join')
            if not phone:
                raise ValueError("æ²’æœ‰å¯ç”¨çš„å·²é€£æ¥å¸³è™Ÿï¼Œè«‹å…ˆé€£æ¥ä¸€å€‹å¸³è™Ÿ")
            self.send_log(f"ğŸ“± æ™ºèƒ½é¸æ“‡å¸³è™Ÿ: {phone[:4]}****", "info")
        
        # ğŸ†• Phase5-P2: ä½¿ç”¨å¸³è™Ÿè¼ªæ›åŠ ç¾¤
        self.send_log(f"ğŸš€ æ­£åœ¨åŠ å…¥: {title}", "info")
        join_result = await self.telegram_manager.join_group_with_rotation(
            phone, group_url,
            on_rotation_log=lambda msg, level: self.send_log(f"ğŸ”„ {msg}", level)
        )
        
        # å¦‚æœä½¿ç”¨äº†ä¸åŒçš„å¸³è™Ÿï¼Œæ›´æ–° phone
        actual_phone = join_result.get('used_phone', phone)
        if actual_phone != phone:
            self.send_log(f"ğŸ”„ å¸³è™Ÿè¼ªæ›: {phone[:4]}**** â†’ {actual_phone[:4]}****", "info")
            phone = actual_phone
        
        if join_result.get('success'):
            self.send_log(f"âœ… å·²åŠ å…¥ç¾¤çµ„: {title}", "success")
            
            from database import db
            await db.connect()
            
            # ç²å–ç¾¤çµ„ä¿¡æ¯
            members_count = 0
            chat_telegram_id = None
            resource_type = 'group'
            try:
                client = None
                if phone and phone in self.telegram_manager.clients:
                    client = self.telegram_manager.clients[phone]
                    if client and not client.is_connected:
                        client = None
                
                if not client:
                    for c in self.telegram_manager._clients.values():
                        if c and c.is_connected:
                            client = c
                            break
                
                if client:
                    chat_target = username or telegram_id
                    if chat_target:
                        try:
                            chat_info = await client.get_chat(chat_target)
                            if chat_info:
                                members_count = getattr(chat_info, 'members_count', 0) or 0
                                chat_telegram_id = chat_info.id
                                from pyrogram.enums import ChatType
                                if chat_info.type == ChatType.CHANNEL:
                                    resource_type = 'channel'
                                elif chat_info.type == ChatType.SUPERGROUP:
                                    resource_type = 'supergroup'
                        except Exception as e:
                            print(f"[Backend] join-resource get_chat error: {e}", file=sys.stderr)
            except Exception as chat_err:
                print(f"[Backend] Error getting member count: {chat_err}", file=sys.stderr)
            
            # åƒ…æ›´æ–° discovered_resourcesï¼ˆä¸å¯«å…¥ monitored_groupsï¼‰
            tg_id_str = str(chat_telegram_id) if chat_telegram_id else None
            if resource_id:
                await db.execute(
                    """UPDATE discovered_resources 
                       SET status = 'joined', member_count = ?, resource_type = ?, 
                           joined_by_phone = ?, joined_at = CURRENT_TIMESTAMP,
                           telegram_id = COALESCE(telegram_id, ?)
                       WHERE id = ?""",
                    (members_count, resource_type, phone, tg_id_str, resource_id))
            
            # ğŸ†• è‡ªå‹•åŒæ­¥åˆ° unified_contacts
            try:
                from unified_contacts import get_unified_contacts_manager
                sync_db = db
                manager = get_unified_contacts_manager(sync_db)
                await manager.sync_from_sources()
                self.send_log(f"ğŸ”„ å·²åŒæ­¥åˆ°è³‡æºä¸­å¿ƒ", "info")
                self.send_event("unified-contacts:updated", {"reason": "join-resource"})
            except Exception as sync_err:
                print(f"[Backend] Auto-sync after join-resource failed: {sync_err}", file=sys.stderr)
            
            # ç™¼é€å®Œæˆäº‹ä»¶ï¼ˆå…¼å®¹ join-and-monitor-complete æ ¼å¼ï¼‰
            self.send_event("join-and-monitor-complete", {
                "success": True,
                "resourceId": resource_id,
                "telegramId": telegram_id,
                "username": username,
                "joined": True,
                "monitored": False,  # å€åˆ¥ï¼šæœªåŠ å…¥ç›£æ§
                "memberCount": members_count,
                "phone": phone,
                "status": "joined"
            })
        else:
            raw_error = join_result.get('error', 'åŠ å…¥å¤±æ•—')
            raise Exception(raw_error)
            
    except Exception as e:
        error_str = str(e)
        friendly_error = self._get_friendly_join_error(error_str)
        
        # ğŸ”§ Phase2: æå– error_code ä¾›å‰ç«¯ç²¾ç´°è™•ç†
        import re as _re
        code_match = _re.match(r'\[(\w+)\]\s*(.*)', friendly_error)
        error_code = code_match.group(1) if code_match else 'UNKNOWN'
        error_msg = code_match.group(2) if code_match else friendly_error
        
        self.send_log(f"âŒ åŠ å…¥å¤±æ•—: {error_msg}", "error")
        self.send_event("join-and-monitor-complete", {
            "success": False,
            "error": error_msg,
            "error_code": error_code,
            "resourceId": payload.get('resourceId'),
            "username": payload.get('username'),
            "telegramId": payload.get('telegramId')
        })


async def handle_join_and_monitor_with_account(self, payload: Dict[str, Any]):
    """ä½¿ç”¨æŒ‡å®šå¸³è™ŸåŠ å…¥ä¸¦ç›£æ§ç¾¤çµ„"""
    try:
        resource_id = payload.get('resourceId', 0)
        phone = payload.get('phone')
        keywords = payload.get('keywords', [])
        # ğŸ”§ FIX: è®€å–å‰ç«¯å‚³éçš„é—œéµè©é›† ID åˆ—è¡¨
        keyword_set_ids = payload.get('keywordSetIds', [])
        auto_enable = payload.get('autoEnableMonitor', True)
        # ğŸ†• æ”¯æŒå¾å‰ç«¯å‚³éè³‡æºä¿¡æ¯ï¼ˆç•¶ resourceId === 0 æ™‚ï¼‰
        resource_info = payload.get('resourceInfo', {})
        # ğŸ†• æˆå“¡æ•¸ï¼ˆåŠ å…¥å¾Œæ›´æ–°ï¼‰
        members_count = 0
        
        # ğŸ”§ FIX: è¨˜éŒ„æ¥æ”¶åˆ°çš„é—œéµè©é›† ID
        if keyword_set_ids:
            self.send_log(f"ğŸ“‹ æ¥æ”¶åˆ°é—œéµè©é›†ç¶å®š: {keyword_set_ids}", "info")
        
        if not phone:
            raise ValueError("è«‹é¸æ“‡åŠ å…¥å¸³è™Ÿ")
        
        self.send_log(f"ğŸš€ ä½¿ç”¨ {phone} åŠ å…¥ç¾¤çµ„ä¸¦è¨­ç½®ç›£æ§...", "info")
        
        # ç²å–è³‡æºè©³æƒ…
        from database import db
        await db.connect()
        
        resource = None
        title = ''
        username = ''
        invite_link = ''
        current_status = 'discovered'
        
        # ğŸ†• å¦‚æœ resourceId === 0ï¼Œå˜—è©¦ä½¿ç”¨å„ç¨®æ–¹å¼æŸ¥æ‰¾æˆ–å‰µå»ºè³‡æº
        if resource_id == 0:
            # å¾ resourceInfo ç²å–ä¿¡æ¯
            username = resource_info.get('username', '').strip()
            telegram_id = resource_info.get('telegram_id', '').strip()
            title = resource_info.get('title', '').strip()
            link = resource_info.get('link', '').strip()
            
            import re
            
            # ğŸ”‘ å¾ link ä¸­æå–æœ‰æ•ˆä¿¡æ¯
            extracted_username = ''
            extracted_invite_hash = ''
            is_message_link = False  # æ˜¯å¦ç‚ºæ¶ˆæ¯éˆæ¥ï¼ˆéç¾¤çµ„ç›´é€£ï¼‰
            
            if link:
                # è§£æ link æ ¼å¼
                if '/+' in link or '/joinchat/' in link:
                    # ç§æœ‰ç¾¤çµ„é‚€è«‹éˆæ¥ï¼šhttps://t.me/+hash æˆ– https://t.me/joinchat/hash
                    invite_link = link
                    self.send_log(f"ğŸ“‹ æª¢æ¸¬åˆ°é‚€è«‹éˆæ¥: {link}", "info")
                elif 't.me/' in link:
                    # æª¢æŸ¥æ˜¯å¦ç‚ºæ¶ˆæ¯éˆæ¥æ ¼å¼ï¼šhttps://t.me/username/messageId
                    message_link_match = re.search(r't\.me/([^/?\s]+)/(\d+)', link)
                    if message_link_match:
                        # é€™æ˜¯æ¶ˆæ¯éˆæ¥ï¼Œä¸æ˜¯ç¾¤çµ„ç›´é€£
                        link_username = message_link_match.group(1)
                        message_id = message_link_match.group(2)
                        is_message_link = True
                        self.send_log(f"âš ï¸ æª¢æ¸¬åˆ°æ¶ˆæ¯éˆæ¥ï¼ˆéç¾¤çµ„ç›´é€£ï¼‰: {link}", "warning")
                        
                        # æª¢æŸ¥ username æ˜¯å¦ç‚º botï¼ˆæœç´¢æ©Ÿå™¨äººï¼‰
                        if link_username.lower().endswith('bot'):
                            self.send_log(f"âš ï¸ éˆæ¥æŒ‡å‘æœç´¢æ©Ÿå™¨äºº @{link_username}ï¼Œéœ€è¦ç²å–çœŸæ­£çš„ç¾¤çµ„éˆæ¥", "warning")
                            # æ¸…ç©º usernameï¼Œå› ç‚ºé€™æ˜¯æ©Ÿå™¨äººçš„ username
                            if username and username.lower().endswith('bot'):
                                username = ''
                                telegram_id = ''
                    else:
                        # æ™®é€šç¾¤çµ„éˆæ¥ï¼šhttps://t.me/username
                        match = re.search(r't\.me/([^/?\s]+)$', link)
                        if match:
                            extracted_username = match.group(1)
                            if not extracted_username.startswith('+'):
                                # æª¢æŸ¥æ˜¯å¦ç‚º bot
                                if not extracted_username.lower().endswith('bot'):
                                    username = extracted_username
                                    self.send_log(f"ğŸ“‹ å¾éˆæ¥æå– username: {username}", "info")
                                else:
                                    self.send_log(f"âš ï¸ éˆæ¥æŒ‡å‘æ©Ÿå™¨äºº @{extracted_username}ï¼Œè·³é", "warning")
                            else:
                                invite_link = link
            
            # ğŸ”‘ æª¢æŸ¥ username æ˜¯å¦ç‚ºæœç´¢æ©Ÿå™¨äººï¼ˆä»¥ 'bot' çµå°¾ï¼‰
            if username and username.lower().endswith('bot'):
                self.send_log(f"âš ï¸ username '{username}' çœ‹èµ·ä¾†æ˜¯æ©Ÿå™¨äººï¼Œä¸æ˜¯ç¾¤çµ„", "warning")
                # å¦‚æœæ²’æœ‰å…¶ä»–åŠ å…¥æ–¹å¼ï¼Œå ±éŒ¯
                if not invite_link:
                    raise ValueError(f"ç„¡æ³•åŠ å…¥ï¼š'{username}' æ˜¯æœç´¢æ©Ÿå™¨äººï¼Œè«‹å¾æœç´¢çµæœä¸­é»æ“Šé€²å…¥ç¾¤çµ„ï¼Œç„¶å¾Œè¤‡è£½ç¾¤çµ„çš„é‚€è«‹éˆæ¥")
                username = ''  # æ¸…ç©º bot username
            
            # ğŸ”‘ é©—è­‰ telegram_id æ˜¯å¦ç‚ºæœ‰æ•ˆ IDï¼ˆä¸æ˜¯ title çš„èª¤ç”¨ï¼‰
            # æœ‰æ•ˆçš„ telegram_id æ‡‰è©²æ˜¯æ•¸å­—æˆ–ç°¡çŸ­çš„æ¨™è­˜ç¬¦
            if telegram_id and (len(telegram_id) > 50 or not telegram_id.replace('-', '').replace('_', '').isalnum()):
                self.send_log(f"âš ï¸ telegram_id æ ¼å¼ç„¡æ•ˆï¼Œå¿½ç•¥: {telegram_id[:30]}...", "warning")
                telegram_id = ''  # é‡ç½®ç„¡æ•ˆçš„ telegram_id
            
            # å¦‚æœ telegram_id ä¹Ÿæ˜¯ bot usernameï¼Œæ¸…ç©º
            if telegram_id and telegram_id.lower().endswith('bot'):
                telegram_id = ''
            
            # å˜—è©¦æ ¹æ“š username æŸ¥æ‰¾
            if username:
                resources = await db.fetch_all(
                    "SELECT * FROM discovered_resources WHERE username = ?",
                    (username,)
                )
                if resources:
                    resource = resources[0]
                    resource_id = resource.get('id')
                    self.send_log(f"ğŸ“‹ æ ¹æ“š username æ‰¾åˆ°è³‡æº ID: {resource_id}", "info")
            
            # å˜—è©¦æ ¹æ“š invite_link æŸ¥æ‰¾
            if not resource and invite_link:
                resources = await db.fetch_all(
                    "SELECT * FROM discovered_resources WHERE invite_link = ?",
                    (invite_link,)
                )
                if resources:
                    resource = resources[0]
                    resource_id = resource.get('id')
                    self.send_log(f"ğŸ“‹ æ ¹æ“š invite_link æ‰¾åˆ°è³‡æº ID: {resource_id}", "info")
            
            # å¦‚æœé‚„æ˜¯æ²’æ‰¾åˆ°ï¼Œä¸”æœ‰æœ‰æ•ˆçš„ telegram_idï¼Œå˜—è©¦ä½¿ç”¨ telegram_id æŸ¥æ‰¾
            if not resource and telegram_id:
                resources = await db.fetch_all(
                    "SELECT * FROM discovered_resources WHERE telegram_id = ?",
                    (telegram_id,)
                )
                if resources:
                    resource = resources[0]
                    resource_id = resource.get('id')
                    self.send_log(f"ğŸ“‹ æ ¹æ“š telegram_id æ‰¾åˆ°è³‡æº ID: {resource_id}", "info")
            
            # ğŸ†• å¦‚æœé‚„æ˜¯æ²’æ‰¾åˆ°ï¼Œæª¢æŸ¥æ˜¯å¦æœ‰è¶³å¤ ä¿¡æ¯å‰µå»ºè³‡æº
            if not resource:
                # å¿…é ˆæœ‰åŠ å…¥æ–¹å¼ï¼ˆusername æˆ– invite_linkï¼‰
                if not username and not invite_link:
                    raise ValueError("ç¼ºå°‘åŠ å…¥æ–¹å¼ï¼šè«‹æä¾›ç¾¤çµ„ username æˆ–é‚€è«‹éˆæ¥")
                
                self.send_log(f"ğŸ“ è³‡æºä¸å­˜åœ¨ï¼Œæ­£åœ¨å‰µå»ºæ–°è³‡æº...", "info")
                # ä½¿ç”¨ resource_discovery æ·»åŠ è³‡æºï¼ˆä¾†è‡ª service_locatorï¼‰
                
                # ç”Ÿæˆæœ‰æ•ˆçš„ telegram_id
                valid_telegram_id = username or f"invite_{int(time.time())}"
                if telegram_id and len(telegram_id) <= 50:
                    valid_telegram_id = telegram_id
                
                new_resource = {
                    'telegram_id': valid_telegram_id,
                    'username': username,
                    'title': title or username or 'æœªå‘½åè³‡æº',
                    'description': resource_info.get('description', ''),
                    'member_count': resource_info.get('member_count', 0),
                    'resource_type': resource_info.get('resource_type', 'supergroup'),
                    'discovery_source': 'manual_join',
                    'status': 'discovered',
                    'invite_link': invite_link or (f"https://t.me/{username}" if username else '')
                }
                
                resource_id = await resource_discovery.add_resource(new_resource)
                self.send_log(f"âœ… å·²å‰µå»ºæ–°è³‡æº ID: {resource_id}", "success")
                
                # é‡æ–°æŸ¥è©¢ç²å–å®Œæ•´è³‡æºä¿¡æ¯
                resources = await db.fetch_all(
                    "SELECT * FROM discovered_resources WHERE id = ?",
                    (resource_id,)
                )
                if resources:
                    resource = resources[0]
        
        # å¦‚æœ resourceId ä¸ç‚º 0ï¼Œæ­£å¸¸æŸ¥è©¢
        if not resource and resource_id > 0:
            resources = await db.fetch_all(
                "SELECT * FROM discovered_resources WHERE id = ?",
                (resource_id,)
            )
            if not resources:
                raise ValueError(f"æ‰¾ä¸åˆ°è³‡æº ID: {resource_id}")
            resource = resources[0]
        
        if not resource:
            raise ValueError("ç„¡æ³•æ‰¾åˆ°æˆ–å‰µå»ºè³‡æº")
        
        # æ›´æ–°è³‡æºä¿¡æ¯ï¼ˆå„ªå…ˆä½¿ç”¨è³‡æºä¸­çš„å€¼ï¼Œä½†ä¿ç•™å¾ resourceInfo æå–çš„ invite_linkï¼‰
        title = resource.get('title', '') or title
        username = resource.get('username', '') or username
        # ğŸ”‘ é—œéµï¼šç¢ºä¿ invite_link è¢«æ­£ç¢ºè¨­ç½®
        invite_link = resource.get('invite_link', '') or invite_link or resource_info.get('link', '')
        current_status = resource.get('status', 'discovered')
        
        # æª¢æŸ¥å¸³è™Ÿæ˜¯å¦å­˜åœ¨ä¸”å·²é€£æ¥
        if phone not in self.telegram_manager.clients:
            raise ValueError(f"å¸³è™Ÿ {phone} æœªé€£æ¥")
        
        client = self.telegram_manager.clients[phone]
        if not client.is_connected:
            raise ValueError(f"å¸³è™Ÿ {phone} æœªé€£æ¥")
        
        # è¿½è¸ªåŠ å…¥ç‹€æ…‹
        join_status = 'joined'  # é»˜èªç‚ºå·²åŠ å…¥
        
        # å¦‚æœè³‡æºå°šæœªåŠ å…¥ï¼Œå…ˆåŠ å…¥ç¾¤çµ„
        if current_status not in ['joined', 'monitoring']:
            self.send_log(f"ğŸ“¥ æ­£åœ¨åŠ å…¥ç¾¤çµ„: {title}", "info")
            
            # å˜—è©¦åŠ å…¥ç¾¤çµ„
            join_target = username or invite_link
            
            # ğŸ†• å¦‚æœæ²’æœ‰æœ‰æ•ˆçš„åŠ å…¥æ–¹å¼ï¼Œå˜—è©¦ä½¿ç”¨ç¾¤çµ„åç¨±æœç´¢
            if not join_target and title:
                self.send_log(f"ğŸ” æ²’æœ‰ username æˆ–é‚€è«‹éˆæ¥ï¼Œå˜—è©¦æœç´¢ç¾¤çµ„: {title}", "info")
                try:
                    # ä½¿ç”¨ Telegram å…¨å±€æœç´¢
                    search_results = await client.search_global(title, limit=5)
                    for result in search_results:
                        if hasattr(result, 'chat') and result.chat:
                            chat = result.chat
                            chat_title = getattr(chat, 'title', '') or ''
                            chat_username = getattr(chat, 'username', '')
                            
                            # æª¢æŸ¥æ¨™é¡Œæ˜¯å¦åŒ¹é…
                            if title.lower() in chat_title.lower() or chat_title.lower() in title.lower():
                                if chat_username:
                                    join_target = chat_username
                                    username = chat_username
                                    self.send_log(f"âœ… æ‰¾åˆ°åŒ¹é…ç¾¤çµ„: @{chat_username}", "success")
                                    break
                except Exception as search_err:
                    self.send_log(f"æœç´¢ç¾¤çµ„å¤±æ•—: {search_err}", "warning")
            
            if not join_target:
                # æä¾›æ›´å‹å¥½çš„éŒ¯èª¤æç¤º
                error_msg = f"ç„¡æ³•åŠ å…¥ç¾¤çµ„ã€Œ{title}ã€ï¼š\n"
                error_msg += "â€¢ æ­¤æœç´¢çµæœæ²’æœ‰æä¾›ç¾¤çµ„çš„ username æˆ–é‚€è«‹éˆæ¥\n"
                error_msg += "â€¢ è«‹åœ¨ Telegram ä¸­é»æ“Šæœç´¢æ©Ÿå™¨äººçš„çµæœï¼Œæ‰‹å‹•ç²å–ç¾¤çµ„éˆæ¥å¾Œå†è©¦\n"
                error_msg += "â€¢ æˆ–è€…ç›´æ¥åœ¨ Telegram ä¸­æœç´¢ä¸¦åŠ å…¥è©²ç¾¤çµ„"
                raise ValueError(error_msg)
            
            try:
                if username:
                    await client.join_chat(username)
                elif invite_link:
                    await client.join_chat(invite_link)
                
                self.send_log(f"âœ… å·²åŠ å…¥ç¾¤çµ„: {title}", "success")
                
                # ğŸ” é—œéµï¼šç²å–çœŸå¯¦çš„èŠå¤©é¡å‹å’Œæˆå“¡æ•¸ä¸¦æ›´æ–°æ•¸æ“šåº«
                verified_type = None
                members_count = 0
                telegram_id = None
                try:
                    chat_target = username or invite_link
                    chat_info = await client.get_chat(chat_target)
                    if chat_info:
                        # å¾ Pyrogram Chat å°è±¡ç²å–çœŸå¯¦é¡å‹
                        from pyrogram.enums import ChatType
                        if chat_info.type == ChatType.CHANNEL:
                            verified_type = "channel"
                        elif chat_info.type == ChatType.SUPERGROUP:
                            verified_type = "supergroup"
                        elif chat_info.type == ChatType.GROUP:
                            verified_type = "group"
                        elif chat_info.type == ChatType.BOT:
                            verified_type = "bot"
                        
                        # ğŸ†• ç²å–æˆå“¡æ•¸
                        members_count = getattr(chat_info, 'members_count', 0) or 0
                        telegram_id = chat_info.id
                        
                        if verified_type:
                            self.send_log(f"ğŸ“‹ é¡å‹ç¢ºèª: {verified_type}, æˆå“¡æ•¸: {members_count}", "info")
                except Exception as type_err:
                    import sys
                    print(f"[Backend] Error getting chat type: {type_err}", file=sys.stderr)
                
                # æ›´æ–°è³‡æºç‹€æ…‹ï¼ˆåŒ…å«é©—è­‰å¾Œçš„é¡å‹å’Œæˆå“¡æ•¸ï¼‰
                if verified_type:
                    await db.execute(
                        """UPDATE discovered_resources 
                           SET status = ?, joined_by_phone = ?, joined_at = CURRENT_TIMESTAMP, resource_type = ?, member_count = ?, telegram_id = COALESCE(telegram_id, ?)
                           WHERE id = ?""",
                        ('joined', phone, verified_type, members_count, telegram_id, resource_id)
                    )
                else:
                    await db.execute(
                        """UPDATE discovered_resources 
                           SET status = ?, joined_by_phone = ?, joined_at = CURRENT_TIMESTAMP, member_count = ?, telegram_id = COALESCE(telegram_id, ?)
                           WHERE id = ?""",
                        ('joined', phone, members_count, telegram_id, resource_id)
                    )
                await db._connection.commit()
                
            except Exception as join_error:
                error_msg = str(join_error)
                error_lower = error_msg.lower()
                
                if 'already' in error_lower or 'participant' in error_lower:
                    # å¸³è™Ÿå·²åœ¨ç¾¤çµ„ä¸­
                    self.send_log(f"â„¹ï¸ å¸³è™Ÿå·²åœ¨ç¾¤çµ„ä¸­", "info")
                    await db.execute(
                        """UPDATE discovered_resources 
                           SET status = ?, joined_by_phone = ? 
                           WHERE id = ?""",
                        ('joined', phone, resource_id)
                    )
                    await db._connection.commit()
                elif 'invite_request_sent' in error_lower or 'request_sent' in error_lower:
                    # ğŸ†• ç¾¤çµ„éœ€è¦ç®¡ç†å“¡æ‰¹å‡†ï¼ŒåŠ å…¥è«‹æ±‚å·²ç™¼é€
                    self.send_log(f"ğŸ“¨ åŠ å…¥è«‹æ±‚å·²ç™¼é€ï¼Œç­‰å¾…ç®¡ç†å“¡æ‰¹å‡†: {title}", "info")
                    join_status = 'pending_approval'  # æ›´æ–°ç‹€æ…‹
                    await db.execute(
                        """UPDATE discovered_resources 
                           SET status = ?, joined_by_phone = ? 
                           WHERE id = ?""",
                        ('pending_approval', phone, resource_id)
                    )
                    await db._connection.commit()
                    # ä¸æ‹‹å‡ºéŒ¯èª¤ï¼Œç¹¼çºŒè¨­ç½®ç›£æ§
                elif 'user_already_participant' in error_lower:
                    # å¸³è™Ÿå·²ç¶“æ˜¯æˆå“¡
                    self.send_log(f"â„¹ï¸ å¸³è™Ÿå·²æ˜¯ç¾¤çµ„æˆå“¡", "info")
                    await db.execute(
                        """UPDATE discovered_resources 
                           SET status = ?, joined_by_phone = ? 
                           WHERE id = ?""",
                        ('joined', phone, resource_id)
                    )
                    await db._connection.commit()
                else:
                    raise join_error
        
        # ğŸ”§ P0-FIX: å§‹çµ‚å°‡ç¾¤çµ„æ·»åŠ åˆ° monitored_groupsï¼ˆä¸å†ä¾è³´ auto_enable æ¢ä»¶ï¼‰
        # is_active æ ¹æ“šæ˜¯å¦æœ‰é—œéµè©/auto_enable æ±ºå®š
        is_active = 1 if (auto_enable or keywords or keyword_set_ids) else 0
        new_status = 'monitoring' if is_active else 'joined'
        keywords_str = ','.join(keywords) if keywords else ''
        
        # ğŸ”§ P0-FIX: ä½¿ç”¨äº‹å‹™åŒ…è£¹æ‰€æœ‰ DB å¯«å…¥ + ç²¾ç¢ºåŒ¹é…æ›¿ä»£ LIKE
        import json
        keyword_set_ids_json = json.dumps(keyword_set_ids) if keyword_set_ids else '[]'
        group_link = f"https://t.me/{username}" if username else invite_link
        
        try:
            await db.begin_transaction()
            
            # æ›´æ–° discovered_resources
            await db.execute(
                """UPDATE discovered_resources 
                   SET status = ?, monitoring_keywords = ?, monitoring_enabled = ? 
                   WHERE id = ?""",
                (new_status, keywords_str, 1 if is_active else 0, resource_id), auto_commit=False
            )
            
            # ç²¾ç¢ºæŸ¥æ‰¾ï¼šå„ªå…ˆç”¨ telegram_idï¼Œå…¶æ¬¡ç”¨ link
            existing = None
            if telegram_id:
                existing = await db.fetch_one(
                    "SELECT id FROM monitored_groups WHERE telegram_id = ?",
                    (str(telegram_id),)
                )
            if not existing and username:
                existing = await db.fetch_one(
                    "SELECT id FROM monitored_groups WHERE link = ?",
                    (group_link,)
                )
            
            if not existing:
                # ğŸ”§ Phase8-P1: åŒ…å« owner_user_id
                try:
                    from core.tenant_filter import get_owner_user_id
                    _mg_owner2 = get_owner_user_id()
                except ImportError:
                    _mg_owner2 = 'local_user'
                await db.execute(
                    """INSERT INTO monitored_groups (name, link, phone, is_active, keywords, keyword_set_ids, member_count, telegram_id, resource_type, owner_user_id, last_active, created_at)
                       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)""",
                    (title, group_link, phone, is_active, keywords_str, keyword_set_ids_json, members_count, telegram_id, resource.get('resource_type', 'group') if resource else 'group', _mg_owner2), auto_commit=False
                )
                bound_msg = f", ç¶å®š {len(keyword_set_ids)} å€‹è©é›†" if keyword_set_ids else ""
                active_msg = "ç›£æ§ä¸­" if is_active else "å·²åŠ å…¥ï¼ˆå¾…é…ç½®é—œéµè©ï¼‰"
                self.send_log(f"âœ… å·²æ·»åŠ åˆ°ç›£æ§åˆ—è¡¨: {title} ({members_count} æˆå“¡{bound_msg}) [{active_msg}]", "success")
            else:
                if keyword_set_ids:
                    await db.execute(
                        """UPDATE monitored_groups 
                           SET keywords = ?, keyword_set_ids = ?, phone = ?, is_active = ?, member_count = ?, telegram_id = COALESCE(telegram_id, ?)
                           WHERE id = ?""",
                        (keywords_str, keyword_set_ids_json, phone, is_active, members_count, telegram_id, existing['id']), auto_commit=False
                    )
                else:
                    await db.execute(
                        """UPDATE monitored_groups 
                           SET phone = ?, is_active = ?, member_count = ?, telegram_id = COALESCE(telegram_id, ?)
                           WHERE id = ?""",
                        (phone, is_active, members_count, telegram_id, existing['id']), auto_commit=False
                    )
                bound_msg = f", ç¶å®š {len(keyword_set_ids)} å€‹è©é›†" if keyword_set_ids else ""
                self.send_log(f"âœ… å·²æ›´æ–°ç›£æ§è¨­ç½®: {title} ({members_count} æˆå“¡{bound_msg})", "success")
            
            await db.commit_transaction()
        except Exception as db_err:
            await db.rollback_transaction()
            raise Exception(f"æ•¸æ“šåº«å¯«å…¥å¤±æ•—: {db_err}")
        
        if keywords:
            self.send_log(f"ğŸ” ç›£æ§é—œéµè©: {', '.join(keywords)}", "info")
        
        self.send_event("join-and-monitor-with-account-complete", {
            "success": True,
            "resourceId": resource_id,
            "phone": phone,
            "keywords": keywords,
            "keywordSetIds": keyword_set_ids,  # ğŸ”§ FIX: è¿”å›ç¶å®šçš„é—œéµè©é›† ID
            "status": join_status,  # ğŸ†• è¿”å›åŠ å…¥ç‹€æ…‹
            "memberCount": members_count,  # ğŸ†• è¿”å›æˆå“¡æ•¸
            "message": "åŠ å…¥è«‹æ±‚å·²ç™¼é€ï¼Œç­‰å¾…ç®¡ç†å“¡æ‰¹å‡†" if join_status == 'pending_approval' else "å·²æˆåŠŸåŠ å…¥ä¸¦è¨­ç½®ç›£æ§"
        })
        
    except Exception as e:
        # ğŸ†• ä½¿ç”¨å‹å¥½éŒ¯èª¤è™•ç†
        error_str = str(e)
        friendly_error = self._get_friendly_join_error(error_str)
        
        self.send_log(f"âŒ åŠ å…¥å¤±æ•—: {friendly_error}", "error")
        import traceback
        traceback.print_exc()
        self.send_event("join-and-monitor-with-account-complete", {
            "success": False,
            "error": friendly_error
        })

async def handle_batch_add_monitored_groups(self, payload: Dict[str, Any]):
    """ğŸ”§ Phase7-2: æ‰¹é‡æ·»åŠ ç¾¤çµ„åˆ°ç›£æ§åˆ—è¡¨"""
    try:
        groups = payload.get('groups', [])
        if not groups:
            self.send_event("batch-add-monitored-result", {"success": False, "error": "ç©ºçš„ç¾¤çµ„åˆ—è¡¨"})
            return
        
        self.send_log(f"ğŸ“¡ é–‹å§‹æ‰¹é‡æ·»åŠ  {len(groups)} å€‹ç¾¤çµ„åˆ°ç›£æ§åˆ—è¡¨...", "info")
        
        results = {"added": 0, "failed": 0, "skipped": 0, "errors": []}
        
        for i, group_data in enumerate(groups):
            try:
                # å¾©ç”¨ handle_add_monitored_group çš„é‚è¼¯
                await handle_add_monitored_group(self, group_data)
                results["added"] += 1
            except Exception as e:
                err_msg = str(e)
                if "å·²å­˜åœ¨" in err_msg or "already" in err_msg.lower():
                    results["skipped"] += 1
                else:
                    results["failed"] += 1
                    results["errors"].append(f"{group_data.get('name', '?')}: {err_msg}")
            
            # æ¯å€‹ç¾¤çµ„ä¹‹é–“ç­‰ä¸€ä¸‹ï¼Œé¿å…è§¸ç™¼ FloodWait
            if i < len(groups) - 1:
                await asyncio.sleep(1)
        
        msg = f"âœ… æ‰¹é‡æ·»åŠ å®Œæˆ: {results['added']} æˆåŠŸ"
        if results["skipped"]:
            msg += f", {results['skipped']} å·²å­˜åœ¨"
        if results["failed"]:
            msg += f", {results['failed']} å¤±æ•—"
        
        self.send_log(msg, "success" if results["failed"] == 0 else "warning")
        
        self.send_event("batch-add-monitored-result", {
            "success": True,
            **results
        })
        
        # åˆ·æ–°ç¾¤çµ„åˆ—è¡¨
        try:
            from domain.automation.monitoring_handlers_impl import handle_get_monitored_groups
            await handle_get_monitored_groups(self)
        except Exception:
            pass
        
    except Exception as e:
        print(f"[Backend] æ‰¹é‡æ·»åŠ ç¾¤çµ„å¤±æ•—: {e}", file=sys.stderr)
        self.send_event("batch-add-monitored-result", {
            "success": False,
            "error": str(e)
        })


async def handle_batch_reassign_accounts(self, payload: Dict[str, Any]):
    """ğŸ”§ Phase7-2: æ‰¹é‡é‡åˆ†é…ç¾¤çµ„çš„ç›£æ§å¸³è™Ÿ"""
    try:
        group_ids = payload.get('groupIds', [])
        new_phone = payload.get('phone')
        
        if not group_ids or not new_phone:
            self.send_event("batch-reassign-result", {"success": False, "error": "ç¼ºå°‘åƒæ•¸"})
            return
        
        # é©—è­‰å¸³è™Ÿ
        client = self.telegram_manager.get_client(new_phone)
        if not client or not client.is_connected:
            self.send_event("batch-reassign-result", {
                "success": False,
                "error": f"å¸³è™Ÿ {new_phone[:4]}**** æœªé€£æ¥"
            })
            return
        
        updated = 0
        for gid in group_ids:
            try:
                await db.execute(
                    "UPDATE monitored_groups SET phone = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?",
                    (new_phone, gid)
                )
                updated += 1
            except Exception:
                pass
        
        self.send_log(f"âœ… å·²å°‡ {updated}/{len(group_ids)} å€‹ç¾¤çµ„åˆ‡æ›åˆ°å¸³è™Ÿ {new_phone[:4]}****", "success")
        self.send_event("batch-reassign-result", {
            "success": True,
            "updated": updated,
            "total": len(group_ids)
        })
        
        # åˆ·æ–°
        try:
            from domain.automation.monitoring_handlers_impl import handle_get_monitored_groups
            await handle_get_monitored_groups(self)
        except Exception:
            pass
        
    except Exception as e:
        self.send_event("batch-reassign-result", {"success": False, "error": str(e)})


async def handle_batch_bind_keywords(self, payload: Dict[str, Any]):
    """ğŸ”§ Phase7-2: æ‰¹é‡ç¶å®šé—œéµè©é›†åˆ°ç¾¤çµ„"""
    try:
        group_ids = payload.get('groupIds', [])
        keyword_set_ids = payload.get('keywordSetIds', [])
        mode = payload.get('mode', 'append')  # 'append' è¿½åŠ  | 'replace' æ›¿æ›
        
        if not group_ids or not keyword_set_ids:
            self.send_event("batch-bind-keywords-result", {"success": False, "error": "ç¼ºå°‘åƒæ•¸"})
            return
        
        import json
        updated = 0
        
        for gid in group_ids:
            try:
                if mode == 'replace':
                    new_ids = keyword_set_ids
                else:
                    # è¿½åŠ æ¨¡å¼ï¼šè®€å–ç¾æœ‰çš„å†åˆä½µ
                    row = await db.fetch_one(
                        "SELECT keyword_set_ids FROM monitored_groups WHERE id = ?", (gid,)
                    )
                    existing = []
                    if row and row.get('keyword_set_ids'):
                        try:
                            existing = json.loads(row['keyword_set_ids'])
                        except Exception:
                            pass
                    # åˆä½µå»é‡
                    merged = list(dict.fromkeys(existing + keyword_set_ids))
                    new_ids = merged
                
                await db.execute(
                    "UPDATE monitored_groups SET keyword_set_ids = ?, is_active = 1, updated_at = CURRENT_TIMESTAMP WHERE id = ?",
                    (json.dumps(new_ids), gid)
                )
                updated += 1
            except Exception as e:
                print(f"[BatchBind] ç¾¤çµ„ {gid} ç¶å®šå¤±æ•—: {e}", file=sys.stderr)
        
        self.send_log(f"âœ… å·²ç‚º {updated}/{len(group_ids)} å€‹ç¾¤çµ„ç¶å®š {len(keyword_set_ids)} å€‹è©é›†", "success")
        self.send_event("batch-bind-keywords-result", {
            "success": True,
            "updated": updated,
            "total": len(group_ids)
        })
        
        # åˆ·æ–°
        try:
            from domain.automation.monitoring_handlers_impl import handle_get_monitored_groups
            await handle_get_monitored_groups(self)
        except Exception:
            pass
        
    except Exception as e:
        self.send_event("batch-bind-keywords-result", {"success": False, "error": str(e)})


async def handle_get_account_recommendations(self, payload: Dict[str, Any]):
    """ğŸ”§ Phase6-3: ç²å–å¸³è™Ÿæ¨è–¦åˆ—è¡¨ï¼ˆå«è² è¼‰/å¥åº·/å†·å»ç‹€æ…‹ï¼‰"""
    try:
        recommendations = await get_account_recommendations(self.telegram_manager, db)
        self.send_event("account-recommendations-result", {
            "success": True,
            "accounts": recommendations
        })
    except Exception as e:
        print(f"[Backend] ç²å–å¸³è™Ÿæ¨è–¦å¤±æ•—: {e}", file=sys.stderr)
        self.send_event("account-recommendations-result", {
            "success": False,
            "error": str(e),
            "accounts": []
        })


async def handle_reassign_group_account(self, payload: Dict[str, Any]):
    """ğŸ”§ Phase6-3: é‡æ–°åˆ†é…ç¾¤çµ„çš„ç›£æ§å¸³è™Ÿ"""
    try:
        group_id = payload.get('groupId')
        new_phone = payload.get('phone')
        
        if not group_id or not new_phone:
            self.send_event("group-account-reassigned", {
                "success": False,
                "error": "ç¼ºå°‘ç¾¤çµ„ ID æˆ–å¸³è™Ÿé›»è©±"
            })
            return
        
        # é©—è­‰å¸³è™Ÿæ˜¯å¦åœ¨ç·š
        client = self.telegram_manager.get_client(new_phone)
        if not client or not client.is_connected:
            self.send_event("group-account-reassigned", {
                "success": False,
                "error": f"å¸³è™Ÿ {new_phone[:4]}**** æœªé€£æ¥ï¼Œè«‹å…ˆç™»å…¥"
            })
            return
        
        # æ›´æ–°æ•¸æ“šåº«
        await db.execute(
            "UPDATE monitored_groups SET phone = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?",
            (new_phone, group_id)
        )
        
        # ç²å–ç¾¤çµ„åç¨±
        group = await db.fetch_one("SELECT name FROM monitored_groups WHERE id = ?", (group_id,))
        group_name = group['name'] if group else f'ID:{group_id}'
        
        self.send_log(f"âœ… å·²å°‡ç¾¤çµ„ã€Œ{group_name}ã€çš„ç›£æ§å¸³è™Ÿåˆ‡æ›åˆ° {new_phone[:4]}****", "success")
        
        self.send_event("group-account-reassigned", {
            "success": True,
            "groupId": group_id,
            "phone": new_phone,
            "message": f"å·²åˆ‡æ›ç›£æ§å¸³è™Ÿ"
        })
        
        # é€šçŸ¥å‰ç«¯åˆ·æ–°ç¾¤çµ„åˆ—è¡¨
        try:
            from domain.automation.monitoring_handlers_impl import handle_get_monitored_groups
            await handle_get_monitored_groups(self)
        except Exception:
            pass
        
    except Exception as e:
        print(f"[Backend] é‡æ–°åˆ†é…å¸³è™Ÿå¤±æ•—: {e}", file=sys.stderr)
        self.send_event("group-account-reassigned", {
            "success": False,
            "error": str(e)
        })


async def handle_get_admin_groups(self, payload: Dict[str, Any]):
    """ç²å–ç”¨æˆ¶ä½œç‚ºç®¡ç†å“¡çš„ç¾¤çµ„åˆ—è¡¨"""
    import sys
    
    try:
        # ç²å–å·²ç™»éŒ„å¸³è™Ÿ
        accounts = await db.get_all_accounts()
        online_accounts = [a for a in accounts if a.get('status') == 'Online' or a.get('status') == 'active']
        
        if not online_accounts:
            self.send_event("get-admin-groups-result", {"groups": []})
            return
        
        groups = []
        
        for account in online_accounts[:1]:  # åªä½¿ç”¨ç¬¬ä¸€å€‹å¸³è™ŸæŸ¥è©¢
            phone = account.get('phone')
            client = self.telegram_manager.get_client(phone)
            
            if not client or not client.is_connected:
                continue
            
            try:
                # ç²å–ç”¨æˆ¶æ‰€åœ¨çš„æ‰€æœ‰å°è©±
                dialogs = []
                async for dialog in client.get_dialogs():
                    if dialog.chat.type in ['group', 'supergroup']:
                        # æª¢æŸ¥æ˜¯å¦ç‚ºç®¡ç†å“¡
                        is_admin = False
                        try:
                            me = await client.get_me()
                            member = await client.get_chat_member(dialog.chat.id, me.id)
                            is_admin = member.status in ['administrator', 'creator']
                        except:
                            pass
                        
                        groups.append({
                            "id": str(dialog.chat.id),
                            "name": dialog.chat.title or dialog.chat.first_name or 'æœªçŸ¥ç¾¤çµ„',
                            "url": dialog.chat.username or f"t.me/c/{str(dialog.chat.id)[4:]}",
                            "memberCount": dialog.chat.members_count or 0,
                            "isAdmin": is_admin,
                            "type": dialog.chat.type
                        })
            except Exception as e:
                print(f"[GetAdminGroups] ç²å–å°è©±åˆ—è¡¨å¤±æ•—: {e}", file=sys.stderr)
        
        # æŒ‰ç®¡ç†å“¡å„ªå…ˆæ’åº
        groups.sort(key=lambda g: (not g['isAdmin'], g['name']))
        
        self.send_event("get-admin-groups-result", {"groups": groups})
        self.send_log(f"ğŸ“‹ ç²å–ç¾¤çµ„åˆ—è¡¨: {len(groups)} å€‹", "info")
        
    except Exception as e:
        print(f"[GetAdminGroups] éŒ¯èª¤: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_event("get-admin-groups-result", {"groups": [], "error": str(e)})

