"""
Extracted handler implementations: batch_ops
Auto-generated by refactor_main.py
"""
import json
import sys
import time
import asyncio
import traceback
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from service_context import get_service_context

# All handlers receive (self, payload) where self is BackendService instance.
# They are called via: await handler_impl(self, payload)
# Inside, use self.db, self.send_event(), self.telegram_manager, etc.
# This is a transitional pattern - later, replace self.xxx with ctx.xxx


async def handle_undo_batch_operation(self, payload: Dict[str, Any]):
    """æ’¤éŠ·æ‰¹é‡æ“ä½œ"""
    try:
        operation_id = payload.get('operationId')
        
        if not operation_id:
            self.send_event("batch-undo-result", {
                "success": False,
                "error": "æœªæŒ‡å®šæ“ä½œ ID"
            })
            return
        
        batch_ops = get_batch_ops()
        if not batch_ops:
            self.send_event("batch-undo-result", {
                "success": False,
                "error": "æ‰¹é‡æ“ä½œç³»çµ±æœªåˆå§‹åŒ–"
            })
            return
        
        result = await batch_ops.undo_operation(operation_id)
        
        if result.get('success'):
            self.send_log(f"æ’¤éŠ·æ“ä½œæˆåŠŸ: {operation_id}", "success")
        else:
            self.send_log(f"æ’¤éŠ·æ“ä½œå¤±æ•—: {result.get('error')}", "error")
        
        self.send_event("batch-undo-result", result)
        
    except Exception as e:
        self.send_log(f"æ’¤éŠ·æ“ä½œå¤±æ•—: {str(e)}", "error")
        self.send_event("batch-undo-result", {
            "success": False,
            "error": str(e)
        })


async def handle_get_batch_operation_history(self, payload: Dict[str, Any]):
    """ç²å–æ‰¹é‡æ“ä½œæ­·å²"""
    try:
        limit = payload.get('limit', 50)
        offset = payload.get('offset', 0)
        operation_type = payload.get('operationType')
        
        batch_ops = get_batch_ops()
        if not batch_ops:
            self.send_event("batch-operation-history", {
                "success": False,
                "error": "æ‰¹é‡æ“ä½œç³»çµ±æœªåˆå§‹åŒ–"
            })
            return
        
        result = await batch_ops.get_operation_history(limit, offset, operation_type)
        
        self.send_event("batch-operation-history", result)
        
    except Exception as e:
        self.send_log(f"ç²å–æ“ä½œæ­·å²å¤±æ•—: {str(e)}", "error")
        self.send_event("batch-operation-history", {
            "success": False,
            "error": str(e)
        })


async def handle_add_to_join_queue(self, payload: Dict[str, Any]):
    """æ·»åŠ è³‡æºåˆ°åŠ å…¥éšŠåˆ—"""
    try:
        resource_ids = payload.get('resourceIds', [])
        priority = payload.get('priority', 5)
        
        if not resource_ids:
            raise ValueError("è³‡æº ID åˆ—è¡¨ä¸èƒ½ç‚ºç©º")
        
        added = 0
        for rid in resource_ids:
            await resource_discovery.add_to_join_queue(rid, priority)
            added += 1
        
        self.send_log(f"ğŸ“‹ å·²æ·»åŠ  {added} å€‹è³‡æºåˆ°åŠ å…¥éšŠåˆ—", "success")
        self.send_event("join-queue-updated", {
            "success": True,
            "added": added
        })
        
    except Exception as e:
        self.send_log(f"âŒ æ·»åŠ åˆ°éšŠåˆ—å¤±æ•—: {e}", "error")
        self.send_event("join-queue-updated", {
            "success": False,
            "error": str(e)
        })


async def handle_process_join_queue(self, payload: Dict[str, Any]):
    """è™•ç†åŠ å…¥éšŠåˆ—"""
    try:
        limit = payload.get('limit', 5)
        
        group_search_service.set_clients(self.telegram_manager.clients)
        stats = await group_search_service.process_join_queue(limit=limit)
        
        self.send_log(f"ğŸš€ è™•ç†éšŠåˆ—: æˆåŠŸ {stats['successCount']}, å¤±æ•— {stats['failed']}", "success")
        self.send_event("join-queue-processed", {
            "success": True,
            **stats
        })
        
    except Exception as e:
        self.send_log(f"âŒ è™•ç†éšŠåˆ—å¤±æ•—: {e}", "error")
        self.send_event("join-queue-processed", {
            "success": False,
            "error": str(e)
        })


async def handle_batch_join_and_monitor(self, payload: Dict[str, Any]):
    """æ‰¹é‡åŠ å…¥ä¸¦ç›£æ§"""
    try:
        resource_ids = payload.get('resourceIds', [])
        
        if not resource_ids:
            raise ValueError("è³‡æº ID åˆ—è¡¨ä¸èƒ½ç‚ºç©º")
        
        self.send_log(f"ğŸš€ é–‹å§‹æ‰¹é‡åŠ å…¥ä¸¦ç›£æ§ {len(resource_ids)} å€‹è³‡æº", "info")
        
        # ç²å–è³‡æºè©³æƒ…
        from database import db
from config import config
        await db.connect()
        
        success_count = 0
        fail_count = 0
        
        for resource_id in resource_ids:
            try:
                resource = await db.fetch_one(
                    "SELECT * FROM discovered_resources WHERE id = ?",
                    (resource_id,)
                )
                
                if resource:
                    await self.handle_join_and_monitor_resource({
                        'resourceId': resource_id,
                        'username': resource.get('username'),
                        'telegramId': resource.get('telegram_id'),
                        'title': resource.get('title', '')
                    })
                    success_count += 1
                    
                    # å»¶é²é¿å…é »ç‡é™åˆ¶
                    import random
                    await asyncio.sleep(random.uniform(30, 60))
                    
            except Exception as e:
                self.send_log(f"âŒ è™•ç†è³‡æº {resource_id} å¤±æ•—: {e}", "error")
                fail_count += 1
        
        self.send_log(f"âœ… æ‰¹é‡åŠ å…¥ç›£æ§å®Œæˆ: æˆåŠŸ {success_count}, å¤±æ•— {fail_count}", "success")
        self.send_event("batch-join-and-monitor-complete", {
            "success": True,
            "total": len(resource_ids),
            "successCount": success_count,
            "failed": fail_count
        })
        
    except Exception as e:
        self.send_log(f"âŒ æ‰¹é‡åŠ å…¥ä¸¦ç›£æ§å¤±æ•—: {e}", "error")
        self.send_event("batch-join-and-monitor-complete", {
            "success": False,
            "error": str(e)
        })


# ==================== ç‡ŸéŠ·è§¸é”è™•ç†å™¨ ====================

async def handle_send_bulk_messages(self, payload: Dict[str, Any]):
    """æ‰¹é‡ç™¼é€ç§ä¿¡"""
    try:
        user_ids = payload.get('userIds', [])
        message_template = payload.get('messageTemplate', '')
        delay_min = payload.get('delayMin', 30)
        delay_max = payload.get('delayMax', 90)
        
        if not user_ids:
            raise ValueError("ç”¨æˆ¶ ID åˆ—è¡¨ä¸èƒ½ç‚ºç©º")
        if not message_template:
            raise ValueError("æ¶ˆæ¯æ¨¡æ¿ä¸èƒ½ç‚ºç©º")
        
        self.send_log(f"ğŸ“¤ é–‹å§‹æ‰¹é‡ç™¼é€: {len(user_ids)} äºº", "info")
        
        # è¨­ç½®å®¢æˆ¶ç«¯
        marketing_outreach_service.set_clients(self.telegram_manager.clients)
        marketing_outreach_service.set_event_callback(self.send_event)
        
        # åœ¨å¾Œå°åŸ·è¡Œ
        async def send_task():
            stats = await marketing_outreach_service.batch_send_messages(
                user_ids=user_ids,
                message_template=message_template,
                delay_range=(delay_min, delay_max)
            )
            self.send_event("bulk-send-complete", {
                "success": True,
                **stats
            })
        
        asyncio.create_task(send_task())
        
        self.send_event("bulk-send-started", {
            "success": True,
            "total": len(user_ids)
        })
        
    except Exception as e:
        self.send_log(f"âŒ æ‰¹é‡ç™¼é€å¤±æ•—: {e}", "error")
        self.send_event("bulk-send-complete", {
            "success": False,
            "error": str(e)
        })


async def handle_batch_invite_to_group(self, payload: Dict[str, Any]):
    """æ‰¹é‡é‚€è«‹å…¥ç¾¤"""
    try:
        user_ids = payload.get('userIds', [])
        group_id = payload.get('groupId', '')
        delay_min = payload.get('delayMin', 30)
        delay_max = payload.get('delayMax', 90)
        
        if not user_ids:
            raise ValueError("ç”¨æˆ¶ ID åˆ—è¡¨ä¸èƒ½ç‚ºç©º")
        if not group_id:
            raise ValueError("ç›®æ¨™ç¾¤çµ„ä¸èƒ½ç‚ºç©º")
        
        self.send_log(f"ğŸ“¥ é–‹å§‹æ‰¹é‡é‚€è«‹: {len(user_ids)} äºº -> {group_id}", "info")
        
        # è¨­ç½®å®¢æˆ¶ç«¯
        marketing_outreach_service.set_clients(self.telegram_manager.clients)
        marketing_outreach_service.set_event_callback(self.send_event)
        
        # åœ¨å¾Œå°åŸ·è¡Œ
        async def invite_task():
            stats = await marketing_outreach_service.batch_invite(
                user_ids=user_ids,
                group_id=group_id,
                delay_range=(delay_min, delay_max)
            )
            self.send_event("batch-invite-complete", {
                "success": True,
                **stats
            })
        
        asyncio.create_task(invite_task())
        
        self.send_event("batch-invite-started", {
            "success": True,
            "total": len(user_ids)
        })
        
    except Exception as e:
        self.send_log(f"âŒ æ‰¹é‡é‚€è«‹å¤±æ•—: {e}", "error")
        self.send_event("batch-invite-complete", {
            "success": False,
            "error": str(e)
        })


async def handle_batch_invite_start(self, payload: Dict[str, Any]):
    """é–‹å§‹æ‰¹é‡æ‹‰ç¾¤"""
    import sys
    import asyncio
    import random
    import pyrogram
    from pyrogram import raw
    
    try:
        targets = payload.get('targets', [])
        group_id = payload.get('groupId', '')
        group_url = payload.get('groupUrl', '')
        config = payload.get('config', {})
        invite_id = payload.get('inviteId', '')  # ğŸ”§ Phase 2: ç²å–é‚€è«‹ ID
        
        batch_size = config.get('batchSize', 10)
        min_interval = config.get('minInterval', 60)
        max_interval = config.get('maxInterval', 120)
        send_welcome_message = config.get('sendWelcomeMessage', False)
        welcome_message = config.get('welcomeMessage', '')
        
        print(f"[BatchInvite] é–‹å§‹æ‰¹é‡æ‹‰ç¾¤: {len(targets)} å€‹ç›®æ¨™ -> {group_url}", file=sys.stderr)
        print(f"[BatchInvite] æ­¡è¿æ¶ˆæ¯: {send_welcome_message}, å…§å®¹: {welcome_message[:50] if welcome_message else 'N/A'}", file=sys.stderr)
        self.send_log(f"ğŸ‘¥ é–‹å§‹æ‰¹é‡æ‹‰ç¾¤: {len(targets)} å€‹ç”¨æˆ¶ -> {group_url}", "info")
        
        self._batch_invite_active = True
        self._batch_invite_cancelled = False
        
        # ç²å–ç®¡ç†å“¡å¸³è™Ÿ
        accounts = await db.get_all_accounts()
        admin_accounts = [a for a in accounts if a.get('status') == 'Online' or a.get('status') == 'active']
        
        if not admin_accounts:
            self.send_log("âš ï¸ æ²’æœ‰å¯ç”¨çš„å¸³è™Ÿ", "warning")
            self.send_event("batch-invite:complete", {
                "inviteId": invite_id,  # ğŸ”§ Phase 2: è¿”å›é‚€è«‹ ID
                "success": 0, 
                "failed": len(targets), 
                "skipped": 0
            })
            return
        
        success_count = 0
        failed_count = 0
        skipped_count = 0
        
        for idx, target in enumerate(targets):
            if self._batch_invite_cancelled:
                print(f"[BatchInvite] ç”¨æˆ¶å–æ¶ˆ", file=sys.stderr)
                break
            
            try:
                account = admin_accounts[0]
                phone = account.get('phone')
                user_id = target.get('telegramId')
                username = target.get('username', '')
                
                # ğŸ”§ P0: é©—è­‰ username æ ¼å¼ï¼ˆå¿…é ˆä»¥å­—æ¯é–‹é ­ï¼Œé•·åº¦ 5-32ï¼‰
                import re
                def is_valid_username(uname: str) -> bool:
                    if not uname or len(uname) < 5 or len(uname) > 32:
                        return False
                    # å¿…é ˆä»¥å­—æ¯é–‹é ­ï¼Œåªèƒ½åŒ…å«å­—æ¯ã€æ•¸å­—ã€ä¸‹åŠƒç·š
                    return bool(re.match(r'^[a-zA-Z][a-zA-Z0-9_]{4,31}$', uname))
                
                valid_username = is_valid_username(username)
                print(f"[BatchInvite] é‚€è«‹ {idx + 1}/{len(targets)}: user_id={user_id}, username={username} (valid={valid_username})", file=sys.stderr)
                
                # ç²å– Telegram å®¢æˆ¶ç«¯
                client = self.telegram_manager.get_client(phone)
                if not client or not client.is_connected:
                    self.send_log(f"âš ï¸ å¸³è™Ÿ {phone} æœªé€£ç·š", "warning")
                    failed_count += 1
                    continue
                
                # ğŸ”§ P0: å˜—è©¦ç›´æ¥é‚€è«‹ï¼Œå¤±æ•—å‰‡ç™¼é€é‚€è«‹éˆæ¥
                invite_success = False
                link_sent = False
                first_name = target.get('firstName', '')
                display_name = target.get('displayName', first_name or username or 'æœ‹å‹')
                
                try:
                    # æ–¹æ³•1: å˜—è©¦ç›´æ¥é‚€è«‹ï¼ˆéœ€è¦ access_hashï¼‰
                    peer_to_invite = None
                    
                    # å˜—è©¦é€šé username è§£æï¼ˆæ›´å¯é ï¼‰
                    if valid_username:
                        try:
                            peer_to_invite = await client.resolve_peer(f"@{username}")
                            print(f"[BatchInvite] é€šé @{username} è§£ææˆåŠŸ", file=sys.stderr)
                        except Exception as e:
                            print(f"[BatchInvite] ç„¡æ³•è§£æ @{username}: {e}", file=sys.stderr)
                    
                    # å˜—è©¦é€šé user_id è§£æ
                    if peer_to_invite is None and user_id:
                        try:
                            peer_to_invite = await client.resolve_peer(int(user_id))
                            print(f"[BatchInvite] é€šé user_id={user_id} è§£ææˆåŠŸ", file=sys.stderr)
                        except Exception as e:
                            print(f"[BatchInvite] ç„¡æ³•è§£æ user_id={user_id}: {e}", file=sys.stderr)
                    
                    if peer_to_invite:
                        await client.invoke(
                            pyrogram.raw.functions.channels.InviteToChannel(
                                channel=await client.resolve_peer(group_url or group_id),
                                users=[peer_to_invite]
                            )
                        )
                        invite_success = True
                        success_count += 1
                        print(f"[BatchInvite] âœ… ç›´æ¥é‚€è«‹æˆåŠŸ: {display_name}", file=sys.stderr)
                        self.send_log(f"âœ… å·²é‚€è«‹ {display_name} åŠ å…¥ç¾¤çµ„", "success")
                    
                except Exception as invite_err:
                    err_str = str(invite_err).lower()
                    if 'already' in err_str or 'participant' in err_str:
                        skipped_count += 1
                        print(f"[BatchInvite] {display_name} å·²åœ¨ç¾¤å…§", file=sys.stderr)
                        self.send_log(f"â­ï¸ {display_name} å·²åœ¨ç¾¤å…§", "info")
                        continue
                    elif 'privacy' in err_str or 'restrict' in err_str:
                        print(f"[BatchInvite] {display_name} éš±ç§é™åˆ¶ï¼Œå˜—è©¦ç™¼é€é‚€è«‹éˆæ¥", file=sys.stderr)
                    else:
                        print(f"[BatchInvite] ç›´æ¥é‚€è«‹å¤±æ•—: {invite_err}", file=sys.stderr)
                
                # ğŸ”§ P0: æ–¹æ³•2: å¦‚æœç›´æ¥é‚€è«‹å¤±æ•—ï¼Œç™¼é€é‚€è«‹éˆæ¥
                if not invite_success and group_url:
                    try:
                        # æ§‹å»ºé‚€è«‹æ¶ˆæ¯
                        invite_msg = f"ğŸ‘‹ {display_name}ï¼Œæ‚¨å¥½ï¼\n\n"
                        invite_msg += f"èª æ‘¯é‚€è«‹æ‚¨åŠ å…¥æˆ‘å€‘çš„ç¾¤çµ„ï¼Œé»æ“Šä¸‹æ–¹éˆæ¥å³å¯åŠ å…¥ï¼š\n\n"
                        invite_msg += f"ğŸ”— {group_url}\n\n"
                        invite_msg += f"æœŸå¾…æ‚¨çš„åŠ å…¥ï¼"
                        
                        # å˜—è©¦ç™¼é€ç§ä¿¡
                        if valid_username:
                            await client.send_message(f"@{username}", invite_msg)
                            link_sent = True
                            print(f"[BatchInvite] ğŸ“¨ å·²ç™¼é€é‚€è«‹éˆæ¥çµ¦ @{username}", file=sys.stderr)
                        elif user_id:
                            await client.send_message(int(user_id), invite_msg)
                            link_sent = True
                            print(f"[BatchInvite] ğŸ“¨ å·²ç™¼é€é‚€è«‹éˆæ¥çµ¦ user_id={user_id}", file=sys.stderr)
                        
                        if link_sent:
                            success_count += 1
                            self.send_log(f"ğŸ“¨ å·²ç™¼é€é‚€è«‹éˆæ¥çµ¦ {display_name}", "success")
                            
                    except Exception as msg_err:
                        err_msg = str(msg_err).lower()
                        if 'privacy' in err_msg or 'not mutual' in err_msg or 'peer_id_invalid' in err_msg:
                            print(f"[BatchInvite] âš ï¸ {display_name} éš±ç§è¨­ç½®ä¸å…è¨±æ¥æ”¶æ¶ˆæ¯", file=sys.stderr)
                            self.send_log(f"âš ï¸ {display_name} éš±ç§è¨­ç½®é™åˆ¶ï¼Œç„¡æ³•ç™¼é€é‚€è«‹", "warning")
                            skipped_count += 1
                        else:
                            print(f"[BatchInvite] ç™¼é€é‚€è«‹éˆæ¥å¤±æ•—: {msg_err}", file=sys.stderr)
                            failed_count += 1
                
                # å¦‚æœå…©ç¨®æ–¹æ³•éƒ½å¤±æ•—
                if not invite_success and not link_sent:
                    if 'skipped_count' not in dir() or skipped_count == 0:
                        failed_count += 1
                        self.send_log(f"âŒ ç„¡æ³•é‚€è«‹ {display_name}", "error")
                
                # ç™¼é€è‡ªå®šç¾©æ­¡è¿æ¶ˆæ¯ï¼ˆåªåœ¨ç›´æ¥é‚€è«‹æˆåŠŸæ™‚ï¼‰
                if invite_success and send_welcome_message and welcome_message:
                    try:
                        msg = welcome_message
                        msg = msg.replace('{name}', display_name)
                        msg = msg.replace('{first_name}', first_name)
                        msg = msg.replace('{username}', username)
                        
                        if valid_username:
                            await client.send_message(f"@{username}", msg)
                        elif user_id:
                            await client.send_message(int(user_id), msg)
                            
                        print(f"[BatchInvite] å·²ç™¼é€æ­¡è¿æ¶ˆæ¯çµ¦ {display_name}", file=sys.stderr)
                    except Exception as msg_err:
                        print(f"[BatchInvite] ç™¼é€æ­¡è¿æ¶ˆæ¯å¤±æ•—: {msg_err}", file=sys.stderr)
                
            except Exception as e:
                print(f"[BatchInvite] éŒ¯èª¤: {e}", file=sys.stderr)
                failed_count += 1
            
            # æ›´æ–°é€²åº¦
            self.send_event("batch-invite:progress", {
                "invited": idx + 1,
                "success": success_count,
                "failed": failed_count,
                "skipped": skipped_count,
                "total": len(targets)
            })
            
            # æ‰¹æ¬¡é–“éš”
            if idx < len(targets) - 1 and (idx + 1) % batch_size == 0:
                interval = random.randint(min_interval, max_interval)
                print(f"[BatchInvite] æ‰¹æ¬¡å®Œæˆï¼Œç­‰å¾… {interval} ç§’", file=sys.stderr)
                await asyncio.sleep(interval)
            elif idx < len(targets) - 1:
                # å–®å€‹é–“éš”
                await asyncio.sleep(random.randint(3, 8))
        
        # å®Œæˆ
        self._batch_invite_active = False
        self.send_event("batch-invite:complete", {
            "inviteId": invite_id,  # ğŸ”§ Phase 2: è¿”å›é‚€è«‹ ID
            "success": success_count,
            "failed": failed_count,
            "skipped": skipped_count
        })
        self.send_log(f"âœ… æ‰¹é‡æ‹‰ç¾¤å®Œæˆ: æˆåŠŸ {success_count}, è·³é {skipped_count}, å¤±æ•— {failed_count}", "success")
        
    except Exception as e:
        print(f"[BatchInvite] éŒ¯èª¤: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
        self._batch_invite_active = False
        self.send_event("batch-invite:complete", {
            "inviteId": invite_id if 'invite_id' in locals() else '',  # ğŸ”§ Phase 2
            "success": 0, 
            "failed": len(targets) if 'targets' in locals() else 0, 
            "skipped": 0
        })
        self.send_log(f"âŒ æ‰¹é‡æ‹‰ç¾¤éŒ¯èª¤: {e}", "error")


async def handle_batch_invite_cancel(self, payload: Dict[str, Any]):
    """å–æ¶ˆæ‰¹é‡æ‹‰ç¾¤"""
    self._batch_invite_cancelled = True
    self.send_log("â¹ï¸ æ‰¹é‡æ‹‰ç¾¤å·²å–æ¶ˆ", "info")

