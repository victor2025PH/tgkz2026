"""
Extracted handler implementations: chat
Auto-generated by refactor_main.py
"""
import json
import sys
import time
import asyncio
import traceback
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from service_context import get_service_context
from database import db

# All handlers receive (self, payload) where self is BackendService instance.
# They are called via: await handler_impl(self, payload)
# Inside, use self.db, self.send_event(), self.telegram_manager, etc.
# This is a transitional pattern - later, replace self.xxx with ctx.xxx


async def handle_reindex_conversations(self, payload: Dict[str, Any]):
    """重新索引對話"""
    try:
        from chat_history_indexer import chat_indexer
        
        high_value_only = payload.get('highValueOnly', False)
        days = payload.get('days', 30)
        
        if high_value_only:
            result = await chat_indexer.reindex_high_value_conversations(days=days)
        else:
            result = await chat_indexer.index_pending_conversations()
        
        self.send_log(f"重新索引完成: 處理 {result.get('conversations_processed', 0)} 個對話", "success")
        
        self.send_event("rag-reindex-complete", {
            "success": True,
            **result
        })
        
    except Exception as e:
        self.send_event("rag-reindex-complete", {
            "success": False,
            "error": str(e)
        })


# ==================== Full-Text Search Handlers ====================

async def handle_search_chat_history(self, payload: Dict[str, Any]):
    """全文搜索聊天記錄"""
    try:
        from fulltext_search import get_search_engine
        from datetime import datetime as dt
        
        query = payload.get('query', '')
        if not query:
            self.send_event("search-chat-history", {
                "success": False,
                "error": "搜索查詢不能為空"
            })
            return
        
        user_id = payload.get('userId')
        account_phone = payload.get('accountPhone')
        role = payload.get('role')
        limit = payload.get('limit', 50)
        offset = payload.get('offset', 0)
        
        # 解析日期範圍
        date_from = None
        date_to = None
        if payload.get('dateFrom'):
            try:
                date_from = dt.fromisoformat(payload['dateFrom'])
            except:
                pass
        if payload.get('dateTo'):
            try:
                date_to = dt.fromisoformat(payload['dateTo'])
            except:
                pass
        
        search_engine = get_search_engine()
        results = await search_engine.search_chat_history(
            query=query,
            user_id=user_id,
            account_phone=account_phone,
            role=role,
            date_from=date_from,
            date_to=date_to,
            limit=limit,
            offset=offset
        )
        
        self.send_event("search-chat-history", {
            "success": True,
            "query": query,
            "results": results,
            "count": len(results),
            "hasMore": len(results) == limit
        })
    except Exception as e:
        self.send_event("search-chat-history", {
            "success": False,
            "error": str(e)
        })


async def handle_get_chat_list(self, payload: Dict[str, Any]):
    """獲取聊天列表（所有有對話的用戶）"""
    try:
        limit = payload.get('limit', 50)
        offset = payload.get('offset', 0)
        search_query = payload.get('search', '')
        funnel_stage = payload.get('funnelStage')
        
        # 構建查詢
        query = """
            SELECT DISTINCT 
                ch.user_id,
                up.username,
                up.first_name,
                up.last_name,
                up.funnel_stage,
                up.interest_level,
                up.last_interaction,
                (SELECT content FROM chat_history ch2 
                 WHERE ch2.user_id = ch.user_id 
                 ORDER BY ch2.timestamp DESC LIMIT 1) as last_message,
                (SELECT timestamp FROM chat_history ch2 
                 WHERE ch2.user_id = ch.user_id 
                 ORDER BY ch2.timestamp DESC LIMIT 1) as last_message_time,
                (SELECT COUNT(*) FROM chat_history ch3 
                 WHERE ch3.user_id = ch.user_id AND ch3.role = 'user') as unread_count
            FROM chat_history ch
            LEFT JOIN user_profiles up ON ch.user_id = up.user_id
            WHERE 1=1
        """
        params = []
        
        if search_query:
            query += " AND (up.username LIKE ? OR up.first_name LIKE ? OR ch.content LIKE ?)"
            search_pattern = f"%{search_query}%"
            params.extend([search_pattern, search_pattern, search_pattern])
        
        if funnel_stage:
            query += " AND up.funnel_stage = ?"
            params.append(funnel_stage)
        
        query += " ORDER BY last_message_time DESC LIMIT ? OFFSET ?"
        params.extend([limit, offset])
        
        cursor = await db._connection.execute(query, params)
        rows = await cursor.fetchall()
        
        chats = []
        for row in rows:
            chats.append({
                "userId": row['user_id'],
                "username": row['username'],
                "firstName": row['first_name'],
                "lastName": row['last_name'],
                "funnelStage": row['funnel_stage'] or 'new',
                "interestLevel": row['interest_level'] or 1,
                "lastInteraction": row['last_interaction'],
                "lastMessage": row['last_message'],
                "lastMessageTime": row['last_message_time'],
                "unreadCount": row['unread_count'] or 0,
            })
        
        # 獲取總數
        count_query = """
            SELECT COUNT(DISTINCT ch.user_id) as total
            FROM chat_history ch
            LEFT JOIN user_profiles up ON ch.user_id = up.user_id
            WHERE 1=1
        """
        count_params = []
        
        if search_query:
            count_query += " AND (up.username LIKE ? OR up.first_name LIKE ? OR ch.content LIKE ?)"
            search_pattern = f"%{search_query}%"
            count_params.extend([search_pattern, search_pattern, search_pattern])
        
        if funnel_stage:
            count_query += " AND up.funnel_stage = ?"
            count_params.append(funnel_stage)
        
        count_cursor = await db._connection.execute(count_query, count_params)
        count_row = await count_cursor.fetchone()
        total = count_row['total'] if count_row else 0
        
        self.send_event("chat-list", {
            "success": True,
            "chats": chats,
            "total": total,
            "limit": limit,
            "offset": offset
        })
    except Exception as e:
        self.send_event("chat-list", {
            "success": False,
            "error": str(e)
        })


async def handle_send_ai_response(self, payload: Dict[str, Any]):
    """發送 AI 生成的回復（用於半自動模式）"""
    try:
        user_id = payload.get('userId', '')
        message = payload.get('message', '')
        account_phone = payload.get('accountPhone')
        source_group = payload.get('sourceGroup')
        username = payload.get('username', '')
        
        if not account_phone:
            # 自動選擇發送帳號
            accounts = await db.get_all_accounts()
            sender_accounts = [a for a in accounts if a.get('role') == 'Sender' and a.get('status') == 'Online']
            if sender_accounts:
                import random
                account_phone = random.choice(sender_accounts).get('phone')
            else:
                raise ValueError("沒有可用的發送帳號")
        
        # 檢查用戶是否已互動（決定是否計入限額）
        has_interacted = await self._user_has_interacted(user_id)
        
        # 檢查帳號限額（未互動用戶）
        if not has_interacted:
            account = await db.get_account_by_phone(account_phone)
            if account:
                if account.get('dailySendCount', 0) >= account.get('dailySendLimit', 50):
                    raise ValueError(f"帳號 {account_phone} 已達每日發送限額")
        
        # 發送消息
        result = await self.telegram_manager.send_message(
            phone=account_phone,
            user_id=user_id,
            text=message,
            source_group=source_group
        )
        
        if result.get('success'):
            # 保存 AI 回復到聊天歷史
            await db.add_chat_message(
                user_id=user_id,
                role='assistant',
                content=message,
                account_phone=account_phone,
                source_group=source_group
            )
            
            # 更新每日計數（僅未互動用戶）
            if not has_interacted:
                account = await db.get_account_by_phone(account_phone)
                if account:
                    await db.update_account(account.get('id'), {
                        'dailySendCount': account.get('dailySendCount', 0) + 1
                    })
            
            # 記錄互動
            await db._connection.execute("""
                INSERT INTO user_interactions 
                (user_id, interaction_type, direction, content, account_phone, platform)
                VALUES (?, 'message', 'outbound', ?, ?, 'telegram')
            """, (user_id, message, account_phone))
            await db._connection.commit()
            
            self.send_event("ai-response-sent", {
                "success": True,
                "userId": user_id,
                "message": message,
                "accountPhone": account_phone
            })
        else:
            raise Exception(result.get('error', '發送失敗'))
            
    except Exception as e:
        self.send_event("ai-response-sent", {
            "success": False,
            "error": str(e)
        })


async def handle_get_smart_replies(self, payload: Dict[str, Any]):
    """獲取智能回覆建議"""
    try:
        from smart_reply import generate_smart_replies
        
        message = payload.get("message", "")
        context = payload.get("context", [])
        intent_type = payload.get("intentType", "general")
        intent_score = payload.get("intentScore", 50)
        max_suggestions = payload.get("maxSuggestions", 3)
        
        result = await generate_smart_replies(
            message=message,
            context=context,
            intent_type=intent_type,
            intent_score=intent_score,
            max_suggestions=max_suggestions
        )
        
        self.send_event("smart-replies-result", {
            "success": True,
            **result
        })
    except Exception as e:
        print(f"[Backend] Error generating smart replies: {e}", file=sys.stderr)
        self.send_event("smart-replies-result", {
            "success": False,
            "error": str(e)
        })

