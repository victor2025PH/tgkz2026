"""
Extracted handler implementations: messaging
Auto-generated by refactor_main.py
"""
import json
import sys
import time
import asyncio
import traceback
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from service_context import get_service_context
from database import db
from config import config

from error_handler import handle_error, AppError, ErrorType
from message_queue import MessagePriority
from service_locator import get_SpintaxGenerator

# All handlers receive (self, payload) where self is BackendService instance.
# They are called via: await handler_impl(self, payload)
# Inside, use self.db, self.send_event(), self.telegram_manager, etc.
# This is a transitional pattern - later, replace self.xxx with ctx.xxx


async def handle_get_queue_status(self, payload: Dict[str, Any]):
    """Handle get-queue-status command"""
    try:
        phone = payload.get('phone')  # Optional, if None returns all
        status = await self.message_queue.get_queue_status(phone)
        self.send_event("queue-status", status)
    
    except Exception as e:
        self.send_log(f"Error getting queue status: {str(e)}", "error")


async def handle_clear_queue(self, payload: Dict[str, Any]):
    """Handle clear-queue command"""
    try:
        phone = payload.get('phone')
        status_str = payload.get('status')  # Optional: 'pending', 'failed', etc.
        
        if not phone:
            self.send_log("Phone number required to clear queue", "error")
            return
        
        # Convert status string to enum if provided
        status = None
        if status_str:
            from message_queue import MessageStatus
            status_map = {
                'pending': MessageStatus.PENDING,
                'processing': MessageStatus.PROCESSING,
                'failed': MessageStatus.FAILED,
                'retrying': MessageStatus.RETRYING
            }
            status = status_map.get(status_str.lower())
        
        await self.message_queue.clear_queue(phone, status)
        await db.add_log(f"Queue cleared for {phone}", "info")
        self.send_log(f"Queue cleared for {phone}", "success")
        
        # Send updated status
        status = await self.message_queue.get_queue_status(phone)
        self.send_event("queue-status", status)
    
    except Exception as e:
        self.send_log(f"Error clearing queue: {str(e)}", "error")


async def handle_pause_queue(self, payload: Dict[str, Any]):
    """Handle pause-queue command"""
    try:
        phone = payload.get('phone')
        if not phone:
            self.send_log("Phone number required to pause queue", "error")
            return
        
        await self.message_queue.pause_queue(phone)
        self.send_log(f"Queue paused for {phone}", "info")
        
        # Send updated queue status
        queue_status = await self.message_queue.get_queue_status(phone)
        queue_status['paused'] = True
        self.send_event("queue-status", queue_status)
    
    except Exception as e:
        self.send_log(f"Error pausing queue: {str(e)}", "error")


async def handle_resume_queue(self, payload: Dict[str, Any]):
    """Handle resume-queue command"""
    try:
        phone = payload.get('phone')
        if not phone:
            self.send_log("Phone number required to resume queue", "error")
            return
        
        await self.message_queue.resume_queue(phone)
        self.send_log(f"Queue resumed for {phone}", "success")
        
        # Send updated queue status
        queue_status = await self.message_queue.get_queue_status(phone)
        queue_status['paused'] = False
        self.send_event("queue-status", queue_status)
    
    except Exception as e:
        self.send_log(f"Error resuming queue: {str(e)}", "error")


async def handle_delete_queue_message(self, payload: Dict[str, Any]):
    """Handle delete-queue-message command"""
    try:
        phone = payload.get('phone')
        message_id = payload.get('messageId')
        
        if not phone or not message_id:
            self.send_log("Phone number and message ID required", "error")
            return
        
        success = await self.message_queue.delete_message(phone, message_id)
        if success:
            self.send_log(f"Message {message_id} deleted from queue", "success")
            # Send updated queue status
            queue_status = await self.message_queue.get_queue_status(phone)
            self.send_event("queue-status", queue_status)
        else:
            self.send_log(f"Message {message_id} not found in queue", "warning")
    
    except Exception as e:
        self.send_log(f"Error deleting queue message: {str(e)}", "error")


async def handle_update_queue_message_priority(self, payload: Dict[str, Any]):
    """Handle update-queue-message-priority command"""
    try:
        phone = payload.get('phone')
        message_id = payload.get('messageId')
        priority_str = payload.get('priority')  # 'HIGH', 'NORMAL', 'LOW'
        
        if not phone or not message_id or not priority_str:
            self.send_log("Phone number, message ID, and priority required", "error")
            return
        
        from message_queue import MessagePriority
        priority_map = {
            'HIGH': MessagePriority.HIGH,
            'NORMAL': MessagePriority.NORMAL,
            'LOW': MessagePriority.LOW
        }
        priority = priority_map.get(priority_str.upper())
        
        if not priority:
            self.send_log(f"Invalid priority: {priority_str}", "error")
            return
        
        success = await self.message_queue.update_message_priority(phone, message_id, priority)
        if success:
            self.send_log(f"Message {message_id} priority updated to {priority_str}", "success")
            # Send updated queue status
            queue_status = await self.message_queue.get_queue_status(phone)
            self.send_event("queue-status", queue_status)
        else:
            self.send_log(f"Message {message_id} not found in queue", "warning")
    
    except Exception as e:
        self.send_log(f"Error updating message priority: {str(e)}", "error")


async def handle_get_queue_messages(self, payload: Dict[str, Any]):
    """Handle get-queue-messages command"""
    try:
        phone = payload.get('phone')  # Optional
        status_str = payload.get('status')  # Optional
        limit = payload.get('limit', 100)
        
        status = None
        if status_str:
            from message_queue import MessageStatus
            status_map = {
                'pending': MessageStatus.PENDING,
                'processing': MessageStatus.PROCESSING,
                'failed': MessageStatus.FAILED,
                'retrying': MessageStatus.RETRYING,
                'completed': MessageStatus.COMPLETED
            }
            status = status_map.get(status_str.lower())
        
        messages = await self.message_queue.get_queue_messages(phone, status, limit)
        self.send_event("queue-messages", {
            "phone": phone,
            "messages": messages,
            "count": len(messages)
        })
    
    except Exception as e:
        self.send_log(f"Error getting queue messages: {str(e)}", "error")


async def handle_send_message(self, payload: Dict[str, Any]):
    """Handle send-message command with message queue"""
    try:
        lead_id = payload.get('leadId')
        account_phone = payload.get('accountPhone')
        user_id = payload.get('userId')
        source_group = payload.get('sourceGroup')  # æºç¾¤çµ„ï¼ˆç”¨æ–¼ç²å–ç”¨æˆ¶ä¿¡æ¯ï¼‰
        message_text = payload.get('message')
        attachment = payload.get('attachment')
        priority = payload.get('priority', 'normal')  # high, normal, low
        scheduled_at = payload.get('scheduledAt')  # Optional ISO datetime string
        owner_user_id = payload.get('ownerUserId')  # ç”¨æ–¼é…é¡æª¢æŸ¥
        
        # é…é¡æª¢æŸ¥
        quota_check = await self.check_quota('daily_messages', 1, owner_user_id)
        if not quota_check.get('allowed', True):
            self.send_quota_exceeded_error('message-sent', 'daily_messages', quota_check.get('result', {}))
            return
        
        # å¿…é ˆæœ‰å¸³è™Ÿå’Œç”¨æˆ¶IDï¼Œæ¶ˆæ¯å…§å®¹æˆ–é™„ä»¶è‡³å°‘ä¸€å€‹
        if not account_phone or not user_id:
            self.send_log("Missing required parameters for sending message (accountPhone or userId)", "error")
            return
        
        if not message_text and not attachment:
            self.send_log("Missing message text or attachment", "error")
            return
        
        # å¦‚æœæ²’æœ‰æ–‡å­—æ¶ˆæ¯ï¼Œè¨­ç½®ç‚ºç©ºå­—ç¬¦ä¸²
        if not message_text:
            message_text = ""
        
        # å˜—è©¦ç²å–ç¾¤çµ„ URLï¼ˆç”¨æ–¼åŠ å…¥ç¾¤çµ„ï¼‰
        source_group_url = source_group
        if source_group:
            try:
                source_group_str = str(source_group)
                
                # å¦‚æœå·²ç¶“æ˜¯ URLï¼Œç›´æ¥ä½¿ç”¨
                if 't.me/' in source_group_str or source_group_str.startswith('@'):
                    source_group_url = source_group_str
                    print(f"[Backend] source_group is already a URL: {source_group_url}", file=sys.stderr)
                else:
                    # source_group æ˜¯ Telegram chat_idï¼Œéœ€è¦å¾ monitoredGroups æŸ¥æ‰¾å°æ‡‰çš„ URL
                    # monitoredGroups å­˜å„²çš„æ˜¯ URLï¼Œè€Œä¸æ˜¯ chat_id
                    # æˆ‘å€‘éœ€è¦å¾ lead æ•¸æ“šä¸­ç²å– source_group_url
                    if lead_id:
                        lead = await db.get_lead(lead_id)
                        if lead:
                            # æª¢æŸ¥ lead ä¸­æ˜¯å¦æœ‰å­˜å„²ç¾¤çµ„ URL
                            lead_source = lead.get('source_group') or lead.get('sourceGroup')
                            if lead_source and ('t.me/' in str(lead_source) or str(lead_source).startswith('@')):
                                source_group_url = str(lead_source)
                                print(f"[Backend] Found group URL from lead: {source_group_url}", file=sys.stderr)
                            else:
                                # å¦‚æœ lead ä¸­æ²’æœ‰ URLï¼Œå˜—è©¦å¾ monitoredGroups æŸ¥æ‰¾
                                # ç”±æ–¼ monitoredGroups å­˜å„²çš„æ˜¯ URLï¼Œè€Œ source_group æ˜¯ chat_id
                                # æˆ‘å€‘ç„¡æ³•ç›´æ¥åŒ¹é…ï¼Œåªèƒ½ä½¿ç”¨ç¬¬ä¸€å€‹åŒ¹é…çš„ URL
                                monitored_groups = await db.get_all_monitored_groups()
                                if monitored_groups:
                                    # ä½¿ç”¨ç¬¬ä¸€å€‹å¯ç”¨çš„ç¾¤çµ„ URL ä½œç‚ºå‚™é¸
                                    source_group_url = monitored_groups[0].get('url')
                                    print(f"[Backend] Using first monitored group URL as fallback: {source_group_url}", file=sys.stderr)
                    
                    if source_group_url == source_group:
                        print(f"[Backend] Could not find URL for chat_id {source_group}, using as-is", file=sys.stderr)
            except Exception as e:
                print(f"[Backend] Error looking up group URL: {e}", file=sys.stderr)
        
        # ç²å–ç”¨æˆ¶åä½œç‚ºå‚™é¸ï¼ˆå¦‚æœé€šé userId ç„¡æ³•ç™¼é€ï¼‰
        # å„ªå…ˆä½¿ç”¨ payload ä¸­ç›´æ¥å‚³éçš„ username
        target_username = payload.get('username')
        if target_username:
            print(f"[Backend] Got target username from payload: @{target_username}", file=sys.stderr)
        elif lead_id:
            # å˜—è©¦å¾æ•¸æ“šåº«ä¸­æŸ¥è©¢ï¼ˆä½¿ç”¨ user_id è€Œé lead_idï¼‰
            try:
                lead = await db.get_lead_by_user_id(str(user_id))
                if lead:
                    target_username = lead.get('username')
                    if target_username:
                        print(f"[Backend] Got target username from database: @{target_username}", file=sys.stderr)
            except Exception as e:
                print(f"[Backend] Error getting username from database: {e}", file=sys.stderr)
        
        # Convert priority
        if priority == 'high':
            msg_priority = MessagePriority.HIGH
        elif priority == 'low':
            msg_priority = MessagePriority.LOW
        else:
            msg_priority = MessagePriority.NORMAL
        
        # Parse scheduled time if provided
        scheduled_datetime = None
        if scheduled_at:
            try:
                scheduled_datetime = datetime.fromisoformat(scheduled_at.replace('Z', '+00:00'))
            except:
                pass
        
        # Add message to queue
        message_id = await self.message_queue.add_message(
            phone=account_phone,
            user_id=user_id,
            text=message_text,
            attachment=attachment,
            source_group=source_group_url,  # ä½¿ç”¨ URL è€Œé ID
            target_username=target_username,  # ç”¨æˆ¶åä½œç‚ºå‚™é¸
            priority=msg_priority,
            scheduled_at=scheduled_datetime,
            callback=self._on_message_sent_callback(lead_id)
        )
        
        await db.add_log(f"Message queued for lead {lead_id} (queue ID: {message_id})", "info")
        self.send_log(f"Message queued for lead {lead_id}", "success")
        
        # Send queued event
        self.send_event("message-queued", {
            "messageId": message_id,
            "leadId": lead_id,
            "accountPhone": account_phone,
            "userId": user_id
        })
    
    except Exception as e:
        self.send_log(f"Error queueing message: {str(e)}", "error")


async def handle_send_group_message(self, payload: Dict[str, Any]):
    """Handle send-group-message command - Send message to a group/chat"""
    import sys
    try:
        resource_id = payload.get('resourceId')
        telegram_id = payload.get('telegramId')
        content = payload.get('content')
        account_phone = payload.get('accountPhone')
        
        print(f"[Backend] send-group-message: resourceId={resource_id}, telegramId={telegram_id}, phone={account_phone}", file=sys.stderr)
        
        if not content:
            self.send_log("æ¶ˆæ¯å…§å®¹ä¸èƒ½ç‚ºç©º", "error")
            self.send_event("group-message-sent", {
                "success": False,
                "resourceId": resource_id,
                "error": "æ¶ˆæ¯å…§å®¹ä¸èƒ½ç‚ºç©º"
            })
            return
        
        if not account_phone:
            self.send_log("è«‹é¸æ“‡ç™¼é€å¸³è™Ÿ", "error")
            self.send_event("group-message-sent", {
                "success": False,
                "resourceId": resource_id,
                "error": "è«‹é¸æ“‡ç™¼é€å¸³è™Ÿ"
            })
            return
        
        # ç²å–ç¾¤çµ„ä¿¡æ¯
        chat_id = telegram_id
        if not chat_id and resource_id:
            # ğŸ”§ P2 ä¿®å¾©: å„ªå…ˆæª¢æŸ¥ resource_id æ˜¯å¦ç‚º Telegram chat ID
            resource_id_str = str(resource_id)
            
            # Telegram chat ID ç‰¹å¾µï¼šç´”æ•¸å­—æˆ–ä»¥è² è™Ÿé–‹é ­çš„æ•¸å­—ï¼ˆç¾¤çµ„IDé€šå¸¸æ˜¯è² æ•¸ï¼‰
            if resource_id_str.lstrip('-').isdigit():
                # ç›´æ¥ä½¿ç”¨ç‚º chat_id
                chat_id = int(resource_id_str)
                print(f"[Backend] ä½¿ç”¨ resourceId ä½œç‚º chat_id: {chat_id}", file=sys.stderr)
            else:
                # å˜—è©¦å¾æ•¸æ“šåº«ç²å–
                try:
                    from resource_discovery import ResourceDiscoverySystem
                    resource_service = ResourceDiscoverySystem()
                    resource = await resource_service.get_resource_by_telegram_id(resource_id_str)
                    
                    if resource:
                        chat_id = resource.get('telegram_id') or resource.get('username')
                except Exception as res_err:
                    print(f"[Backend] ç²å–è³‡æºå¤±æ•—: {res_err}", file=sys.stderr)
        
        if not chat_id:
            self.send_log("ç„¡æ³•ç²å–ç¾¤çµ„ ID", "error")
            self.send_event("group-message-sent", {
                "success": False,
                "resourceId": resource_id,
                "error": "ç„¡æ³•ç²å–ç¾¤çµ„ ID"
            })
            return
        
        # ç²å–å®¢æˆ¶ç«¯
        if account_phone not in self.telegram_manager.clients:
            self.send_log(f"å¸³è™Ÿ {account_phone} æœªé€£æ¥", "error")
            self.send_event("group-message-sent", {
                "success": False,
                "resourceId": resource_id,
                "error": f"å¸³è™Ÿ {account_phone} æœªé€£æ¥"
            })
            return
        
        client = self.telegram_manager.clients[account_phone]
        
        if not client.is_connected:
            await client.connect()
        
        self.send_log(f"ğŸ“¨ æ­£åœ¨ç™¼é€æ¶ˆæ¯åˆ°ç¾¤çµ„...", "info")
        
        # ç™¼é€æ¶ˆæ¯
        try:
            # è§£æ chat_id
            target_chat = chat_id
            if isinstance(chat_id, str) and chat_id.lstrip('-').isdigit():
                target_chat = int(chat_id)
            
            message = await client.send_message(target_chat, content)
            
            self.send_log(f"âœ… æ¶ˆæ¯å·²ç™¼é€åˆ°ç¾¤çµ„", "success")
            self.send_event("group-message-sent", {
                "success": True,
                "resourceId": resource_id,
                "messageId": message.id
            })
            
        except Exception as send_error:
            error_msg = str(send_error)
            print(f"[Backend] Error sending message: {send_error}", file=sys.stderr)
            
            # æª¢æŸ¥æ˜¯å¦æ˜¯æ¬Šé™å•é¡Œ
            if "CHAT_WRITE_FORBIDDEN" in error_msg:
                error_msg = "æ²’æœ‰ç™¼é€æ¶ˆæ¯çš„æ¬Šé™ï¼ˆå¯èƒ½æ˜¯é »é“æˆ–ç¦è¨€ç¾¤çµ„ï¼‰"
            elif "CHAT_RESTRICTED" in error_msg:
                error_msg = "ç¾¤çµ„å·²è¢«é™åˆ¶"
            elif "USER_BANNED" in error_msg:
                error_msg = "å¸³è™Ÿå·²è¢«è©²ç¾¤çµ„å°ç¦"
            elif "SLOWMODE_WAIT" in error_msg:
                error_msg = "æ…¢é€Ÿæ¨¡å¼é™åˆ¶ï¼Œè«‹ç¨å¾Œå†è©¦"
            
            self.send_log(f"âŒ ç™¼é€å¤±æ•—: {error_msg}", "error")
            self.send_event("group-message-sent", {
                "success": False,
                "resourceId": resource_id,
                "error": error_msg
            })
    
    except Exception as e:
        import traceback
        traceback.print_exc(file=sys.stderr)
        self.send_log(f"âŒ ç™¼é€ç¾¤çµ„æ¶ˆæ¯å¤±æ•—: {str(e)}", "error")
        self.send_event("group-message-sent", {
            "success": False,
            "resourceId": payload.get('resourceId'),
            "error": str(e)
        })


async def handle_get_queue_length_history(self, payload: Dict[str, Any]):
    """Handle get-queue-length-history command"""
    try:
        days = payload.get('days', 7)
        
        history = await db.get_queue_length_history(days)
        self.send_event("queue-length-history", {"history": history, "days": days})
    except Exception as e:
        handle_error(e, {"command": "get-queue-length-history", "payload": payload})
        self.send_log(f"Error getting queue length history: {str(e)}", "error")


async def handle_validate_spintax(self, payload: Dict[str, Any]):
    """é©—è­‰ Spintax èªæ³•"""
    try:
        content = payload.get('content', '')
        SpintaxGenerator = get_SpintaxGenerator()
        result = SpintaxGenerator.preview_variants(content, 5)
        result['success'] = result.get('valid', False)
        
        self.send_event("spintax-validated", result)
        
    except Exception as e:
        self.send_event("spintax-validated", {"success": False, "error": str(e)})


async def handle_predict_send_time(self, payload: Dict[str, Any]):
    """é æ¸¬æœ€ä½³ç™¼é€æ™‚é–“"""
    try:
        from send_time_predictor import predict_best_send_time
        
        user_id = payload.get("userId")
        urgency = payload.get("urgency", "normal")
        
        result = await predict_best_send_time(
            user_id=user_id,
            urgency=urgency
        )
        
        self.send_event("send-time-prediction", {
            "success": True,
            **result
        })
    except Exception as e:
        print(f"[Backend] Error predicting send time: {e}", file=sys.stderr)
        self.send_event("send-time-prediction", {
            "success": False,
            "error": str(e)
        })


async def handle_batch_send_start(self, payload: Dict[str, Any]):
    """é–‹å§‹æ‰¹é‡ç™¼é€ - ğŸ”§ ä¿®å¾©ï¼šä½œç‚ºå¾Œå°ä»»å‹™é‹è¡Œï¼Œç«‹å³è¿”å› HTTP éŸ¿æ‡‰"""
    import sys
    import asyncio
    
    targets = payload.get('targets', [])
    if not targets:
        self.send_event("batch-send:complete", {
            "success": 0, "failed": 0,
            "error": "æ²’æœ‰é¸æ“‡ç™¼é€ç›®æ¨™"
        })
        return {'success': False, 'error': 'æ²’æœ‰é¸æ“‡ç™¼é€ç›®æ¨™'}
    
    print(f"[BatchSend] æ”¶åˆ°æ‰¹é‡ç™¼é€è«‹æ±‚: {len(targets)} å€‹ç›®æ¨™", file=sys.stderr)
    
    # ğŸ”§ æ ¸å¿ƒä¿®å¾©ï¼šå•Ÿå‹•å¾Œå°ä»»å‹™ï¼Œç«‹å³è¿”å› HTTP éŸ¿æ‡‰
    # é€™è§£æ±ºäº† HTTP è¶…æ™‚å°è‡´å‰ç«¯å¡ä½çš„å•é¡Œ
    self._batch_send_active = True
    self._batch_send_cancelled = False
    
    asyncio.ensure_future(_batch_send_worker(self, payload))
    
    return {'success': True, 'message': f'æ‰¹é‡ç™¼é€å·²å•Ÿå‹•: {len(targets)} å€‹ç›®æ¨™'}


async def _batch_send_worker(self, payload: Dict[str, Any]):
    """ğŸ”§ å¾Œå°æ‰¹é‡ç™¼é€ worker - ç¨ç«‹æ–¼ HTTP è«‹æ±‚é‹è¡Œ"""
    import sys
    import random
    
    targets = payload.get('targets', [])
    message_template = payload.get('message', '')
    messages = payload.get('messages', [])
    send_strategy = payload.get('sendStrategy', 'random')
    attachments = payload.get('attachments', [])
    cfg = payload.get('config', {})
    
    min_interval = cfg.get('minInterval', 30)
    max_interval = cfg.get('maxInterval', 60)
    account_rotation = cfg.get('accountRotation', True)
    
    is_multi_template = len(messages) > 1
    
    try:
        if is_multi_template:
            print(f"[BatchSend] å¤šæ¨¡æ¿æ¨¡å¼: {len(messages)} å€‹æ¨¡æ¿, ç­–ç•¥: {send_strategy}", file=sys.stderr)
            self.send_log(f"ğŸ“¨ é–‹å§‹æ‰¹é‡ç™¼é€: {len(targets)} å€‹ç›®æ¨™, {len(messages)} å€‹æ¨¡æ¿ ({send_strategy})", "info")
        else:
            print(f"[BatchSend] é–‹å§‹æ‰¹é‡ç™¼é€: {len(targets)} å€‹ç›®æ¨™", file=sys.stderr)
            self.send_log(f"ğŸ“¨ é–‹å§‹æ‰¹é‡ç™¼é€: {len(targets)} å€‹ç›®æ¨™", "info")
        
        # ç²å–å¯ç”¨å¸³è™Ÿï¼ˆæª¢æŸ¥ Online ç‹€æ…‹ + å·²é€£æ¥çš„å®¢æˆ¶ç«¯ï¼‰
        accounts = await db.get_all_accounts()
        available_accounts = [a for a in accounts if a.get('status') in ('Online', 'active')]
        
        if not available_accounts:
            connected_phones = list(self.telegram_manager.clients.keys()) if hasattr(self.telegram_manager, 'clients') else []
            if connected_phones:
                available_accounts = [a for a in accounts if a.get('phone') in connected_phones]
                print(f"[BatchSend] é€šé TelegramManager æ‰¾åˆ° {len(available_accounts)} å€‹å·²é€£æ¥å¸³è™Ÿ", file=sys.stderr)
        
        print(f"[BatchSend] å¯ç”¨å¸³è™Ÿ: {len(available_accounts)} å€‹", file=sys.stderr)
        for acc in available_accounts:
            print(f"[BatchSend]   - {acc.get('phone')} ({acc.get('status')})", file=sys.stderr)
        
        if not available_accounts:
            error_msg = "æ²’æœ‰å¯ç”¨çš„ç™¼é€å¸³è™Ÿï¼Œè«‹å…ˆç™»å…¥å¸³è™Ÿ"
            self.send_log(f"âš ï¸ {error_msg}", "warning")
            self.send_event("batch-send:complete", {
                "success": 0,
                "failed": len(targets),
                "error": error_msg,
                "failureReasons": {"no_account": len(targets)}
            })
            self._batch_send_active = False
            return
        
        success_count = 0
        failed_count = 0
        failure_reasons = {}
        failed_targets = []
        
        for idx, target in enumerate(targets):
            if self._batch_send_cancelled:
                print(f"[BatchSend] ç”¨æˆ¶å–æ¶ˆ", file=sys.stderr)
                remaining = len(targets) - idx
                failure_reasons['cancelled'] = failure_reasons.get('cancelled', 0) + remaining
                break
            
            # æå–ç›®æ¨™ä¿¡æ¯
            user_id = target.get('telegramId')
            username = target.get('username', '')
            first_name = target.get('firstName', target.get('first_name', ''))
            last_name = target.get('lastName', target.get('last_name', ''))
            display_name = target.get('displayName', target.get('name', first_name or username or 'æœ‹å‹'))
            full_name = f"{first_name} {last_name}".strip() or display_name
            group_name = target.get('groupName', target.get('sourceGroup', target.get('source', '')))
            keyword = target.get('keyword', target.get('triggeredKeyword', target.get('matchedKeyword', '')))
            source = target.get('source', target.get('sourceType', ''))
            
            try:
                # é¸æ“‡å¸³è™Ÿ
                if account_rotation:
                    account = available_accounts[idx % len(available_accounts)]
                else:
                    account = available_accounts[0]
                
                phone = account.get('phone')
                
                # é©—è­‰ç›®æ¨™ç”¨æˆ¶ ID
                if not user_id:
                    raise ValueError(f"ç›®æ¨™ç”¨æˆ¶ ID ç‚ºç©º (username={username})")
                
                # æ™‚é–“ç›¸é—œè®Šé‡
                now = datetime.now()
                hour = now.hour
                if 5 <= hour < 12:
                    greeting = 'æ—©ä¸Šå¥½'
                elif 12 <= hour < 14:
                    greeting = 'ä¸­åˆå¥½'
                elif 14 <= hour < 18:
                    greeting = 'ä¸‹åˆå¥½'
                elif 18 <= hour < 22:
                    greeting = 'æ™šä¸Šå¥½'
                else:
                    greeting = 'å¤œæ·±äº†'
                
                days = ['æ˜ŸæœŸä¸€', 'æ˜ŸæœŸäºŒ', 'æ˜ŸæœŸä¸‰', 'æ˜ŸæœŸå››', 'æ˜ŸæœŸäº”', 'æ˜ŸæœŸå…­', 'æ˜ŸæœŸæ—¥']
                date_str = f"{now.month}æœˆ{now.day}æ—¥"
                time_str = now.strftime('%H:%M')
                day_str = days[now.weekday()]
                
                # é¸æ“‡æ¶ˆæ¯æ¨¡æ¿
                ab_test_id = cfg.get('abTestId')
                ab_variant_idx = None
                
                if ab_test_id:
                    try:
                        from core.template_ab_test import get_ab_test_manager
                        ab_mgr = get_ab_test_manager()
                        variant = ab_mgr.select_template(ab_test_id)
                        if variant and messages:
                            ab_variant_idx = variant.get('variant_index', 0)
                            tmpl_idx = min(ab_variant_idx, len(messages) - 1)
                            selected_template = messages[tmpl_idx]
                        else:
                            selected_template = messages[0] if messages else message_template
                    except Exception as ab_err:
                        print(f"[BatchSend] A/B æ¸¬è©¦å›é€€: {ab_err}", file=sys.stderr)
                        selected_template = messages[0] if messages else message_template
                elif is_multi_template and messages:
                    if send_strategy == 'random':
                        selected_template = random.choice(messages)
                    elif send_strategy == 'rotate':
                        selected_template = messages[idx % len(messages)]
                    else:
                        selected_template = messages[idx % len(messages)]
                else:
                    selected_template = message_template
                
                # æ›¿æ›è®Šé‡
                message = selected_template
                message = message.replace('{firstName}', first_name)
                message = message.replace('{first_name}', first_name)
                message = message.replace('{lastName}', last_name)
                message = message.replace('{last_name}', last_name)
                message = message.replace('{username}', username)
                message = message.replace('{displayName}', display_name)
                message = message.replace('{name}', display_name)
                message = message.replace('{fullName}', full_name)
                message = message.replace('{full_name}', full_name)
                message = message.replace('{groupName}', group_name)
                message = message.replace('{group_name}', group_name)
                message = message.replace('{keyword}', keyword)
                message = message.replace('{source}', source)
                message = message.replace('{greeting}', greeting)
                message = message.replace('{date}', date_str)
                message = message.replace('{time}', time_str)
                message = message.replace('{day}', day_str)
                
                print(f"[BatchSend] ç™¼é€ {idx + 1}/{len(targets)}: {phone} -> {user_id} ({username})", file=sys.stderr)
                
                # ğŸ”§ æ ¸å¿ƒä¿®å¾©ï¼šç›´æ¥èª¿ç”¨ telegram_manager.send_message
                # ä¸å†é€šé message_queueï¼ˆéšŠåˆ—æ˜¯ç•°æ­¥çš„ï¼Œç„¡æ³•å¾—åˆ°å³æ™‚åé¥‹ï¼‰
                send_result = await self.telegram_manager.send_message(
                    phone=phone,
                    user_id=str(user_id),
                    text=message,
                    attachment=attachments[0] if attachments else None,
                    source_group=group_name or None,
                    target_username=username or None
                )
                
                if send_result.get('success'):
                    success_count += 1
                    print(f"[BatchSend] âœ“ ç™¼é€æˆåŠŸ: {user_id}", file=sys.stderr)
                else:
                    raise Exception(send_result.get('error', 'ç™¼é€å¤±æ•—'))
                
                # A/B æ¸¬è©¦è¨˜éŒ„
                if ab_test_id and ab_variant_idx is not None:
                    try:
                        from core.template_ab_test import get_ab_test_manager
                        ab_mgr = get_ab_test_manager()
                        test_obj = ab_mgr.get_test(ab_test_id)
                        if test_obj:
                            test_obj.record_result(ab_variant_idx, success=True)
                    except Exception:
                        pass
                
            except Exception as e:
                error_str = str(e).lower()
                print(f"[BatchSend] âœ— ç™¼é€å¤±æ•— ({user_id}): {e}", file=sys.stderr)
                failed_count += 1
                
                if ab_test_id and ab_variant_idx is not None:
                    try:
                        from core.template_ab_test import get_ab_test_manager
                        ab_mgr = get_ab_test_manager()
                        test_obj = ab_mgr.get_test(ab_test_id)
                        if test_obj:
                            test_obj.record_result(ab_variant_idx, success=False)
                    except Exception:
                        pass
                
                # åˆ†é¡å¤±æ•—åŸå› 
                if 'privacy' in error_str or 'private' in error_str:
                    reason = 'privacy_restricted'
                elif 'flood' in error_str:
                    reason = 'flood_wait'
                elif 'peer' in error_str or 'not found' in error_str:
                    reason = 'user_not_found'
                elif 'blocked' in error_str:
                    reason = 'user_blocked'
                elif 'id' in error_str and 'ç‚ºç©º' in str(e):
                    reason = 'invalid_id'
                else:
                    reason = 'other'
                
                failure_reasons[reason] = failure_reasons.get(reason, 0) + 1
                failed_targets.append({
                    'target': target,
                    'reason': reason,
                    'error': str(e)
                })
            
            # ğŸ”§ ç«‹å³ç™¼é€é€²åº¦äº‹ä»¶
            self.send_event("batch-send:progress", {
                "sent": idx + 1,
                "success": success_count,
                "failed": failed_count,
                "total": len(targets),
                "currentTarget": display_name or username or str(user_id),
                "failureReasons": failure_reasons
            })
            
            # é–“éš”ï¼ˆåªåœ¨é‚„æœ‰ä¸‹ä¸€å€‹ç›®æ¨™æ™‚ï¼‰
            if idx < len(targets) - 1 and not self._batch_send_cancelled:
                interval = random.randint(min_interval, max_interval)
                print(f"[BatchSend] ç­‰å¾… {interval}s å†ç™¼é€ä¸‹ä¸€æ¢...", file=sys.stderr)
                await asyncio.sleep(interval)
        
        # å®Œæˆ
        self._batch_send_active = False
        
        reason_summary = []
        reason_labels = {
            'privacy_restricted': 'éš±ç§é™åˆ¶',
            'flood_wait': 'API é™åˆ¶',
            'user_not_found': 'ç”¨æˆ¶ä¸å­˜åœ¨',
            'user_blocked': 'è¢«å°é–',
            'invalid_id': 'ç„¡æ•ˆ ID',
            'cancelled': 'å·²å–æ¶ˆ',
            'other': 'å…¶ä»–éŒ¯èª¤'
        }
        for reason, count in failure_reasons.items():
            label = reason_labels.get(reason, reason)
            reason_summary.append(f"{label}: {count}")
        
        self.send_event("batch-send:complete", {
            "success": success_count,
            "failed": failed_count,
            "failureReasons": failure_reasons,
            "failureSummary": ", ".join(reason_summary) if reason_summary else None,
            "failedTargets": failed_targets[:10]
        })
        
        if failed_count > 0:
            self.send_log(f"âš ï¸ æ‰¹é‡ç™¼é€å®Œæˆ: æˆåŠŸ {success_count}, å¤±æ•— {failed_count} ({', '.join(reason_summary)})", "warning")
        else:
            self.send_log(f"âœ… æ‰¹é‡ç™¼é€å®Œæˆ: æˆåŠŸ {success_count}", "success")
        
    except Exception as e:
        print(f"[BatchSend] éŒ¯èª¤: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
        self._batch_send_active = False
        self.send_event("batch-send:complete", {
            "success": 0, "failed": len(targets),
            "error": str(e)
        })
        self.send_log(f"âŒ æ‰¹é‡ç™¼é€éŒ¯èª¤: {e}", "error")


async def handle_batch_send_cancel(self, payload: Dict[str, Any]):
    """å–æ¶ˆæ‰¹é‡ç™¼é€"""
    self._batch_send_cancelled = True
    self.send_log("â¹ï¸ æ‰¹é‡ç™¼é€å·²å–æ¶ˆ", "info")


# ====================================================================
# ğŸ”§ P7-3: ç¼ºå¤± handler è¡¥å……å®ç°
# ====================================================================

async def handle_send_greeting(self, payload: Dict[str, Any]):
    """å‘é€é—®å€™æ¶ˆæ¯ï¼ˆå§”æ‰˜åˆ° handle_send_messageï¼‰"""
    if not payload.get('text'):
        payload['text'] = payload.get('greeting', 'ä½ å¥½ï¼')
    return await handle_send_message(self, payload)


async def handle_add_to_queue(self, payload: Dict[str, Any]):
    """æ·»åŠ æ¶ˆæ¯åˆ°é˜Ÿåˆ—ï¼ˆå§”æ‰˜åˆ° handle_send_messageï¼‰"""
    return await handle_send_message(self, payload)
