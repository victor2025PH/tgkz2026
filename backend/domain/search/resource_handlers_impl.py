"""
Extracted handler implementations: resources
Auto-generated by refactor_main.py
"""
import json
import sys
import time
import asyncio
import traceback
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from service_context import get_service_context

from database import db
from service_locator import group_search_service, resource_discovery, get_DiscoveredResource
# All handlers receive (self, payload) where self is BackendService instance.
# They are called via: await handler_impl(self, payload)
# Inside, use self.db, self.send_event(), self.telegram_manager, etc.
# This is a transitional pattern - later, replace self.xxx with ctx.xxx


async def handle_get_resource_history(self, payload: Dict[str, Any]):
    """ç²å–è³‡æºçš„æ­·å²è¨˜éŒ„"""
    try:
        from search_history_service import get_search_history_service
        search_history = get_search_history_service()
        
        resource_id = payload.get('resourceId')
        username = payload.get('username')
        telegram_id = payload.get('telegramId')
        
        result = search_history.get_resource_history(
            resource_id=resource_id,
            username=username,
            telegram_id=telegram_id
        )
        
        if result:
            self.send_event("resource-history-result", {
                "success": True,
                **result
            })
        else:
            self.send_event("resource-history-result", {
                "success": False,
                "error": "è³‡æºä¸å­˜åœ¨"
            })
        
    except Exception as e:
        self.send_log(f"ç²å–è³‡æºæ­·å²å¤±æ•—: {str(e)}", "error")
        self.send_event("resource-history-result", {
            "success": False,
            "error": str(e)
        })


# ==================== Resource Discovery Handlers ====================

async def handle_init_resource_discovery(self):
    """åˆå§‹åŒ–è³‡æºç™¼ç¾ç³»çµ±"""
    try:
        self.send_log("ğŸš€ é–‹å§‹åˆå§‹åŒ–è³‡æºç™¼ç¾ç³»çµ±...", "info")
        
        # è¨­ç½®æœç´¢æœå‹™ï¼ˆä¸éœ€è¦é¡å¤–åˆå§‹åŒ–æ•¸æ“šåº«ï¼Œå…±ç”¨ä¸»æ•¸æ“šåº«ï¼‰
        group_search_service.set_clients(self.telegram_manager.clients)
        group_search_service.set_event_callback(self.send_event)
        resource_discovery.set_event_callback(self.send_event)
        resource_discovery._initialized = True  # æ¨™è¨˜ç‚ºå·²åˆå§‹åŒ–
        
        # çµ±è¨ˆå·²é€£æ¥çš„å¸³è™Ÿ
        connected_clients = {phone: client for phone, client in self.telegram_manager.clients.items() if client.is_connected}
        self.send_log(f"ğŸ“± æ‰¾åˆ° {len(connected_clients)} å€‹å·²é€£æ¥çš„å¸³è™Ÿ", "info")

        # è¼‰å…¥è‡ªå®šç¾©æœç´¢æ¸ é“
        await self._refresh_custom_bots()

        self.send_log("âœ… è³‡æºç™¼ç¾ç³»çµ±åˆå§‹åŒ–å®Œæˆ", "success")
        self.send_event("resource-discovery-initialized", {"success": True})
        
    except Exception as e:
        import traceback
        self.send_log(f"âŒ è³‡æºç™¼ç¾ç³»çµ±åˆå§‹åŒ–å¤±æ•—: {e}", "error")
        traceback.print_exc()
        self.send_event("resource-discovery-initialized", {
            "success": False,
            "error": str(e)
        })


async def handle_search_resources(self, payload: Dict[str, Any]):
    """æœç´¢ç¾¤çµ„/é »é“è³‡æº"""
    try:
        query = payload.get('query', '')
        phone = payload.get('phone')
        limit = payload.get('limit', 50)
        keywords = payload.get('keywords', [])
        search_type = payload.get('searchType', 'all')  # all, group, channel, supergroup
        min_members = payload.get('minMembers', 0)
        language = payload.get('language')
        # ğŸ†• Dæ–¹æ¡ˆï¼šæœç´¢æœƒè©± ID
        search_session_id = payload.get('searchSessionId', '')
        search_keyword = payload.get('searchKeyword', query)
        
        if not query:
            self.send_event("search-resources-complete", {
                "success": False,
                "error": "æœç´¢é—œéµè©ä¸èƒ½ç‚ºç©º"
            })
            return
        
        self.send_log(f"ğŸ” é–‹å§‹æœç´¢: '{query}'", "info")
        
        # æª¢æŸ¥æ˜¯å¦æœ‰å·²é€£æ¥çš„å®¢æˆ¶ç«¯
        connected_clients = {p: c for p, c in self.telegram_manager.clients.items() if c.is_connected}
        if not connected_clients:
            self.send_log("âš ï¸ æ²’æœ‰å·²é€£æ¥çš„å¸³è™Ÿï¼Œç„¡æ³•æœç´¢", "warning")
            self.send_event("search-resources-complete", {
                "success": False,
                "error": "æ²’æœ‰å·²é€£æ¥çš„å¸³è™Ÿï¼Œè«‹å…ˆç™»éŒ„å¸³è™Ÿ"
            })
            return
        
        self.send_log(f"ğŸ“± ä½¿ç”¨ {len(connected_clients)} å€‹å¸³è™Ÿé€²è¡Œæœç´¢", "info")
        
        # ç¢ºä¿å®¢æˆ¶ç«¯å·²è¨­ç½®
        group_search_service.set_clients(self.telegram_manager.clients)
        group_search_service.set_event_callback(self.send_event)
        
        # ç™¼é€æœç´¢é–‹å§‹äº‹ä»¶
        self.send_event("search-progress", {
            "query": query,
            "status": "searching",
            "message": f"æ­£åœ¨æœç´¢ '{query}'..."
        })
        
        # ğŸ†• Cæ–¹æ¡ˆï¼šåªæœç´¢ï¼Œä¸ä¿å­˜åˆ°æ•¸æ“šåº«
        # ç›´æ¥ä½¿ç”¨ search_groups è¿”å›çµæœï¼Œç”¨æˆ¶é»æ“Šæ”¶è—æ™‚æ‰ä¿å­˜
        try:
            search_results = await asyncio.wait_for(
                group_search_service.search_groups(
                    query=query,
                    phone=phone,
                    limit=limit,
                    search_type=search_type,
                    min_members=min_members,
                    language=language
                ),
                timeout=60.0  # 60ç§’è¶…æ™‚
            )
        except asyncio.TimeoutError:
            self.send_log("â±ï¸ æœç´¢è¶…æ™‚ï¼ˆ60ç§’ï¼‰", "warning")
            self.send_event("search-results-direct", {
                "success": False,
                "query": query,
                "error": "æœç´¢è¶…æ™‚ï¼Œè«‹ç¨å¾Œå†è©¦"
            })
            self.send_event("search-resources-complete", {
                "success": False,
                "error": "æœç´¢è¶…æ™‚ï¼Œè«‹ç¨å¾Œå†è©¦"
            })
            return
        
        self.send_log(f"ğŸ” æœç´¢å®Œæˆ: æ‰¾åˆ° {len(search_results)} å€‹çµæœ", "success")
        
        # è½‰æ›ç‚ºå‰ç«¯å¯ç”¨çš„æ ¼å¼
        results_for_frontend = []
        for result in search_results:
            # è¨ˆç®—ç›¸é—œåº¦è©•åˆ†
            relevance_score = resource_discovery.calculate_relevance_score(
                result.title, result.description, [query]
            )
            
            results_for_frontend.append({
                'id': None,  # æœªä¿å­˜åˆ°æ•¸æ“šåº«ï¼Œæ²’æœ‰ ID
                'telegram_id': result.telegram_id,
                'username': result.username,
                'title': result.title,
                'description': result.description,
                'member_count': result.member_count,
                'resource_type': result.chat_type,
                'overall_score': relevance_score,
                'relevance_score': relevance_score,
                'is_public': result.is_public,
                'status': 'discovered',
                'discovery_source': 'search',
                'discovery_keyword': query,
                'is_saved': False  # ğŸ†• æ¨™è¨˜ï¼šå°šæœªä¿å­˜åˆ°æ•¸æ“šåº«
            })
        
        # ç™¼é€ç›´æ¥çµæœçµ¦å‰ç«¯
        self.send_event("search-results-direct", {
            "success": True,
            "query": query,
            "results": results_for_frontend,
            "total": len(results_for_frontend)
        })
        
        # åŒæ™‚ç™¼é€èˆŠæ ¼å¼äº‹ä»¶ï¼ˆå…¼å®¹ï¼‰
        self.send_event("search-resources-complete", {
            "success": True,
            "query": query,
            "found": len(results_for_frontend),
            "new": 0,
            "updated": 0
        })
        
    except Exception as e:
        self.send_log(f"âŒ æœç´¢è³‡æºå¤±æ•—: {e}", "error")
        import traceback
        traceback.print_exc()
        self.send_event("search-results-direct", {
            "success": False,
            "query": query,
            "error": str(e)
        })
        self.send_event("search-resources-complete", {
            "success": False,
            "error": str(e)
        })


async def handle_clear_resources(self, payload: Dict[str, Any]):
    """ğŸ†• æ¸…ç†è³‡æºæ•¸æ“š"""
    try:
        clear_type = payload.get('type', 'all')  # all, search_history, old_data
        days_to_keep = payload.get('daysToKeep', 0)  # ä¿ç•™æœ€è¿‘ N å¤©çš„æ•¸æ“š
        
        self.send_log(f"ğŸ§¹ é–‹å§‹æ¸…ç†è³‡æºæ•¸æ“š (é¡å‹: {clear_type})...", "info")
        
        deleted_count = 0
        
        if clear_type == 'all':
            # æ¸…ç†æ‰€æœ‰ discovered_resources
            result = await db.execute_async(
                "DELETE FROM discovered_resources"
            )
            deleted_count = result.rowcount if hasattr(result, 'rowcount') else 0
            
        elif clear_type == 'old_data':
            # æ¸…ç†èˆŠæ•¸æ“šï¼ˆä¿ç•™æœ€è¿‘ N å¤©ï¼‰
            if days_to_keep > 0:
                cutoff_date = datetime.now() - timedelta(days=days_to_keep)
                result = await db.execute_async(
                    "DELETE FROM discovered_resources WHERE discovered_at < ?",
                    (cutoff_date.isoformat(),)
                )
                deleted_count = result.rowcount if hasattr(result, 'rowcount') else 0
            else:
                result = await db.execute_async(
                    "DELETE FROM discovered_resources"
                )
                deleted_count = result.rowcount if hasattr(result, 'rowcount') else 0
        
        elif clear_type == 'search_history':
            # åªæ¸…ç†æœç´¢æ­·å²ï¼ˆä¿ç•™å·²æ”¶è—çš„ï¼‰
            result = await db.execute_async(
                "DELETE FROM discovered_resources WHERE is_saved = 0 OR is_saved IS NULL"
            )
            deleted_count = result.rowcount if hasattr(result, 'rowcount') else 0
        
        self.send_log(f"âœ… æ¸…ç†å®Œæˆï¼Œå·²åˆªé™¤ {deleted_count} æ¢è¨˜éŒ„", "success")
        
        # ç™¼é€æ›´æ–°äº‹ä»¶
        self.send_event("clear-resources-complete", {
            "success": True,
            "deleted_count": deleted_count,
            "type": clear_type
        })
        
        # é‡æ–°ç²å–è³‡æºçµ±è¨ˆ
        await self.handle_get_resource_stats({})
        
    except Exception as e:
        self.send_log(f"âŒ æ¸…ç†å¤±æ•—: {e}", "error")
        import traceback
        traceback.print_exc()
        self.send_event("clear-resources-complete", {
            "success": False,
            "error": str(e)
        })


async def handle_get_resources(self, payload: Dict[str, Any]):
    """ç²å–è³‡æºåˆ—è¡¨"""
    print(f"[Backend] handle_get_resources called with payload: {payload}", file=sys.stderr)
    try:
        status = payload.get('status')
        resource_type = payload.get('type')
        limit = payload.get('limit', 50)
        offset = payload.get('offset', 0)
        # ğŸ†• å„ªåŒ–æ’åºï¼šæŒ‰ç›¸é—œæ€§è©•åˆ†é™åº + æ›´æ–°æ™‚é–“é™åº
        order_by = payload.get('orderBy', 'overall_score DESC, updated_at DESC')
        # ğŸ†• æ”¯æŒæŒ‰æœç´¢æœƒè©±éæ¿¾
        search_session_id = payload.get('searchSessionId')
        search_keyword = payload.get('searchKeyword')
        
        print(f"[Backend] Fetching resources with limit={limit}, session={search_session_id}...", file=sys.stderr)
        resources = await resource_discovery.list_resources(
            status=status,
            resource_type=resource_type,
            limit=limit,
            offset=offset,
            order_by=order_by,
            search_session_id=search_session_id,
            search_keyword=search_keyword
        )
        
        total = await resource_discovery.count_resources(
            status=status, 
            resource_type=resource_type,
            search_session_id=search_session_id,
            search_keyword=search_keyword
        )
        print(f"[Backend] Found {len(resources)} resources (total: {total})", file=sys.stderr)
        
        self.send_event("resources-list", {
            "success": True,
            "resources": resources,
            "total": total,
            "limit": limit,
            "offset": offset,
            "searchSessionId": search_session_id  # ğŸ†• è¿”å›æœƒè©± ID
        })
        print(f"[Backend] Sent resources-list event", file=sys.stderr)
        
        # ğŸ”§ å¾Œå°è‡ªå‹•é©—è­‰æœªé©—è­‰é¡å‹çš„è³‡æºï¼ˆç•°æ­¥åŸ·è¡Œï¼Œä¸é˜»å¡ï¼‰
        asyncio.create_task(self._auto_verify_resource_types(resources))
        
    except Exception as e:
        self.send_log(f"âŒ ç²å–è³‡æºåˆ—è¡¨å¤±æ•—: {e}", "error")
        self.send_event("resources-list", {
            "success": False,
            "error": str(e)
        })


async def handle_get_resource_stats(self, payload: Dict[str, Any] = None):
    """ç²å–è³‡æºçµ±è¨ˆ"""
    try:
        stats = await resource_discovery.get_statistics()
        
        self.send_event("resource-stats", {
            "success": True,
            **stats
        })
        
    except Exception as e:
        self.send_log(f"âŒ ç²å–è³‡æºçµ±è¨ˆå¤±æ•—: {e}", "error")
        self.send_event("resource-stats", {
            "success": False,
            "error": str(e)
        })


async def handle_add_resource_manually(self, payload: Dict[str, Any]):
    """æ‰‹å‹•æ·»åŠ è³‡æº"""
    try:
        DiscoveredResource = get_DiscoveredResource()
        resource = DiscoveredResource(
            resource_type=payload.get('type', 'group'),
            telegram_id=payload.get('telegramId', ''),
            username=payload.get('username', ''),
            title=payload.get('title', ''),
            description=payload.get('description', ''),
            member_count=payload.get('memberCount', 0),
            invite_link=payload.get('inviteLink', ''),
            discovery_source='manual',
            tags=payload.get('tags', []),
            notes=payload.get('notes', '')
        )
        
        # å¦‚æœæœ‰ username æˆ–é‚€è«‹éˆæ¥ï¼Œå˜—è©¦ç²å–è©³ç´°ä¿¡æ¯ä¸¦è‡ªå‹•è­˜åˆ¥é¡å‹
        if resource.username or resource.invite_link:
            group_search_service.set_clients(self.telegram_manager.clients)
            chat_id = resource.username or resource.invite_link
            info = await group_search_service.get_chat_info(chat_id)
            if info and 'error' not in info:
                resource.telegram_id = info.get('telegram_id', resource.telegram_id)
                resource.title = info.get('title', resource.title)
                resource.description = info.get('description', resource.description)
                resource.member_count = info.get('member_count', resource.member_count)
                resource.is_public = info.get('is_public', True)
                resource.has_discussion = info.get('has_discussion', False)
                # ğŸ”§ è‡ªå‹•è­˜åˆ¥è³‡æºé¡å‹ï¼ˆé »é“/ç¾¤çµ„ï¼‰
                chat_type = info.get('type', '')
                if chat_type:
                    resource.resource_type = chat_type
                    self.send_log(f"ğŸ“‹ è‡ªå‹•è­˜åˆ¥é¡å‹: {chat_type}", "info")
        
        resource_id = await resource_discovery.add_resource(resource)
        
        self.send_log(f"â• æ‰‹å‹•æ·»åŠ è³‡æº: {resource.title or resource.username}", "success")
        self.send_event("resource-added", {
            "success": True,
            "resourceId": resource_id
        })
        
    except Exception as e:
        self.send_log(f"âŒ æ·»åŠ è³‡æºå¤±æ•—: {e}", "error")
        self.send_event("resource-added", {
            "success": False,
            "error": str(e)
        })

# ğŸ†• Cæ–¹æ¡ˆï¼šæ”¶è—è³‡æºï¼ˆä¿å­˜åˆ°æ•¸æ“šåº«ï¼‰

# ğŸ†• Cæ–¹æ¡ˆï¼šæ”¶è—è³‡æºï¼ˆä¿å­˜åˆ°æ•¸æ“šåº«ï¼‰
async def handle_save_resource(self, payload: Dict[str, Any]):
    """æ”¶è—è³‡æº - å°‡æœç´¢çµæœä¿å­˜åˆ°æ•¸æ“šåº«"""
    try:
        telegram_id = payload.get('telegram_id')
        if not telegram_id:
            raise ValueError("ç¼ºå°‘ telegram_id")
        
        # æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
        existing = await resource_discovery.get_resource_by_telegram_id(telegram_id)
        if existing:
            self.send_log(f"â­ è³‡æºå·²å­˜åœ¨: {payload.get('title')}", "info")
            self.send_event("resource-saved", {
                "success": True,
                "telegram_id": telegram_id,
                "resource_id": existing['id'],
                "already_exists": True
            })
            return
        
        # å‰µå»ºæ–°è³‡æº
        from resource_discovery import DiscoveredResource
        resource = DiscoveredResource(
            resource_type=payload.get('resource_type', 'group'),
            telegram_id=telegram_id,
            username=payload.get('username', ''),
            title=payload.get('title', ''),
            description=payload.get('description', ''),
            member_count=payload.get('member_count', 0),
            activity_score=0.5,
            relevance_score=payload.get('overall_score', 0.5),
            discovery_source='search',
            discovery_keyword=payload.get('discovery_keyword', ''),
            discovered_by_phone='',
            status='discovered'
        )
        
        resource_id = await resource_discovery.add_resource(resource)
        
        self.send_log(f"â­ å·²æ”¶è—: {payload.get('title')}", "success")
        self.send_event("resource-saved", {
            "success": True,
            "telegram_id": telegram_id,
            "resource_id": resource_id,
            "already_exists": False
        })
        
    except Exception as e:
        self.send_log(f"âŒ æ”¶è—å¤±æ•—: {e}", "error")
        self.send_event("resource-saved", {
            "success": False,
            "error": str(e)
        })


async def handle_unsave_resource(self, payload: Dict[str, Any]):
    """å–æ¶ˆæ”¶è— - å¾æ•¸æ“šåº«åˆªé™¤è³‡æº"""
    try:
        telegram_id = payload.get('telegram_id')
        if not telegram_id:
            raise ValueError("ç¼ºå°‘ telegram_id")
        
        # æŸ¥æ‰¾è³‡æº
        existing = await resource_discovery.get_resource_by_telegram_id(telegram_id)
        if not existing:
            self.send_log(f"è³‡æºä¸å­˜åœ¨ï¼Œç„¡éœ€åˆªé™¤", "info")
            self.send_event("resource-unsaved", {
                "success": True,
                "telegram_id": telegram_id
            })
            return
        
        # åˆªé™¤è³‡æº
        await resource_discovery.delete_resource(existing['id'])
        
        self.send_log(f"ğŸ—‘ï¸ å·²å–æ¶ˆæ”¶è—", "success")
        self.send_event("resource-unsaved", {
            "success": True,
            "telegram_id": telegram_id
        })
        
    except Exception as e:
        self.send_log(f"âŒ å–æ¶ˆæ”¶è—å¤±æ•—: {e}", "error")
        self.send_event("resource-unsaved", {
            "success": False,
            "error": str(e)
        })


async def handle_delete_resource(self, payload: Dict[str, Any]):
    """åˆªé™¤è³‡æº"""
    try:
        resource_id = payload.get('resourceId')
        if not resource_id:
            raise ValueError("è³‡æº ID ä¸èƒ½ç‚ºç©º")
        
        await resource_discovery.delete_resource(resource_id)
        
        self.send_log(f"ğŸ—‘ï¸ å·²åˆªé™¤è³‡æº ID: {resource_id}", "success")
        self.send_event("resource-deleted", {
            "success": True,
            "resourceId": resource_id
        })
        
    except Exception as e:
        self.send_log(f"âŒ åˆªé™¤è³‡æºå¤±æ•—: {e}", "error")
        self.send_event("resource-deleted", {
            "success": False,
            "error": str(e)
        })


async def handle_delete_resources_batch(self, payload: Dict[str, Any]):
    """æ‰¹é‡åˆªé™¤è³‡æº"""
    try:
        resource_ids = payload.get('resourceIds', [])
        if not resource_ids:
            raise ValueError("è³‡æº ID åˆ—è¡¨ä¸èƒ½ç‚ºç©º")
        
        deleted_count = 0
        for rid in resource_ids:
            try:
                await resource_discovery.delete_resource(rid)
                deleted_count += 1
            except Exception as e:
                self.send_log(f"åˆªé™¤è³‡æº {rid} å¤±æ•—: {e}", "warning")
        
        self.send_log(f"ğŸ—‘ï¸ å·²æ‰¹é‡åˆªé™¤ {deleted_count}/{len(resource_ids)} å€‹è³‡æº", "success")
        self.send_event("resources-batch-deleted", {
            "success": True,
            "deletedCount": deleted_count,
            "totalRequested": len(resource_ids)
        })
        
    except Exception as e:
        self.send_log(f"âŒ æ‰¹é‡åˆªé™¤è³‡æºå¤±æ•—: {e}", "error")
        self.send_event("resources-batch-deleted", {
            "success": False,
            "error": str(e)
        })


async def handle_verify_resource_type(self, payload: Dict[str, Any]):
    """é©—è­‰ä¸¦æ›´æ–°è³‡æºçš„çœŸå¯¦é¡å‹"""
    try:
        import sys
        resource_id = payload.get('resourceId')
        
        if not resource_id:
            raise ValueError("è³‡æº ID ä¸èƒ½ç‚ºç©º")
        
        # ç²å–è³‡æºè©³æƒ…
        from database import db
        await db.connect()
        
        resources = await db.fetch_all(
            "SELECT * FROM discovered_resources WHERE id = ?",
            (resource_id,)
        )
        
        if not resources:
            raise ValueError(f"æ‰¾ä¸åˆ°è³‡æº ID: {resource_id}")
        
        resource = resources[0]
        username = resource.get('username', '')
        invite_link = resource.get('invite_link', '')
        title = resource.get('title', '')
        old_type = resource.get('resource_type', 'unknown')
        
        self.send_log(f"ğŸ” æ­£åœ¨é©—è­‰è³‡æºé¡å‹: {title}", "info")
        
        # ç²å–åœ¨ç·šå¸³è™Ÿ
        accounts = await db.get_all_accounts()
        online_phone = None
        for acc in accounts:
            if acc.get('status') == 'Online':
                phone = acc.get('phone')
                if phone in self.telegram_manager.clients:
                    online_phone = phone
                    break
        
        if not online_phone:
            raise ValueError("æ²’æœ‰å¯ç”¨çš„åœ¨ç·šå¸³è™Ÿï¼Œè«‹å…ˆç™»éŒ„")
        
        client = self.telegram_manager.clients[online_phone]
        
        # ä½¿ç”¨ Telegram API ç²å–çœŸå¯¦é¡å‹
        chat_target = username or invite_link
        if not chat_target:
            raise ValueError("æ²’æœ‰å¯ç”¨çš„ username æˆ– invite_link")
        
        chat_info = await client.get_chat(chat_target)
        
        verified_type = old_type
        if chat_info:
            from pyrogram.enums import ChatType
            if chat_info.type == ChatType.CHANNEL:
                verified_type = "channel"
            elif chat_info.type == ChatType.SUPERGROUP:
                verified_type = "supergroup"
            elif chat_info.type == ChatType.GROUP:
                verified_type = "group"
            elif chat_info.type == ChatType.BOT:
                verified_type = "bot"
        
        # æ›´æ–°æ•¸æ“šåº«
        if verified_type != old_type:
            await db.execute(
                "UPDATE discovered_resources SET resource_type = ? WHERE id = ?",
                (verified_type, resource_id)
            )
            await db._connection.commit()
            self.send_log(f"âœ… é¡å‹å·²æ›´æ–°: {old_type} â†’ {verified_type}", "success")
        else:
            self.send_log(f"âœ… é¡å‹ç¢ºèª: {verified_type}", "info")
        
        self.send_event("resource-type-verified", {
            "success": True,
            "resourceId": resource_id,
            "oldType": old_type,
            "newType": verified_type,
            "title": title
        })
        
    except Exception as e:
        import sys
        print(f"[Backend] Error verifying resource type: {e}", file=sys.stderr)
        self.send_log(f"âŒ é©—è­‰é¡å‹å¤±æ•—: {e}", "error")
        self.send_event("resource-type-verified", {
            "success": False,
            "resourceId": payload.get('resourceId'),
            "error": str(e)
        })


async def handle_batch_verify_resource_types(self, payload: Dict[str, Any]):
    """æ‰¹é‡é©—è­‰è³‡æºé¡å‹ï¼ˆåœ¨å¾Œå°éœé»˜è™•ç†ï¼Œé¿å… FloodWaitï¼‰"""
    try:
        import sys
        import asyncio
        resource_ids = payload.get('resourceIds', [])
        
        if not resource_ids:
            return
        
        print(f"[Backend] Batch verifying {len(resource_ids)} resources", file=sys.stderr)
        
        # ç²å–åœ¨ç·šå¸³è™Ÿ
        from database import db
        await db.connect()
        accounts = await db.get_all_accounts()
        online_phone = None
        for acc in accounts:
            if acc.get('status') == 'Online':
                phone = acc.get('phone')
                if phone in self.telegram_manager.clients:
                    online_phone = phone
                    break
        
        if not online_phone:
            print("[Backend] No online account for batch verification", file=sys.stderr)
            return
        
        client = self.telegram_manager.clients[online_phone]
        verified_count = 0
        
        for resource_id in resource_ids:
            try:
                resources = await db.fetch_all(
                    "SELECT * FROM discovered_resources WHERE id = ?",
                    (resource_id,)
                )
                
                if not resources:
                    continue
                
                resource = resources[0]
                username = resource.get('username', '')
                old_type = resource.get('resource_type', 'unknown')
                
                if not username:
                    continue
                
                chat_info = await client.get_chat(username)
                
                if chat_info:
                    from pyrogram.enums import ChatType
                    if chat_info.type == ChatType.CHANNEL:
                        new_type = "channel"
                    elif chat_info.type == ChatType.SUPERGROUP:
                        new_type = "supergroup"
                    elif chat_info.type == ChatType.GROUP:
                        new_type = "group"
                    else:
                        new_type = old_type
                    
                    if new_type != old_type:
                        await db.execute(
                            "UPDATE discovered_resources SET resource_type = ?, type_verified = 1 WHERE id = ?",
                            (new_type, resource_id)
                        )
                        await db._connection.commit()
                        verified_count += 1
                        print(f"[Backend] Type updated: {resource.get('title')} {old_type} -> {new_type}", file=sys.stderr)
                    else:
                        # æ¨™è¨˜ç‚ºå·²é©—è­‰
                        await db.execute(
                            "UPDATE discovered_resources SET type_verified = 1 WHERE id = ?",
                            (resource_id,)
                        )
                        await db._connection.commit()
                
                # ç­‰å¾… 1-2 ç§’é¿å… FloodWait
                await asyncio.sleep(1.5)
                
            except Exception as e:
                print(f"[Backend] Error verifying resource {resource_id}: {e}", file=sys.stderr)
                continue
        
        if verified_count > 0:
            self.send_log(f"âœ… è‡ªå‹•æ›´æ–°äº† {verified_count} å€‹è³‡æºé¡å‹", "info")
            # ç™¼é€æ›´æ–°äº‹ä»¶è®“å‰ç«¯åˆ·æ–°
            self.send_event("resources-types-verified", {
                "success": True,
                "count": verified_count
            })
            
    except Exception as e:
        import sys
        print(f"[Backend] Error in batch verify: {e}", file=sys.stderr)


async def handle_clear_all_resources(self):
    """æ¸…ç©ºæ‰€æœ‰æœç´¢çµæœè³‡æº"""
    try:
        deleted_count = await resource_discovery.clear_all_resources()
        self.send_log(f"ğŸ—‘ï¸ å·²æ¸…ç©ºæ‰€æœ‰è³‡æºï¼Œå…± {deleted_count} æ¢", "success")
        self.send_event("resources-cleared", {
            "success": True,
            "deletedCount": deleted_count
        })
    except Exception as e:
        self.send_log(f"âŒ æ¸…ç©ºè³‡æºå¤±æ•—: {e}", "error")
        self.send_event("resources-cleared", {
            "success": False,
            "error": str(e)
        })


async def handle_batch_join_resources(self, payload: Dict[str, Any]):
    """æ‰¹é‡åŠ å…¥è³‡æº"""
    try:
        resource_ids = payload.get('resourceIds', [])
        delay_min = payload.get('delayMin', 30)
        delay_max = payload.get('delayMax', 60)
        
        if not resource_ids:
            raise ValueError("è³‡æº ID åˆ—è¡¨ä¸èƒ½ç‚ºç©º")
        
        group_search_service.set_clients(self.telegram_manager.clients)
        
        # åœ¨å¾Œå°é‹è¡Œæ‰¹é‡åŠ å…¥
        async def batch_join_task():
            stats = await group_search_service.batch_join(
                resource_ids=resource_ids,
                delay_range=(delay_min, delay_max)
            )
            self.send_event("batch-join-complete", {
                "success": True,
                **stats
            })
        
        task = asyncio.create_task(batch_join_task())
        self.background_tasks.append(task)
        
        self.send_log(f"ğŸš€ é–‹å§‹æ‰¹é‡åŠ å…¥ {len(resource_ids)} å€‹è³‡æº", "info")
        self.send_event("batch-join-started", {
            "success": True,
            "count": len(resource_ids)
        })
        
    except Exception as e:
        self.send_log(f"âŒ æ‰¹é‡åŠ å…¥å¤±æ•—: {e}", "error")
        self.send_event("batch-join-started", {
            "success": False,
            "error": str(e)
        })

