"""
Extracted handler implementations: search
Auto-generated by refactor_main.py
"""
import json
import sys
import time
import asyncio
import traceback
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from service_context import get_service_context
from database import db

import re
from service_locator import resource_discovery, jiso_search_service, get_DiscoveredResource
# All handlers receive (self, payload) where self is BackendService instance.
# They are called via: await handler_impl(self, payload)
# Inside, use self.db, self.send_event(), self.telegram_manager, etc.
# This is a transitional pattern - later, replace self.xxx with ctx.xxx


async def handle_rebuild_search_index(self):
    """é‡å»ºæœç´¢ç´¢å¼•"""
    try:
        from fulltext_search import get_search_engine
        
        search_engine = get_search_engine()
        await search_engine.rebuild_index()
        
        self.send_log("æœç´¢ç´¢å¼•é‡å»ºå®Œæˆ", "success")
        self.send_event("search-index-rebuilt", {
            "success": True,
            "message": "æœç´¢ç´¢å¼•é‡å»ºå®Œæˆ"
        })
    except Exception as e:
        self.send_log(f"é‡å»ºæœç´¢ç´¢å¼•å¤±æ•—: {str(e)}", "error")
        self.send_event("search-index-rebuilt", {
            "success": False,
            "error": str(e)
        })


# ==================== Search History Handlers ====================

async def handle_get_search_history(self, payload: Dict[str, Any]):
    """ç²å–æœç´¢æ­·å²è¨˜éŒ„"""
    try:
        from search_history_service import get_search_history_service
        search_history = get_search_history_service()
        
        keyword = payload.get('keyword')
        limit = payload.get('limit', 50)
        offset = payload.get('offset', 0)
        
        results = search_history.get_search_history(keyword, limit, offset)
        
        self.send_event("search-history-result", {
            "success": True,
            "history": results,
            "total": len(results)
        })
        
    except Exception as e:
        self.send_log(f"ç²å–æœç´¢æ­·å²å¤±æ•—: {str(e)}", "error")
        self.send_event("search-history-result", {
            "success": False,
            "error": str(e)
        })


async def handle_get_keyword_suggestions(self, payload: Dict[str, Any]):
    """ğŸ”§ Phase3: ç²å–æœç´¢é—œéµè©æ¨è–¦"""
    try:
        from search_history_service import get_search_history_service
        search_history = get_search_history_service()
        
        current = payload.get('keyword', '')
        limit = payload.get('limit', 10)
        
        suggestions = search_history.get_keyword_suggestions(current, limit)
        
        self.send_event("keyword-suggestions", {
            "success": True,
            "suggestions": suggestions,
            "keyword": current
        })
        
    except Exception as e:
        self.send_event("keyword-suggestions", {
            "success": False,
            "error": str(e),
            "suggestions": []
        })


async def handle_get_search_results_by_id(self, payload: Dict[str, Any]):
    """ç²å–æŸæ¬¡æœç´¢çš„çµæœ"""
    try:
        from search_history_service import get_search_history_service
        search_history = get_search_history_service()
        
        search_id = payload.get('searchId')
        if not search_id:
            self.send_event("search-results-by-id", {
                "success": False,
                "error": "ç¼ºå°‘ searchId åƒæ•¸"
            })
            return
        
        results = search_history.get_search_results(search_id)
        
        self.send_event("search-results-by-id", {
            "success": True,
            "results": results,
            "total": len(results)
        })
        
    except Exception as e:
        self.send_log(f"ç²å–æœç´¢çµæœå¤±æ•—: {str(e)}", "error")
        self.send_event("search-results-by-id", {
            "success": False,
            "error": str(e)
        })


async def handle_get_search_statistics(self, payload: Dict[str, Any]):
    """ç²å–æœç´¢çµ±è¨ˆä¿¡æ¯"""
    try:
        from search_history_service import get_search_history_service
        search_history = get_search_history_service()
        
        stats = search_history.get_statistics()
        
        self.send_event("search-statistics-result", {
            "success": True,
            **stats
        })
        
    except Exception as e:
        self.send_log(f"ç²å–æœç´¢çµ±è¨ˆå¤±æ•—: {str(e)}", "error")
        self.send_event("search-statistics-result", {
            "success": False,
            "error": str(e)
        })


async def handle_cleanup_search_history(self, payload: Dict[str, Any]):
    """æ¸…ç†èˆŠçš„æœç´¢è¨˜éŒ„"""
    try:
        from search_history_service import get_search_history_service
        search_history = get_search_history_service()
        
        days = payload.get('days', 30)
        deleted = search_history.cleanup_old_records(days)
        
        self.send_log(f"å·²æ¸…ç† {deleted} æ¢èˆŠæœç´¢è¨˜éŒ„", "success")
        self.send_event("cleanup-search-history-result", {
            "success": True,
            "deleted": deleted
        })
        
    except Exception as e:
        self.send_log(f"æ¸…ç†æœç´¢æ­·å²å¤±æ•—: {str(e)}", "error")
        self.send_event("cleanup-search-history-result", {
            "success": False,
            "error": str(e)
        })


async def handle_search_jiso(self, payload: Dict[str, Any]):
    """ææœ Bot æœç´¢"""
    try:
        keyword = payload.get('keyword', '').strip()
        phone = payload.get('phone')
        limit = payload.get('limit', 50)
        
        if not keyword:
            self.send_event("search-jiso-complete", {
                "success": False,
                "error": "æœç´¢å…³é”®è¯ä¸èƒ½ä¸ºç©º"
            })
            return
        
        self.send_log(f"ğŸ” å¼€å§‹ææœæœç´¢: '{keyword}'", "info")
        
        # ç¡®ä¿å®¢æˆ·ç«¯å·²è®¾ç½®
        jiso_search_service.set_clients(self.telegram_manager.clients)
        jiso_search_service.set_event_callback(self.send_event)
        
        # æ‰§è¡Œæœç´¢
        result = await jiso_search_service.search(
            keyword=keyword,
            phone=phone,
            limit=limit
        )
        
        if result["success"]:
            self.send_log(f"ğŸ” ææœå®Œæˆ: æ‰¾åˆ° {len(result['results'])} ä¸ªç»“æœ", "success")
            
            # ä¿å­˜ç»“æœåˆ°èµ„æºå‘ç°æ•°æ®åº“
            saved_count = 0
            import hashlib as _hashlib
            
            for item in result["results"]:
                try:
                    # ä¼˜å…ˆä½¿ç”¨ usernameï¼Œå¦åˆ™ä½¿ç”¨ title ç”Ÿæˆå”¯ä¸€æ ‡è¯†
                    username = item.get("username")
                    title = item.get("title", "")

                    # å¦‚æœæ²¡æœ‰ usernameï¼Œå°è¯•ä» title ä¸­æå–æˆ–ç”Ÿæˆ
                    if not username and title:
                        # å°è¯•ä» title ä¸­æå– @username
                        import re
                        at_match = re.search(r'@([a-zA-Z][a-zA-Z0-9_]{3,})', title)
                        if at_match:
                            username = at_match.group(1)
                        else:
                            # ä½¿ç”¨ title çš„å“ˆå¸Œä½œä¸ºå”¯ä¸€æ ‡è¯†
                            title_hash = _hashlib.md5(title.encode()).hexdigest()[:12]
                            username = f"jiso_{title_hash}"

                    if username or title:
                        # è¨ˆç®—ç›¸é—œåº¦è©•åˆ†
                        description = item.get("description", "")
                        relevance_score = resource_discovery.calculate_relevance_score(
                            title, description, [keyword]
                        )
                        
                        # åˆ¤æ–·æ˜¯å¦æœ‰çœŸå¯¦éˆæ¥ï¼ˆç”¨æ–¼å¯é”æ€§è©•åˆ†ï¼‰
                        has_real_link = bool(item.get("link") or (username and not username.startswith("jiso_")))
                        
                        # åˆ›å»º DiscoveredResource å¯¹è±¡
                        DiscoveredResource = get_DiscoveredResource()
                        resource = DiscoveredResource(
                            telegram_id=username or f"jiso_{saved_count}",
                            username=username if not username.startswith("jiso_") else "",  # jiso_ é–‹é ­ä¸æ˜¯çœŸå¯¦ username
                            title=title,
                            description=description,
                            member_count=item.get("member_count", 0),
                            resource_type=item.get("chat_type", "supergroup"),
                            discovery_source="jiso",
                            discovery_keyword=keyword,
                            status="discovered",
                            relevance_score=relevance_score,
                            invite_link=item.get("link", "")
                        )
                        resource_id = await resource_discovery.add_resource(resource)
                        if saved_count < 3:  # åªæ˜¾ç¤ºå‰3ä¸ª
                            self.send_log(f"  ğŸ’¾ ä¿å­˜: {title[:30]}... (ID:{resource_id})", "info")
                        saved_count += 1
                except Exception as e:
                    self.send_log(f"ä¿å­˜èµ„æºå¤±è´¥: {e}", "warning")
                    import traceback
                    traceback.print_exc()

            self.send_log(f"ğŸ’¾ æ€»å…±ä¿å­˜äº† {saved_count}/{len(result['results'])} ä¸ªèµ„æº", "info")
        
        self.send_event("search-jiso-complete", result)
        
    except Exception as e:
        self.send_log(f"âŒ ææœå¤±è´¥: {e}", "error")
        import traceback
        traceback.print_exc()
        self.send_event("search-jiso-complete", {
            "success": False,
            "error": str(e)
        })


async def handle_check_jiso_availability(self, payload: Dict[str, Any]):
    """æ£€æŸ¥ææœå¯ç”¨æ€§"""
    try:
        phone = payload.get('phone')
        
        # ç¡®ä¿å®¢æˆ·ç«¯å·²è®¾ç½®
        jiso_search_service.set_clients(self.telegram_manager.clients)
        
        result = await jiso_search_service.check_availability(phone)
        
        self.send_event("jiso-availability", result)
        
    except Exception as e:
        self.send_event("jiso-availability", {
            "available": False,
            "reason": str(e)
        })


# ==================== è‡ªå®šç¾©æœç´¢æ¸ é“ç®¡ç† ====================

async def handle_get_search_channels(self, payload: Dict[str, Any]):
    """ç²å–æœç´¢æ¸ é“åˆ—è¡¨"""
    try:
        enabled_only = payload.get('enabledOnly', False)
        
        # ç²å–è‡ªå®šç¾©æ¸ é“
        custom_channels = await db.get_custom_search_channels(enabled_only)
        
        # ç³»çµ±æ¸ é“å·²å…§å»ºåœ¨å¾Œç«¯ï¼Œä¸åœ¨å‰ç«¯é¡¯ç¤º
        # å‰ç«¯åªç®¡ç†ç”¨æˆ¶è‡ªå®šç¾©æ¸ é“
        system_channels = []
        
        # æ¨™è¨˜è‡ªå®šç¾©æ¸ é“
        for ch in custom_channels:
            ch['is_system'] = False
        
        self.send_event("search-channels-list", {
            "success": True,
            "system_channels": system_channels,
            "custom_channels": custom_channels
        })
        
    except Exception as e:
        self.send_log(f"ç²å–æœç´¢æ¸ é“å¤±æ•—: {e}", "error")
        self.send_event("search-channels-list", {
            "success": False,
            "error": str(e)
        })


async def handle_add_search_channel(self, payload: Dict[str, Any]):
    """æ·»åŠ è‡ªå®šç¾©æœç´¢æ¸ é“"""
    try:
        bot_username = payload.get('botUsername', '').strip().lstrip('@')
        display_name = payload.get('displayName', '').strip()
        query_format = payload.get('queryFormat', '{keyword}')
        priority = payload.get('priority', 'backup')
        notes = payload.get('notes', '')
        
        if not bot_username:
            self.send_event("search-channel-added", {
                "success": False,
                "error": "Bot ç”¨æˆ¶åä¸èƒ½ç‚ºç©º"
            })
            return
        
        # æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
        existing = await db.get_custom_search_channels()
        for ch in existing:
            if ch['bot_username'] == bot_username:
                self.send_event("search-channel-added", {
                    "success": False,
                    "error": f"@{bot_username} å·²å­˜åœ¨"
                })
                return
        
        channel_id = await db.add_custom_search_channel(
            bot_username=bot_username,
            display_name=display_name or bot_username,
            query_format=query_format,
            priority=priority,
            notes=notes
        )
        
        if channel_id:
            self.send_log(f"â• æ·»åŠ æœç´¢æ¸ é“: @{bot_username}", "success")
            self.send_event("search-channel-added", {
                "success": True,
                "channelId": channel_id,
                "botUsername": bot_username
            })
            
            # æ›´æ–° jiso_search_service çš„è‡ªå®šç¾© Bot åˆ—è¡¨
            await self._refresh_custom_bots()
        else:
            self.send_event("search-channel-added", {
                "success": False,
                "error": "æ·»åŠ å¤±æ•—"
            })
            
    except Exception as e:
        self.send_log(f"æ·»åŠ æœç´¢æ¸ é“å¤±æ•—: {e}", "error")
        self.send_event("search-channel-added", {
            "success": False,
            "error": str(e)
        })


async def handle_update_search_channel(self, payload: Dict[str, Any]):
    """æ›´æ–°æœç´¢æ¸ é“"""
    try:
        channel_id = payload.get('channelId')
        
        if not channel_id or channel_id < 0:
            self.send_event("search-channel-updated", {
                "success": False,
                "error": "ç„¡æ³•ä¿®æ”¹ç³»çµ±æ¸ é“"
            })
            return
        
        updates = {}
        if 'displayName' in payload:
            updates['display_name'] = payload['displayName']
        if 'queryFormat' in payload:
            updates['query_format'] = payload['queryFormat']
        if 'priority' in payload:
            updates['priority'] = payload['priority']
        if 'enabled' in payload:
            updates['enabled'] = 1 if payload['enabled'] else 0
        if 'notes' in payload:
            updates['notes'] = payload['notes']
        
        success = await db.update_custom_search_channel(channel_id, **updates)
        
        if success:
            self.send_log(f"âœï¸ æ›´æ–°æœç´¢æ¸ é“ ID:{channel_id}", "success")
            await self._refresh_custom_bots()
        
        self.send_event("search-channel-updated", {
            "success": success,
            "channelId": channel_id
        })
        
    except Exception as e:
        self.send_log(f"æ›´æ–°æœç´¢æ¸ é“å¤±æ•—: {e}", "error")
        self.send_event("search-channel-updated", {
            "success": False,
            "error": str(e)
        })


async def handle_delete_search_channel(self, payload: Dict[str, Any]):
    """åˆªé™¤æœç´¢æ¸ é“"""
    try:
        channel_id = payload.get('channelId')
        
        if not channel_id or channel_id < 0:
            self.send_event("search-channel-deleted", {
                "success": False,
                "error": "ç„¡æ³•åˆªé™¤ç³»çµ±æ¸ é“"
            })
            return
        
        success = await db.delete_custom_search_channel(channel_id)
        
        if success:
            self.send_log(f"ğŸ—‘ï¸ åˆªé™¤æœç´¢æ¸ é“ ID:{channel_id}", "success")
            await self._refresh_custom_bots()
        
        self.send_event("search-channel-deleted", {
            "success": success,
            "channelId": channel_id
        })
        
    except Exception as e:
        self.send_log(f"åˆªé™¤æœç´¢æ¸ é“å¤±æ•—: {e}", "error")
        self.send_event("search-channel-deleted", {
            "success": False,
            "error": str(e)
        })


async def handle_test_search_channel(self, payload: Dict[str, Any]):
    """æ¸¬è©¦æœç´¢æ¸ é“"""
    try:
        bot_username = payload.get('botUsername', '').lstrip('@')
        
        if not bot_username:
            self.send_event("search-channel-tested", {
                "success": False,
                "error": "Bot ç”¨æˆ¶åä¸èƒ½ç‚ºç©º"
            })
            return
        
        self.send_log(f"ğŸ” æ¸¬è©¦æ¸ é“: @{bot_username}...", "info")
        
        # ä½¿ç”¨ jiso_search_service æ¸¬è©¦ Bot
        import time
        start_time = time.time()
        
        jiso_search_service.set_clients(self.telegram_manager.clients)
        
        # å˜—è©¦è§£æ Bot
        available_clients = {p: c for p, c in self.telegram_manager.clients.items() if c.is_connected}
        if not available_clients:
            self.send_event("search-channel-tested", {
                "success": False,
                "botUsername": bot_username,
                "status": "offline",
                "error": "æ²’æœ‰å¯ç”¨çš„å¸³è™Ÿ"
            })
            return
        
        client = list(available_clients.values())[0]
        peer = await jiso_search_service._resolve_bot(client, bot_username)
        
        response_time = time.time() - start_time
        
        if peer:
            # æ›´æ–°æ•¸æ“šåº«
            await db.update_channel_test_result(bot_username, True, response_time)
            
            self.send_log(f"âœ… @{bot_username} å¯ç”¨ ({response_time:.1f}s)", "success")
            self.send_event("search-channel-tested", {
                "success": True,
                "botUsername": bot_username,
                "status": "online",
                "responseTime": response_time
            })
        else:
            await db.update_channel_test_result(bot_username, False)
            
            self.send_log(f"âŒ @{bot_username} ä¸å¯ç”¨", "warning")
            self.send_event("search-channel-tested", {
                "success": False,
                "botUsername": bot_username,
                "status": "offline",
                "error": "Bot ä¸å­˜åœ¨æˆ–ä¸å¯è¨ªå•"
            })
            
    except Exception as e:
        self.send_log(f"æ¸¬è©¦æ¸ é“å¤±æ•—: {e}", "error")
        self.send_event("search-channel-tested", {
            "success": False,
            "error": str(e)
        })

