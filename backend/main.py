"""
TG-Matrix Backend Main Entry Point
Handles communication with Electron via stdin/stdout
"""
import sys
import os
import io

# ğŸ”§ P0: å¼·åˆ¶è¨­ç½® stdin/stdout/stderr ç‚º UTF-8 ç·¨ç¢¼ï¼ˆè§£æ±º Windows GBK å•é¡Œï¼‰
if sys.platform == 'win32':
    # ğŸ†• è¨­ç½® stdin ç‚º UTF-8ï¼ˆé—œéµï¼šæ¥æ”¶ä¾†è‡ª Electron çš„ä¸­æ–‡é—œéµè©ï¼‰
    sys.stdin = io.TextIOWrapper(sys.stdin.buffer, encoding='utf-8', errors='replace')
    # è¨­ç½® stdout ç‚º UTF-8ï¼Œä¸¦å¿½ç•¥ç·¨ç¢¼éŒ¯èª¤
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8', errors='replace', line_buffering=True)
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8', errors='replace', line_buffering=True)

# ğŸ”§ ç«‹å³è¼¸å‡ºå•Ÿå‹•ä¿¡è™Ÿï¼ˆç”¨æ–¼è¨ºæ–·ï¼‰
print('{"event":"backend-starting","payload":{"status":"initializing"}}', flush=True)
sys.stderr.write("[Backend] ===== Python backend starting =====\n")
sys.stderr.flush()

import json
import asyncio
import gc
import time
from typing import Dict, Any, Optional, List
from datetime import datetime, timedelta
from pathlib import Path
# ========== ğŸ”§ Phase 3 å„ªåŒ–ï¼šå…§å­˜å„ªåŒ–å°å…¥ ==========
# åªåœ¨å•Ÿå‹•æ™‚åŠ è¼‰å¿…éœ€çš„æ ¸å¿ƒæ¨¡å¡Šï¼Œå…¶ä»–æ¨¡å¡Šå»¶é²åŠ è¼‰

# ç¬¬ä¸€å±¤ï¼šçµ•å°æ ¸å¿ƒæ¨¡å¡Šï¼ˆå•Ÿå‹•æ™‚å¿…é ˆåŠ è¼‰ï¼Œç´„ 50MBï¼‰
from database import db
from config import config, IS_DEV_MODE
from telegram_client import TelegramClientManager
from message_queue import MessageQueue, MessagePriority
from error_handler import init_error_handler, handle_error, AppError, ErrorType
from message_ack import init_ack_manager, get_ack_manager
from text_utils import safe_json_dumps, sanitize_text, sanitize_dict, format_chat_info, format_user_info
from cache_manager import init_cache_manager, get_cache_manager

# ç¬¬äºŒå±¤ï¼šè¼•é‡æ ¸å¿ƒå·¥å…·ï¼ˆç´„ 10MBï¼‰
from validators import (
    validate_account, validate_keyword, validate_template, 
    validate_campaign, validate_group_url,
    AccountValidator, KeywordValidator, TemplateValidator,
    CampaignValidator, GroupValidator, ValidationError
)
from flood_wait_handler import flood_handler, safe_telegram_call

# ========== ğŸ”§ ä»¥ä¸‹æ¨¡å¡Šå…¨éƒ¨å»¶é²åŠ è¼‰ ==========
# ä½¿ç”¨ lazy_imports ç®¡ç†å™¨é€²è¡Œå»¶é²åŠ è¼‰ï¼Œç¯€çœç´„ 300-400MB å…§å­˜

from lazy_imports import lazy_imports, get_lazy_imports

# è¨»å†Šæ‰€æœ‰éæ ¸å¿ƒæ¨¡å¡Šï¼ˆåªè¨»å†Šï¼Œä¸åŠ è¼‰ï¼‰
# === Telegram æœå‹™ ===
lazy_imports.register('private_message_poller')
lazy_imports.register('group_message_poller')
lazy_imports.register('group_join_service')
lazy_imports.register('member_extraction_service')
lazy_imports.register('qr_auth_manager')
lazy_imports.register('ip_binding_manager')

# === AI å’ŒçŸ¥è­˜åº«ï¼ˆæœ€å¤§å…§å­˜æ¶ˆè€—è€…ï¼‰===
lazy_imports.register('ai_context_manager')
lazy_imports.register('ai_auto_chat')
lazy_imports.register('vector_memory')
lazy_imports.register('auto_funnel_manager')

# === ç›£æ§å’Œåˆ†æ ===
lazy_imports.register('connection_monitor')
lazy_imports.register('resource_discovery')
lazy_imports.register('discussion_watcher')
lazy_imports.register('performance_monitor')
lazy_imports.register('enhanced_health_monitor')

# === æœç´¢æœå‹™ ===
lazy_imports.register('fulltext_search')
lazy_imports.register('group_search_service')
lazy_imports.register('jiso_search_service')

# === ç‡ŸéŠ·å’Œå»£å‘Š ===
lazy_imports.register('batch_operations')
lazy_imports.register('credential_scraper')
lazy_imports.register('ad_template')
lazy_imports.register('ad_manager')
lazy_imports.register('ad_broadcaster')
lazy_imports.register('ad_scheduler')
lazy_imports.register('ad_analytics')
lazy_imports.register('user_tracker')
lazy_imports.register('user_analytics')
lazy_imports.register('campaign_orchestrator')
lazy_imports.register('multi_channel_stats')
lazy_imports.register('marketing_outreach_service')
lazy_imports.register('marketing_task_service')

# === å”ä½œå’Œè…³æœ¬ ===
lazy_imports.register('script_engine')
lazy_imports.register('collaboration_coordinator')
lazy_imports.register('multi_role_manager')

# === è¨­å‚™å’Œä»£ç† ===
lazy_imports.register('device_fingerprint')
lazy_imports.register('proxy_manager')
lazy_imports.register('warmup_manager')
lazy_imports.register('proxy_rotation_manager')
lazy_imports.register('behavior_simulator')

# === å…¶ä»– ===
lazy_imports.register('backup_manager')
lazy_imports.register('queue_optimizer')
lazy_imports.register('scheduler')
lazy_imports.register('error_recovery_manager')
lazy_imports.register('alert_manager')
lazy_imports.register('smart_alert_manager')
lazy_imports.register('db_optimizer')
lazy_imports.register('memory_monitor')


# ========== å»¶é²åŠ è¼‰çš„æ¨¡å¡Šç²å–å‡½æ•¸ ==========
def _get_module(name: str):
    """å®‰å…¨ç²å–å»¶é²åŠ è¼‰çš„æ¨¡å¡Š"""
    return lazy_imports.get(name)


# ç‚ºå‘å¾Œå…¼å®¹å‰µå»ºæ¨¡å¡Šä»£ç†è®Šé‡
# é€™äº›è®Šé‡åœ¨é¦–æ¬¡è¨ªå•æ™‚æ‰æœƒåŠ è¼‰å¯¦éš›æ¨¡å¡Š
class _LazyModuleProxy:
    """å»¶é²æ¨¡å¡Šä»£ç†ï¼Œé¦–æ¬¡è¨ªå•æ™‚åŠ è¼‰"""
    def __init__(self, module_name: str, attr_name: str = None):
        self._module_name = module_name
        self._attr_name = attr_name
        self._loaded = None
    
    def _load(self):
        if self._loaded is None:
            module = _get_module(self._module_name)
            if self._attr_name:
                self._loaded = getattr(module, self._attr_name, module)
            else:
                self._loaded = module
        return self._loaded
    
    def __getattr__(self, name):
        return getattr(self._load(), name)
    
    def __call__(self, *args, **kwargs):
        return self._load()(*args, **kwargs)


# ğŸ”§ å‘å¾Œå…¼å®¹çš„å»¶é²ä»£ç†
# Telegram æœå‹™
private_message_poller = _LazyModuleProxy('private_message_poller', 'private_message_poller')
group_join_service = _LazyModuleProxy('group_join_service', 'group_join_service')
member_extraction_service = _LazyModuleProxy('member_extraction_service', 'member_extraction_service')

# AI æœå‹™
ai_context = _LazyModuleProxy('ai_context_manager', 'ai_context')
ai_auto_chat = _LazyModuleProxy('ai_auto_chat', 'ai_auto_chat')
vector_memory = _LazyModuleProxy('vector_memory', 'vector_memory')
auto_funnel = _LazyModuleProxy('auto_funnel_manager', 'auto_funnel')

# ç›£æ§æœå‹™
connection_monitor = _LazyModuleProxy('connection_monitor', 'connection_monitor')
resource_discovery = _LazyModuleProxy('resource_discovery', 'resource_discovery')
discussion_watcher = _LazyModuleProxy('discussion_watcher', 'discussion_watcher')

# æœç´¢æœå‹™
group_search_service = _LazyModuleProxy('group_search_service', 'group_search_service')
jiso_search_service = _LazyModuleProxy('jiso_search_service', 'jiso_search_service')

# ç‡ŸéŠ·æœå‹™
marketing_outreach_service = _LazyModuleProxy('marketing_outreach_service', 'marketing_outreach_service')

# èª¿åº¦å™¨
scheduler = _LazyModuleProxy('scheduler', 'scheduler')


# å»¶é²åŠ è¼‰çš„åˆå§‹åŒ–å‡½æ•¸ç²å–å™¨
def get_init_group_poller():
    return _get_module('group_message_poller').init_group_poller

def get_group_poller():
    return _get_module('group_message_poller').get_group_poller

def get_init_qr_auth_manager():
    return _get_module('qr_auth_manager').init_qr_auth_manager

def get_qr_auth_manager_func():
    return _get_module('qr_auth_manager').get_qr_auth_manager

def get_init_ip_binding_manager():
    return _get_module('ip_binding_manager').init_ip_binding_manager

def get_ip_binding_manager_func():
    return _get_module('ip_binding_manager').get_ip_binding_manager

def get_init_performance_monitor():
    return _get_module('performance_monitor').init_performance_monitor

def get_init_search_engine():
    return _get_module('fulltext_search').init_search_engine

def get_search_engine():
    return _get_module('fulltext_search').get_search_engine

def get_init_batch_operations():
    return _get_module('batch_operations').init_batch_operations

def get_batch_ops():
    return _get_module('batch_operations').get_batch_ops

def get_init_credential_scraper():
    return _get_module('credential_scraper').init_credential_scraper

def get_credential_scraper():
    return _get_module('credential_scraper').get_credential_scraper

def get_init_ad_template_manager():
    return _get_module('ad_template').init_ad_template_manager

def get_ad_template_manager():
    return _get_module('ad_template').get_ad_template_manager

def get_init_ad_manager():
    return _get_module('ad_manager').init_ad_manager

def get_ad_manager():
    return _get_module('ad_manager').get_ad_manager

def get_init_ad_broadcaster():
    return _get_module('ad_broadcaster').init_ad_broadcaster

def get_ad_broadcaster():
    return _get_module('ad_broadcaster').get_ad_broadcaster

def get_init_ad_scheduler():
    return _get_module('ad_scheduler').init_ad_scheduler

def get_ad_scheduler():
    return _get_module('ad_scheduler').get_ad_scheduler

def get_init_ad_analytics():
    return _get_module('ad_analytics').init_ad_analytics

def get_ad_analytics():
    return _get_module('ad_analytics').get_ad_analytics

def get_init_user_tracker():
    return _get_module('user_tracker').init_user_tracker

def get_user_tracker():
    return _get_module('user_tracker').get_user_tracker

def get_init_user_analytics():
    return _get_module('user_analytics').init_user_analytics

def get_user_analytics():
    return _get_module('user_analytics').get_user_analytics

def get_init_campaign_orchestrator():
    return _get_module('campaign_orchestrator').init_campaign_orchestrator

def get_campaign_orchestrator():
    return _get_module('campaign_orchestrator').get_campaign_orchestrator

def get_init_multi_channel_stats():
    return _get_module('multi_channel_stats').init_multi_channel_stats

def get_multi_channel_stats():
    return _get_module('multi_channel_stats').get_multi_channel_stats

def get_init_marketing_task_service():
    return _get_module('marketing_task_service').init_marketing_task_service

def get_marketing_task_service():
    return _get_module('marketing_task_service').get_marketing_task_service

def get_init_script_engine():
    return _get_module('script_engine').init_script_engine

def get_script_engine():
    return _get_module('script_engine').get_script_engine

def get_init_collaboration_coordinator():
    return _get_module('collaboration_coordinator').init_collaboration_coordinator

def get_collaboration_coordinator():
    return _get_module('collaboration_coordinator').get_collaboration_coordinator

def get_multi_role_manager():
    return _get_module('multi_role_manager').get_multi_role_manager


# å…¶ä»–æ¨¡å¡Šåˆå§‹åŒ–å‡½æ•¸
def get_init_alert_manager():
    return _get_module('alert_manager').init_alert_manager

def get_init_db_optimizer():
    return _get_module('db_optimizer').init_db_optimizer

def get_init_memory_monitor():
    return _get_module('memory_monitor').init_memory_monitor

def get_init_group_poller():
    return _get_module('group_message_poller').init_group_poller


# é¡å‹æç¤ºçš„é¡ç²å–å™¨
def get_QRAuthManager():
    return _get_module('qr_auth_manager').QRAuthManager

def get_IPBindingManager():
    return _get_module('ip_binding_manager').IPBindingManager

def get_CredentialScraper():
    return _get_module('credential_scraper').CredentialScraper

def get_EnhancedHealthMonitor():
    return _get_module('enhanced_health_monitor').EnhancedHealthMonitor

def get_Anomaly():
    return _get_module('enhanced_health_monitor').Anomaly

def get_BatchOperationManager():
    return _get_module('batch_operations').BatchOperationManager

def get_SpintaxGenerator():
    return _get_module('ad_template').SpintaxGenerator

def get_GroupJoinService():
    return _get_module('group_join_service').GroupJoinService

def get_MemberExtractionService():
    return _get_module('member_extraction_service').MemberExtractionService

def get_VectorMemorySystem():
    return _get_module('vector_memory').VectorMemorySystem

def get_AutoFunnelManager():
    return _get_module('auto_funnel_manager').AutoFunnelManager

def get_DiscoveredResource():
    return _get_module('resource_discovery').DiscoveredResource

def get_MarketingOutreachService():
    return _get_module('marketing_outreach_service').MarketingOutreachService

def get_TaskScheduler():
    return _get_module('scheduler').TaskScheduler

def get_QueueOptimizer():
    return _get_module('queue_optimizer').QueueOptimizer

def get_BackupManager():
    return _get_module('backup_manager').BackupManager

def get_ProxyManager():
    return _get_module('proxy_manager').ProxyManager

def get_ProxyConfig():
    return _get_module('proxy_manager').ProxyConfig

def get_WarmupManager():
    return _get_module('warmup_manager').WarmupManager

def get_ProxyRotationManager():
    return _get_module('proxy_rotation_manager').ProxyRotationManager

def get_RotationReason():
    return _get_module('proxy_rotation_manager').RotationReason

def get_ProxyRotationConfig():
    return _get_module('proxy_rotation_manager').ProxyRotationConfig

def get_BehaviorSimulator():
    return _get_module('behavior_simulator').BehaviorSimulator

def get_BehaviorConfig():
    return _get_module('behavior_simulator').BehaviorConfig

def get_DeviceFingerprintGenerator():
    return _get_module('device_fingerprint').DeviceFingerprintGenerator


# éŒ¯èª¤æ¢å¾©æ¨¡å¡Šï¼ˆå»¶é²åŠ è¼‰ï¼‰
def get_ErrorRecoveryManager():
    try:
        return _get_module('error_recovery_manager').ErrorRecoveryManager
    except:
        return None

RecoveryAction = None
ErrorCategory = None


# ğŸ†• Phase 2: å‘½ä»¤è·¯ç”±å™¨æ•´åˆï¼ˆå»¶é²æª¢æ¸¬ï¼‰
ROUTER_AVAILABLE = False
def check_router_available():
    global ROUTER_AVAILABLE
    try:
        from api.router_integration import setup_command_router, try_route_command
        ROUTER_AVAILABLE = True
        return True
    except ImportError as e:
        print(f"[Backend] Command router not available: {e}", file=sys.stderr)
        ROUTER_AVAILABLE = False
        return False


# ğŸ†• Phase 8: ä½¿ç”¨çµ±ä¸€çš„æ—¥èªŒè„«æ•å·¥å…·ï¼ˆå»¶é²å°å…¥ï¼‰
def get_mask_phone():
    from core.logging import mask_phone
    return mask_phone

def get_mask_sensitive():
    from core.logging import mask_sensitive
    return mask_sensitive

# å…¼å®¹æ€§åˆ¥å
def mask_phone(phone):
    return get_mask_phone()(phone)

def mask_sensitive_log(data):
    return get_mask_sensitive()(data)


# ========== å…§å­˜å„ªåŒ–ç‹€æ…‹å ±å‘Š ==========
print(f"[Backend] ğŸš€ Phase 3 å…§å­˜å„ªåŒ–å·²å•Ÿç”¨", file=sys.stderr)
print(f"[Backend] ğŸ“Š å·²è¨»å†Š {len(lazy_imports._modules)} å€‹å»¶é²åŠ è¼‰æ¨¡å¡Š", file=sys.stderr)


class BackendService:
    """Main backend service handling commands and events"""
    
    def __init__(self):
        self.is_monitoring = False
        self.running = True
        self.telegram_manager = TelegramClientManager(event_callback=self.send_event)
        self.background_tasks = []  # Track background tasks
        self.last_reset_date = None  # Track last daily reset date
        
        # Initialize message queue (will be connected to database in initialize())
        self.message_queue = None
        self.alert_manager = None
        
        # Proxy rotation manager (will be initialized in initialize())
        self.proxy_rotation_manager: Optional[ProxyRotationManager] = None
        
        # Enhanced health monitor (will be initialized in initialize())
        self.enhanced_health_monitor: Optional[EnhancedHealthMonitor] = None
        
        # Queue optimizer (will be initialized in initialize())
        self.queue_optimizer: Optional[QueueOptimizer] = None
        
        # Error recovery manager (will be initialized in initialize())
        self.error_recovery_manager: Optional[ErrorRecoveryManager] = None
        
        # Backup manager (will be initialized in initialize())
        self.backup_manager: Optional[Any] = None
        
        # Smart alert manager (will be initialized in initialize())
        self.smart_alert_manager: Optional[Any] = None
        
        # QR Auth Manager for QR code login
        self.qr_auth_manager: Optional[QRAuthManager] = None
        
        # IP Binding Manager for IP stickiness (Phase 2)
        self.ip_binding_manager: Optional[IPBindingManager] = None
        
        # Credential Scraper for native API credentials (Phase 2)
        self.credential_scraper: Optional[CredentialScraper] = None

        # Cache for frequently accessed data (TTL: 30 seconds)
        # ğŸ”§ Phase 1 å„ªåŒ–ï¼šæ·»åŠ ç·©å­˜å¤§å°é™åˆ¶
        self._cache: Dict[str, Any] = {}
        self._cache_timestamps: Dict[str, datetime] = {}
        self._cache_ttl = timedelta(seconds=30)
        self._max_cache_size = 500  # æœ€å¤šç·©å­˜ 500 å€‹æ¢ç›®
    
    def _invalidate_cache(self, cache_key: str):
        """Invalidate a specific cache entry"""
        self._cache.pop(cache_key, None)
        self._cache_timestamps.pop(cache_key, None)
    
    def _cleanup_cache(self):
        """ğŸ”§ Phase 1 å„ªåŒ–ï¼šæ¸…ç†éæœŸå’Œè¶…å‡ºé™åˆ¶çš„ç·©å­˜"""
        now = datetime.now()
        
        # 1. æ¸…ç†éæœŸæ¢ç›®
        expired_keys = [
            key for key, ts in self._cache_timestamps.items()
            if now - ts > self._cache_ttl
        ]
        for key in expired_keys:
            self._invalidate_cache(key)
        
        # 2. å¦‚æœä»è¶…å‡ºé™åˆ¶ï¼Œç§»é™¤æœ€èˆŠçš„æ¢ç›®
        if len(self._cache) > self._max_cache_size:
            sorted_keys = sorted(
                self._cache_timestamps.keys(),
                key=lambda k: self._cache_timestamps.get(k, datetime.min)
            )
            keys_to_remove = sorted_keys[:len(self._cache) - self._max_cache_size + 50]
            for key in keys_to_remove:
                self._invalidate_cache(key)
    
    async def initialize(self):
        """Initialize the backend service"""
        # ç¢ºä¿ sys åœ¨å‡½æ•¸é–‹é ­å°å…¥ï¼ˆé¿å…å¾ŒçºŒ import sys å°è‡´çš„ UnboundLocalErrorï¼‰
        import sys
        import traceback
        import time
        
        init_start_time = time.time()
        print("[Backend] ========== Starting initialization ==========", file=sys.stderr)
        
        # Initialize error handler
        def error_log_callback(error_type: str, message: str, details: Dict[str, Any]):
            """Callback for error logging"""
            log_type = "error"
            if error_type == ErrorType.NETWORK_ERROR.value:
                log_type = "warning"
            elif error_type == ErrorType.VALIDATION_ERROR.value:
                log_type = "warning"
            
            self.send_log(f"[{error_type}] {message}", log_type)
        
        init_error_handler(error_log_callback)
        
        # Initialize acknowledgment manager
        await init_ack_manager()
        
        # Initialize performance monitor
        def performance_event_callback(event_type: str, data: Any):
            """Callback for performance events"""
            if event_type == "performance-metric":
                # Send metric to frontend
                self.send_event("performance-metric", data)
            elif event_type == "performance-alert":
                # Send alert to frontend
                self.send_event("performance-alert", data)
                # Also log as warning
                alerts = data.get("alerts", [])
                if alerts:
                    self.send_log(f"Performance alert: {', '.join(alerts)}", "warning")
        
        performance_monitor = get_init_performance_monitor()(performance_event_callback)
        await performance_monitor.start()
        
        # Initialize cache manager
        cache_manager = init_cache_manager(default_ttl=300)  # 5åˆ†é˜é»˜èªTTL
        await cache_manager.start_cleanup_task()
        self.send_log("Cache manager initialized", "info")
        
        # Initialize database
        await db.initialize()
        await db.connect()
        
        # Initialize full-text search engine
        try:
            from config import DATABASE_PATH
            search_engine = get_init_search_engine()(str(DATABASE_PATH))
            # ç•°æ­¥é‡å»ºç´¢å¼•ï¼ˆä¸é˜»å¡å•Ÿå‹•ï¼‰ï¼Œå¦‚æœè³‡æ–™åº«æå£å‰‡è·³é
            async def safe_rebuild_index():
                try:
                    await search_engine.rebuild_index()
                except Exception as e:
                    error_str = str(e).lower()
                    if "malformed" in error_str or "corrupt" in error_str or "database disk image" in error_str:
                        import sys
                        print(f"[Backend] Database corruption detected, skipping search index rebuild: {e}", file=sys.stderr)
                        self.send_log("è³‡æ–™åº«æå£ï¼Œè·³éæœç´¢ç´¢å¼•é‡å»º", "warning")
                    else:
                        import sys
                        print(f"[Backend] Error rebuilding search index: {e}", file=sys.stderr)
            asyncio.create_task(safe_rebuild_index())
            self.send_log("å…¨æ–‡æœç´¢å¼•æ“å·²åˆå§‹åŒ–", "success")
        except Exception as e:
            import sys
            print(f"[Backend] Failed to initialize search engine: {e}", file=sys.stderr)
            self.send_log(f"å…¨æ–‡æœç´¢å¼•æ“åˆå§‹åŒ–å¤±æ•—: {str(e)}", "warning")
        
        # Initialize migration manager (after database is ready)
        from migrations.migration_manager import init_migration_manager, get_migration_manager
        from pathlib import Path
        try:
            # é¦–å…ˆå»ºç«‹ç•°æ­¥æ•¸æ“šåº«é€£æ¥ï¼ˆé·ç§»ç³»çµ±éœ€è¦ï¼‰
            await db.connect()
            print("[Backend] Async database connection established for migrations", file=sys.stderr)
            
            migrations_dir = Path(__file__).parent / "migrations"
            init_migration_manager(db, migrations_dir)
            migration_manager = get_migration_manager()
            if migration_manager:
                await migration_manager.initialize()
                # ğŸ”§ P0: å„ªåŒ– - åªæª¢æŸ¥ç‰ˆæœ¬ï¼Œè¿ç§»åœ¨å¾Œå°åŸ·è¡Œï¼ˆä¸é˜»å¡å•Ÿå‹•ï¼‰
                current_version = await migration_manager.get_current_version()
                pending = await migration_manager.get_pending_migrations()
                print(f"[Backend] Database version: {current_version}, pending migrations: {len(pending)}", file=sys.stderr)
                if pending:
                    self.send_log(f"Found {len(pending)} pending migration(s), running in background...", "info")
                    # ğŸ”§ P0: å¾Œå°åŸ·è¡Œé·ç§»ï¼Œä¸é˜»å¡å•Ÿå‹•
                    async def background_migrate():
                        try:
                            success = await migration_manager.migrate()
                            if success:
                                self.send_log("âœ“ Migrations applied successfully", "success")
                            else:
                                self.send_log("âš  Some migrations completed with warnings", "warning")
                        except Exception as mig_err:
                            import sys
                            print(f"[Backend] Background migration error: {mig_err}", file=sys.stderr)
                            self.send_log(f"âš  Migration error: {str(mig_err)[:100]}", "warning")
                    asyncio.create_task(background_migrate())
                else:
                    print(f"[Backend] Database is up to date (version {current_version})", file=sys.stderr)
        except Exception as e:
            import traceback
            print(f"[Backend] Error initializing migration system: {e}", file=sys.stderr)
            traceback.print_exc(file=sys.stderr)
            self.send_log(f"é·ç§»ç³»çµ±åˆå§‹åŒ–å¤±æ•—: {str(e)}", "warning")
        
        # Initialize alert manager (after database is ready)
        def alert_notification_callback(alert):
            """Callback for alert notifications"""
            # Send alert to frontend
            self.send_event("alert-triggered", {
                "id": alert.id,
                "type": alert.alert_type.value,
                "level": alert.level.value,
                "message": alert.message,
                "details": alert.details,
                "timestamp": alert.timestamp.isoformat()
            })
            # Also log
            log_type = "warning" if alert.level.value in ["warning", "info"] else "error"
            self.send_log(f"[å‘Šè­¦] {alert.message}", log_type)
        
        self.alert_manager = get_init_alert_manager()(db, alert_notification_callback)
        await self.alert_manager.start()
        
        # ========== å„ªåŒ–ï¼šå»¶é²åŸ·è¡Œå‚™ä»½å’Œæ¸…ç†ä»»å‹™ï¼ˆä¸é˜»å¡å•Ÿå‹•ï¼‰ ==========
        async def delayed_maintenance_tasks():
            """å»¶é²åŸ·è¡Œçš„ç¶­è­·ä»»å‹™ï¼Œé¿å…é˜»å¡å•Ÿå‹•"""
            await asyncio.sleep(5)  # ç­‰å¾… 5 ç§’å¾Œå†åŸ·è¡Œï¼Œç¢ºä¿æ‡‰ç”¨å·²å®Œæˆè¼‰å…¥
            
            # å•Ÿå‹•å‚™ä»½ï¼ˆå»¶é²åŸ·è¡Œï¼‰
            if self.backup_manager:
                try:
                    await self.backup_manager.create_backup(backup_type='startup', compress=True)
                    self.send_log("âœ“ å•Ÿå‹•å‚™ä»½å·²å‰µå»ºï¼ˆå»¶é²ï¼‰", "success")
                except Exception as e:
                    self.send_log(f"å•Ÿå‹•å‚™ä»½å¤±æ•—: {str(e)}", "warning")
            
            # æ¸…ç†èˆŠå‚™ä»½
            try:
                removed_count = backup_manager.cleanup_old_backups()
                if removed_count > 0:
                    self.send_log(f"Cleaned up {removed_count} old backup(s)", "info")
            except Exception as e:
                pass  # éœé»˜è™•ç†æ¸…ç†éŒ¯èª¤
            
            # æ—¥èªŒè¼ªè½‰å’Œæ¸…ç†
            try:
                log_rotator = get_log_rotator()
                rotated_files = log_rotator.rotate_all_logs()
                if rotated_files:
                    self.send_log(f"Rotated {len(rotated_files)} log file(s)", "info")
                
                removed_logs = log_rotator.cleanup_old_logs()
                if removed_logs > 0:
                    self.send_log(f"Cleaned up {removed_logs} old log file(s)", "info")
            except Exception as e:
                pass  # éœé»˜è™•ç†è¼ªè½‰éŒ¯èª¤
            
            # ğŸ”§ Phase 1 å„ªåŒ–ï¼šé¦–æ¬¡ GC æ¸…ç†
            gc.collect()
            self.send_log("âœ“ åˆå§‹åƒåœ¾å›æ”¶å®Œæˆ", "info")
            
            # ğŸ”§ Phase 3 å„ªåŒ–ï¼šæ•¸æ“šåº«ç´¢å¼•å„ªåŒ–
            try:
                from config import DATABASE_PATH
                optimizer = await get_init_db_optimizer()(str(DATABASE_PATH))
                index_result = await optimizer.create_indexes()
                if index_result.get('total_created', 0) > 0:
                    self.send_log(f"âœ“ å‰µå»ºäº† {index_result['total_created']} å€‹æ•¸æ“šåº«ç´¢å¼•", "info")
            except Exception as e:
                print(f"[Backend] æ•¸æ“šåº«ç´¢å¼•å„ªåŒ–å¤±æ•—: {e}", file=sys.stderr)
        
        # ğŸ”§ Phase 1+2 å„ªåŒ–ï¼šå®šæ™‚å…§å­˜æ¸…ç†ä»»å‹™
        async def periodic_memory_cleanup():
            """å®šæ™‚å…§å­˜æ¸…ç†ä»»å‹™ï¼Œæ¯ 5 åˆ†é˜åŸ·è¡Œä¸€æ¬¡"""
            while True:
                await asyncio.sleep(300)  # 5 åˆ†é˜
                try:
                    # 1. æ¸…ç†ç·©å­˜
                    self._cleanup_cache()
                    
                    # 2. ğŸ”§ Phase 2: æ¸…ç†é–’ç½®çš„ Telegram å®¢æˆ¶ç«¯
                    if self.telegram_manager:
                        idle_cleaned = await self.telegram_manager.cleanup_idle_clients()
                        if idle_cleaned > 0:
                            print(f"[MemoryCleanup] å·²æ¸…ç† {idle_cleaned} å€‹é–’ç½®å®¢æˆ¶ç«¯", file=sys.stderr)
                    
                    # 3. å¼·åˆ¶åƒåœ¾å›æ”¶
                    collected = gc.collect()
                    
                    # 4. è¨˜éŒ„å…§å­˜ä½¿ç”¨æƒ…æ³
                    try:
                        import psutil
                        process = psutil.Process()
                        memory_mb = process.memory_info().rss / 1024 / 1024
                        print(f"[MemoryCleanup] GC å›æ”¶ {collected} å€‹å°è±¡ï¼Œç•¶å‰å…§å­˜: {memory_mb:.1f}MB", file=sys.stderr)
                    except ImportError:
                        print(f"[MemoryCleanup] GC å›æ”¶ {collected} å€‹å°è±¡", file=sys.stderr)
                except Exception as e:
                    print(f"[MemoryCleanup] æ¸…ç†å¤±æ•—: {e}", file=sys.stderr)
        
        # ğŸ”§ Phase 3 å„ªåŒ–ï¼šæ¯æ—¥æ•¸æ“šåº«ç¶­è­·ä»»å‹™
        async def daily_db_maintenance():
            """æ¯æ—¥æ•¸æ“šåº«ç¶­è­·ä»»å‹™"""
            await asyncio.sleep(3600)  # é¦–æ¬¡å»¶é² 1 å°æ™‚åŸ·è¡Œ
            while True:
                try:
                    from db_optimizer import get_db_optimizer
                    optimizer = get_db_optimizer()
                    if optimizer:
                        # æ¸…ç†éæœŸæ•¸æ“š
                        cleanup_result = await optimizer.cleanup_expired_data()
                        total = cleanup_result.get('total_cleaned', 0)
                        if total > 0:
                            print(f"[DBMaintenance] æ¸…ç†äº† {total} æ¢éæœŸæ•¸æ“š", file=sys.stderr)
                        
                        # æ›´æ–°çµ±è¨ˆä¿¡æ¯
                        await optimizer.analyze()
                except Exception as e:
                    print(f"[DBMaintenance] ç¶­è­·å¤±æ•—: {e}", file=sys.stderr)
                
                await asyncio.sleep(86400)  # 24 å°æ™‚
        
        # å‰µå»ºå¾Œå°ä»»å‹™ï¼ˆä¸ç­‰å¾…å®Œæˆï¼‰
        asyncio.create_task(delayed_maintenance_tasks())
        asyncio.create_task(periodic_memory_cleanup())
        asyncio.create_task(daily_db_maintenance())
        
        # ğŸ”§ Phase 2 å„ªåŒ–ï¼šåˆå§‹åŒ–å…§å­˜ç›£æ§å™¨
        try:
            async def memory_cleanup_callback():
                """å…§å­˜ç·Šæ€¥æ¸…ç†å›èª¿"""
                self._cleanup_cache()
                if self.telegram_manager:
                    await self.telegram_manager.cleanup_idle_clients()
            
            await get_init_memory_monitor()(
                event_callback=self.send_event,
                cleanup_callback=memory_cleanup_callback
            )
            print("[Backend] âœ“ å…§å­˜ç›£æ§å™¨å·²å•Ÿå‹•", file=sys.stderr)
        except Exception as e:
            print(f"[Backend] âš  å…§å­˜ç›£æ§å™¨åˆå§‹åŒ–å¤±æ•—: {e}", file=sys.stderr)
        
        # Initialize queue optimizer (æ¶ˆæ¯å‘é€é˜Ÿåˆ—ä¼˜åŒ–)
        self.queue_optimizer = get_QueueOptimizer()(
            max_batch_size=10,
            batch_interval_seconds=5.0,
            min_send_interval=2.0,
            max_send_interval=10.0
        )
        
        # Initialize message queue with database and optimizer
        self.message_queue = MessageQueue(
            send_callback=self._queue_send_callback,
            database=db,
            optimizer=self.queue_optimizer
        )
        
        # ========== å„ªåŒ–ï¼šä¸¦è¡Œåˆå§‹åŒ–å­ç³»çµ± ==========
        import time
        parallel_init_start = time.time()
        print("[Backend] Starting parallel subsystem initialization...", file=sys.stderr)
        
        # ç¬¬ä¸€æ‰¹ä¸¦è¡Œåˆå§‹åŒ–ï¼ˆæ ¸å¿ƒç®¡ç†å™¨ï¼‰
        await asyncio.gather(
            self._initialize_proxy_rotation_manager(),      # æ™ºèƒ½ä»£ç†è½®æ¢
            self._initialize_enhanced_health_monitor(),     # è´¦æˆ·å¥åº·ç›‘æ§å¢å¼º
            self._initialize_error_recovery(),              # é”™è¯¯æ¢å¤å’Œè‡ªåŠ¨é‡è¯•
            self._initialize_auto_funnel(),                 # å…¨è‡ªåŠ¨é”€å”®æ¼æ–—
            self._initialize_ai_auto_chat(),                # AIè‡ªåŠ¨èŠå¤©
            self._initialize_vector_memory(),               # å‘é‡åŒ–è®°å¿†ç³»ç»Ÿ
            return_exceptions=True  # é˜²æ­¢å–®å€‹å¤±æ•—å½±éŸ¿å…¶ä»–
        )
        
        # ç¬¬äºŒæ‰¹ä¸¦è¡Œåˆå§‹åŒ–ï¼ˆæ¥­å‹™ç³»çµ±ï¼Œä¾è³´ç¬¬ä¸€æ‰¹ï¼‰
        await asyncio.gather(
            self._initialize_scheduler(),                   # è‡ªåŠ¨åŒ–ä»»åŠ¡è°ƒåº¦å™¨
            self._initialize_batch_operations(),            # æ‰¹é‡æ“ä½œç³»çµ±
            self._initialize_ad_system(),                   # å»£å‘Šç™¼é€ç³»çµ±
            self._initialize_user_tracking(),               # ç”¨æˆ¶è¿½è¹¤ç³»çµ±
            self._initialize_campaign_system(),             # ç‡ŸéŠ·æ´»å‹•å”èª¿å™¨
            self._initialize_multi_role_system(),           # å¤šè§’è‰²å”ä½œç³»çµ±
            return_exceptions=True
        )
        
        parallel_init_duration = time.time() - parallel_init_start
        print(f"[Backend] âœ“ Parallel subsystem initialization completed in {parallel_init_duration:.3f}s", file=sys.stderr)
        
        # ğŸ†• Phase 2: åˆå§‹åŒ–å‘½ä»¤è·¯ç”±å™¨
        if ROUTER_AVAILABLE:
            try:
                router = setup_command_router(self)
                print(f"[Backend] âœ“ Command router initialized with {len(router.get_commands())} commands", file=sys.stderr)
            except Exception as e:
                print(f"[Backend] âš  Command router initialization failed: {e}", file=sys.stderr)
        
        # Register private message handlers for already logged-in Sender accounts
        await self._register_existing_sender_handlers()
        
        # ========== å„ªåŒ–ï¼šå¾Œå°åŸ·è¡Œéé—œéµå•Ÿå‹•ä»»å‹™ ==========
        async def background_startup_tasks():
            """å¾Œå°åŸ·è¡Œçš„éé—œéµå•Ÿå‹•ä»»å‹™ï¼Œä¸é˜»å¡ä¸»å•Ÿå‹•æµç¨‹"""
            await asyncio.sleep(2)  # ç­‰å¾…ä¸»è¦åˆå§‹åŒ–å®Œæˆ
            
            # Sync leads to user_profiles (one-time migration)
            try:
                await self._sync_leads_to_user_profiles()
            except Exception as e:
                import sys
                print(f"[Backend] Background sync leads error: {e}", file=sys.stderr)
            
            # ä¸€è‡´æ€§æª¢æŸ¥ï¼ˆå¾Œå°åŸ·è¡Œï¼‰
            try:
                await self._startup_consistency_check()
            except Exception as e:
                import sys
                print(f"[Backend] Background consistency check error: {e}", file=sys.stderr)
        
        # å‰µå»ºå¾Œå°ä»»å‹™ï¼ˆä¸ç­‰å¾…å®Œæˆï¼‰
        asyncio.create_task(background_startup_tasks())
        
        total_init_time = time.time() - init_start_time
        print(f"[Backend] ========== Initialization complete in {total_init_time:.3f}s ==========", file=sys.stderr)
        self.send_log(f"âœ“ å¾Œç«¯åˆå§‹åŒ–å®Œæˆ ({total_init_time:.2f}s)", "success")
        
        # ğŸ†• ç™¼é€æ•¸æ“šè·¯å¾‘ä¿¡æ¯åˆ°å‰ç«¯ï¼ˆä¾¿æ–¼èª¿è©¦ï¼‰
        try:
            from config import DATABASE_DIR, DATABASE_PATH, SESSIONS_DIR, IS_DEV_MODE
            data_info = {
                "isDevMode": IS_DEV_MODE,
                "databaseDir": str(DATABASE_DIR),
                "databasePath": str(DATABASE_PATH),
                "sessionsDir": str(SESSIONS_DIR),
                "databaseExists": DATABASE_PATH.exists()
            }
            self.send_event("data-paths-info", data_info)
            
            mode_str = "é–‹ç™¼æ¨¡å¼" if IS_DEV_MODE else "ç”Ÿç”¢æ¨¡å¼"
            self.send_log(f"ğŸ“ {mode_str} - æ•¸æ“šç›®éŒ„: {DATABASE_DIR}", "info")
            
            # ğŸ†• æª¢æ¸¬æ˜¯å¦æœ‰å…¶ä»–ä½ç½®çš„æ•¸æ“šéœ€è¦é·ç§»
            if IS_DEV_MODE:
                # é–‹ç™¼æ¨¡å¼ä¸‹ï¼Œæª¢æŸ¥ AppData æ˜¯å¦æœ‰æ•¸æ“š
                import os
                appdata_path = os.environ.get('TG_DATA_DIR', '')
                if appdata_path:
                    appdata_db = Path(appdata_path) / "tgmatrix.db"
                    if appdata_db.exists() and not DATABASE_PATH.exists():
                        self.send_log(f"âš ï¸ ç™¼ç¾ AppData ä¸­æœ‰æ•¸æ“šåº«ï¼Œä½†æœ¬åœ°ç›®éŒ„ç‚ºç©ºã€‚å¯èƒ½éœ€è¦é·ç§»æ•¸æ“šã€‚", "warning")
                        self.send_event("data-migration-hint", {
                            "sourceDir": appdata_path,
                            "targetDir": str(DATABASE_DIR),
                            "message": "ç™¼ç¾å…¶ä»–ä½ç½®æœ‰æ•¸æ“šï¼Œæ˜¯å¦éœ€è¦é·ç§»ï¼Ÿ"
                        })
        except Exception as e:
            print(f"[Backend] Error sending data paths info: {e}", file=sys.stderr)
    
    async def _sync_leads_to_user_profiles(self):
        """åŒæ­¥ç¾æœ‰çš„ leads åˆ° user_profiles è¡¨"""
        try:
            # å…ˆç¢ºä¿ user_profiles è¡¨å­˜åœ¨
            await db._connection.execute("""
                CREATE TABLE IF NOT EXISTS user_profiles (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id TEXT UNIQUE NOT NULL,
                    username TEXT,
                    first_name TEXT,
                    last_name TEXT,
                    funnel_stage TEXT DEFAULT 'new',
                    interest_level INTEGER DEFAULT 1,
                    last_interaction TEXT,
                    notes TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)
            await db._connection.commit()
            
            leads = await db.get_all_leads()
            synced_count = 0
            
            for lead in leads:
                user_id = str(lead.get('userId', lead.get('user_id', '')))
                if not user_id:
                    continue
                    
                # æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
                profile = await db.get_user_profile(user_id)
                if not profile:
                    await db._connection.execute("""
                        INSERT INTO user_profiles 
                        (user_id, username, first_name, last_name, funnel_stage, interest_level, created_at)
                        VALUES (?, ?, ?, ?, 'new', 1, CURRENT_TIMESTAMP)
                    """, (
                        user_id,
                        lead.get('username', ''),
                        lead.get('firstName', lead.get('first_name', '')),
                        lead.get('lastName', lead.get('last_name', ''))
                    ))
                    synced_count += 1
            
            if synced_count > 0:
                await db._connection.commit()
                self.send_log(f"ğŸ“Š å·²åŒæ­¥ {synced_count} å€‹ Lead åˆ°æ¼æ–—ç³»çµ±", "info")
                
        except Exception as e:
            import sys
            print(f"[Backend] Error syncing leads to user_profiles: {e}", file=sys.stderr)
    
    async def _startup_consistency_check(self):
        """
        å•Ÿå‹•æ™‚ä¸€è‡´æ€§æª¢æŸ¥ï¼š
        1. æƒææœ‰ session æ–‡ä»¶ä½†ç„¡æ•¸æ“šåº«è¨˜éŒ„çš„ã€Œå­¤ç«‹ã€å¸³è™Ÿ
        2. å˜—è©¦ä½¿ç”¨ metadata.json è‡ªå‹•æ¢å¾©
        3. å‘å‰ç«¯ç™¼é€æ¢å¾©æç¤ºäº‹ä»¶
        """
        import sys
        import json
        from pathlib import Path
        from config import SESSIONS_DIR
        
        try:
            print("[Backend] Starting consistency check...", file=sys.stderr)
            
            # ç²å–æ‰€æœ‰ session æ–‡ä»¶
            session_files = list(SESSIONS_DIR.glob("*.session"))
            
            if not session_files:
                print("[Backend] No session files found, skipping consistency check", file=sys.stderr)
                return
            
            # ç²å–æ•¸æ“šåº«ä¸­çš„å¸³è™Ÿ
            existing_accounts = await db.get_all_accounts()
            existing_phones = set()
            for acc in existing_accounts:
                phone = acc.get('phone', '')
                safe_phone = phone.replace("+", "").replace("-", "").replace(" ", "")
                existing_phones.add(safe_phone)
                existing_phones.add(phone)
            
            # æŸ¥æ‰¾å­¤ç«‹çš„ session
            orphan_sessions = []
            auto_recoverable = []
            
            for session_file in session_files:
                phone = session_file.stem
                # è·³éè‡¨æ™‚æ–‡ä»¶
                if phone.endswith('-journal') or phone.startswith('.'):
                    continue
                
                # æª¢æŸ¥æ˜¯å¦åœ¨æ•¸æ“šåº«ä¸­
                if phone not in existing_phones and f"+{phone}" not in existing_phones:
                    # æª¢æŸ¥æ˜¯å¦æœ‰ metadata æ–‡ä»¶
                    metadata_path = SESSIONS_DIR / f"{phone}.metadata.json"
                    metadata = None
                    
                    if metadata_path.exists():
                        try:
                            with open(metadata_path, 'r', encoding='utf-8') as f:
                                metadata = json.load(f)
                        except Exception:
                            pass
                    
                    session_info = {
                        "phone": phone,
                        "hasMetadata": metadata is not None,
                        "metadata": metadata
                    }
                    
                    orphan_sessions.append(session_info)
                    
                    if metadata:
                        auto_recoverable.append(session_info)
            
            if orphan_sessions:
                print(f"[Backend] Found {len(orphan_sessions)} orphan session(s), {len(auto_recoverable)} auto-recoverable", file=sys.stderr)
                
                # è‡ªå‹•æ¢å¾©æœ‰ metadata çš„å¸³è™Ÿ
                recovered_count = 0
                for session_info in auto_recoverable:
                    try:
                        metadata = session_info['metadata']
                        phone = metadata.get('phone', f"+{session_info['phone']}")
                        
                        # ä½¿ç”¨ add_account æ–¹æ³•æ’å…¥åˆ°æ­£ç¢ºçš„æ•¸æ“šåº«ï¼ˆtgmatrix.dbï¼‰
                        account_data = {
                            'phone': phone,
                            'apiId': metadata.get('apiId'),
                            'apiHash': metadata.get('apiHash'),
                            'firstName': metadata.get('firstName', ''),
                            'lastName': metadata.get('lastName', ''),
                            'username': metadata.get('username', ''),
                            'telegramId': metadata.get('telegramId', ''),
                            'role': metadata.get('role', 'Unassigned'),
                            'status': 'Offline'
                        }
                        await db.add_account(account_data)
                        recovered_count += 1
                        print(f"[Backend] Auto-recovered account: {mask_phone(phone)}", file=sys.stderr)
                    except Exception as e:
                        print(f"[Backend] Failed to auto-recover {mask_phone(session_info['phone'])}: {e}", file=sys.stderr)
                
                if recovered_count > 0:
                    self.send_log(f"ğŸ”„ å·²è‡ªå‹•æ¢å¾© {recovered_count} å€‹å¸³è™Ÿ", "success")
                
                # é‚„æœ‰ç„¡æ³•è‡ªå‹•æ¢å¾©çš„å¸³è™Ÿï¼Œç™¼é€äº‹ä»¶çµ¦å‰ç«¯
                remaining_orphans = [s for s in orphan_sessions if not s.get('hasMetadata')]
                if remaining_orphans:
                    self.send_event("orphan-sessions-detected", {
                        "count": len(remaining_orphans),
                        "sessions": remaining_orphans,
                        "message": f"ç™¼ç¾ {len(remaining_orphans)} å€‹ç„¡æ³•è‡ªå‹•æ¢å¾©çš„ Session æ–‡ä»¶"
                    })
            else:
                print("[Backend] No orphan sessions found, database is consistent", file=sys.stderr)
                
        except Exception as e:
            import sys
            print(f"[Backend] Error in consistency check: {e}", file=sys.stderr)
    
    async def _register_existing_sender_handlers(self):
        """ç‚ºå·²ç™»éŒ„çš„ç™¼é€å¸³è™Ÿè¨»å†Šç§ä¿¡è™•ç†å™¨"""
        try:
            accounts = await db.get_all_accounts()
            for account in accounts:
                if account.get('status') == 'Online':
                    phone = account.get('phone')
                    account_role = account.get('role', 'Unassigned')
                    try:
                        await self.telegram_manager.register_private_message_handler(
                            phone=phone,
                            account_role=account_role
                        )
                        self.send_log(f"å·²ç‚ºå¸³è™Ÿ {phone} ({account_role}) è¨»å†Šç§ä¿¡è™•ç†å™¨", "info")
                    except Exception as e:
                        self.send_log(f"è¨»å†Šç§ä¿¡è™•ç†å™¨å¤±æ•— ({phone}): {e}", "warning")
        except Exception as e:
            self.send_log(f"è¨»å†Šç¾æœ‰ç™¼é€å¸³è™Ÿè™•ç†å™¨éŒ¯èª¤: {e}", "warning")
    
    async def _initialize_auto_funnel(self):
        """Initialize auto funnel manager"""
        try:
            # Set callbacks
            auto_funnel.set_callbacks(
                send_callback=self._funnel_send_callback,
                log_callback=self.send_log,
                event_callback=self.send_event
            )
            
            # Start auto funnel
            await auto_funnel.start()
            self.send_log("[AutoFunnel] å…¨è‡ªåŠ¨é”€å”®æ¼æ–—å·²å¯åŠ¨", "success")
        except Exception as e:
            self.send_log(f"[AutoFunnel] åˆå§‹åŒ–å¤±è´¥: {e}", "error")
    
    async def _initialize_ai_auto_chat(self):
        """Initialize AI auto chat service"""
        try:
            # Initialize AI auto chat
            await ai_auto_chat.initialize()
            
            # Set callbacks
            async def ai_send_callback(account_phone: str, target_user_id: str, 
                                       message: str, source_group: str = None,
                                       username: str = None):
                """AI è‡ªå‹•å›å¾©ç™¼é€å›èª¿"""
                try:
                    # æª¢æŸ¥ç”¨æˆ¶æ˜¯å¦å·²äº’å‹•ï¼ˆæ±ºå®šæ˜¯å¦è¨ˆå…¥é™é¡ï¼‰
                    has_interacted = await self._user_has_interacted(target_user_id)
                    
                    # æª¢æŸ¥å¸³è™Ÿé™é¡ï¼ˆæœªäº’å‹•ç”¨æˆ¶ï¼‰
                    if not has_interacted:
                        account = await db.get_account_by_phone(account_phone)
                        if account:
                            if account.get('dailySendCount', 0) >= account.get('dailySendLimit', 50):
                                self.send_log(f"å¸³è™Ÿ {account_phone} å·²é”æ¯æ—¥ç™¼é€é™é¡ï¼Œç„¡æ³•è‡ªå‹•å›å¾©", "warning")
                                return False
                    
                    # ä½¿ç”¨æ¶ˆæ¯éšŠåˆ—ç™¼é€
                    # ğŸ”§ FIX: æ·»åŠ  target_username åƒæ•¸
                    await self.message_queue.add_message(
                        phone=account_phone,
                        user_id=target_user_id,
                        text=message,
                        source_group=source_group,
                        target_username=username,  # ğŸ†• ç”¨æˆ¶åå‚™é¸
                        priority=MessagePriority.NORMAL
                    )
                    
                    # æ›´æ–°æ¯æ—¥è¨ˆæ•¸ï¼ˆåƒ…æœªäº’å‹•ç”¨æˆ¶ï¼‰
                    if not has_interacted:
                        account = await db.get_account_by_phone(account_phone)
                        if account:
                            await db.update_account(account.get('id'), {
                                'dailySendCount': account.get('dailySendCount', 0) + 1
                            })
                    
                    # ä¿å­˜ AI å›å¾©åˆ°èŠå¤©æ­·å²
                    await db.add_chat_message(
                        user_id=target_user_id,
                        role='assistant',
                        content=message,
                        account_phone=account_phone,
                        source_group=source_group
                    )
                    
                    return True
                except Exception as e:
                    self.send_log(f"AI è‡ªå‹•å›å¾©ç™¼é€å¤±æ•—: {e}", "error")
                    return False
            
            ai_auto_chat.set_callbacks(
                send_callback=ai_send_callback,
                log_callback=self.send_log,
                event_callback=self.send_event
            )
            
            self.send_log("[AIAutoChat] AI è‡ªå‹•èŠå¤©æœå‹™å·²åˆå§‹åŒ–", "success")
        except Exception as e:
            self.send_log(f"[AIAutoChat] åˆå§‹åŒ–å¤±è´¥: {e}", "error")
    
    async def _funnel_send_callback(self, target_user_id: str, message: str, 
                                     is_follow_up: bool = False, **kwargs):
        """Callback for auto funnel to send messages"""
        try:
            # ğŸ”§ FIX: å¾æ•¸æ“šåº«ç²å–ç”¨æˆ¶çš„ source_group å’Œ username
            source_group = kwargs.get('source_group', '')
            target_username = kwargs.get('username', '')
            
            # å¦‚æœæ²’æœ‰å‚³å…¥ï¼Œå˜—è©¦å¾ leads è¡¨æŸ¥è©¢
            if not source_group or not target_username:
                lead = await db.fetch_one(
                    "SELECT source_group_url, source_group, username FROM leads WHERE user_id = ? ORDER BY id DESC LIMIT 1",
                    (str(target_user_id),)
                )
                if lead:
                    if not source_group:
                        source_group = lead.get('source_group_url') or lead.get('source_group', '')
                    if not target_username:
                        target_username = lead.get('username', '')
            
            # Find an available sender account
            accounts = await db.get_all_accounts()
            sender = None
            for acc in accounts:
                if acc['status'] == 'Online' and acc['role'] == 'Sender':
                    sender = acc
                    break
            
            if not sender:
                # Find any online account
                for acc in accounts:
                    if acc['status'] == 'Online':
                        sender = acc
                        break
            
            if sender:
                await self.message_queue.add_message(
                    phone=sender['phone'],
                    user_id=target_user_id,
                    text=message,
                    source_group=source_group,      # ğŸ†• ä¾†æºç¾¤çµ„
                    target_username=target_username, # ğŸ†• ç”¨æˆ¶åå‚™é¸
                    priority=MessagePriority.NORMAL
                )
                return True
            return False
        except Exception as e:
            self.send_log(f"[AutoFunnel] å‘é€å¤±è´¥: {e}", "error")
            return False
    
    async def _initialize_vector_memory(self):
        """Initialize vector memory system"""
        try:
            await vector_memory.initialize(use_neural=False)  # é»˜è®¤ä½¿ç”¨ç®€å•åµŒå…¥
            self.send_log("[VectorMemory] å‘é‡åŒ–è®°å¿†ç³»ç»Ÿå·²å¯åŠ¨", "success")
        except Exception as e:
            self.send_log(f"[VectorMemory] åˆå§‹åŒ–å¤±è´¥: {e}", "error")
    
    async def _initialize_scheduler(self):
        """Initialize task scheduler"""
        try:
            # Set callbacks
            scheduler.set_log_callback(self.send_log)
            scheduler.set_task_callback('follow_up', self._funnel_send_callback)
            
            # Start scheduler
            await scheduler.start()
            self.send_log("[Scheduler] è‡ªåŠ¨åŒ–ä»»åŠ¡è°ƒåº¦å™¨å·²å¯åŠ¨", "success")
        except Exception as e:
            self.send_log(f"[Scheduler] åˆå§‹åŒ–å¤±è´¥: {e}", "error")
    
    async def _initialize_batch_operations(self):
        """Initialize batch operations manager"""
        try:
            self.batch_ops = await get_init_batch_operations()(db, self.send_event)
            self.send_log("[BatchOps] æ‰¹é‡æ“ä½œç³»çµ±å·²å•Ÿå‹•", "success")
        except Exception as e:
            self.send_log(f"[BatchOps] åˆå§‹åŒ–å¤±æ•—: {e}", "error")
            self.batch_ops = None
    
    async def _initialize_ad_system(self):
        """Initialize ad system (å»£å‘Šç™¼é€ç³»çµ±)"""
        try:
            # Initialize ad template manager
            await get_init_ad_template_manager()(db)
            
            # Initialize ad manager
            await get_init_ad_manager()(db, self.send_event)
            
            # Initialize ad broadcaster
            get_init_ad_broadcaster()(
                telegram_manager=self.telegram_manager,
                db=db,
                event_callback=self.send_event,
                log_callback=self.send_log
            )
            
            # Initialize ad scheduler
            ad_scheduler = get_init_ad_scheduler()(
                event_callback=self.send_event,
                log_callback=self.send_log
            )
            await ad_scheduler.start()
            
            # Initialize ad analytics
            get_init_ad_analytics()(db)
            
            self.send_log("[AdSystem] å»£å‘Šç™¼é€ç³»çµ±å·²å•Ÿå‹•", "success")
        except Exception as e:
            self.send_log(f"[AdSystem] åˆå§‹åŒ–å¤±æ•—: {e}", "error")
    
    async def _initialize_user_tracking(self):
        """Initialize user tracking system (ç”¨æˆ¶è¿½è¹¤ç³»çµ±)"""
        try:
            # Initialize user tracker
            await get_init_user_tracker()(
                db=db,
                telegram_manager=self.telegram_manager,
                event_callback=self.send_event,
                log_callback=self.send_log
            )
            
            # Initialize user analytics
            get_init_user_analytics()(db)
            
            self.send_log("[UserTracker] ç”¨æˆ¶è¿½è¹¤ç³»çµ±å·²å•Ÿå‹•", "success")
        except Exception as e:
            self.send_log(f"[UserTracker] åˆå§‹åŒ–å¤±æ•—: {e}", "error")
    
    async def _initialize_campaign_system(self):
        """Initialize campaign orchestrator and multi-channel stats"""
        try:
            # Initialize campaign orchestrator
            await get_init_campaign_orchestrator()(
                db=db,
                event_callback=self.send_event,
                log_callback=self.send_log
            )
            
            # Initialize multi-channel stats
            get_init_multi_channel_stats()(db)
            
            self.send_log("[Campaign] ç‡ŸéŠ·æ´»å‹•ç³»çµ±å·²å•Ÿå‹•", "success")
        except Exception as e:
            self.send_log(f"[Campaign] åˆå§‹åŒ–å¤±æ•—: {e}", "error")
    
    async def _initialize_multi_role_system(self):
        """Initialize multi-role collaboration system"""
        try:
            # Initialize multi-role manager
            await _get_module('multi_role_manager').init_multi_role_manager(
                db=db,
                event_callback=self.send_event,
                log_callback=self.send_log
            )
            
            # Initialize script engine
            await get_init_script_engine()(
                db=db,
                event_callback=self.send_event,
                log_callback=self.send_log
            )
            
            # Initialize collaboration coordinator
            await get_init_collaboration_coordinator()(
                db=db,
                telegram_manager=self.telegram_manager,
                event_callback=self.send_event,
                log_callback=self.send_log
            )
            
            # ğŸ†• P1-1: Initialize marketing task service
            marketing_task_svc = await get_init_marketing_task_service()(
                db=db,
                event_callback=self.send_event,
                log_callback=self.send_log
            )
            # Link with collaboration coordinator
            coordinator = get_collaboration_coordinator()
            if coordinator:
                marketing_task_svc.set_collaboration_coordinator(coordinator)
            
            self.send_log("[MultiRole] å¤šè§’è‰²å”ä½œç³»çµ±å·²å•Ÿå‹•", "success")
            self.send_log("[MarketingTask] çµ±ä¸€ç‡ŸéŠ·ä»»å‹™æœå‹™å·²å•Ÿå‹•", "success")
        except Exception as e:
            self.send_log(f"[MultiRole] åˆå§‹åŒ–å¤±æ•—: {e}", "error")
    
    async def _initialize_enhanced_health_monitor(self):
        """Initialize enhanced health monitor"""
        try:
            # Create alert callback
            def alert_callback(anomaly: Anomaly):
                """å‘Šè­¦å›è°ƒå‡½æ•°"""
                # å‘é€å‘Šè­¦äº‹ä»¶åˆ°å‰ç«¯
                self.send_event("health-anomaly-detected", {
                    "account_id": anomaly.account_id,
                    "phone": anomaly.phone,
                    "anomaly_type": anomaly.anomaly_type,
                    "severity": anomaly.severity,
                    "message": anomaly.message,
                    "current_value": anomaly.current_value,
                    "threshold": anomaly.threshold,
                    "timestamp": anomaly.timestamp.isoformat(),
                    "details": anomaly.details
                })
                
                # è®°å½•æ—¥å¿—
                log_type = "error" if anomaly.severity == "critical" else "warning"
                self.send_log(f"[å¥åº·ç›‘æ§] è´¦æˆ· {anomaly.phone}: {anomaly.message}", log_type)
                
                # å¦‚æœä¸¥é‡ï¼Œä¹Ÿå‘é€åˆ°å‘Šè­¦ç®¡ç†å™¨
                if anomaly.severity in ['high', 'critical']:
                    if self.alert_manager:
                        try:
                            from alert_manager import AlertType, AlertLevel
                            alert_type = AlertType.ACCOUNT_HEALTH
                            level = AlertLevel.CRITICAL if anomaly.severity == 'critical' else AlertLevel.WARNING
                            self.alert_manager.create_alert(
                                alert_type=alert_type,
                                level=level,
                                message=anomaly.message,
                                details={
                                    "account_id": anomaly.account_id,
                                    "phone": anomaly.phone,
                                    "anomaly_type": anomaly.anomaly_type,
                                    "current_value": anomaly.current_value,
                                    "threshold": anomaly.threshold,
                                    **anomaly.details
                                }
                            )
                        except Exception as e:
                            import sys
                            print(f"[EnhancedHealthMonitor] Error creating alert: {e}", file=sys.stderr)
            
            # Initialize enhanced health monitor
            self.enhanced_health_monitor = get_EnhancedHealthMonitor()(
                alert_callback=alert_callback,
                check_interval_seconds=300  # 5 åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
            )
            
            import sys
            print("[Backend] Enhanced health monitor initialized", file=sys.stderr)
        except Exception as e:
            import sys
            print(f"[Backend] Failed to initialize enhanced health monitor: {e}", file=sys.stderr)
            # Don't fail initialization if health monitor fails
            self.enhanced_health_monitor = None
    
    async def _initialize_proxy_rotation_manager(self):
        """Initialize proxy rotation manager"""
        try:
            # Callback to update account proxy in database
            async def update_proxy_callback(account_id: int, phone: str, new_proxy: str):
                """æ›´æ–°è´¦æˆ·ä»£ç†çš„å›è°ƒå‡½æ•°"""
                await db.update_account(account_id, {"proxy": new_proxy})
                import sys
                print(f"[ProxyRotationManager] Updated proxy for account {mask_phone(phone)}: {new_proxy[:30]}...", file=sys.stderr)
            
            # Initialize proxy rotation manager with empty pool (will be populated dynamically)
            self.proxy_rotation_manager = get_ProxyRotationManager()(
                proxy_pool=[],  # Empty pool, will be populated from accounts
                config=None,  # Use default config
                health_check_callback=None
            )
            
            # Set update callback
            self.proxy_rotation_manager.update_proxy_callback = update_proxy_callback
            
            import sys
            print("[Backend] Proxy rotation manager initialized", file=sys.stderr)
        except Exception as e:
            import sys
            print(f"[Backend] Failed to initialize proxy rotation manager: {e}", file=sys.stderr)
            # Don't fail initialization if proxy rotation manager fails
            self.proxy_rotation_manager = None
    
    async def _initialize_error_recovery(self):
        """Initialize error recovery manager"""
        try:
            # Reconnect client callback
            async def reconnect_client(account_id: int, phone: str):
                """é‡æ–°è¿æ¥å®¢æˆ·ç«¯çš„å›è°ƒå‡½æ•°"""
                try:
                    # Disconnect and reconnect the client
                    if phone in self.telegram_manager.clients:
                        client = self.telegram_manager.clients[phone]
                        if client.is_connected:
                            await client.disconnect()
                        await client.connect()
                        return True
                    return False
                except Exception as e:
                    import sys
                    print(f"[ErrorRecovery] Failed to reconnect client for {mask_phone(phone)}: {e}", file=sys.stderr)
                    return False
            
            # Rotate proxy callback
            async def rotate_proxy(account_id: int, phone: str):
                """åˆ‡æ¢ä»£ç†çš„å›è°ƒå‡½æ•°"""
                if self.proxy_rotation_manager:
                    try:
                        account = await db.get_account(account_id)
                        if account:
                            current_proxy = account.get('proxy')
                            new_proxy = await self.proxy_rotation_manager.rotate_proxy(
                                phone=phone,
                                current_proxy=current_proxy,
                                reason=get_RotationReason().ERROR
                            )
                            if new_proxy:
                                await db.update_account(account_id, {"proxy": new_proxy})
                                return new_proxy
                    except Exception as e:
                        import sys
                        print(f"[ErrorRecovery] Failed to rotate proxy for {mask_phone(phone)}: {e}", file=sys.stderr)
                return None
            
            # Relogin callback
            async def relogin_account(account_id: int, phone: str):
                """é‡æ–°ç™»å½•è´¦æˆ·çš„å›è°ƒå‡½æ•°"""
                try:
                    account = await db.get_account(account_id)
                    if account:
                        result = await self.telegram_manager.login_account(
                            phone=phone,
                            api_id=account.get('apiId'),
                            api_hash=account.get('apiHash'),
                            proxy=account.get('proxy'),
                            two_factor_password=account.get('twoFactorPassword')
                        )
                        return result.get('success', False)
                except Exception as e:
                    import sys
                    print(f"[ErrorRecovery] Failed to relogin account {mask_phone(phone)}: {e}", file=sys.stderr)
                return False
            
            # Initialize error recovery manager
            def log_callback(message: str, level: str = "info"):
                self.send_log(f"[éŒ¯èª¤æ¢å¾©] {message}", level)
            
            # å…¼å®¹å…©å€‹ç‰ˆæœ¬çš„ ErrorRecoveryManager
            try:
                # å˜—è©¦ä½¿ç”¨ error_recovery_manager (æ–°ç‰ˆæœ¬ï¼Œæ¥å— log_callback)
                ErrorRecoveryManagerClass = get_ErrorRecoveryManager()
                if ErrorRecoveryManagerClass:
                    self.error_recovery_manager = ErrorRecoveryManagerClass(log_callback=log_callback)
                else:
                    self.error_recovery_manager = None
            except TypeError:
                # å¦‚æœå¤±æ•—ï¼Œå¯èƒ½æ˜¯ error_recovery (èˆŠç‰ˆæœ¬ï¼Œä¸æ¥å— log_callback)
                # ä½¿ç”¨èˆŠç‰ˆæœ¬çš„åƒæ•¸
                ErrorRecoveryManagerClass = get_ErrorRecoveryManager()
                if ErrorRecoveryManagerClass:
                    self.error_recovery_manager = ErrorRecoveryManagerClass()
                else:
                    self.error_recovery_manager = None
            
            import sys
            print("[Backend] Error recovery manager initialized", file=sys.stderr)
        except Exception as e:
            import sys
            print(f"[Backend] Failed to initialize error recovery manager: {e}", file=sys.stderr)
            # Don't fail initialization if error recovery manager fails
            self.error_recovery_manager = None
        
        # Initialize backup manager
        try:
            from config import DATABASE_PATH
            
            backup_dir = Path(DATABASE_PATH).parent / "backups"
            BackupManagerClass = get_BackupManager()
            self.backup_manager = BackupManagerClass(
                db_path=Path(DATABASE_PATH),
                backup_dir=backup_dir,
                log_callback=lambda msg, level="info": self.send_log(f"[å‚™ä»½] {msg}", level)
            )
            
            # å•Ÿå‹•å®šæœŸå‚™ä»½ï¼ˆæ¯24å°æ™‚ä¸€æ¬¡ï¼‰
            await self.backup_manager.start_scheduled_backups(interval_hours=24)
            
            import sys
            print("[Backend] Backup manager initialized", file=sys.stderr)
            self.send_log("å‚™ä»½ç®¡ç†å™¨å·²åˆå§‹åŒ–ï¼ˆæ¯24å°æ™‚è‡ªå‹•å‚™ä»½ï¼‰", "success")
        except Exception as e:
            import sys
            print(f"[Backend] Failed to initialize backup manager: {e}", file=sys.stderr)
            self.backup_manager = None
        
        # Initialize smart alert manager
        try:
            SmartAlertManagerClass = _get_module('smart_alert_manager').SmartAlertManager
            self.smart_alert_manager = SmartAlertManagerClass(db)
            import sys
            print("[Backend] Smart alert manager initialized", file=sys.stderr)
            self.send_log("æ™ºèƒ½å‘Šè­¦ç®¡ç†å™¨å·²åˆå§‹åŒ–", "success")
        except Exception as e:
            import sys
            print(f"[Backend] Failed to initialize smart alert manager: {e}", file=sys.stderr)
            self.smart_alert_manager = None
        
        # Initialize QR Auth Manager for QR code login
        try:
            # æª¢æŸ¥ä¾è³´åº«æ˜¯å¦å¯ç”¨
            from qr_auth_manager import HAS_TELETHON, HAS_QRCODE
            print(f"[Backend] QR Auth dependencies: HAS_TELETHON={HAS_TELETHON}, HAS_QRCODE={HAS_QRCODE}", file=sys.stderr)
            
            if not HAS_TELETHON:
                print("[Backend] Warning: telethon library not available for QR login", file=sys.stderr)
                self.send_log("telethon åº«æœªå®‰è£ï¼ŒQR ç™»å…¥åŠŸèƒ½ä¸å¯ç”¨", "warning")
            if not HAS_QRCODE:
                print("[Backend] Warning: qrcode library not available for QR login", file=sys.stderr)
                self.send_log("qrcode åº«æœªå®‰è£ï¼ŒQR ç™»å…¥åŠŸèƒ½ä¸å¯ç”¨", "warning")
            
            # ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨çµ±ä¸€çš„ SESSIONS_DIR é…ç½®
            from config import SESSIONS_DIR
            sessions_dir = str(SESSIONS_DIR)
            print(f"[Backend] Initializing QR Auth manager with sessions_dir: {sessions_dir}", file=sys.stderr)
            
            # å‰µå»º QR ç™»å…¥äº‹ä»¶å›èª¿å‡½æ•¸ï¼Œè™•ç† qr-login-account-ready äº‹ä»¶
            def qr_event_callback(event_name: str, payload: Any):
                # ç™¼é€äº‹ä»¶åˆ°å‰ç«¯
                self.send_event(event_name, payload)
                
                # è™•ç† qr-login-account-ready äº‹ä»¶ï¼šå°‡å¸³è™Ÿæ·»åŠ åˆ°æ•¸æ“šåº«
                if event_name == "qr-login-account-ready":
                    # ä½¿ç”¨ asyncio åœ¨äº‹ä»¶å¾ªç’°ä¸­åŸ·è¡Œç•°æ­¥æ“ä½œ
                    asyncio.create_task(self._handle_qr_login_account_ready(payload))
            
            self.qr_auth_manager = get_init_qr_auth_manager()(sessions_dir, qr_event_callback)
            await self.qr_auth_manager.start()
            print("[Backend] QR Auth manager initialized successfully", file=sys.stderr)
            self.send_log("QR æƒç¢¼ç™»å…¥ç®¡ç†å™¨å·²åˆå§‹åŒ–", "success")
        except Exception as e:
            print(f"[Backend] Failed to initialize QR auth manager: {e}", file=sys.stderr)
            traceback.print_exc(file=sys.stderr)
            self.qr_auth_manager = None
        
        # Initialize IP Binding Manager (Phase 2)
        try:
            data_dir = str(Path(config.DATA_PATH))
            self.ip_binding_manager = get_init_ip_binding_manager()(data_dir, self.send_event)
            import sys
            print("[Backend] IP Binding manager initialized", file=sys.stderr)
            self.send_log("IP ç²˜æ€§ç¶å®šç®¡ç†å™¨å·²åˆå§‹åŒ–", "success")
        except Exception as e:
            import sys
            print(f"[Backend] Failed to initialize IP binding manager: {e}", file=sys.stderr)
            self.ip_binding_manager = None
        
        # Initialize Credential Scraper (Phase 2)
        try:
            # ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨çµ±ä¸€çš„ SESSIONS_DIR é…ç½®
            sessions_dir = str(SESSIONS_DIR)
            data_dir = str(Path(config.DATA_PATH))
            
            # Database callback for saving credential logs
            async def save_credential_log(log):
                try:
                    await db.add_credential_log(
                        account_id=log.account_id,
                        phone=log.phone,
                        action=log.action,
                        api_id=log.api_id,
                        api_hash=log.api_hash,
                        status=log.status,
                        error_message=log.error_message,
                        details_json=log.details_json
                    )
                except Exception as e:
                    print(f"[Backend] Error saving credential log: {e}", file=sys.stderr)
            
            self.credential_scraper = get_init_credential_scraper()(
                sessions_dir, data_dir, self.send_event, save_credential_log
            )
            import sys
            print("[Backend] Credential scraper initialized", file=sys.stderr)
            self.send_log("API æ†‘æ“šç²å–å™¨å·²åˆå§‹åŒ–", "success")
        except Exception as e:
            import sys
            print(f"[Backend] Failed to initialize credential scraper: {e}", file=sys.stderr)
            self.credential_scraper = None

    async def _user_has_interacted(self, user_id: str) -> bool:
        """
        æª¢æŸ¥ç”¨æˆ¶æ˜¯å¦å·²äº’å‹•éï¼ˆç”¨æ–¼ç™¼é€é™é¡è±å…ï¼‰
        
        Args:
            user_id: ç”¨æˆ¶ID
        
        Returns:
            True å¦‚æœç”¨æˆ¶å·²äº’å‹•éï¼ŒFalse å¦å‰‡
        """
        try:
            # æª¢æŸ¥èŠå¤©æ­·å²ä¸­æ˜¯å¦æœ‰ç”¨æˆ¶ç™¼é€çš„æ¶ˆæ¯
            cursor = await db._connection.execute("""
                SELECT COUNT(*) as count FROM chat_history 
                WHERE user_id = ? AND role = 'user'
            """, (user_id,))
            row = await cursor.fetchone()
            user_message_count = row['count'] if row else 0
            
            # å¦‚æœç”¨æˆ¶ç™¼é€éè‡³å°‘ä¸€æ¢æ¶ˆæ¯ï¼Œè¦–ç‚ºå·²äº’å‹•
            return user_message_count > 0
        except Exception as e:
            import sys
            print(f"[Backend] Error checking user interaction: {e}", file=sys.stderr)
            return False
    
    async def _queue_send_callback(self, phone: str, user_id: str, text: str, attachment: Any = None, source_group: Optional[str] = None, target_username: Optional[str] = None) -> Dict[str, Any]:
        """
        Callback function for MessageQueue to actually send messages via Telegram
        
        Args:
            phone: Account phone number
            user_id: Target user ID
            text: Message text
            attachment: Optional attachment (path string or {name, type, dataUrl} object)
            source_group: Optional source group ID/URL
            target_username: Optional target username (fallback)
            
        Returns:
            Dict with 'success' (bool) and optionally 'error' (str)
        """
        import sys
        attachment_info = f"attachment={type(attachment).__name__}" if attachment else "no attachment"
        if attachment and isinstance(attachment, dict):
            attachment_info = f"attachment={{name={attachment.get('name')}, type={attachment.get('type')}}}"
        print(f"[Backend] _queue_send_callback called: phone={phone}, user_id={user_id}, source_group={source_group}, target_username={target_username}, {attachment_info}, text={text[:50] if text else '(empty)'}...", file=sys.stderr)
        self.send_log(f"æ­£åœ¨ç™¼é€æ¶ˆæ¯åˆ° {target_username or user_id}...", "info")
        
        try:
            # Check Warmup status before sending (é˜²å°)
            account = await db.get_account_by_phone(phone)
            if account:
                # Determine message type (simplified: assume "active" for now)
                message_type = "active"  # Could be "reply_only" if replying to a message
                
                # Check if sending is allowed
                warmup_check = WarmupManager.should_allow_send(account, message_type)
                
                if not warmup_check.get('allowed'):
                    reason = warmup_check.get('reason', 'Unknown reason')
                    stage_info = warmup_check.get('current_stage')
                    
                    import sys
                    print(f"[Backend] Warmup check failed for {phone}: {reason}", file=sys.stderr)
                    if stage_info:
                        print(f"[Backend] Current stage: {stage_info.get('stage_name')} (Stage {stage_info.get('stage')})", file=sys.stderr)
                        print(f"[Backend] Daily limit: {warmup_check.get('daily_limit')}", file=sys.stderr)
                    
                    return {
                        "success": False,
                        "error": f"Warmupé™åˆ¶: {reason}",
                        "warmup_info": warmup_check
                    }
            
            # Send message via Pyrogram
            import time
            send_start_time = time.time()
            
            result = await self.telegram_manager.send_message(
                phone=phone,
                user_id=user_id,
                text=text,
                attachment=attachment,
                source_group=source_group,
                target_username=target_username
            )
            
            send_latency = (time.time() - send_start_time) * 1000  # è½¬æ¢ä¸ºæ¯«ç§’
            
            print(f"[Backend] telegram_manager.send_message result: {result}", file=sys.stderr)
            
            if result.get('success'):
                self.send_log(f"âœ“ æ¶ˆæ¯ç™¼é€æˆåŠŸåˆ° {user_id}", "success")
                # Record send performance
                from performance_monitor import get_performance_monitor
                try:
                    monitor = get_performance_monitor()
                    monitor.record_send_performance(phone, send_latency)
                except:
                    pass  # Performance monitor might not be initialized
                
                # Record health metrics (è´¦æˆ·å¥åº·ç›‘æ§å¢å¼º)
                if self.enhanced_health_monitor:
                    account = await db.get_account_by_phone(phone)
                    if account:
                        account_id = account.get('id')
                        self.enhanced_health_monitor.record_send_success(account_id, phone, send_latency)
                
                # Record proxy success (æ™ºèƒ½ä»£ç†è½®æ¢)
                if self.proxy_rotation_manager:
                    account = await db.get_account_by_phone(phone)
                    if account:
                        current_proxy = account.get('proxy')
                        if current_proxy:
                            self.proxy_rotation_manager.record_proxy_success(current_proxy, send_latency)
                
                return result
            else:
                # Handle flood wait
                error = result.get('error', 'Unknown error')
                self.send_log(f"âœ— æ¶ˆæ¯ç™¼é€å¤±æ•—: {error}", "error")
                print(f"[Backend] Message send failed: {error}", file=sys.stderr)
                
                # ğŸ”§ FIX: PEER_ID_INVALID éŒ¯èª¤å›é€€ç­–ç•¥ - å˜—è©¦ä½¿ç”¨å…¶ä»–å¸³è™Ÿ
                if 'PEER_ID_INVALID' in error or 'peer' in error.lower():
                    print(f"[Backend] PEER_ID_INVALID detected, trying fallback strategy...", file=sys.stderr)
                    
                    # å˜—è©¦æ‰¾ä¸€å€‹åœ¨åŒä¸€ç¾¤çµ„çš„å¸³è™Ÿ
                    fallback_result = await self._try_fallback_send(
                        original_phone=phone,
                        user_id=user_id,
                        text=text,
                        attachment=attachment,
                        source_group=source_group,
                        target_username=target_username
                    )
                    
                    if fallback_result and fallback_result.get('success'):
                        self.send_log(f"âœ“ å›é€€ç­–ç•¥æˆåŠŸ: ä½¿ç”¨å¸³è™Ÿ {fallback_result.get('used_phone')} ç™¼é€", "success")
                        return fallback_result
                    else:
                        fallback_error = fallback_result.get('error', 'ç„¡å¯ç”¨çš„å›é€€å¸³è™Ÿ') if fallback_result else 'å›é€€å¤±æ•—'
                        self.send_log(f"å›é€€ç­–ç•¥å¤±æ•—: {fallback_error}", "warning")
                
                # Record proxy error (æ™ºèƒ½ä»£ç†è½®æ¢)
                if self.proxy_rotation_manager:
                    account = await db.get_account_by_phone(phone)
                    if account:
                        account_id = account.get('id')
                        current_proxy = account.get('proxy')
                        if current_proxy:
                            self.proxy_rotation_manager.record_proxy_error(current_proxy, error)
                            
                            # å¦‚æœæ˜¯ä»£ç†é”™è¯¯ï¼Œå°è¯•è‡ªåŠ¨è½®æ¢
                            if 'Proxy' in error or 'proxy' in error or 'Connection' in error:
                                try:
                                    new_proxy = await self.proxy_rotation_manager.rotate_proxy(
                                        account_id=account_id,
                                        phone=phone,
                                        reason=get_RotationReason().ERROR,
                                        preferred_country=account.get('proxyCountry')
                                    )
                                    if new_proxy and new_proxy != current_proxy:
                                        # æ›´æ–°æ•°æ®åº“ä¸­çš„ä»£ç†
                                        await db.update_account(account_id, {'proxy': new_proxy})
                                        self.send_log(f"è´¦æˆ· {phone} ä»£ç†å·²è‡ªåŠ¨è½®æ¢: {current_proxy[:30]}... -> {new_proxy[:30]}...", "info")
                                except Exception as e:
                                    import sys
                                    print(f"[Backend] Failed to auto-rotate proxy: {e}", file=sys.stderr)
                
                # Handle error with recovery manager (é”™è¯¯æ¢å¤å’Œè‡ªåŠ¨é‡è¯•æœºåˆ¶)
                account = await db.get_account_by_phone(phone)
                account_id = account.get('id') if account else None
                
                if account_id and self.error_recovery_manager:
                    try:
                        # å¤„ç†é”™è¯¯å¹¶æ‰§è¡Œæ¢å¤åŠ¨ä½œ
                        error_exception = Exception(error)
                        recovery_result = await self.error_recovery_manager.handle_error(
                            account_id=str(account_id),
                            phone=phone,
                            error=error_exception,
                            attempt=0,  # è¿™é‡Œåº”è¯¥ä»æ¶ˆæ¯é˜Ÿåˆ—è·å–å®é™…å°è¯•æ¬¡æ•°
                            context={
                                "user_id": user_id,
                                "message_text": text[:100] if text else None
                            }
                        )
                        
                        # è®°å½•æ¢å¤ç»“æœ
                        if recovery_result.success:
                            self.error_recovery_manager.record_recovery_success(str(account_id), recovery_result.action_taken)
                            if recovery_result.action_taken != RecoveryAction.RETRY:
                                self.send_log(f"è´¦æˆ· {phone} é”™è¯¯æ¢å¤æˆåŠŸ: {recovery_result.message}", "info")
                        else:
                            self.error_recovery_manager.record_recovery_failure(str(account_id), recovery_result.action_taken)
                            self.send_log(f"è´¦æˆ· {phone} é”™è¯¯æ¢å¤å¤±è´¥: {recovery_result.message}", "warning")
                        
                        # å¦‚æœéœ€è¦ç­‰å¾…ï¼Œæ›´æ–°ç»“æœä¸­çš„é”™è¯¯ä¿¡æ¯
                        if recovery_result.retry_after:
                            result['retry_after'] = recovery_result.retry_after
                            result['recovery_action'] = recovery_result.action_taken.value
                    except Exception as e:
                        import sys
                        print(f"[Backend] Error in error recovery: {e}", file=sys.stderr)
                
                # Record health metrics (è´¦æˆ·å¥åº·ç›‘æ§å¢å¼º)
                if self.enhanced_health_monitor and account:
                    account_id = account.get('id')
                    self.enhanced_health_monitor.record_send_failure(account_id, phone, error, send_latency)
                
                if 'Flood wait' in error:
                    # Extract wait time from error message
                    import re
                    wait_match = re.search(r'wait (\d+) seconds', error)
                    if wait_match:
                        wait_seconds = int(wait_match.group(1))
                        
                        # Record Flood Wait (è´¦æˆ·å¥åº·ç›‘æ§å¢å¼º)
                        if self.enhanced_health_monitor:
                            account = await db.get_account_by_phone(phone)
                            if account:
                                account_id = account.get('id')
                                self.enhanced_health_monitor.record_flood_wait(account_id, phone, wait_seconds)
                        
                        # Update rate limiter in message queue
                        if self.message_queue and phone in self.message_queue.rate_limiters:
                            await self.message_queue.rate_limiters[phone].set_flood_wait(wait_seconds)
                
                return result
                
        except Exception as e:
            error_msg = str(e)
            # Provide user-friendly error messages
            if "not connected" in error_msg.lower() or "client not" in error_msg.lower():
                friendly_msg = f"è´¦æˆ· {phone} æœªè¿æ¥ã€‚è¯·å…ˆç™»å½•è¯¥è´¦æˆ·ã€‚"
            elif "flood" in error_msg.lower():
                friendly_msg = f"è´¦æˆ· {phone} è§¦å‘é™æµä¿æŠ¤ã€‚ç³»ç»Ÿå°†è‡ªåŠ¨ç­‰å¾…åé‡è¯•ã€‚"
            elif "banned" in error_msg.lower() or "deactivated" in error_msg.lower():
                friendly_msg = f"è´¦æˆ· {phone} å¯èƒ½è¢«å°ç¦æˆ–å·²åœç”¨ã€‚è¯·æ£€æŸ¥è´¦æˆ·çŠ¶æ€ã€‚"
            else:
                friendly_msg = f"å‘é€æ¶ˆæ¯å¤±è´¥ ({phone}): {error_msg}"
            
            self.send_log(friendly_msg, "error")
            return {
                "success": False,
                "error": friendly_msg
            }
        
        # Restore pending messages from database
        await self.message_queue.restore_from_database()
    
    async def _try_fallback_send(
        self, 
        original_phone: str, 
        user_id: str, 
        text: str, 
        attachment: Any = None, 
        source_group: Optional[str] = None, 
        target_username: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        ğŸ”§ å›é€€ç™¼é€ç­–ç•¥ï¼šç•¶åŸå§‹å¸³è™Ÿç„¡æ³•ç™¼é€æ™‚ï¼Œå˜—è©¦ä½¿ç”¨å…¶ä»–å¸³è™Ÿ
        
        ç­–ç•¥å„ªå…ˆç´šï¼š
        1. å˜—è©¦ä½¿ç”¨ç›£æ§è©²ç¾¤çµ„çš„ Listener å¸³è™Ÿï¼ˆå®ƒå€‘å·²ç¶“åœ¨ç¾¤çµ„ä¸­ï¼‰
        2. å˜—è©¦ä½¿ç”¨å…¶ä»–åœ¨ç·šçš„ Sender å¸³è™Ÿ
        3. å˜—è©¦ä½¿ç”¨ä»»ä½•åœ¨ç·šå¸³è™Ÿ
        """
        import sys
        print(f"[Backend] _try_fallback_send: source_group={source_group}, target_username={target_username}", file=sys.stderr)
        
        try:
            # ç²å–æ‰€æœ‰åœ¨ç·šå¸³è™Ÿ
            accounts = await db.get_all_accounts()
            online_accounts = [a for a in accounts if a.get('status') == 'Online' and a.get('phone') != original_phone]
            
            if not online_accounts:
                return {"success": False, "error": "æ²’æœ‰å…¶ä»–åœ¨ç·šå¸³è™Ÿå¯ç”¨"}
            
            # å„ªå…ˆç´š 1ï¼šæ‰¾ç›£æ§è©²ç¾¤çµ„çš„ Listener å¸³è™Ÿ
            if source_group:
                # æª¢æŸ¥å“ªäº›å¸³è™Ÿåœ¨é€™å€‹ç¾¤çµ„ä¸­
                for acc in online_accounts:
                    if acc.get('role') == 'Listener':
                        phone = acc.get('phone')
                        print(f"[Backend] Trying Listener account: {phone}", file=sys.stderr)
                        
                        result = await self.telegram_manager.send_message(
                            phone=phone,
                            user_id=user_id,
                            text=text,
                            attachment=attachment,
                            source_group=source_group,
                            target_username=target_username
                        )
                        
                        if result.get('success'):
                            result['used_phone'] = phone
                            result['fallback_strategy'] = 'listener'
                            return result
                        else:
                            print(f"[Backend] Listener {phone} also failed: {result.get('error')}", file=sys.stderr)
            
            # å„ªå…ˆç´š 2ï¼šå˜—è©¦å…¶ä»– Sender å¸³è™Ÿ
            sender_accounts = [a for a in online_accounts if a.get('role') == 'Sender']
            for acc in sender_accounts:
                phone = acc.get('phone')
                print(f"[Backend] Trying other Sender account: {phone}", file=sys.stderr)
                
                result = await self.telegram_manager.send_message(
                    phone=phone,
                    user_id=user_id,
                    text=text,
                    attachment=attachment,
                    source_group=source_group,
                    target_username=target_username
                )
                
                if result.get('success'):
                    result['used_phone'] = phone
                    result['fallback_strategy'] = 'other_sender'
                    return result
            
            # å„ªå…ˆç´š 3ï¼šå˜—è©¦ä»»ä½•åœ¨ç·šå¸³è™Ÿï¼ˆåŒ…æ‹¬æ²’æœ‰æŒ‡å®šè§’è‰²çš„ï¼‰
            for acc in online_accounts:
                if acc.get('role') not in ['Listener', 'Sender']:
                    phone = acc.get('phone')
                    print(f"[Backend] Trying any online account: {phone}", file=sys.stderr)
                    
                    result = await self.telegram_manager.send_message(
                        phone=phone,
                        user_id=user_id,
                        text=text,
                        attachment=attachment,
                        source_group=source_group,
                        target_username=target_username
                    )
                    
                    if result.get('success'):
                        result['used_phone'] = phone
                        result['fallback_strategy'] = 'any_account'
                        return result
            
            return {"success": False, "error": "æ‰€æœ‰å¸³è™Ÿéƒ½ç„¡æ³•ç™¼é€"}
            
        except Exception as e:
            print(f"[Backend] _try_fallback_send error: {e}", file=sys.stderr)
            return {"success": False, "error": str(e)}
    
    async def _start_browsing_simulation(self, account_id: int, phone: str, group_urls: List[str]):
        """
        å¯åŠ¨æµè§ˆè¡Œä¸ºæ¨¡æ‹Ÿåå°ä»»åŠ¡
        
        Args:
            account_id: è´¦æˆ· ID
            phone: ç”µè¯å·ç 
            group_urls: ç¾¤ç»„ URL åˆ—è¡¨
        """
        async def browsing_task():
            """æµè§ˆè¡Œä¸ºæ¨¡æ‹Ÿä»»åŠ¡"""
            try:
                # è·å–è¡Œä¸ºæ¨¡æ‹Ÿå™¨
                behavior_simulator = self.telegram_manager.behavior_simulator
                
                # è·å–å®¢æˆ·ç«¯
                if phone not in self.telegram_manager.clients:
                    return
                client = self.telegram_manager.clients[phone]
                
                # è½¬æ¢ç¾¤ç»„ URL ä¸º ID
                group_ids = []
                for group_url in group_urls:
                    try:
                        if isinstance(group_url, (int, str)) and str(group_url).lstrip('-').isdigit():
                            group_ids.append(int(group_url))
                        else:
                            chat = await client.get_chat(group_url)
                            group_ids.append(chat.id)
                    except Exception:
                        continue
                
                if not group_ids:
                    return
                
                # æŒç»­è¿è¡Œæµè§ˆæ¨¡æ‹Ÿ
                while self.running:
                    try:
                        # æ£€æŸ¥æ˜¯å¦åº”è¯¥æµè§ˆ
                        if behavior_simulator.should_browse_now(account_id):
                            # æ¨¡æ‹Ÿæµè§ˆ
                            browse_result = await behavior_simulator.simulate_browsing(
                                client=client,
                                account_id=account_id,
                                group_ids=group_ids
                            )
                            
                            if browse_result.get('success'):
                                import sys
                                print(f"[BehaviorSimulator] Account {phone} browsed {browse_result.get('count', 0)} groups", file=sys.stderr)
                        
                        # ç­‰å¾…ä¸‹æ¬¡æµè§ˆï¼ˆ30-60 åˆ†é’Ÿï¼‰
                        delay = behavior_simulator.get_random_activity_delay()
                        await asyncio.sleep(delay)
                    
                    except asyncio.CancelledError:
                        break
                    except Exception as e:
                        import sys
                        print(f"[BehaviorSimulator] Error in browsing task for {phone}: {e}", file=sys.stderr)
                        # ç­‰å¾…ä¸€æ®µæ—¶é—´åé‡è¯•
                        await asyncio.sleep(300)  # 5 åˆ†é’Ÿåé‡è¯•
            
            except Exception as e:
                import sys
                print(f"[BehaviorSimulator] Browsing task failed for {phone}: {e}", file=sys.stderr)
        
        # å¯åŠ¨åå°ä»»åŠ¡
        task = asyncio.create_task(browsing_task())
        self.background_tasks.append(task)
        import sys
        print(f"[BehaviorSimulator] Started browsing simulation for account {phone}", file=sys.stderr)
        
        # Start background tasks
        self.background_tasks.append(asyncio.create_task(self.daily_reset_task()))
        self.background_tasks.append(asyncio.create_task(self.account_health_monitor_task()))
        self.background_tasks.append(asyncio.create_task(self.queue_cleanup_task()))
        self.background_tasks.append(asyncio.create_task(self.message_confirmation_timeout_task()))
        
        # åŒæ­¥ API æ†‘æ“šä½¿ç”¨è¨ˆæ•¸
        try:
            from api_credential_pool import get_api_credential_pool
            data_dir = str(Path(config.DATA_PATH))
            pool = get_api_credential_pool(data_dir)
            accounts = await db.get_all_accounts()
            pool.sync_usage_counts(accounts)
            print(f"[Backend] API credential usage counts synced for {len(accounts)} accounts", file=sys.stderr)
        except Exception as e:
            print(f"[Backend] Error syncing API credential usage: {e}", file=sys.stderr)
        
        # Log startup
        await db.add_log("Backend service started", "info")
        print(safe_json_dumps({
            "event": "log-entry",
            "payload": {
                "id": int(datetime.now().timestamp() * 1000),
                "timestamp": datetime.now().isoformat() + "Z",
                "message": "Backend service started",
                "type": "info"
            }
        }), flush=True)
    
    async def safe_delete_session_file(self, session_path: Path, max_retries: int = 5, retry_delay: float = 0.5) -> bool:
        """
        Safely delete a session file with retry mechanism for Windows file locking issues
        
        Args:
            session_path: Path to the session file to delete
            max_retries: Maximum number of retry attempts
            retry_delay: Delay between retries in seconds
            
        Returns:
            True if file was deleted successfully, False otherwise
        """
        if not session_path.exists():
            return True  # File doesn't exist, consider it "deleted"
        
        import sys
        for attempt in range(max_retries):
            try:
                session_path.unlink()
                print(f"[Backend] Successfully deleted session file: {session_path} (attempt {attempt + 1})", file=sys.stderr)
                return True
            except PermissionError as e:
                if attempt < max_retries - 1:
                    print(f"[Backend] Session file locked, retrying in {retry_delay}s (attempt {attempt + 1}/{max_retries}): {session_path}", file=sys.stderr)
                    # Force garbage collection to release file handles
                    gc.collect()
                    await asyncio.sleep(retry_delay)
                    retry_delay *= 1.5  # Exponential backoff
                else:
                    print(f"[Backend] Failed to delete session file after {max_retries} attempts: {e}", file=sys.stderr)
                    return False
            except Exception as e:
                print(f"[Backend] Error deleting session file: {e}", file=sys.stderr)
                return False
        
        return False
    
    async def shutdown(self):
        """Shutdown the backend service"""
        self.running = False
        
        # Stop acknowledgment manager
        try:
            ack_manager = get_ack_manager()
            await ack_manager.stop()
        except Exception as e:
            print(f"[Backend] Error stopping ack manager: {e}", file=sys.stderr)
        
        # Disconnect all Telegram clients
        try:
            await self.telegram_manager.disconnect_all()
        except Exception as e:
            print(f"[Backend] Error disconnecting clients: {e}", file=sys.stderr)
        
        # Try to log shutdown (only if database is still connected)
        try:
            if db._connection is not None:
                await db.add_log("Backend service shutting down", "info")
                await db.close()
        except Exception as e:
            print(f"[Backend] Error during database shutdown: {e}", file=sys.stderr)
    
    def send_event(self, event_name: str, payload: Any, message_id: Optional[str] = None):
        """
        Send an event to Electron via stdout
        
        Args:
            event_name: Event name
            payload: Event payload
            message_id: Optional message ID for confirmation
        """
        message = {
            "event": event_name,
            "payload": payload
        }
        if message_id:
            message["message_id"] = message_id
        
        # Debug logging for important events
        if event_name in ('initial-state', 'accounts-updated'):
            import sys
            print(f"[Backend] â˜…â˜…â˜… send_event called for {event_name} â˜…â˜…â˜…", file=sys.stderr)
            if event_name == 'initial-state':
                accounts_count = len(payload.get('accounts', [])) if isinstance(payload, dict) else 0
                print(f"[Backend] initial-state payload accounts: {accounts_count}", file=sys.stderr)
            elif event_name == 'accounts-updated':
                accounts_count = len(payload) if isinstance(payload, list) else 0
                print(f"[Backend] accounts-updated payload count: {accounts_count}", file=sys.stderr)
        
        # ä½¿ç”¨å®‰å…¨çš„ JSON åºåˆ—åŒ–ï¼Œè™•ç† emoji å’Œç‰¹æ®Šå­—ç¬¦
        try:
            json_str = safe_json_dumps(message)
            if event_name in ('initial-state', 'accounts-updated'):
                import sys
                print(f"[Backend] JSON length for {event_name}: {len(json_str)}", file=sys.stderr)
            print(json_str, flush=True)
        except Exception as e:
            import sys
            print(f"[Backend] Error in safe_json_dumps for {event_name}: {e}", file=sys.stderr)
            # æœ€å¾Œçš„å‚™ç”¨æ–¹æ¡ˆï¼šå¼·åˆ¶ ASCII ç·¨ç¢¼
            print(json.dumps(sanitize_dict(message), ensure_ascii=True, default=str), flush=True)
    
    # ğŸ†• æ—¥èªŒæ‰¹é‡æ¨¡å¼ç›¸é—œ
    _log_batch_mode = False
    _log_batch_buffer: list = []
    
    def send_log(self, message: str, log_type: str = "info"):
        """Send a log entry event (æ”¯æŒæ‰¹é‡æ¨¡å¼)"""
        log_entry = {
            "id": int(datetime.now().timestamp() * 1000),
            "timestamp": datetime.now().isoformat() + "Z",
            "message": message,
            "type": log_type
        }
        
        # ğŸ†• æ‰¹é‡æ¨¡å¼ï¼šæš«å­˜æ—¥èªŒï¼Œç¨å¾Œä¸€æ¬¡æ€§ç™¼é€
        if self._log_batch_mode:
            self._log_batch_buffer.append(log_entry)
            # æ¯ç´¯ç© 10 æ¢æˆ–é‡åˆ° error/success é¡å‹æ™‚åˆ·æ–°
            if len(self._log_batch_buffer) >= 10 or log_type in ('error', 'success'):
                self._flush_log_batch()
        else:
            self.send_event("log-entry", log_entry)
    
    def start_log_batch_mode(self):
        """ğŸ†• å•Ÿå‹•æ—¥èªŒæ‰¹é‡æ¨¡å¼ï¼ˆæ¸›å°‘ IPC èª¿ç”¨ï¼‰"""
        self._log_batch_mode = True
        self._log_batch_buffer = []
    
    def stop_log_batch_mode(self):
        """ğŸ†• åœæ­¢æ—¥èªŒæ‰¹é‡æ¨¡å¼ä¸¦åˆ·æ–°æ‰€æœ‰ç·©è¡æ—¥èªŒ"""
        self._flush_log_batch()
        self._log_batch_mode = False
    
    def _flush_log_batch(self):
        """ğŸ†• åˆ·æ–°æ—¥èªŒæ‰¹é‡ç·©è¡å€"""
        if self._log_batch_buffer:
            # æ‰¹é‡ç™¼é€æ‰€æœ‰æ—¥èªŒ
            self.send_event("log-entries-batch", {
                "entries": self._log_batch_buffer
            })
            self._log_batch_buffer = []
    
    async def _save_session_metadata(self, phone: str, metadata: dict):
        """
        ä¿å­˜ Session Metadata åˆ° JSON æ–‡ä»¶
        ç”¨æ–¼åœ¨æ•¸æ“šåº«ä¸Ÿå¤±æ™‚æ¢å¾©å¸³è™Ÿ
        """
        import json
        from pathlib import Path
        from config import SESSIONS_DIR
        
        # è¦ç¯„åŒ–é›»è©±è™Ÿç¢¼ï¼ˆç§»é™¤ +ï¼‰
        normalized_phone = phone.replace('+', '').strip()
        
        # ğŸ†• ä½¿ç”¨æŒä¹…åŒ– sessions ç›®éŒ„
        metadata_path = SESSIONS_DIR / f"{normalized_phone}.metadata.json"
        
        # ç¢ºä¿ç›®éŒ„å­˜åœ¨
        metadata_path.parent.mkdir(parents=True, exist_ok=True)
        
        # å¯«å…¥ metadata
        with open(metadata_path, 'w', encoding='utf-8') as f:
            json.dump(metadata, f, indent=2, ensure_ascii=False)
    
    async def handle_command(self, command: str, payload: Any, request_id: Optional[str] = None):
        """Handle incoming commands"""
        try:
            # Register request for acknowledgment if request_id is provided
            ack_manager = get_ack_manager()
            if request_id:
                # Register the request
                await ack_manager.register_request(
                    command=command,
                    payload=payload,
                    callback=None,  # No callback needed for simple acknowledgment
                    timeout_seconds=30.0,
                    max_retries=0  # Don't retry, just acknowledge
                )
                
                # Send immediate acknowledgment
                self.send_event("command-ack", {
                    "request_id": request_id,
                    "command": command,
                    "status": "received"
                })
            
            # ğŸ†• Phase 7: ä½¿ç”¨å‘½ä»¤è·¯ç”±å™¨è™•ç†æ‰€æœ‰å‘½ä»¤
            if ROUTER_AVAILABLE:
                try:
                    # ğŸ”§ P0: æ·»åŠ å‘½ä»¤è·¯ç”±æ—¥èªŒ
                    print(f"[Backend] Processing command via router: {command}", file=sys.stderr)
                    handled, result = await try_route_command(command, payload, request_id)
                    if handled:
                        print(f"[Backend] âœ“ Command handled by router: {command}", file=sys.stderr)
                        return result  # ğŸ”§ FIX: Return the result from router
                    else:
                        print(f"[Backend] Command not handled by router, using fallback: {command}", file=sys.stderr)
                except Exception as router_error:
                    # è·¯ç”±å™¨éŒ¯èª¤ï¼Œä½¿ç”¨å‹•æ…‹å›é€€æ©Ÿåˆ¶
                    print(f"[Backend] Router error for {command}: {router_error}, using fallback", file=sys.stderr)
            
            # ğŸ”§ P0: é¡¯å¼è™•ç†çŸ¥è­˜åº«å‘½ä»¤ï¼ˆç¹éè·¯ç”±å™¨å•é¡Œï¼‰
            if command == 'add-knowledge-base':
                print(f"[Backend] ğŸ”§ Direct handling add-knowledge-base", file=sys.stderr)
                await self.handle_add_knowledge_base(payload or {})
                return
            elif command == 'add-knowledge-item':
                print(f"[Backend] ğŸ”§ Direct handling add-knowledge-item", file=sys.stderr)
                await self.handle_add_knowledge_item(payload or {})
                return
            elif command == 'get-knowledge-items':
                print(f"[Backend] ğŸ”§ Direct handling get-knowledge-items", file=sys.stderr)
                await self.handle_get_knowledge_items(payload or {})
                return
            elif command == 'ai-generate-knowledge':
                print(f"[Backend] ğŸ”§ Direct handling ai-generate-knowledge", file=sys.stderr)
                await self.handle_ai_generate_knowledge(payload or {})
                return
            elif command == 'apply-industry-template':
                print(f"[Backend] ğŸ”§ Direct handling apply-industry-template", file=sys.stderr)
                await self.handle_apply_industry_template(payload or {})
                return
            elif command == 'learn-from-chat-history':
                print(f"[Backend] ğŸ”§ Direct handling learn-from-chat-history", file=sys.stderr)
                await self.handle_learn_from_chat_history(payload or {})
                return
            
            # ğŸ§  RAG çŸ¥è­˜å¤§è…¦ 2.0 å‘½ä»¤
            elif command == 'rag-initialize':
                print(f"[Backend] ğŸ§  RAG Initialize", file=sys.stderr)
                await self.handle_rag_initialize(payload or {})
                return
            elif command == 'rag-search':
                print(f"[Backend] ğŸ§  RAG Search", file=sys.stderr)
                await self.handle_rag_search(payload or {})
                return
            elif command == 'rag-get-stats':
                print(f"[Backend] ğŸ§  RAG Get Stats", file=sys.stderr)
                await self.handle_rag_get_stats(payload or {})
                return
            elif command == 'rag-add-knowledge':
                print(f"[Backend] ğŸ§  RAG Add Knowledge", file=sys.stderr)
                await self.handle_rag_add_knowledge(payload or {})
                return
            elif command == 'rag-record-feedback':
                print(f"[Backend] ğŸ§  RAG Record Feedback", file=sys.stderr)
                await self.handle_rag_record_feedback(payload or {})
                return
            elif command == 'rag-build-from-conversation':
                print(f"[Backend] ğŸ§  RAG Build From Conversation", file=sys.stderr)
                await self.handle_rag_build_from_conversation(payload or {})
                return
            elif command == 'rag-preview-import':
                print(f"[Backend] ğŸ§  RAG Preview Import (P1-2)", file=sys.stderr)
                await self.handle_rag_preview_import(payload or {})
                return
            elif command == 'rag-confirm-import':
                print(f"[Backend] ğŸ§  RAG Confirm Import (P1-2)", file=sys.stderr)
                await self.handle_rag_confirm_import(payload or {})
                return
            elif command == 'rag-import-url':
                print(f"[Backend] ğŸ§  RAG Import URL", file=sys.stderr)
                await self.handle_rag_import_url(payload or {})
                return
            elif command == 'rag-import-document':
                print(f"[Backend] ğŸ§  RAG Import Document", file=sys.stderr)
                await self.handle_rag_import_document(payload or {})
                return
            elif command == 'rag-cleanup':
                print(f"[Backend] ğŸ§  RAG Cleanup", file=sys.stderr)
                await self.handle_rag_cleanup(payload or {})
                return
            elif command == 'rag-merge-similar':
                print(f"[Backend] ğŸ§  RAG Merge Similar", file=sys.stderr)
                await self.handle_rag_merge_similar(payload or {})
                return
            elif command == 'rag-get-gaps':
                print(f"[Backend] ğŸ§  RAG Get Gaps", file=sys.stderr)
                await self.handle_rag_get_gaps(payload or {})
                return
            elif command == 'rag-resolve-gap':
                print(f"[Backend] ğŸ§  RAG Resolve Gap", file=sys.stderr)
                await self.handle_rag_resolve_gap(payload or {})
                return
            elif command == 'rag-ignore-gap':
                print(f"[Backend] ğŸ§  RAG Ignore Gap", file=sys.stderr)
                await self.handle_rag_ignore_gap(payload or {})
                return
            elif command == 'rag-delete-gap':
                print(f"[Backend] ğŸ§  RAG Delete Gap", file=sys.stderr)
                await self.handle_rag_delete_gap(payload or {})
                return
            elif command == 'rag-delete-gaps-batch':
                print(f"[Backend] ğŸ§  RAG Delete Gaps Batch", file=sys.stderr)
                await self.handle_rag_delete_gaps_batch(payload or {})
                return
            elif command == 'rag-cleanup-duplicate-gaps':
                print(f"[Backend] ğŸ§  RAG Cleanup Duplicate Gaps", file=sys.stderr)
                await self.handle_rag_cleanup_duplicate_gaps(payload or {})
                return
            elif command == 'rag-suggest-gap-answer':
                print(f"[Backend] ğŸ§  RAG Suggest Gap Answer", file=sys.stderr)
                await self.handle_rag_suggest_gap_answer(payload or {})
                return
            elif command == 'rag-get-all-knowledge':
                print(f"[Backend] ğŸ§  RAG Get All Knowledge", file=sys.stderr)
                await self.handle_rag_get_all_knowledge(payload or {})
                return
            elif command == 'rag-add-knowledge':
                print(f"[Backend] ğŸ§  RAG Add Knowledge", file=sys.stderr)
                await self.handle_rag_add_knowledge(payload or {})
                return
            elif command == 'rag-update-knowledge':
                print(f"[Backend] ğŸ§  RAG Update Knowledge", file=sys.stderr)
                await self.handle_rag_update_knowledge(payload or {})
                return
            elif command == 'rag-delete-knowledge':
                print(f"[Backend] ğŸ§  RAG Delete Knowledge", file=sys.stderr)
                await self.handle_rag_delete_knowledge(payload or {})
                return
            elif command == 'rag-delete-knowledge-batch':
                print(f"[Backend] ğŸ§  RAG Delete Knowledge Batch", file=sys.stderr)
                await self.handle_rag_delete_knowledge_batch(payload or {})
                return
            elif command == 'rag-get-health-report':
                print(f"[Backend] ğŸ§  RAG Get Health Report", file=sys.stderr)
                await self.handle_rag_get_health_report(payload or {})
                return
            elif command == 'rag-start-guided-build':
                print(f"[Backend] ğŸ§  RAG Start Guided Build", file=sys.stderr)
                await self.handle_rag_start_guided_build(payload or {})
                return
            
            # ğŸ†• Phase 7: å‹•æ…‹å›é€€æ©Ÿåˆ¶ - æ›¿ä»£å·¨å‹ if-elif éˆ
            # å°‡å‘½ä»¤åè½‰æ›ç‚ºæ–¹æ³•å: add-account -> handle_add_account, batch-send:start -> handle_batch_send_start
            # ğŸ”§ P0: åŒæ™‚è™•ç† - å’Œ : ç¬¦è™Ÿ
            method_name = 'handle_' + command.replace('-', '_').replace(':', '_')
            handler = getattr(self, method_name, None)
            
            # ğŸ”§ P0: æ·»åŠ å›é€€æ—¥èªŒ
            print(f"[Backend] Fallback: looking for {method_name}, found={handler is not None}", file=sys.stderr)
            
            if handler is not None and callable(handler):
                # ç‰¹æ®Šè™•ç† graceful-shutdown
                if command == "graceful-shutdown":
                    await handler()
                    return  # Don't continue processing after shutdown
                
                # ğŸ”§ Phase 3 ä¿®å¾©ï¼šæª¢æŸ¥ handler å‡½æ•¸æ˜¯å¦æ¥å— payload åƒæ•¸
                import inspect
                try:
                    sig = inspect.signature(handler)
                    # è¨ˆç®—é™¤ self ä¹‹å¤–çš„åƒæ•¸æ•¸é‡ï¼ˆå°æ–¼ç¶å®šæ–¹æ³•ï¼Œself å·²è¢«ç¶å®šï¼‰
                    params = list(sig.parameters.values())
                    accepts_payload = len(params) > 0
                except (ValueError, TypeError):
                    # ç„¡æ³•ç²å–ç°½åæ™‚ï¼Œå˜—è©¦å‚³å…¥ payload
                    accepts_payload = True
                
                # èª¿ç”¨è™•ç†å™¨ä¸¦è¿”å›çµæœ
                if payload is not None and accepts_payload:
                    result = await handler(payload)
                else:
                    result = await handler()
                return result  # ğŸ”§ FIX: Return the handler result
            else:
                # å‘½ä»¤æœªæ‰¾åˆ°
                self.send_log(f"Unknown command: {command}", "warning")
                return None
            
            # ğŸ†• Phase 7: èˆŠçš„ if-elif éˆï¼ˆ1,370+ è¡Œï¼‰å·²è¢«ä¸Šæ–¹å‹•æ…‹æ©Ÿåˆ¶å–ä»£
            # æ‰€æœ‰ 452 å€‹å‘½ä»¤ç¾åœ¨é€šé CommandRouter + å‹•æ…‹ getattr å›é€€è™•ç†
            # é€™å¤§å¹…æ¸›å°‘äº†ä»£ç¢¼é‡è¤‡ä¸¦æé«˜äº†å¯ç¶­è­·æ€§
        
        except Exception as e:
            # Use global error handler
            app_error = handle_error(e, {"command": command, "payload": payload})
            # Error is already logged by error handler
            
            # Send error acknowledgment if request_id provided
            if request_id:
                self.send_event("command-complete", {
                    "request_id": request_id,
                    "command": command,
                    "status": "error",
                    "error": str(app_error)
                })
            
            import traceback
            traceback.print_exc()
    
    # ==================== Command Handlers ====================
    
    async def handle_get_initial_state(self):
        """Handle get-initial-state command and restore monitoring state if needed"""
        try:
            import sys
            import time
            start_time = time.time()
            print("[Backend] handle_get_initial_state called", file=sys.stderr)
            
            # ğŸ†• ç™¼é€è¼‰å…¥é€²åº¦äº‹ä»¶ï¼ˆä¸‰éšæ®µé€²åº¦ï¼‰
            self.send_event("loading-progress", {
                "step": "start",
                "message": "ğŸ”— æ­£åœ¨é€£æ¥æ•¸æ“šåº«...",
                "progress": 10
            })
            
            # ========== å„ªåŒ–ï¼šä¸¦è¡Œç²å–æ‰€æœ‰æ•¸æ“š ==========
            print("[Backend] Loading all data in parallel...", file=sys.stderr)
            parallel_start = time.time()
            
            # ä¸¦è¡ŒåŸ·è¡Œæ‰€æœ‰æ•¸æ“šåº«æŸ¥è©¢
            results = await asyncio.gather(
                db.get_all_accounts(),
                db.get_all_keyword_sets(),
                db.get_all_groups(),
                db.get_all_campaigns(),
                db.get_all_templates(),
                db.get_leads_with_total(limit=20, initial_load=True),  # ğŸ†• é¦–æ‰¹åªåŠ è¼‰ 20 æ¢ï¼Œæ¸›å°‘å•Ÿå‹•æ™‚é–“
                db.get_recent_logs(limit=50),
                db.get_all_settings(),
                db.get_monitoring_config(),
                db.get_all_trigger_rules(),  # ğŸ”§ FIX: ä¹ŸåŠ è¼‰è§¸ç™¼è¦å‰‡
                return_exceptions=True
            )
            
            parallel_duration = time.time() - parallel_start
            print(f"[Backend] Parallel data loading completed in {parallel_duration:.3f}s", file=sys.stderr)
            
            # ğŸ†• ç™¼é€è¼‰å…¥é€²åº¦äº‹ä»¶ï¼ˆéšæ®µ2ï¼šæ•¸æ“šè™•ç†ï¼‰
            self.send_event("loading-progress", {
                "step": "data_loaded",
                "message": "ğŸ“Š æ•¸æ“šè¼‰å…¥å®Œæˆï¼Œæ­£åœ¨åˆå§‹åŒ–...",
                "progress": 50
            })
            
            # è§£æçµæœï¼ˆè™•ç†å¯èƒ½çš„ç•°å¸¸ï¼‰
            accounts = results[0] if not isinstance(results[0], Exception) else []
            keyword_sets = results[1] if not isinstance(results[1], Exception) else []
            monitored_groups = results[2] if not isinstance(results[2], Exception) else []
            campaigns = results[3] if not isinstance(results[3], Exception) else []
            message_templates = results[4] if not isinstance(results[4], Exception) else []
            leads_data = results[5] if not isinstance(results[5], Exception) else {'leads': [], 'total': 0, 'hasMore': False}
            leads = leads_data.get('leads', []) if isinstance(leads_data, dict) else []
            leads_total = leads_data.get('total', 0) if isinstance(leads_data, dict) else 0
            leads_has_more = leads_data.get('hasMore', False) if isinstance(leads_data, dict) else False
            logs = results[6] if not isinstance(results[6], Exception) else []
            settings = results[7] if not isinstance(results[7], Exception) else {}
            monitoring_config = results[8] if not isinstance(results[8], Exception) else {}
            trigger_rules = results[9] if not isinstance(results[9], Exception) else []  # ğŸ”§ FIX: è§¸ç™¼è¦å‰‡
            
            # è¨˜éŒ„ä»»ä½•æŸ¥è©¢éŒ¯èª¤
            for i, result in enumerate(results):
                if isinstance(result, Exception):
                    print(f"[Backend] Query {i} failed: {result}", file=sys.stderr)
            
            print(f"[Backend] Loaded: {len(accounts)} accounts, {len(keyword_sets)} keyword_sets, {len(monitored_groups)} groups, {len(campaigns)} campaigns, {len(message_templates)} templates, {len(trigger_rules)} trigger_rules, {len(leads)} leads, {len(logs)} logs", file=sys.stderr)
            
            # ğŸ†• å„ªåŒ–ï¼šæ‰¹é‡åŒæ­¥å¸³è™Ÿé€£æ¥ç‹€æ…‹ï¼ˆæ¸›å°‘æ•¸æ“šåº«èª¿ç”¨ï¼‰
            sync_start = time.time()
            print("[Backend] Syncing account connection status...", file=sys.stderr)
            
            # æ”¶é›†éœ€è¦é‡ç½®ç‚º Offline çš„å¸³è™Ÿ ID
            accounts_to_reset = []
            
            for account in accounts:
                phone = account.get('phone')
                db_status = account.get('status', 'Offline')
                should_reset = False
                
                # æ£€æŸ¥ Telegram å®¢æˆ·ç«¯æ˜¯å¦çœŸæ­£è¿æ¥
                client = self.telegram_manager.get_client(phone) if phone else None
                is_actually_connected = client and client.is_connected if client else False
                
                # å¦‚æœæ•°æ®åº“æ˜¾ç¤ºåœ¨çº¿ä½†å®¢æˆ·ç«¯æœªè¿æ¥
                if db_status == 'Online' and not is_actually_connected:
                    should_reset = True
                    print(f"[Backend] Account {mask_phone(phone)}: Online but not connected -> Offline", file=sys.stderr)
                
                # ä¿®å¾© Error ç‹€æ…‹
                elif db_status.lower() in ['error', 'proxy error', 'auth error', 'session expired']:
                    should_reset = True
                    print(f"[Backend] Account {phone}: {db_status} -> Offline (resetting error)", file=sys.stderr)
                elif 'error' in db_status.lower():
                    should_reset = True
                    print(f"[Backend] Account {phone}: {db_status} -> Offline (contains error)", file=sys.stderr)
                
                if should_reset:
                    account['status'] = 'Offline'
                    if account.get('id'):
                        accounts_to_reset.append(account['id'])
                
                account['isConnected'] = is_actually_connected
            
            # ğŸ†• æ‰¹é‡æ›´æ–°æ•¸æ“šåº«ï¼ˆå–®ä¸€ SQL èª¿ç”¨ï¼‰
            if accounts_to_reset:
                updated_count = await db.batch_update_account_status(accounts_to_reset, 'Offline')
                print(f"[Backend] Batch updated {updated_count} accounts to Offline in {time.time() - sync_start:.3f}s", file=sys.stderr)
            else:
                print(f"[Backend] No accounts need status update ({time.time() - sync_start:.3f}s)", file=sys.stderr)
            
            # ========== å„ªåŒ–ï¼šæ‰¹é‡è™•ç†æ™‚é–“æˆ³ ==========
            def normalize_timestamp(ts):
                """å¿«é€Ÿæ ¼å¼åŒ–æ™‚é–“æˆ³"""
                if ts is None:
                    return datetime.now().isoformat() + "Z"
                if isinstance(ts, str):
                    return ts if ts.endswith('Z') else ts + "Z"
                try:
                    return datetime.fromisoformat(str(ts)).isoformat() + "Z"
                except (ValueError, TypeError):
                    return datetime.now().isoformat() + "Z"
            
            ts_start = time.time()
            
            # æ‰¹é‡è™•ç† leads æ™‚é–“æˆ³
            for lead in leads:
                lead['timestamp'] = normalize_timestamp(lead.get('timestamp'))
                # åªè™•ç†å‰å¹¾å€‹ interactionï¼ˆå„ªåŒ–ï¼‰
                interactions = lead.get('interactionHistory', [])
                for interaction in interactions[:10]:  # åªè™•ç†æœ€è¿‘10å€‹
                    interaction['timestamp'] = normalize_timestamp(interaction.get('timestamp'))
            
            # æ‰¹é‡è™•ç† logs æ™‚é–“æˆ³
            for log in logs:
                log['timestamp'] = normalize_timestamp(log.get('timestamp'))
            
            ts_duration = time.time() - ts_start
            print(f"[Backend] Timestamps processed in {ts_duration:.3f}s", file=sys.stderr)
            
            # Settings å’Œ monitoring_config å·²åœ¨ä¸¦è¡ŒæŸ¥è©¢ä¸­ç²å–
            is_monitoring = monitoring_config.get('isActive', False)
            print(f"[Backend] Monitoring config: isActive={is_monitoring}", file=sys.stderr)
            
            # ğŸ†• å»¶é²æ¢å¾©ç›£æ§ï¼šä¸é˜»å¡åˆå§‹ç‹€æ…‹ç™¼é€ï¼Œæ”¹ç‚ºå¾Œå°ä»»å‹™
            should_restore_monitoring = False
            if is_monitoring and not self.is_monitoring:
                # Check if we can restore monitoring
                listener_accounts = [a for a in accounts if a.get('role') == 'Listener' and a.get('status') == 'Online']
                if listener_accounts and monitored_groups and keyword_sets:
                    should_restore_monitoring = True
                    print("[Backend] Will restore monitoring in background after initial-state sent", file=sys.stderr)
                else:
                    # Cannot restore, reset state
                    await db.set_monitoring_active(False)
                    is_monitoring = False
                    print("[Backend] Cannot restore monitoring: missing requirements", file=sys.stderr)
            
            self.is_monitoring = is_monitoring
            
            # ğŸ†• æ¼¸é€²å¼ç™¼é€ï¼šåˆ†æ‰¹ç™¼é€æ•¸æ“šï¼Œè®“ UI ç›¡å¿«é¡¯ç¤º
            print(f"[Backend] Sending initial-state progressively with {len(accounts)} accounts, {leads_total} leads total", file=sys.stderr)
            print(f"[Backend] Account details: {[(a.get('phone'), a.get('firstName'), a.get('status')) for a in accounts]}", file=sys.stderr)
            
            # éšæ®µ 1: ç™¼é€æ ¸å¿ƒæ•¸æ“šï¼ˆå¸³è™Ÿã€è¨­ç½®ï¼‰- è®“ UI ç«‹å³é¡¯ç¤º
            self.send_event("loading-progress", {
                "step": "sending",
                "message": "æ­£åœ¨ç™¼é€å¸³è™Ÿæ•¸æ“š...",
                "progress": 70
            })
            
            self.send_event("initial-state-core", {
                "accounts": accounts,
                "settings": settings,
                "isMonitoring": is_monitoring
            })
            
            # éšæ®µ 2: ç™¼é€é…ç½®æ•¸æ“š
            self.send_event("loading-progress", {
                "step": "sending",
                "message": "æ­£åœ¨ç™¼é€é…ç½®æ•¸æ“š...",
                "progress": 80
            })
            
            self.send_event("initial-state-config", {
                "keywordSets": keyword_sets,
                "monitoredGroups": monitored_groups,
                "campaigns": campaigns,
                "messageTemplates": message_templates,
                "chatTemplates": message_templates,
                "triggerRules": trigger_rules  # ğŸ”§ FIX: åŒ…å«è§¸ç™¼è¦å‰‡
            })
            
            # éšæ®µ 3: ç™¼é€æ¥­å‹™æ•¸æ“šï¼ˆleadsã€logsï¼‰
            self.send_event("loading-progress", {
                "step": "sending",
                "message": "æ­£åœ¨ç™¼é€å®¢æˆ¶æ•¸æ“š...",
                "progress": 90
            })
            
            self.send_event("initial-state-data", {
                "leads": leads,
                "leadsTotal": leads_total,
                "leadsHasMore": leads_has_more,  # ğŸ†• æ˜¯å¦æœ‰æ›´å¤š leads éœ€è¦åŠ è¼‰
                "logs": logs
            })
            
            # ğŸ”„ å…¼å®¹èˆŠé‚è¼¯ï¼šä»ç„¶ç™¼é€å®Œæ•´çš„ initial-stateï¼ˆç”¨æ–¼å°šæœªæ›´æ–°çš„çµ„ä»¶ï¼‰
            self.send_event("initial-state", {
                "accounts": accounts,
                "keywordSets": keyword_sets,
                "monitoredGroups": monitored_groups,
                "campaigns": campaigns,
                "messageTemplates": message_templates,
                "chatTemplates": message_templates,
                "triggerRules": trigger_rules,  # ğŸ”§ FIX: åŒ…å«è§¸ç™¼è¦å‰‡
                "leads": leads,
                "leadsTotal": leads_total,
                "leadsHasMore": leads_has_more,  # ğŸ†• æ˜¯å¦æœ‰æ›´å¤š leads
                "logs": logs,
                "settings": settings,
                "isMonitoring": is_monitoring
            })
            
            # é¡å¤–ç™¼é€ accounts-updated äº‹ä»¶ç¢ºä¿å‰ç«¯æ¥æ”¶
            self.send_event("accounts-updated", accounts)
            
            total_duration = time.time() - start_time
            print(f"[Backend] âœ“ Initial state sent in {total_duration:.3f}s (parallel query: {parallel_duration:.3f}s)", file=sys.stderr)
            
            # ğŸ†• ç™¼é€è¼‰å…¥å®Œæˆäº‹ä»¶ï¼ˆéšæ®µ3ï¼šå®Œæˆï¼‰
            self.send_event("loading-progress", {
                "step": "complete",
                "message": f"âœ… é€£æ¥æˆåŠŸ ({total_duration:.1f}ç§’)",
                "progress": 100,
                "duration": total_duration
            })
            
            await db.add_log(f"Initial state sent to frontend ({total_duration:.2f}s)", "success")
            
            # ğŸ†• å¾Œå°æ¢å¾©ç›£æ§ï¼ˆä¸é˜»å¡ä¸»ç·šç¨‹ï¼‰
            if should_restore_monitoring:
                async def restore_monitoring_background():
                    try:
                        print("[Backend] Restoring monitoring in background...", file=sys.stderr)
                        await self.handle_start_monitoring()
                        await db.add_log("Monitoring state restored from database", "info")
                        print("[Backend] âœ“ Monitoring restored successfully", file=sys.stderr)
                    except Exception as e:
                        print(f"[Backend] Failed to restore monitoring: {e}", file=sys.stderr)
                        await db.add_log(f"Failed to restore monitoring: {str(e)}", "warning")
                        await db.set_monitoring_active(False)
                
                # å»¶é² 1 ç§’å¾Œåœ¨å¾Œå°æ¢å¾©ç›£æ§
                asyncio.get_event_loop().call_later(1.0, lambda: asyncio.create_task(restore_monitoring_background()))
            
            # ğŸ†• è¿”å› HTTP éŸ¿æ‡‰ï¼ˆWeb æ¨¡å¼éœ€è¦ï¼‰
            return {
                "success": True,
                "accounts": accounts,
                "keywordSets": keyword_sets,
                "monitoredGroups": monitored_groups,
                "campaigns": campaigns,
                "messageTemplates": message_templates,
                "chatTemplates": message_templates,
                "triggerRules": trigger_rules,
                "leads": leads,
                "leadsTotal": leads_total,
                "leadsHasMore": leads_has_more,
                "logs": logs,
                "settings": settings,
                "isMonitoring": is_monitoring
            }
        
        except Exception as e:
            import traceback
            print(f"[Backend] â˜…â˜…â˜… ERROR in handle_get_initial_state: {str(e)} â˜…â˜…â˜…", file=sys.stderr)
            traceback.print_exc(file=sys.stderr)
            self.send_log(f"Error getting initial state: {str(e)}", "error")
    
    # ========== Partial Update Functions ==========
    # These functions send only the updated data instead of full state refresh
    
    async def send_keyword_sets_update(self):
        """Send only keyword sets update to frontend with deduplication and error handling"""
        try:
            keyword_sets = await db.get_all_keyword_sets()
            
            if not keyword_sets:
                # å¦‚æœæ²’æœ‰é—œéµè©é›†ï¼Œç™¼é€ç©ºæ•¸çµ„
                self.send_event("keyword-sets-updated", {"keywordSets": []})
                return
            
            # å»é‡è™•ç†ï¼šç¢ºä¿æ²’æœ‰é‡è¤‡çš„é—œéµè©é›†å’Œé—œéµè©
            seen_set_ids = set()  # ä½¿ç”¨ ID è€Œä¸æ˜¯åç¨±ï¼Œå› ç‚ºåç¨±å¯èƒ½é‡è¤‡
            seen_set_names = {}  # åç¨± -> ID æ˜ å°„ï¼Œç”¨æ–¼æª¢æ¸¬é‡è¤‡åç¨±
            deduplicated_sets = []
            
            for keyword_set in keyword_sets:
                set_id = keyword_set.get('id')
                set_name = keyword_set.get('name', '')
                
                # å¦‚æœé—œéµè©é›† ID å·²è™•ç†éï¼Œè·³éï¼ˆé˜²æ­¢é‡è¤‡ï¼‰
                if set_id in seen_set_ids:
                    continue
                seen_set_ids.add(set_id)
                
                # å¦‚æœé—œéµè©é›†åç¨±å·²å­˜åœ¨ä¸” ID ä¸åŒï¼Œè¨˜éŒ„è­¦å‘Šä½†ä¿ç•™ï¼ˆå› ç‚ºå¯èƒ½ç¢ºå¯¦æœ‰åŒåä½†ä¸åŒçš„é›†ï¼‰
                if set_name and set_name in seen_set_names:
                    if seen_set_names[set_name] != set_id:
                        import sys
                        print(f"[Backend] Warning: Duplicate keyword set name '{set_name}' with different IDs: {seen_set_names[set_name]} and {set_id}", file=sys.stderr)
                seen_set_names[set_name] = set_id
                
                # å°é—œéµè©é€²è¡Œå»é‡ï¼ˆåŸºæ–¼ keyword + isRegex çµ„åˆï¼‰
                seen_keywords = set()
                unique_keywords = []
                for keyword in keyword_set.get('keywords', []):
                    keyword_text = keyword.get('keyword', '')
                    is_regex = keyword.get('isRegex', False)
                    keyword_id = keyword.get('id')
                    key = (keyword_text, is_regex)
                    
                    # å¦‚æœé—œéµè©å·²å­˜åœ¨ï¼Œè·³éï¼ˆä¿ç•™ç¬¬ä¸€å€‹ï¼‰
                    if key in seen_keywords:
                        import sys
                        print(f"[Backend] Warning: Duplicate keyword '{keyword_text}' (isRegex={is_regex}) in set {set_id}, skipping", file=sys.stderr)
                        continue
                    
                    seen_keywords.add(key)
                    unique_keywords.append({
                        'id': keyword_id,
                        'keyword': keyword_text,
                        'isRegex': is_regex
                    })
                
                # å‰µå»ºå»é‡å¾Œçš„é—œéµè©é›†
                deduplicated_set = {
                    'id': set_id,
                    'name': set_name,
                    'keywords': unique_keywords
                }
                deduplicated_sets.append(deduplicated_set)
            
            # ç¢ºä¿äº‹ä»¶è¢«ç™¼é€
            import sys
            print(f"[Backend] Sending keyword-sets-updated event with {len(deduplicated_sets)} sets", file=sys.stderr)
            self.send_event("keyword-sets-updated", {"keywordSets": deduplicated_sets})
        except Exception as e:
            import sys
            print(f"[Backend] Error sending keyword sets update: {e}", file=sys.stderr)
            import traceback
            traceback.print_exc(file=sys.stderr)
            # å³ä½¿å‡ºéŒ¯ï¼Œä¹Ÿå˜—è©¦ç™¼é€ä¸€å€‹ç©ºæ•¸çµ„æˆ–æœ€å¾Œå·²çŸ¥çš„ç‹€æ…‹ï¼Œé¿å…å‰ç«¯ç‹€æ…‹å¡ä½
            try:
                # å˜—è©¦ç²å–ä¸€å€‹ç°¡åŒ–çš„ç‹€æ…‹
                keyword_sets = await db.get_all_keyword_sets()
                self.send_event("keyword-sets-updated", {"keywordSets": keyword_sets if keyword_sets else []})
            except:
                # å¦‚æœé€£é€™å€‹éƒ½å¤±æ•—ï¼Œè‡³å°‘ç™¼é€ç©ºæ•¸çµ„
                self.send_event("keyword-sets-updated", {"keywordSets": []})
    
    async def send_groups_update(self):
        """Send only monitored groups update to frontend"""
        try:
            groups = await db.get_all_groups()
            self.send_event("groups-updated", {"monitoredGroups": groups})
        except Exception as e:
            print(f"[Backend] Error sending groups update: {e}", file=sys.stderr)
    
    async def send_templates_update(self):
        """Send only message templates update to frontend"""
        try:
            templates = await db.get_all_templates()
            self.send_event("templates-updated", {"messageTemplates": templates, "chatTemplates": templates})
        except Exception as e:
            print(f"[Backend] Error sending templates update: {e}", file=sys.stderr)
    
    async def send_campaigns_update(self):
        """Send only campaigns update to frontend"""
        try:
            campaigns = await db.get_all_campaigns()
            self.send_event("campaigns-updated", {"campaigns": campaigns})
        except Exception as e:
            print(f"[Backend] Error sending campaigns update: {e}", file=sys.stderr)
    
    async def send_leads_update(self):
        """Send only leads update to frontendï¼ˆğŸ†• åŒ…å« totalï¼‰"""
        try:
            # ğŸ†• ä½¿ç”¨ get_leads_with_total ç²å–å®Œæ•´æ•¸æ“šå’Œç¸½æ•¸
            data = await db.get_leads_with_total()
            leads = data.get('leads', [])
            total = data.get('total', len(leads))
            
            for lead in leads:
                if isinstance(lead.get('timestamp'), str):
                    pass
                else:
                    lead['timestamp'] = datetime.fromisoformat(lead['timestamp']).isoformat() + "Z"
                for interaction in lead.get('interactionHistory', []):
                    if isinstance(interaction.get('timestamp'), str):
                        pass
                    else:
                        interaction['timestamp'] = datetime.fromisoformat(interaction['timestamp']).isoformat() + "Z"
            
            self.send_event("leads-updated", {"leads": leads, "total": total})
        except Exception as e:
            print(f"[Backend] Error sending leads update: {e}", file=sys.stderr)
    
    # ========== End Partial Update Functions ==========
    
    async def _handle_qr_login_account_ready(self, payload: Dict[str, Any]):
        """
        è™•ç† QR ç™»å…¥æˆåŠŸäº‹ä»¶ï¼Œå°‡å¸³è™Ÿæ·»åŠ åˆ°æ•¸æ“šåº«
        
        Args:
            payload: QR ç™»å…¥è¿”å›çš„å¸³è™Ÿæ•¸æ“šï¼ŒåŒ…å« phone, api_id, api_hash, session_string, device_fingerprint ç­‰
        """
        try:
            phone = payload.get('phone', '')
            api_id = payload.get('api_id') or payload.get('apiId')  # æ”¯æŒå…©ç¨®å­—æ®µå
            api_hash = payload.get('api_hash') or payload.get('apiHash')  # æ”¯æŒå…©ç¨®å­—æ®µå
            proxy = payload.get('proxy', '')
            session_string = payload.get('session_string', '')
            device_fingerprint = payload.get('device_fingerprint', {})
            user_info = payload.get('user_info', {})
            
            print(f"[Backend] Handling QR login account ready for {phone}", file=sys.stderr)
            print(f"[Backend] QR login payload: api_id={api_id}, api_hash={'***' if api_hash else None}", file=sys.stderr)
            
            if not phone:
                print(f"[Backend] Error: No phone number in QR login payload", file=sys.stderr)
                return
            
            # ç¢ºä¿ API æ†‘è­‰å­˜åœ¨ï¼ˆQR ç™»å…¥æ™‚å¿…é ˆæœ‰ï¼‰
            if not api_id or not api_hash:
                print(f"[Backend] Warning: Missing API credentials in QR login payload. Payload keys: {list(payload.keys())}", file=sys.stderr)
                # å˜—è©¦å¾ client ç²å–ï¼ˆå¦‚æœ payload ä¸­æœ‰ client ä¿¡æ¯ï¼‰
                # å¦‚æœé‚„æ˜¯æ²’æœ‰ï¼Œä½¿ç”¨é»˜èªçš„å…¬å…± API æ†‘è­‰
                if not api_id or not api_hash:
                    print(f"[Backend] Using default public API credentials for QR login", file=sys.stderr)
                    # ä½¿ç”¨ Telegram Desktop çš„å…¬å…± API æ†‘è­‰ä½œç‚ºé»˜èªå€¼
                    api_id = api_id or "2040"
                    api_hash = api_hash or "b18441a1ff607e10a989891a5462e627"
            
            # æª¢æŸ¥å¸³è™Ÿæ˜¯å¦å·²å­˜åœ¨
            existing_account = await db.get_account_by_phone(phone)
            
            if existing_account:
                # å¸³è™Ÿå·²å­˜åœ¨ï¼Œæ›´æ–°ç›¸é—œä¿¡æ¯
                account_id = existing_account.get('id')
                print(f"[Backend] Account {phone} already exists (ID: {account_id}), updating...", file=sys.stderr)
                
                update_data = {
                    'status': 'Online',  # QR ç™»å…¥æˆåŠŸï¼Œè¨­ç½®ç‚ºåœ¨ç·š
                }
                
                # å¼·åˆ¶æ›´æ–° API æ†‘æ“šï¼ˆQR ç™»å…¥æ™‚å¿…é ˆæœ‰ï¼‰
                # å„ªå…ˆä½¿ç”¨æ–°çš„ API æ†‘è­‰ï¼Œå¦‚æœæ²’æœ‰å‰‡æª¢æŸ¥ç¾æœ‰å¸³è™Ÿæ˜¯å¦æœ‰
                if api_id and api_hash:
                    update_data['apiId'] = str(api_id)
                    update_data['apiHash'] = str(api_hash)
                    print(f"[Backend] Updating API credentials: apiId={api_id}", file=sys.stderr)
                elif not existing_account.get('apiId') or not existing_account.get('apiHash'):
                    # å¦‚æœç¾æœ‰å¸³è™Ÿæ²’æœ‰ API æ†‘è­‰ï¼Œä½¿ç”¨é»˜èªå…¬å…±æ†‘è­‰
                    print(f"[Backend] WARNING: Missing API credentials, using default public credentials", file=sys.stderr)
                    update_data['apiId'] = "2040"
                    update_data['apiHash'] = "b18441a1ff607e10a989891a5462e627"
                else:
                    # ä¿æŒç¾æœ‰çš„ API æ†‘è­‰
                    print(f"[Backend] Keeping existing API credentials", file=sys.stderr)
                if proxy:
                    update_data['proxy'] = proxy
                
                # æ›´æ–°è¨­å‚™æŒ‡ç´‹
                if device_fingerprint:
                    update_data['deviceModel'] = device_fingerprint.get('device_model', '')
                    update_data['systemVersion'] = device_fingerprint.get('system_version', '')
                    update_data['appVersion'] = device_fingerprint.get('app_version', '')
                    update_data['langCode'] = device_fingerprint.get('lang_code', '')
                    update_data['platform'] = device_fingerprint.get('platform', '')
                
                await db.update_account(account_id, update_data)
                self.send_log(f"âœ… QR ç™»å…¥æˆåŠŸï¼Œå¸³è™Ÿ {phone} å·²æ›´æ–°", "success")
            else:
                # æ–°å¸³è™Ÿï¼Œæ·»åŠ åˆ°æ•¸æ“šåº«
                print(f"[Backend] Adding new account {phone} from QR login", file=sys.stderr)
                
                # ç¢ºä¿ API æ†‘è­‰ä¸ç‚ºç©ºï¼ˆQR ç™»å…¥æ™‚å¿…é ˆæœ‰ï¼‰
                if not api_id or not api_hash:
                    print(f"[Backend] Error: Cannot add account without API credentials", file=sys.stderr)
                    self.send_log(f"âŒ QR ç™»å…¥å¤±æ•—ï¼šç¼ºå°‘ API æ†‘è­‰", "error")
                    return
                
                # ========== QR ç™»å…¥æ™ºèƒ½è§’è‰²åˆ†é… ==========
                all_accounts = await db.get_all_accounts()
                has_listener = any(a.get('role') == 'Listener' for a in all_accounts)
                has_sender = any(a.get('role') == 'Sender' for a in all_accounts)
                
                auto_role = 'Unassigned'
                role_message = None
                
                if not has_listener:
                    auto_role = 'Listener'
                    role_message = f'å·²è‡ªå‹•å°‡ {phone} è¨­ç‚ºã€Œç›£æ§è™Ÿã€ï¼ˆç”¨æ–¼ç›£æ§ç¾¤çµ„æ¶ˆæ¯ï¼‰'
                elif not has_sender:
                    auto_role = 'Sender'
                    role_message = f'å·²è‡ªå‹•å°‡ {phone} è¨­ç‚ºã€Œç™¼é€è™Ÿã€ï¼ˆç”¨æ–¼ç™¼é€æ¶ˆæ¯çµ¦æ½›åœ¨å®¢æˆ¶ï¼‰'
                # ========== QR ç™»å…¥æ™ºèƒ½è§’è‰²åˆ†é…çµæŸ ==========

                account_data = {
                    'phone': phone,
                    'apiId': str(api_id),  # å¼·åˆ¶è½‰æ›ç‚ºå­—ç¬¦ä¸²
                    'apiHash': str(api_hash),  # ç¢ºä¿ä¸ç‚ºç©º
                    'proxy': proxy or '',
                    'group': '',
                    'role': auto_role,  # ä½¿ç”¨è‡ªå‹•åˆ†é…çš„è§’è‰²
                    'status': 'Online',  # QR ç™»å…¥æˆåŠŸï¼Œç›´æ¥è¨­ç½®ç‚ºåœ¨ç·š
                    'twoFactorPassword': '',
                }

                print(f"[Backend] Adding account with API ID: {api_id}, API Hash: {'***' if api_hash else 'MISSING'}, role={auto_role}", file=sys.stderr)

                # æ·»åŠ è¨­å‚™æŒ‡ç´‹
                if device_fingerprint:
                    account_data['deviceModel'] = device_fingerprint.get('device_model', '')
                    account_data['systemVersion'] = device_fingerprint.get('system_version', '')
                    account_data['appVersion'] = device_fingerprint.get('app_version', '')
                    account_data['langCode'] = device_fingerprint.get('lang_code', '')
                    account_data['platform'] = device_fingerprint.get('platform', '')

                account_id = await db.add_account(account_data)
                print(f"[Backend] Account {phone} added with ID: {account_id}", file=sys.stderr)

                # ä½¿ç”¨ self.send_log è€Œä¸æ˜¯ db.add_logï¼ˆDatabase é¡æ²’æœ‰é€™å€‹æ–¹æ³•ï¼‰
                self.send_log(f"âœ… QR ç™»å…¥æˆåŠŸï¼Œå¸³è™Ÿ {phone} å·²æ·»åŠ ", "success")
                
                # é¡¯ç¤ºè§’è‰²åˆ†é…æç¤º
                if role_message:
                    self.send_log(f"ğŸ¯ {role_message}", "success")
                else:
                    self.send_log(f"ğŸ’¡ å¸³è™Ÿ {phone} å·²ç™»å…¥ï¼Œè«‹åœ¨å¸³è™Ÿç®¡ç†ä¸­åˆ†é…è§’è‰²", "info")
            
            # ç™¼é€å¸³è™Ÿåˆ—è¡¨æ›´æ–°äº‹ä»¶
            accounts = await db.get_all_accounts()
            self._cache.pop("accounts", None)
            self._cache_timestamps.pop("accounts", None)
            self.send_event("accounts-updated", accounts)
            print(f"[Backend] Sent accounts-updated event with {len(accounts)} accounts", file=sys.stderr)
            
        except Exception as e:
            print(f"[Backend] Error handling QR login account ready: {e}", file=sys.stderr)
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_log(f"âŒ QR ç™»å…¥å¸³è™Ÿè™•ç†å¤±æ•—: {str(e)}", "error")

    async def handle_add_account(self, payload: Dict[str, Any]):
        """Handle add-account command"""
        try:
            import sys
            import re as re_module
            
            # Clean phone number - remove spaces, dashes, and parentheses
            if 'phone' in payload:
                payload['phone'] = re_module.sub(r'[\s\-\(\)]', '', payload['phone'].strip())
            
            print(f"[Backend] Handling add-account command for phone: {payload.get('phone', 'unknown')}", file=sys.stderr)
            
            # Validate account data
            is_valid, errors = validate_account(payload)
            if not is_valid:
                error_message = "éªŒè¯å¤±è´¥: " + "; ".join(errors)
                print(f"[Backend] Validation failed: {errors}", file=sys.stderr)
                self.send_log(error_message, "error")
                self.send_event("account-validation-error", {
                    "errors": errors,
                    "account_data": payload
                })
                handle_error(
                    AppError(ErrorType.VALIDATION_ERROR, error_message, {"errors": errors}),
                    {"command": "add-account", "payload": payload}
                )
                # ğŸ†• è¿”å›éŒ¯èª¤çµæœï¼ˆHTTP API æ¨¡å¼éœ€è¦ï¼‰
                return {
                    "success": False,
                    "error": error_message,
                    "errors": errors
                }
            
            print(f"[Backend] Validation passed, checking for existing account/session...", file=sys.stderr)
            
            phone = payload.get('phone', '')
            
            # Check if account already exists in database
            existing_account = await db.get_account_by_phone(phone)
            if existing_account:
                existing_status = existing_account.get('status', 'Offline')
                existing_id = existing_account.get('id')
                
                # CRITICAL: If account is already Online, just return success - don't trigger any login
                if existing_status == "Online":
                    print(f"[Backend] Account {phone} already exists and is Online, skipping", file=sys.stderr)
                    # Send duplicate error to inform user
                    error_msg = f"è´¦æˆ·å·²å­˜åœ¨: ç”µè¯å·ç  {phone} å·²ç»åœ¨ç³»ç»Ÿä¸­ï¼ˆçŠ¶æ€: åœ¨çº¿ï¼‰ã€‚æ— éœ€é‡å¤æ·»åŠ ã€‚"
                    self.send_log(error_msg, "info")
                    self.send_event("account-validation-error", {
                        "errors": [error_msg],
                        "account_data": payload,
                        "error_type": "duplicate"
                    })
                    return
                
                # OPTIMIZATION: If account exists with "error" or "Offline" status, 
                # automatically trigger login instead of showing "account already exists" error
                if existing_status in ["error", "Offline"]:
                    print(f"[Backend] Account exists with status '{existing_status}', automatically triggering login...", file=sys.stderr)
                    
                    # Reset status to Offline and clear login state
                    await db.update_account(existing_id, {"status": "Offline"})
                    # Clear any login callbacks for this phone
                    self.telegram_manager.login_callbacks.pop(phone, None)
                    
                    # Update account data if provided (API ID, API Hash, etc.)
                    update_data = {}
                    old_api_id = existing_account.get('apiId')
                    new_api_id = payload.get('apiId')
                    
                    if new_api_id:
                        update_data['apiId'] = new_api_id
                    if payload.get('apiHash'):
                        update_data['apiHash'] = payload['apiHash']
                    if payload.get('proxy'):
                        update_data['proxy'] = payload['proxy']
                    if payload.get('group'):
                        update_data['group'] = payload['group']
                    if payload.get('twoFactorPassword'):
                        update_data['twoFactorPassword'] = payload['twoFactorPassword']
                    if payload.get('role'):
                        update_data['role'] = payload['role']
                    
                    if update_data:
                        await db.update_account(existing_id, update_data)
                        print(f"[Backend] Updated account data for {phone}", file=sys.stderr)
                    
                    # æ›´æ–° API æ†‘æ“šä½¿ç”¨è¨ˆæ•¸ï¼ˆç•¶ API ID æ”¹è®Šæ™‚ï¼‰
                    if new_api_id and new_api_id != old_api_id:
                        try:
                            from api_credential_pool import get_api_credential_pool
                            data_dir = str(Path(config.DATA_PATH))
                            pool = get_api_credential_pool(data_dir)
                            
                            # é‡‹æ”¾èˆŠçš„ API æ†‘æ“š
                            if old_api_id:
                                pool.release_credential(old_api_id)
                                print(f"[Backend] Released old API credential {old_api_id}", file=sys.stderr)
                            
                            # åˆ†é…æ–°çš„ API æ†‘æ“š
                            pool.allocate_credential(new_api_id)
                            print(f"[Backend] Allocated new API credential {new_api_id}", file=sys.stderr)
                            
                            # ç™¼é€æ›´æ–°çš„æ†‘æ“šä¿¡æ¯
                            credentials = pool.list_credentials()
                            self.send_event("api-credentials-updated", {"credentials": credentials})
                        except Exception as e:
                            print(f"[Backend] Error updating API credential usage: {e}", file=sys.stderr)
                    
                    # Send updated accounts list
                    accounts = await db.get_all_accounts()
                    self._cache.pop("accounts", None)
                    self._cache_timestamps.pop("accounts", None)
                    self.send_event("accounts-updated", accounts)
                    
                    # Automatically trigger login
                    print(f"[Backend] Auto-triggering login for existing account {phone} (ID: {existing_id})", file=sys.stderr)
                    self.send_log(f"è´¦æˆ· {phone} å·²å­˜åœ¨ï¼Œè‡ªåŠ¨è§¦å‘ç™»å½•...", "info")
                    
                    # Trigger login asynchronously (don't block the response)
                    asyncio.create_task(self.handle_login_account({
                        "accountId": existing_id,
                        "phoneCode": None,
                        "phoneCodeHash": None
                    }))
                    
                    # Return success with a message indicating auto-login was triggered
                    return
                
                # Check if account has stuck status (Logging in... or Waiting Code)
                if existing_status in ['Logging in...', 'Waiting Code', 'Waiting 2FA']:
                    # CRITICAL: If account is in login process (especially Waiting Code), 
                    # DO NOT update account data or send events that might trigger re-login
                    # Just return success silently to prevent status loop
                    print(f"[Backend] Account {phone} is in login process (status: {existing_status}), skipping update to prevent status loop", file=sys.stderr)
                    
                    # Only update account data if there are actual changes AND status is not Waiting Code
                    # If status is Waiting Code, user is waiting for verification code - do NOT update
                    if existing_status != 'Waiting Code':
                        # For Logging in... or Waiting 2FA, allow minimal updates
                        update_data = {}
                        if payload.get('apiId'):
                            update_data['apiId'] = payload.get('apiId')
                        if payload.get('apiHash'):
                            update_data['apiHash'] = payload.get('apiHash')
                        
                        if update_data and existing_id:
                            await db.update_account(existing_id, update_data)
                            print(f"[Backend] Updated account data for {phone}", file=sys.stderr)
                            # Only send accounts-updated if we actually updated something
                            accounts = await db.get_all_accounts()
                            self._cache.pop("accounts", None)
                            self._cache_timestamps.pop("accounts", None)
                            self.send_event("accounts-updated", accounts)
                    
                    # Return success - account exists and is in login process
                    # DO NOT send accounts-updated event if status is Waiting Code to prevent loop
                    return
                
                # If account exists with other statuses (Online, Offline, error), show error
                error_msg = f"è´¦æˆ·å·²å­˜åœ¨: ç”µè¯å·ç  {phone} å·²ç»åœ¨ç³»ç»Ÿä¸­ï¼ˆçŠ¶æ€: {existing_status}ï¼‰ã€‚å¦‚éœ€æ›´æ–°è´¦æˆ·ä¿¡æ¯ï¼Œè¯·ä½¿ç”¨æ›´æ–°åŠŸèƒ½ã€‚"
                print(f"[Backend] Account already exists in database: {phone}, status: {existing_status}", file=sys.stderr)
                self.send_log(error_msg, "error")
                self.send_event("account-validation-error", {
                    "errors": [error_msg],
                    "account_data": payload,
                    "error_type": "duplicate"
                })
                return
            
            # Check if session file exists (but account not in database)
            from config import SESSIONS_DIR
            safe_phone = phone.replace("+", "").replace("-", "").replace(" ", "")
            session_file = SESSIONS_DIR / f"{safe_phone}.session"
            session_journal = SESSIONS_DIR / f"{safe_phone}.session.journal"
            
            if session_file.exists() or session_journal.exists():
                # Session file exists but account not in database
                # This could be an orphaned session file
                print(f"[Backend] Warning: Session file exists for {phone} but account not in database", file=sys.stderr)
                
                # CRITICAL: Ensure any client using this session is disconnected first
                try:
                    await self.telegram_manager.remove_client(phone, wait_for_disconnect=True)
                    # Force garbage collection to release file handles
                    gc.collect()
                    await asyncio.sleep(0.3)  # Give OS time to release file handles
                except Exception as e:
                    print(f"[Backend] Warning: Could not remove client for {phone} (may not exist): {e}", file=sys.stderr)
                
                # Now try to delete the orphaned session files
                print(f"[Backend] Deleting orphaned session file: {session_file}", file=sys.stderr)
                session_deleted = await self.safe_delete_session_file(session_file)
                
                if session_journal.exists():
                    journal_deleted = await self.safe_delete_session_file(session_journal)
                else:
                    journal_deleted = True
                
                if not session_deleted or not journal_deleted:
                    # If we can't delete the session file, we should not add the account
                    # This prevents database inconsistency
                    error_msg = f"æ— æ³•åˆ é™¤å·²å­˜åœ¨çš„ä¼šè¯æ–‡ä»¶ã€‚è¯·ç¡®ä¿æ²¡æœ‰å…¶ä»–ç¨‹åºæ­£åœ¨ä½¿ç”¨è¯¥æ–‡ä»¶ï¼Œç„¶åé‡è¯•ã€‚"
                    print(f"[Backend] Cannot delete orphaned session file, aborting account addition", file=sys.stderr)
                    self.send_log(error_msg, "error")
                    self.send_event("account-validation-error", {
                        "errors": [error_msg],
                        "account_data": payload,
                        "error_type": "file_locked"
                    })
                    return
                
                print(f"[Backend] Orphaned session file deleted successfully", file=sys.stderr)
            
            print(f"[Backend] Adding account to database...", file=sys.stderr)
            
            # Generate device fingerprint for anti-ban (é˜²å°)
            DeviceFingerprintGenerator = get_DeviceFingerprintGenerator()
            device_config = DeviceFingerprintGenerator.generate_for_phone(phone)
            print(f"[Backend] Generated device fingerprint for {phone}: {device_config.get('device_model')} ({device_config.get('platform')})", file=sys.stderr)
            
            # Add device fingerprint to payload
            payload['deviceModel'] = device_config.get('device_model')
            payload['systemVersion'] = device_config.get('system_version')
            payload['appVersion'] = device_config.get('app_version')
            payload['langCode'] = device_config.get('lang_code')
            payload['platform'] = device_config.get('platform')
            payload['deviceId'] = device_config.get('device_id')
            
            # Get proxy country from phone number (if proxy is provided)
            if payload.get('proxy'):
                proxy_country = ProxyManager.get_country_from_phone(phone)
                if proxy_country:
                    payload['proxyCountry'] = proxy_country
                    payload['proxyType'] = 'residential'  # Default to residential proxy
            
            # Ensure status is set to Offline when adding account
            payload['status'] = 'Offline'
            
            account_id = await db.add_account(payload)
            print(f"[Backend] Account added successfully with ID: {account_id}", file=sys.stderr)
            
            # Double-check: ensure status is Offline (in case of any issues)
            await db.update_account(account_id, {"status": "Offline"})
            print(f"[Backend] Account status set to Offline for {phone}", file=sys.stderr)
            
            # æ›´æ–° API æ†‘æ“šæ± ä½¿ç”¨è¨ˆæ•¸
            api_id = payload.get('apiId')
            if api_id:
                try:
                    from api_credential_pool import get_api_credential_pool
                    data_dir = str(Path(config.DATA_PATH))
                    pool = get_api_credential_pool(data_dir)
                    if pool.allocate_credential(api_id):
                        print(f"[Backend] API credential {api_id} usage count incremented", file=sys.stderr)
                        # ç™¼é€æ›´æ–°çš„æ†‘æ“šä¿¡æ¯
                        credentials = pool.list_credentials()
                        self.send_event("api-credentials-updated", {"credentials": credentials})
                except Exception as e:
                    print(f"[Backend] Error updating API credential usage: {e}", file=sys.stderr)
            
            await db.add_log(f"Account added: {payload.get('phone')}", "success")
            self.send_log(f"è´¦æˆ·æ·»åŠ æˆåŠŸ: {payload.get('phone')}", "success")
            
            # Send updated accounts list
            accounts = await db.get_all_accounts()
            print(f"[Backend] Sending accounts-updated event with {len(accounts)} accounts", file=sys.stderr)
            
            # Invalidate cache
            self._cache.pop("accounts", None)
            self._cache_timestamps.pop("accounts", None)
            self.send_event("accounts-updated", accounts)
            
            # ğŸ†• è¿”å›æˆåŠŸçµæœï¼ˆHTTP API æ¨¡å¼éœ€è¦ï¼‰
            return {
                "success": True,
                "account_id": account_id,
                "phone": phone,
                "message": f"è´¦æˆ· {phone} æ·»åŠ æˆåŠŸ"
            }
        
        except ValidationError as e:
            import sys
            print(f"[Backend] ValidationError: {e.message}", file=sys.stderr)
            self.send_log(f"éªŒè¯é”™è¯¯: {e.message}", "error")
            self.send_event("account-validation-error", {
                "errors": [e.message],
                "field": e.field
            })
        except ValueError as e:
            # Handle specific errors like duplicate phone number
            import sys
            error_msg = str(e)
            print(f"[Backend] ValueError adding account: {error_msg}", file=sys.stderr)
            self.send_log(error_msg, "error")
            self.send_event("account-validation-error", {
                "errors": [error_msg],
                "account_data": payload,
                "error_type": "duplicate" if "å·²å­˜åœ¨" in error_msg else "validation"
            })
        except Exception as e:
            import sys
            error_msg = str(e)
            print(f"[Backend] Exception adding account: {error_msg}", file=sys.stderr)
            import traceback
            traceback.print_exc(file=sys.stderr)
            
            # Provide user-friendly error message
            if "UNIQUE constraint failed: accounts.phone" in error_msg or "phone" in error_msg.lower():
                friendly_msg = f"è´¦æˆ·å·²å­˜åœ¨: ç”µè¯å·ç  {payload.get('phone', '')} å·²ç»åœ¨ç³»ç»Ÿä¸­ã€‚å¦‚éœ€æ›´æ–°è´¦æˆ·ä¿¡æ¯ï¼Œè¯·ä½¿ç”¨æ›´æ–°åŠŸèƒ½ã€‚"
            else:
                friendly_msg = f"æ·»åŠ è´¦æˆ·å¤±è´¥: {error_msg}"
            
            self.send_log(friendly_msg, "error")
            self.send_event("account-validation-error", {
                "errors": [friendly_msg],
                "account_data": payload,
                "error_type": "duplicate" if "å·²å­˜åœ¨" in friendly_msg else "error"
            })
            handle_error(e, {"command": "add-account", "payload": payload})
    
    async def handle_send_code(self, payload: Dict[str, Any]):
        """
        Handle send-code command - ç™¼é€é©—è­‰ç¢¼
        
        é€™æ˜¯ç¨ç«‹çš„é©—è­‰ç¢¼ç™¼é€å‘½ä»¤ï¼Œç”¨æ–¼ SaaS ç‰ˆæœ¬
        """
        try:
            import sys
            print(f"[Backend] handle_send_code called with payload: {payload}", file=sys.stderr)
            
            phone = payload.get('phone', '').strip()
            api_id = payload.get('api_id') or payload.get('apiId')
            api_hash = payload.get('api_hash') or payload.get('apiHash')
            proxy = payload.get('proxy')
            two_factor_password = payload.get('twoFactorPassword') or payload.get('two_factor_password')
            
            if not phone:
                self.send_event("send-code-error", {
                    "success": False,
                    "error": "é›»è©±è™Ÿç¢¼ä¸èƒ½ç‚ºç©º"
                })
                return
            
            # å¦‚æœæ²’æœ‰æä¾› API ID/Hashï¼Œå˜—è©¦ä½¿ç”¨æ¨è–¦çš„æ†‘è­‰
            if not api_id or not api_hash:
                try:
                    from api_credential_pool import get_api_credential_pool
                    data_dir = str(Path(config.DATA_PATH))
                    pool = get_api_credential_pool(data_dir)
                    recommended = pool.get_recommended_credential()
                    if recommended:
                        api_id = api_id or recommended.get('api_id')
                        api_hash = api_hash or recommended.get('api_hash')
                        print(f"[Backend] Using recommended credential: {api_id}", file=sys.stderr)
                except Exception as e:
                    print(f"[Backend] Could not get recommended credential: {e}", file=sys.stderr)
            
            if not api_id or not api_hash:
                self.send_event("send-code-error", {
                    "success": False,
                    "error": "è«‹æä¾› API ID å’Œ API Hashï¼Œæˆ–åœ¨ API æ†‘è­‰æ± ä¸­æ·»åŠ æ†‘è­‰"
                })
                return
            
            # ä½¿ç”¨ TelegramManager ç™¼é€é©—è­‰ç¢¼
            print(f"[Backend] Sending verification code to {phone}...", file=sys.stderr)
            
            result = await self.telegram_manager.login_account(
                phone=phone,
                api_id=api_id,
                api_hash=api_hash,
                proxy=proxy,
                two_factor_password=two_factor_password
            )
            
            if result.get('success'):
                # é©—è­‰ç¢¼å·²ç™¼é€
                self.send_log(result.get('message', f"é©—è­‰ç¢¼å·²ç™¼é€åˆ° {phone}"), "success")
                response = {
                    "success": True,
                    "phone": phone,
                    "status": result.get('status', 'waiting_code'),
                    "message": result.get('message'),
                    "send_type": result.get('send_type', 'unknown'),
                    "requires_code": result.get('requires_code', True),
                    "phone_code_hash": result.get('phone_code_hash')
                }
                self.send_event("send-code-result", response)
                return response
            else:
                # ç™¼é€å¤±æ•—
                error_msg = result.get('message', 'ç™¼é€é©—è­‰ç¢¼å¤±æ•—')
                self.send_log(error_msg, "error")
                response = {
                    "success": False,
                    "phone": phone,
                    "error": error_msg,
                    "status": result.get('status', 'error')
                }
                self.send_event("send-code-error", response)
                return response
                
        except Exception as e:
            import traceback
            print(f"[Backend] Error in handle_send_code: {e}", file=sys.stderr)
            traceback.print_exc(file=sys.stderr)
            self.send_log(f"ç™¼é€é©—è­‰ç¢¼å¤±æ•—: {str(e)}", "error")
            response = {
                "success": False,
                "error": str(e)
            }
            self.send_event("send-code-error", response)
            return response
    
    async def handle_login_account(self, payload: Any):
        """Handle login-account command with Pyrogram"""
        try:
            import sys
            print(f"[Backend] handle_login_account called with payload: {payload}", file=sys.stderr)
            
            # Payload can be account_id (int) or dict with account_id and login details
            if isinstance(payload, int):
                account_id = payload
                account = await db.get_account(account_id)
                phone_code = None
                phone_code_hash = None
                two_factor_password = None
            else:
                account_id = payload.get('accountId')
                phone_code = payload.get('phoneCode')
                phone_code_hash = payload.get('phoneCodeHash')
                two_factor_password = payload.get('twoFactorPassword')
                
                # Try to get account by ID first, then by phone number
                if account_id:
                    account = await db.get_account(account_id)
                else:
                    # If no accountId provided, try to find by phone number
                    phone_from_payload = payload.get('phone')
                    if phone_from_payload:
                        account = await db.get_account_by_phone(phone_from_payload)
                        if account:
                            account_id = account.get('id')
                            print(f"[Backend] Found account by phone {phone_from_payload}, ID: {account_id}", file=sys.stderr)
                    else:
                        account = None
            
            if not account:
                error_msg = f"Account {account_id} not found"
                print(f"[Backend] {error_msg}", file=sys.stderr)
                self.send_log(error_msg, "error")
                return
            
            phone = account.get('phone')
            current_status = account.get('status', 'Offline')
            print(f"[Backend] Found account: {phone}, API ID: {account.get('apiId')}, API Hash: {'***' if account.get('apiHash') else 'None'}", file=sys.stderr)
            
            # CRITICAL: If account is already Online and no verification code is being submitted,
            # skip login to prevent database lock and unnecessary operations
            if current_status == 'Online' and not phone_code:
                print(f"[Backend] Account {phone} is already Online, skipping login", file=sys.stderr)
                # Just verify the account is still valid
                try:
                    status_result = await self.telegram_manager.check_account_status(phone)
                    if status_result.get('online'):
                        print(f"[Backend] Account {phone} verified online", file=sys.stderr)
                        return  # Already online, nothing to do
                except Exception as e:
                    print(f"[Backend] Error checking account status: {e}, will proceed with login", file=sys.stderr)
            
            # CRITICAL: If account is in 'Waiting Code' status and we're NOT submitting a code,
            # just return the existing hash (don't resend code)
            if current_status == 'Waiting Code' and not phone_code:
                if phone in self.telegram_manager.login_callbacks:
                    existing_hash = self.telegram_manager.login_callbacks[phone].get("phone_code_hash")
                    if existing_hash:
                        print(f"[Backend] Account {phone} already waiting for code, returning existing hash", file=sys.stderr)
                        self.send_event("login-requires-code", {
                            "accountId": account_id,
                            "phone": phone,
                            "phoneCodeHash": existing_hash,
                            "sendType": self.telegram_manager.login_callbacks[phone].get("send_type", "app"),
                            "message": "éªŒè¯ç å·²å‘é€ï¼Œè¯·åœ¨ Telegram åº”ç”¨ä¸­æŸ¥çœ‹",
                            "canRetrySMS": False
                        })
                        return
                print(f"[Backend] Account {phone} status is 'Waiting Code' but no callback found, will resend code", file=sys.stderr)
            
            # Update status to "Logging in..."
            await db.update_account(account_id, {"status": "Logging in..."})
            accounts = await db.get_all_accounts()
            # Invalidate cache
            self._cache.pop("accounts", None)
            self._cache_timestamps.pop("accounts", None)
            self.send_event("accounts-updated", accounts)
            
            self.send_log(f"Login initiated for account {phone}", "info")
            print(f"[Backend] Status updated to 'Logging in...', calling telegram_manager.login_account", file=sys.stderr)
            
            # Login with Pyrogram (ä½¿ç”¨è®¾å¤‡æŒ‡çº¹é˜²å°)
            print(f"[Backend] Calling telegram_manager.login_account for {phone}", file=sys.stderr)
            
            # Get device fingerprint from account (if exists) or generate new one
            device_model = account.get('deviceModel')
            system_version = account.get('systemVersion')
            app_version = account.get('appVersion')
            lang_code = account.get('langCode')
            platform = account.get('platform')
            
            # If device fingerprint not in account, generate it (for existing accounts)
            if not device_model or not system_version or not app_version:
                DeviceFingerprintGenerator = get_DeviceFingerprintGenerator()
                device_config = DeviceFingerprintGenerator.generate_for_phone(phone, prefer_platform=platform)
                device_model = device_model or device_config.get('device_model')
                system_version = system_version or device_config.get('system_version')
                app_version = app_version or device_config.get('app_version')
                lang_code = lang_code or device_config.get('lang_code')
                platform = platform or device_config.get('platform')
                
                # Update account with device fingerprint
                await db.update_account(account_id, {
                    'deviceModel': device_model,
                    'systemVersion': system_version,
                    'appVersion': app_version,
                    'langCode': lang_code,
                    'platform': platform,
                    'deviceId': device_config.get('device_id')
                })
                print(f"[Backend] Generated and saved device fingerprint for {phone}: {device_model} ({platform})", file=sys.stderr)
            
            result = await self.telegram_manager.login_account(
                phone=phone,
                api_id=account.get('apiId'),
                api_hash=account.get('apiHash'),
                proxy=account.get('proxy'),
                two_factor_password=two_factor_password or account.get('twoFactorPassword'),
                phone_code=phone_code,
                phone_code_hash=phone_code_hash,
                # Device fingerprint parameters (é˜²å°)
                device_model=device_model,
                system_version=system_version,
                app_version=app_version,
                lang_code=lang_code,
                platform=platform
            )
            
            print(f"[Backend] login_account result: success={result.get('success')}, requires_code={result.get('requires_code')}, requires_2fa={result.get('requires_2fa')}", file=sys.stderr)
            
            if result.get('success'):
                if result.get('requires_code'):
                    # Need verification code
                    phone_code_hash = result.get('phone_code_hash')
                    send_type = result.get('send_type', 'unknown')
                    next_type = result.get('next_type')
                    message = result.get('message', f"éªŒè¯ç å·²å‘é€åˆ° {phone}")
                    
                    print(f"[Backend] Sending login-requires-code event for account {account_id} (phone: {phone}), phone_code_hash: {phone_code_hash[:8] if phone_code_hash else 'None'}...", file=sys.stderr)
                    print(f"[Backend] Code send type: {send_type}, next_type: {next_type}, message: {message}", file=sys.stderr)
                    
                    # Check if we can retry for SMS (if previous was app and enough time has passed)
                    can_retry_sms = result.get('canRetrySMS', False) or result.get('can_retry_sms', False)
                    wait_seconds = result.get('waitSeconds', None)
                    
                    event_data = {
                        "accountId": account_id,
                        "phone": phone,
                        "phoneCodeHash": phone_code_hash,
                        "sendType": send_type,  # Include send type
                        "nextType": next_type,  # Include next type
                        "message": message,  # Include message
                        "canRetrySMS": can_retry_sms,  # Include canRetrySMS flag
                        "waitSeconds": wait_seconds  # Include wait seconds if available
                    }
                    self.send_event("login-requires-code", event_data)
                    print(f"[Backend] login-requires-code event sent successfully", file=sys.stderr)
                    # State: Requesting Code -> Waiting Code
                    await db.update_account(account_id, {"status": "Waiting Code"})
                    print(f"[Backend] Account status updated to 'Waiting Code'", file=sys.stderr)
                    # ğŸ†• è¿”å›çµæœï¼ˆHTTP API æ¨¡å¼éœ€è¦ï¼‰
                    return {
                        "success": True,
                        "requires_code": True,
                        "phone": phone,
                        "phone_code_hash": phone_code_hash,
                        "send_type": send_type,
                        "message": message
                    }
                elif result.get('requires_2fa'):
                    # Need 2FA password
                    self.send_event("login-requires-2fa", {
                        "accountId": account_id,
                        "phone": phone
                    })
                    await db.update_account(account_id, {"status": "Waiting 2FA"})
                    # ğŸ†• è¿”å›çµæœï¼ˆHTTP API æ¨¡å¼éœ€è¦ï¼‰
                    return {
                        "success": True,
                        "requires_2fa": True,
                        "phone": phone,
                        "message": "éœ€è¦äºŒæ­¥é©—è­‰å¯†ç¢¼"
                    }
                else:
                    # Successfully logged in
                    await db.update_account(account_id, {"status": result.get('status', 'Online')})
                    self.send_log(f"Account {phone} logged in successfully", "success")
                    
                    # ğŸ”§ P1: ç²å–ç”¨æˆ¶è³‡æ–™ï¼ˆè·³é bio é¿å… FloodWaitï¼‰
                    try:
                        full_profile = await self.telegram_manager.get_full_user_profile(phone, download_avatar=True, skip_bio=True)
                        if full_profile.get('success'):
                            # ä¿å­˜ç”¨æˆ¶ä¿¡æ¯åˆ°æ•¸æ“šåº«
                            await db.update_account(account_id, {
                                "firstName": full_profile.get('firstName', ''),
                                "lastName": full_profile.get('lastName', ''),
                                "username": full_profile.get('username', ''),
                                "bio": full_profile.get('bio', ''),
                                "avatarPath": full_profile.get('avatarPath', ''),
                                "telegramId": full_profile.get('id', '')
                            })
                            print(f"[Backend] Full profile saved for {phone}: {full_profile.get('firstName')} @{full_profile.get('username')}", file=sys.stderr)
                    except Exception as profile_err:
                        print(f"[Backend] Could not get full profile for {phone}: {profile_err}", file=sys.stderr)
                    
                    # ç²å–å¸³è™Ÿä¿¡æ¯
                    account = await db.get_account(account_id)
                    account_role = account.get('role', 'Unassigned')
                    
                    # ========== æ™ºèƒ½è§’è‰²åˆ†é… ==========
                    # å¦‚æœå¸³è™Ÿæœªåˆ†é…è§’è‰²ï¼Œæ ¹æ“šç¾æœ‰å¸³è™Ÿæƒ…æ³è‡ªå‹•åˆ†é…
                    if account_role == 'Unassigned':
                        all_accounts = await db.get_all_accounts()
                        has_listener = any(a.get('role') == 'Listener' for a in all_accounts)
                        has_sender = any(a.get('role') == 'Sender' for a in all_accounts)
                        
                        new_role = None
                        role_message = None
                        
                        if not has_listener:
                            # å„ªå…ˆåˆ†é…ç‚ºç›£æ§è™Ÿ
                            new_role = 'Listener'
                            role_message = f'å·²è‡ªå‹•å°‡ {phone} è¨­ç‚ºã€Œç›£æ§è™Ÿã€ï¼ˆç”¨æ–¼ç›£æ§ç¾¤çµ„æ¶ˆæ¯ï¼‰'
                        elif not has_sender:
                            # å…¶æ¬¡åˆ†é…ç‚ºç™¼é€è™Ÿ
                            new_role = 'Sender'
                            role_message = f'å·²è‡ªå‹•å°‡ {phone} è¨­ç‚ºã€Œç™¼é€è™Ÿã€ï¼ˆç”¨æ–¼ç™¼é€æ¶ˆæ¯çµ¦æ½›åœ¨å®¢æˆ¶ï¼‰'
                        
                        if new_role:
                            await db.update_account(account_id, {"role": new_role})
                            account_role = new_role
                            self.send_log(f"ğŸ¯ {role_message}", "success")
                            print(f"[Backend] Auto-assigned role {new_role} to account {phone}", file=sys.stderr)
                        else:
                            self.send_log(f"ğŸ’¡ å¸³è™Ÿ {phone} å·²ç™»å…¥ï¼Œè«‹åœ¨å¸³è™Ÿç®¡ç†ä¸­åˆ†é…è§’è‰²", "info")
                    # ========== æ™ºèƒ½è§’è‰²åˆ†é…çµæŸ ==========

                    # ç™¼é€ç™»å…¥æˆåŠŸäº‹ä»¶çµ¦å‰ç«¯ï¼ˆåŒ…å«å®Œæ•´ä¿¡æ¯ï¼‰
                    user_info = result.get('user_info', {})
                    self.send_event("login-success", {
                        "accountId": account_id,
                        "phone": phone,
                        "status": "Online",
                        "role": account_role,  # åŒ…å«è§’è‰²ä¿¡æ¯
                        "message": f"å¸³è™Ÿ {phone} ç™»å…¥æˆåŠŸ",
                        "userInfo": {
                            "phone": phone,
                            "firstName": account.get('firstName') or user_info.get('first_name', ''),
                            "lastName": account.get('lastName') or user_info.get('last_name', ''),
                            "username": account.get('username') or user_info.get('username', ''),
                            "id": account.get('telegramId') or user_info.get('id', ''),
                            "bio": account.get('bio', ''),
                            "avatarPath": account.get('avatarPath', '')
                        }
                    })
                    print(f"[Backend] login-success event sent for account {account_id} ({phone}), role={account_role}", file=sys.stderr)
                    
                    # === P0: ä¿å­˜ Session Metadata ===
                    try:
                        await self._save_session_metadata(phone, {
                            'phone': phone,
                            'apiId': account.get('apiId'),
                            'apiHash': account.get('apiHash'),
                            'firstName': account.get('firstName') or user_info.get('first_name', ''),
                            'lastName': account.get('lastName') or user_info.get('last_name', ''),
                            'username': account.get('username') or user_info.get('username', ''),
                            'telegramId': str(account.get('telegramId') or user_info.get('id', '')),
                            'role': account_role,
                            'created_at': datetime.now().isoformat()
                        })
                        print(f"[Backend] Session metadata saved for {phone}", file=sys.stderr)
                    except Exception as e:
                        print(f"[Backend] Error saving session metadata: {e}", file=sys.stderr)
                    
                    # åˆ·æ–° API æ†‘æ“šåˆ—è¡¨ï¼ˆç¢ºä¿ç¶å®šå¸³è™Ÿæ•¸æ“šæ­£ç¢ºï¼‰
                    try:
                        await self.handle_get_api_credentials({})
                    except Exception as e:
                        print(f"[Backend] Error refreshing API credentials after login: {e}", file=sys.stderr)
                    
                    # ç‚ºæ‰€æœ‰å¸³è™Ÿè¨»å†Šç§ä¿¡è™•ç†å™¨ï¼ˆè™•ç†ç”¨æˆ¶å›å¾©ï¼‰
                    try:
                        await self.telegram_manager.register_private_message_handler(
                            phone=phone,
                            account_role=account_role
                        )
                        self.send_log(f"å·²ç‚ºå¸³è™Ÿ {phone} ({account_role}) è¨»å†Šç§ä¿¡è™•ç†å™¨", "success")
                    except Exception as e:
                            self.send_log(f"è¨»å†Šç§ä¿¡è™•ç†å™¨å¤±æ•—: {e}", "warning")
                    
                    # Start Warmup if enabled and not already started (é˜²å°)
                    warmup_enabled = account.get('warmupEnabled', False)
                    warmup_start_date = account.get('warmupStartDate')
                    
                    if warmup_enabled and not warmup_start_date:
                        # Start Warmup (datetime å·²åœ¨æ–‡ä»¶é ‚éƒ¨å…¨å±€å°å…¥)
                        warmup_info = WarmupManager.start_warmup(account_id, datetime.now())
                        
                        await db.update_account(account_id, {
                            'warmupStartDate': warmup_info['warmup_start_date'],
                            'warmupStage': warmup_info['warmup_stage'],
                            'warmupDaysCompleted': 0
                        })
                        
                        stage_info = warmup_info['current_stage_info']
                        self.send_log(
                            f"è´¦æˆ· {phone} Warmup å·²å¯åŠ¨: {stage_info.get('stage_name')} "
                            f"(æ¯æ—¥é™åˆ¶: {stage_info.get('daily_limit')} æ¡)",
                            "info"
                        )
                        print(f"[Backend] Warmup started for {phone}: Stage {stage_info.get('stage')} - {stage_info.get('stage_name')}", file=sys.stderr)
                    elif warmup_enabled and warmup_start_date:
                        # Update Warmup progress
                        warmup_progress = WarmupManager.get_warmup_progress(account)
                        if warmup_progress.get('enabled') and warmup_progress.get('stage'):
                            stage_info = warmup_progress['stage']
                            await db.update_account(account_id, {
                                'warmupStage': stage_info.get('stage'),
                                'warmupDaysCompleted': stage_info.get('days_completed', 0)
                            })
                            print(f"[Backend] Warmup progress updated for {phone}: Stage {stage_info.get('stage')} - {stage_info.get('stage_name')}, Days: {stage_info.get('days_completed')}", file=sys.stderr)
                    
                    # ğŸ”§ é—œéµä¿®å¾©ï¼šç™»å…¥æˆåŠŸå¾Œç™¼é€ accounts-updated äº‹ä»¶æ›´æ–°å‰ç«¯ç‹€æ…‹
                    accounts = await db.get_all_accounts()
                    self._cache.pop("accounts", None)
                    self._cache_timestamps.pop("accounts", None)
                    self.send_event("accounts-updated", accounts)
                    print(f"[Backend] Sent accounts-updated after successful login for {phone}", file=sys.stderr)
                    
                    # ğŸ†• è¿”å›çµæœï¼ˆHTTP API æ¨¡å¼éœ€è¦ï¼‰
                    return {
                        "success": True,
                        "status": "Online",
                        "phone": phone,
                        "account_id": account_id,
                        "user_info": {
                            "phone": phone,
                            "firstName": account.get('firstName') or user_info.get('first_name', ''),
                            "lastName": account.get('lastName') or user_info.get('last_name', ''),
                            "username": account.get('username') or user_info.get('username', '')
                        }
                    }
            else:
                # Login failed
                import sys
                error_status = result.get('status', 'Error')
                error_message = result.get('message', 'æœªçŸ¥é”™è¯¯')
                flood_wait = result.get('flood_wait')
                
                print(f"[Backend] Login failed for {phone}: status={error_status}, message={error_message}", file=sys.stderr)
                
                # Handle FloodWait
                if flood_wait:
                    friendly_msg = f'è´¦æˆ· {phone} ç™»å½•å¤±è´¥ï¼šè¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç­‰å¾… {flood_wait} ç§’åé‡è¯•ã€‚'
                    self.send_event("account-login-error", {
                        "accountId": account_id,
                        "phone": phone,
                        "status": error_status,
                        "message": error_message,
                        "friendlyMessage": friendly_msg,
                        "floodWait": flood_wait
                    })
                    await db.update_account(account_id, {"status": "Offline"})
                    # ğŸ†• è¿”å›çµæœï¼ˆHTTP API æ¨¡å¼éœ€è¦ï¼‰
                    return {
                        "success": False,
                        "error": friendly_msg,
                        "flood_wait": flood_wait,
                        "phone": phone
                    }
                
                await db.update_account(account_id, {"status": error_status})
                
                # Provide user-friendly error message
                if "API ID and API Hash are required" in error_message:
                    friendly_msg = f"è´¦æˆ· {phone} ç™»å½•å¤±è´¥ï¼šAPI ID æˆ– API Hash æœªå¡«å†™ã€‚è¯·åœ¨è´¦æˆ·ç®¡ç†ä¸­å¡«å†™æ­£ç¡®çš„ API å‡­è¯ã€‚"
                elif "Invalid verification code" in error_message or "PhoneCodeInvalid" in error_message or "PHONE_CODE_INVALID" in error_message.upper():
                    friendly_msg = f"è´¦æˆ· {phone} ç™»å½•å¤±è´¥ï¼šéªŒè¯ç é”™è¯¯ã€‚è¯·æ£€æŸ¥éªŒè¯ç æ˜¯å¦æ­£ç¡®ï¼Œç„¶åé‡æ–°è¾“å…¥ã€‚"
                    # Keep the login state so user can retry
                    # Don't close the dialog, let user try again
                elif "code expired" in error_message.lower() or "PHONE_CODE_EXPIRED" in error_message.upper() or result.get('code_expired'):
                    friendly_msg = f'è´¦æˆ· {phone} ç™»å½•å¤±è´¥ï¼šéªŒè¯ç å·²è¿‡æœŸã€‚è¯·ç‚¹å‡»"é‡æ–°å‘é€"è·å–æ–°çš„éªŒè¯ç ã€‚'
                    # Non-recoverable error: State: Logging in... -> Offline (need to restart)
                    await db.update_account(account_id, {"status": "Offline"})
                    # Clear login callbacks
                    self.telegram_manager.login_callbacks.pop(phone, None)
                    # Mark as code expired so frontend can handle it
                    self.send_event("account-login-error", {
                        "accountId": account_id,
                        "phone": phone,
                        "status": "Offline",
                        "message": error_message,
                        "friendlyMessage": friendly_msg,
                        "codeExpired": True
                    })
                    # Don't send duplicate error event below
                    accounts = await db.get_all_accounts()
                    self._cache.pop("accounts", None)
                    self._cache_timestamps.pop("accounts", None)
                    self.send_event("accounts-updated", accounts)
                    return
                elif "hash mismatch" in error_message.lower() or "hash" in error_message.lower() and "mismatch" in error_message.lower():
                    friendly_msg = f'è´¦æˆ· {phone} ç™»å½•å¤±è´¥ï¼šéªŒè¯ç å“ˆå¸Œä¸åŒ¹é…ã€‚è¿™é€šå¸¸æ˜¯å› ä¸ºå®¢æˆ·ç«¯è¢«é‡æ–°åˆ›å»ºã€‚è¯·ç‚¹å‡»"é‡æ–°å‘é€"è·å–æ–°çš„éªŒè¯ç ã€‚'
                    # Non-recoverable error: State: Logging in... -> Offline (need to restart)
                    await db.update_account(account_id, {"status": "Offline"})
                    # Clear login callbacks
                    self.telegram_manager.login_callbacks.pop(phone, None)
                    # Mark as code expired so frontend can handle it
                    self.send_event("account-login-error", {
                        "accountId": account_id,
                        "phone": phone,
                        "status": "Offline",
                        "message": error_message,
                        "friendlyMessage": friendly_msg,
                        "codeExpired": True
                    })
                    accounts = await db.get_all_accounts()
                    self._cache.pop("accounts", None)
                    self._cache_timestamps.pop("accounts", None)
                    self.send_event("accounts-updated", accounts)
                    return
                elif "Invalid 2FA password" in error_message or "2FA" in error_message and "password" in error_message.lower():
                    friendly_msg = f"å¸³è™Ÿ {phone} ç™»å…¥å¤±æ•—ï¼šäºŒæ­¥é©—è­‰å¯†ç¢¼éŒ¯èª¤ã€‚è«‹æª¢æŸ¥å¯†ç¢¼å¾Œé‡è©¦ã€‚"
                elif "2FA verification timeout" in error_message or ("2FA" in error_message and "timeout" in error_message.lower()):
                    friendly_msg = f"å¸³è™Ÿ {phone} ç™»å…¥å¤±æ•—ï¼šäºŒæ­¥é©—è­‰è¶…æ™‚ã€‚è«‹æª¢æŸ¥ç¶²çµ¡é€£æ¥å¾Œé‡è©¦ã€‚"
                elif "Flood wait" in error_message or "FLOOD_WAIT" in error_message.upper() or result.get('flood_wait'):
                    wait_time = result.get('flood_wait', 0)
                    friendly_msg = f"è´¦æˆ· {phone} ç™»å½•å¤±è´¥ï¼šè¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç­‰å¾… {wait_time} ç§’åé‡è¯•ã€‚"
                elif "Invalid phone number" in error_message or "PHONE_NUMBER_INVALID" in error_message.upper():
                    friendly_msg = f"è´¦æˆ· {phone} ç™»å½•å¤±è´¥ï¼šç”µè¯å·ç æ ¼å¼ä¸æ­£ç¡®ã€‚è¯·ç¡®ä¿æ ¼å¼ä¸º +å›½å®¶ä»£ç +å·ç ã€‚"
                elif "è¶…æ™‚" in error_message or "timeout" in error_message.lower():
                    friendly_msg = f"è´¦æˆ· {phone} ç™»å½•å¤±è´¥ï¼šè¿æ¥è¶…æ—¶ã€‚è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ä»£ç†è®¾ç½®åé‡è¯•ã€‚"
                    # Non-recoverable error: State: Logging in... -> Offline (need to restart)
                    await db.update_account(account_id, {"status": "Offline"})
                    # Clear login callbacks
                    self.telegram_manager.login_callbacks.pop(phone, None)
                elif "Proxy" in error_message or "proxy" in error_message.lower():
                    friendly_msg = f"è´¦æˆ· {phone} ç™»å½•å¤±è´¥ï¼šä»£ç†è¿æ¥é”™è¯¯ã€‚è¯·æ£€æŸ¥ä»£ç†é…ç½®æˆ–æš‚æ—¶ç§»é™¤ä»£ç†ã€‚"
                elif "Connection" in error_message or "connection" in error_message.lower():
                    friendly_msg = f"è´¦æˆ· {phone} ç™»å½•å¤±è´¥ï¼šç½‘ç»œè¿æ¥é”™è¯¯ã€‚è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ä»£ç†è®¾ç½®ã€‚"
                elif "Client connection lost" in error_message or "No valid client" in error_message:
                    friendly_msg = f'è´¦æˆ· {phone} ç™»å½•å¤±è´¥ï¼šå®¢æˆ·ç«¯è¿æ¥ä¸¢å¤±ã€‚è¯·ç‚¹å‡»"é‡æ–°å‘é€"è·å–æ–°çš„éªŒè¯ç ã€‚'
                    # Non-recoverable error: State: Logging in... -> Offline (need to restart)
                    await db.update_account(account_id, {"status": "Offline"})
                    # Clear login callbacks
                    self.telegram_manager.login_callbacks.pop(phone, None)
                    # Mark as code expired so frontend can handle it
                    self.send_event("account-login-error", {
                        "accountId": account_id,
                        "phone": phone,
                        "status": "Offline",
                        "message": error_message,
                        "friendlyMessage": friendly_msg,
                        "codeExpired": True
                    })
                    accounts = await db.get_all_accounts()
                    self._cache.pop("accounts", None)
                    self._cache_timestamps.pop("accounts", None)
                    self.send_event("accounts-updated", accounts)
                    return
                else:
                    friendly_msg = f"è´¦æˆ· {phone} ç™»å½•å¤±è´¥ï¼š{error_message}"
                
                self.send_log(friendly_msg, "error")
                
                # Also send a specific error event for frontend
                self.send_event("account-login-error", {
                    "accountId": account_id,
                    "phone": phone,
                    "status": error_status,
                    "message": error_message,
                    "friendlyMessage": friendly_msg
                })
                
                # ğŸ†• è¿”å›éŒ¯èª¤çµæœï¼ˆHTTP API æ¨¡å¼éœ€è¦ï¼‰
                return {
                    "success": False,
                    "error": friendly_msg,
                    "phone": phone,
                    "status": error_status
                }
            
            # Update accounts list
            accounts = await db.get_all_accounts()
            # Invalidate cache
            self._cache.pop("accounts", None)
            self._cache_timestamps.pop("accounts", None)
            self.send_event("accounts-updated", accounts)
        
        except Exception as e:
            import sys
            import traceback
            error_msg = f"Error logging in account: {str(e)}"
            print(f"[Backend] {error_msg}", file=sys.stderr)
            traceback.print_exc(file=sys.stderr)
            self.send_log(error_msg, "error")
    
    # ===================== QR Code Login Handlers =====================
    
    async def handle_qr_login_create(self, payload: Dict[str, Any]):
        """Handle qr-login-create command - Create a new QR login session"""
        try:
            import sys
            print(f"[Backend] handle_qr_login_create called with payload: {payload}", file=sys.stderr)
            
            if not self.qr_auth_manager:
                # æä¾›æ›´è©³ç´°çš„éŒ¯èª¤ä¿¡æ¯
                from qr_auth_manager import HAS_TELETHON, HAS_QRCODE
                missing_libs = []
                if not HAS_TELETHON:
                    missing_libs.append("telethon")
                if not HAS_QRCODE:
                    missing_libs.append("qrcode")
                
                if missing_libs:
                    error_msg = f"QR ç™»å…¥åŠŸèƒ½æœªå•Ÿç”¨ï¼Œç¼ºå°‘ä¾è³´åº«: {', '.join(missing_libs)}ã€‚è«‹é‹è¡Œ: pip install telethon qrcode[pil]"
                else:
                    error_msg = "QR ç™»å…¥åŠŸèƒ½åˆå§‹åŒ–å¤±æ•—ï¼Œè«‹æŸ¥çœ‹å¾Œç«¯æ—¥èªŒäº†è§£è©³æƒ…"
                
                print(f"[Backend] {error_msg} (HAS_TELETHON={HAS_TELETHON}, HAS_QRCODE={HAS_QRCODE})", file=sys.stderr)
                self.send_event("qr-login-error", {"error": error_msg})
                self.send_log(error_msg, "error")
                return
            
            proxy = payload.get("proxy") if isinstance(payload, dict) else None
            device_type = payload.get("deviceType") if isinstance(payload, dict) else None
            two_factor_password = payload.get("twoFactorPassword") if isinstance(payload, dict) else None
            
            # ç²å–è‡ªå®šç¾© API æ†‘æ“šï¼ˆé˜²å°æ¨è–¦ï¼‰
            custom_api_id = payload.get("customApiId") if isinstance(payload, dict) else None
            custom_api_hash = payload.get("customApiHash") if isinstance(payload, dict) else None
            
            if custom_api_id and custom_api_hash:
                print(f"[Backend] Using CUSTOM API credentials (api_id={custom_api_id}) - Recommended for anti-ban", file=sys.stderr)
            else:
                print(f"[Backend] âš ï¸ WARNING: No custom API credentials provided - Using PUBLIC API (HIGH BAN RISK!)", file=sys.stderr)
            
            print(f"[Backend] Calling qr_auth_manager.create_qr_login with proxy={proxy}, device_type={device_type}", file=sys.stderr)
            
            # æ·»åŠ è¶…æ™‚ä¿è­·ï¼ˆ60ç§’ï¼‰
            try:
                result = await asyncio.wait_for(
                    self.qr_auth_manager.create_qr_login(
                        proxy=proxy,
                        device_type=device_type,
                        two_factor_password=two_factor_password,
                        custom_api_id=custom_api_id,
                        custom_api_hash=custom_api_hash
                    ),
                    timeout=60.0
                )
            except asyncio.TimeoutError:
                error_msg = "å‰µå»º QR ç™»å…¥è¶…æ™‚ï¼ˆ60ç§’ï¼‰ï¼Œè«‹æª¢æŸ¥ç¶²çµ¡é€£æ¥æˆ–ä»£ç†è¨­ç½®"
                print(f"[Backend] {error_msg}", file=sys.stderr)
                self.send_event("qr-login-error", {"error": error_msg})
                self.send_log(error_msg, "error")
                return
            
            print(f"[Backend] create_qr_login result: success={result.get('success')}, error={result.get('error', 'None')}", file=sys.stderr)
            
            if result.get("success"):
                print(f"[Backend] Sending qr-login-created event with sessionId={result.get('sessionId')}", file=sys.stderr)
                self.send_event("qr-login-created", result)
                self.send_log(f"QR ç™»å…¥æœƒè©±å·²å‰µå»ºï¼Œè«‹æƒæäºŒç¶­ç¢¼", "info")
            else:
                error_msg = result.get("error", "å‰µå»º QR ç™»å…¥å¤±æ•—")
                print(f"[Backend] QR login failed: {error_msg}", file=sys.stderr)
                self.send_event("qr-login-error", {"error": error_msg})
                self.send_log(f"å‰µå»º QR ç™»å…¥å¤±æ•—: {error_msg}", "error")
                
        except Exception as e:
            import sys
            import traceback
            error_msg = f"å‰µå»º QR ç™»å…¥æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}"
            print(f"[Backend] Error in handle_qr_login_create: {e}", file=sys.stderr)
            traceback.print_exc(file=sys.stderr)
            self.send_event("qr-login-error", {"error": error_msg})
            self.send_log(error_msg, "error")
    
    async def handle_qr_login_status(self, payload: Dict[str, Any]):
        """Handle qr-login-status command - Get QR login session status"""
        try:
            if not self.qr_auth_manager:
                self.send_event("qr-login-status-result", {
                    "success": False,
                    "error": "QR ç™»å…¥åŠŸèƒ½æœªå•Ÿç”¨"
                })
                return
            
            session_id = payload.get("sessionId") if isinstance(payload, dict) else payload
            result = self.qr_auth_manager.get_session_status(session_id)
            self.send_event("qr-login-status-result", result)
            
        except Exception as e:
            import sys
            print(f"[Backend] Error in handle_qr_login_status: {e}", file=sys.stderr)
            self.send_event("qr-login-status-result", {"success": False, "error": str(e)})
    
    async def handle_qr_login_refresh(self, payload: Dict[str, Any]):
        """Handle qr-login-refresh command - Refresh QR code"""
        try:
            if not self.qr_auth_manager:
                self.send_event("qr-login-error", {"error": "QR ç™»å…¥åŠŸèƒ½æœªå•Ÿç”¨"})
                return
            
            session_id = payload.get("sessionId") if isinstance(payload, dict) else payload
            result = await self.qr_auth_manager.refresh_qr_code(session_id)
            
            if result.get("success"):
                self.send_event("qr-login-refreshed", result)
            else:
                self.send_event("qr-login-error", {
                    "sessionId": session_id,
                    "error": result.get("error", "åˆ·æ–° QR ç¢¼å¤±æ•—")
                })
                
        except Exception as e:
            import sys
            print(f"[Backend] Error in handle_qr_login_refresh: {e}", file=sys.stderr)
            self.send_event("qr-login-error", {"error": str(e)})
    
    async def handle_qr_login_submit_2fa(self, payload: Dict[str, Any]):
        """Handle qr-login-submit-2fa command - Submit 2FA password"""
        try:
            if not self.qr_auth_manager:
                self.send_event("qr-login-error", {"error": "QR ç™»å…¥åŠŸèƒ½æœªå•Ÿç”¨"})
                return
            
            session_id = payload.get("sessionId")
            password = payload.get("password")
            
            if not session_id or not password:
                self.send_event("qr-login-error", {
                    "sessionId": session_id,
                    "error": "ç¼ºå°‘æœƒè©± ID æˆ–å¯†ç¢¼"
                })
                return
            
            result = await self.qr_auth_manager.submit_2fa_password(session_id, password)
            
            if result.get("success"):
                self.send_event("qr-login-2fa-success", {
                    "sessionId": session_id,
                    "message": "äºŒæ­¥é©—è­‰æˆåŠŸ"
                })
            else:
                self.send_event("qr-login-error", {
                    "sessionId": session_id,
                    "error": result.get("error", "äºŒæ­¥é©—è­‰å¤±æ•—")
                })
                
        except Exception as e:
            import sys
            print(f"[Backend] Error in handle_qr_login_submit_2fa: {e}", file=sys.stderr)
            self.send_event("qr-login-error", {"error": str(e)})
    
    async def handle_qr_login_cancel(self, payload: Dict[str, Any]):
        """Handle qr-login-cancel command - Cancel QR login session"""
        try:
            if not self.qr_auth_manager:
                return
            
            session_id = payload.get("sessionId") if isinstance(payload, dict) else payload
            result = await self.qr_auth_manager.cancel_session(session_id)
            
            self.send_event("qr-login-cancelled", {
                "sessionId": session_id,
                "message": "QR ç™»å…¥å·²å–æ¶ˆ"
            })
            
        except Exception as e:
            import sys
            print(f"[Backend] Error in handle_qr_login_cancel: {e}", file=sys.stderr)
    
    # ===================== End QR Code Login Handlers =====================

    # ===================== IP Binding Handlers (Phase 2) =====================
    
    async def handle_ip_bind(self, payload: Dict[str, Any]):
        """Handle ip-bind command - Bind IP to account"""
        try:
            if not self.ip_binding_manager:
                self.send_event("ip-binding-error", {"error": "IP Binding Manager æœªåˆå§‹åŒ–"})
                return
            
            account_id = payload.get("accountId")
            phone = payload.get("phone")
            proxy = payload.get("proxy")
            proxy_country = payload.get("proxyCountry")
            proxy_type = payload.get("proxyType", "residential")
            reason = payload.get("reason", "manual")
            
            if not account_id or not phone or not proxy:
                self.send_event("ip-binding-error", {"error": "ç¼ºå°‘å¿…è¦åƒæ•¸"})
                return
            
            binding = await self.ip_binding_manager.bind_ip(
                account_id=account_id,
                phone=phone,
                proxy=proxy,
                proxy_country=proxy_country,
                proxy_type=proxy_type,
                reason=reason
            )
            
            # Update account in database
            from dataclasses import asdict
            await db.update_account(account_id, {
                "proxy": proxy,
                "ip_binding_id": binding.proxy_ip,
                "ip_bound_at": binding.bound_at,
                "proxy_country": binding.proxy_country,
                "proxy_type": binding.proxy_type,
                "ip_is_sticky": 1
            })
            
            self.send_event("ip-binding-success", {
                "accountId": account_id,
                "phone": phone,
                "binding": asdict(binding)
            })
            self.send_log(f"å¸³è™Ÿ {phone} å·²ç¶å®š IP: {binding.proxy_ip}", "success")
            
            # Refresh accounts list
            accounts = await db.get_all_accounts()
            self._cache.pop("accounts", None)
            self.send_event("accounts-updated", accounts)
            
        except Exception as e:
            import sys
            print(f"[Backend] Error in handle_ip_bind: {e}", file=sys.stderr)
            self.send_event("ip-binding-error", {"error": str(e)})
    
    async def handle_ip_unbind(self, payload: Dict[str, Any]):
        """Handle ip-unbind command - Remove IP binding from account"""
        try:
            if not self.ip_binding_manager:
                return
            
            account_id = payload.get("accountId")
            
            # Just update the database to remove binding info
            await db.update_account(account_id, {
                "ip_binding_id": None,
                "ip_bound_at": None,
                "ip_is_sticky": 0
            })
            
            self.send_event("ip-unbinding-success", {"accountId": account_id})
            
            # Refresh accounts list
            accounts = await db.get_all_accounts()
            self._cache.pop("accounts", None)
            self.send_event("accounts-updated", accounts)
            
        except Exception as e:
            import sys
            print(f"[Backend] Error in handle_ip_unbind: {e}", file=sys.stderr)
    
    async def handle_ip_get_binding(self, payload: Dict[str, Any]):
        """Handle ip-get-binding command - Get IP binding for account"""
        try:
            if not self.ip_binding_manager:
                return
            
            account_id = payload.get("accountId")
            binding = self.ip_binding_manager.get_binding(account_id)
            
            if binding:
                from dataclasses import asdict
                self.send_event("ip-binding-info", {
                    "accountId": account_id,
                    "binding": asdict(binding)
                })
            else:
                self.send_event("ip-binding-info", {
                    "accountId": account_id,
                    "binding": None
                })
                
        except Exception as e:
            import sys
            print(f"[Backend] Error in handle_ip_get_binding: {e}", file=sys.stderr)
    
    async def handle_ip_get_all_bindings(self, payload: Dict[str, Any]):
        """Handle ip-get-all-bindings command - Get all IP bindings"""
        try:
            if not self.ip_binding_manager:
                self.send_event("ip-all-bindings", {"bindings": []})
                return
            
            bindings = self.ip_binding_manager.get_all_bindings()
            self.send_event("ip-all-bindings", {"bindings": bindings})
            
        except Exception as e:
            import sys
            print(f"[Backend] Error in handle_ip_get_all_bindings: {e}", file=sys.stderr)
    
    async def handle_ip_get_statistics(self, payload: Dict[str, Any]):
        """Handle ip-get-statistics command - Get IP binding statistics"""
        try:
            if not self.ip_binding_manager:
                return
            
            stats = self.ip_binding_manager.get_statistics()
            self.send_event("ip-binding-statistics", stats)
            
        except Exception as e:
            import sys
            print(f"[Backend] Error in handle_ip_get_statistics: {e}", file=sys.stderr)
    
    async def handle_ip_verify_binding(self, payload: Dict[str, Any]):
        """Handle ip-verify-binding command - Verify IP binding health"""
        try:
            if not self.ip_binding_manager:
                return
            
            account_id = payload.get("accountId")
            is_valid, error = await self.ip_binding_manager.verify_binding(account_id)
            
            self.send_event("ip-binding-verified", {
                "accountId": account_id,
                "isValid": is_valid,
                "error": error
            })
            
            if not is_valid:
                self.send_log(f"å¸³è™Ÿ {account_id} çš„ IP ç¶å®šé©—è­‰å¤±æ•—: {error}", "warning")
            
        except Exception as e:
            import sys
            print(f"[Backend] Error in handle_ip_verify_binding: {e}", file=sys.stderr)
    
    # ===================== End IP Binding Handlers =====================
    
    # ===================== Credential Scraper Handlers (Phase 2) =====================
    
    async def handle_credential_start_scrape(self, payload: Dict[str, Any]):
        """Handle credential-start-scrape command - Start API credential scraping"""
        try:
            if not self.credential_scraper:
                self.send_event("credential-scrape-error", {"error": "Credential Scraper æœªåˆå§‹åŒ–"})
                return
            
            account_id = payload.get("accountId")
            phone = payload.get("phone")
            proxy = payload.get("proxy")
            headless = payload.get("headless", True)
            
            if not account_id or not phone:
                self.send_event("credential-scrape-error", {"error": "ç¼ºå°‘å¿…è¦åƒæ•¸"})
                return
            
            # Get Telethon client if available for code reception
            telegram_client = None
            # Note: In production, you would get the client from qr_auth_manager or session
            
            result = await self.credential_scraper.start_scrape(
                account_id=account_id,
                phone=phone,
                telegram_client=telegram_client,
                proxy=proxy,
                headless=headless
            )
            
            self.send_event("credential-scrape-started", {
                "accountId": account_id,
                "phone": phone,
                "result": result
            })
            
            if result.get("success"):
                self.send_log(f"å¸³è™Ÿ {phone} é–‹å§‹ç²å– API æ†‘æ“š", "info")
            else:
                self.send_log(f"å¸³è™Ÿ {phone} ç²å– API æ†‘æ“šå¤±æ•—: {result.get('message')}", "warning")
                
        except Exception as e:
            import sys
            print(f"[Backend] Error in handle_credential_start_scrape: {e}", file=sys.stderr)
            self.send_event("credential-scrape-error", {"error": str(e)})
    
    async def handle_credential_submit_code(self, payload: Dict[str, Any]):
        """Handle credential-submit-code command - Submit verification code for scraping"""
        try:
            if not self.credential_scraper:
                return
            
            phone = payload.get("phone")
            code = payload.get("code")
            
            if not phone or not code:
                self.send_event("credential-code-error", {"error": "ç¼ºå°‘å¿…è¦åƒæ•¸"})
                return
            
            success = self.credential_scraper.submit_code(phone, code)
            
            self.send_event("credential-code-submitted", {
                "phone": phone,
                "success": success
            })
            
        except Exception as e:
            import sys
            print(f"[Backend] Error in handle_credential_submit_code: {e}", file=sys.stderr)
    
    async def handle_credential_get_status(self, payload: Dict[str, Any]):
        """Handle credential-get-status command - Get scraping status"""
        try:
            if not self.credential_scraper:
                return
            
            phone = payload.get("phone")
            status = self.credential_scraper.get_scrape_status(phone)
            
            self.send_event("credential-status", {
                "phone": phone,
                "status": status
            })
            
        except Exception as e:
            import sys
            print(f"[Backend] Error in handle_credential_get_status: {e}", file=sys.stderr)
    
    async def handle_credential_get_all(self, payload: Dict[str, Any]):
        """Handle credential-get-all command - Get all credentials"""
        try:
            if not self.credential_scraper:
                self.send_event("credentials-list", {"credentials": []})
                return
            
            credentials = self.credential_scraper.get_all_credentials()
            self.send_event("credentials-list", {"credentials": credentials})
            
        except Exception as e:
            import sys
            print(f"[Backend] Error in handle_credential_get_all: {e}", file=sys.stderr)
    
    async def handle_credential_cancel_scrape(self, payload: Dict[str, Any]):
        """Handle credential-cancel-scrape command - Cancel scraping"""
        try:
            if not self.credential_scraper:
                return
            
            phone = payload.get("phone")
            success = await self.credential_scraper.cancel_scrape(phone)
            
            self.send_event("credential-scrape-cancelled", {
                "phone": phone,
                "success": success
            })
            
        except Exception as e:
            import sys
            print(f"[Backend] Error in handle_credential_cancel_scrape: {e}", file=sys.stderr)
    
    # ===================== End Credential Scraper Handlers =====================

    async def handle_check_account_status(self, payload: int):
        """Handle check-account-status command with Pyrogram"""
        try:
            account_id = payload
            account = await db.get_account(account_id)
            
            if not account:
                self.send_log(f"è´¦æˆ· ID {account_id} ä¸å­˜åœ¨ã€‚æ— æ³•æ£€æŸ¥çŠ¶æ€ã€‚", "error")
                return
            
            phone = account.get('phone')
            
            # Check status with Pyrogram
            status_result = await self.telegram_manager.check_account_status(phone)
            
            # Update database
            await db.update_account(account_id, {"status": status_result.get('status', 'Offline')})
            
            # Send status update event
            status_info = {
                "accountId": account_id,
                "status": status_result.get('status', 'Offline'),
                "online": status_result.get('online', False),
                "message": status_result.get('message', ''),
                "user": status_result.get('user')
            }
            
            self.send_event("account-status-updated", status_info)
            
            # Update accounts list
            accounts = await db.get_all_accounts()
            # Invalidate cache
            self._cache.pop("accounts", None)
            self._cache_timestamps.pop("accounts", None)
            self.send_event("accounts-updated", accounts)
        
        except Exception as e:
            self.send_log(f"Error checking account status: {str(e)}", "error")
    
    async def handle_update_account_data(self, payload: Dict[str, Any]):
        """Handle update-account-data command"""
        try:
            account_id = payload.get('id')
            updates = payload.get('updates', {})
            await db.update_account(account_id, updates)
            
            accounts = await db.get_all_accounts()
            # Invalidate cache
            self._cache.pop("accounts", None)
            self._cache_timestamps.pop("accounts", None)
            self.send_event("accounts-updated", accounts)
            await db.add_log(f"Account {account_id} updated", "success")
        
        except Exception as e:
            self.send_log(f"Error updating account: {str(e)}", "error")
    
    async def handle_update_account(self, payload: Dict[str, Any]):
        """Handle update-account command - å®Œæ•´å¸³è™Ÿç·¨è¼¯"""
        try:
            import sys
            account_id = payload.get('id')
            phone = payload.get('phone')
            
            if not account_id:
                self.send_event("update-account-result", {"success": False, "error": "ç¼ºå°‘å¸³è™Ÿ ID"})
                return

            # æ§‹å»ºæ›´æ–°æ•¸æ“š
            update_data = {}
            
            # åŸºæœ¬è¨­ç½®
            if 'nickname' in payload:
                update_data['nickname'] = payload['nickname']
            if 'notes' in payload:
                update_data['notes'] = payload['notes']
            if 'dailySendLimit' in payload:
                update_data['dailySendLimit'] = payload['dailySendLimit']
            if 'group' in payload:
                update_data['group'] = payload['group']
            if 'enableWarmup' in payload:
                update_data['enableWarmup'] = 1 if payload['enableWarmup'] else 0

            # API å‡­è¯ï¼ˆæ•°æ®åº“å­—æ®µåæ˜¯ apiId å’Œ apiHashï¼‰
            if 'apiId' in payload and payload['apiId']:
                update_data['apiId'] = payload['apiId']
            if 'apiHash' in payload and payload['apiHash']:
                update_data['apiHash'] = payload['apiHash']

            # ä»£ç†è¨­ç½®
            if 'proxy' in payload:
                update_data['proxy'] = payload['proxy']
            if 'proxyType' in payload:
                update_data['proxyType'] = payload['proxyType']
            if 'proxyHost' in payload:
                update_data['proxyHost'] = payload['proxyHost']
            if 'proxyPort' in payload:
                update_data['proxyPort'] = payload['proxyPort']
            if 'proxyUsername' in payload:
                update_data['proxyUsername'] = payload['proxyUsername']
            if 'proxyPassword' in payload:
                update_data['proxyPassword'] = payload['proxyPassword']
            if 'proxyCountry' in payload:
                update_data['proxyCountry'] = payload['proxyCountry']
            if 'proxyRotationEnabled' in payload:
                update_data['proxyRotationEnabled'] = 1 if payload['proxyRotationEnabled'] else 0

            # è§’è‰²è¨­ç½®
            if 'role' in payload:
                update_data['role'] = payload['role']
            if 'aiPersonality' in payload:
                update_data['aiPersonality'] = payload['aiPersonality']

            # AI è¨­ç½®
            if 'aiEnabled' in payload:
                update_data['aiEnabled'] = 1 if payload['aiEnabled'] else 0
            if 'aiModel' in payload:
                update_data['aiModel'] = payload['aiModel']

            # åŸ·è¡Œæ›´æ–°
            await db.update_account(account_id, update_data)
            print(f"[Backend] Account {phone or account_id} updated: {list(update_data.keys())}", file=sys.stderr)

            # åˆ·æ–°å¸³è™Ÿåˆ—è¡¨
            accounts = await db.get_all_accounts()
            self._cache.pop("accounts", None)
            self._cache_timestamps.pop("accounts", None)
            self.send_event("accounts-updated", accounts)
            
            # ç™¼é€æˆåŠŸéŸ¿æ‡‰
            self.send_event("update-account-result", {"success": True})
            await db.add_log(f"å¸³è™Ÿ {phone or account_id} è¨­ç½®å·²æ›´æ–°", "success")

        except Exception as e:
            import sys
            print(f"[Backend] Error updating account: {e}", file=sys.stderr)
            self.send_event("update-account-result", {"success": False, "error": str(e)})
            self.send_log(f"Error updating account: {str(e)}", "error")

    async def handle_test_proxy(self, payload: Dict[str, Any]):
        """Handle test-proxy command - æ¸¬è©¦ä»£ç†é€£æ¥"""
        import sys
        import asyncio
        import aiohttp
        
        try:
            proxy_type = payload.get('type', 'socks5')
            host = payload.get('host', '')
            port = payload.get('port', 0)
            username = payload.get('username', '')
            password = payload.get('password', '')

            if not host or not port:
                self.send_event("test-proxy-result", {
                    "success": False, 
                    "error": "è«‹å¡«å¯«ä»£ç†åœ°å€å’Œç«¯å£"
                })
                return

            print(f"[Backend] Testing proxy: {proxy_type}://{host}:{port}", file=sys.stderr)

            # æ§‹å»ºä»£ç† URL
            if username and password:
                proxy_url = f"{proxy_type}://{username}:{password}@{host}:{port}"
            else:
                proxy_url = f"{proxy_type}://{host}:{port}"

            # æ¸¬è©¦é€£æ¥
            start_time = asyncio.get_event_loop().time()
            
            try:
                connector = None
                if proxy_type in ['socks5', 'socks4']:
                    # ä½¿ç”¨ aiohttp-socks æ”¯æŒ SOCKS ä»£ç†
                    try:
                        from aiohttp_socks import ProxyConnector
                        connector = ProxyConnector.from_url(proxy_url)
                    except ImportError:
                        # å¦‚æœæ²’æœ‰ aiohttp-socksï¼Œå˜—è©¦åŸºæœ¬æ¸¬è©¦
                        pass
                
                timeout = aiohttp.ClientTimeout(total=10)
                
                if connector:
                    async with aiohttp.ClientSession(connector=connector, timeout=timeout) as session:
                        async with session.get('https://api.telegram.org') as response:
                            end_time = asyncio.get_event_loop().time()
                            latency = int((end_time - start_time) * 1000)
                            
                            if response.status == 200:
                                self.send_event("test-proxy-result", {
                                    "success": True,
                                    "latency": latency,
                                    "message": f"é€£æ¥æˆåŠŸï¼Œå»¶é² {latency}ms"
                                })
                            else:
                                self.send_event("test-proxy-result", {
                                    "success": False,
                                    "error": f"HTTP ç‹€æ…‹ç¢¼: {response.status}"
                                })
                else:
                    # HTTP ä»£ç†æ¸¬è©¦
                    async with aiohttp.ClientSession(timeout=timeout) as session:
                        async with session.get('https://api.telegram.org', proxy=proxy_url) as response:
                            end_time = asyncio.get_event_loop().time()
                            latency = int((end_time - start_time) * 1000)
                            
                            if response.status == 200:
                                self.send_event("test-proxy-result", {
                                    "success": True,
                                    "latency": latency,
                                    "message": f"é€£æ¥æˆåŠŸï¼Œå»¶é² {latency}ms"
                                })
                            else:
                                self.send_event("test-proxy-result", {
                                    "success": False,
                                    "error": f"HTTP ç‹€æ…‹ç¢¼: {response.status}"
                                })
                                
            except asyncio.TimeoutError:
                self.send_event("test-proxy-result", {
                    "success": False,
                    "error": "é€£æ¥è¶…æ™‚ï¼ˆ10ç§’ï¼‰"
                })
            except Exception as conn_err:
                self.send_event("test-proxy-result", {
                    "success": False,
                    "error": f"é€£æ¥å¤±æ•—: {str(conn_err)}"
                })

        except Exception as e:
            print(f"[Backend] Error testing proxy: {e}", file=sys.stderr)
            self.send_event("test-proxy-result", {
                "success": False,
                "error": str(e)
            })

    async def handle_sync_account_info(self, payload: Dict[str, Any]):
        """Handle sync-account-info command - åŒæ­¥å¸³è™Ÿä¿¡æ¯ï¼ˆåŒ…æ‹¬é ­åƒï¼‰"""
        import sys
        
        try:
            account_id = payload.get('id') or payload.get('accountId')
            phone = payload.get('phone')
            
            if not account_id and not phone:
                self.send_event("sync-account-info-result", {
                    "success": False, 
                    "error": "ç¼ºå°‘è´¦æˆ· ID æˆ–ç”µè¯å·ç "
                })
                return

            # ç²å–å¸³è™Ÿä¿¡æ¯
            if account_id:
                account = await db.get_account(account_id)
            else:
                account = await db.get_account_by_phone(phone)
            
            if not account:
                self.send_event("sync-account-info-result", {
                    "success": False, 
                    "error": "è´¦æˆ·ä¸å­˜åœ¨"
                })
                return
            
            phone = account.get('phone')
            account_id = account.get('id')
            
            print(f"[Backend] Syncing account info for {phone}...", file=sys.stderr)
            
            # æ£€æŸ¥å®¢æˆ·ç«¯æ˜¯å¦å·²è¿æ¥ï¼Œå¦‚æœæœªè¿æ¥åˆ™å°è¯•è¿æ¥
            client = self.telegram_manager.get_client(phone)
            if not client or not client.is_connected:
                print(f"[Backend] Client not connected, attempting to connect for {phone}...", file=sys.stderr)
                
                # è·å– API å‡­è¯ï¼ˆæ•°æ®åº“å­—æ®µåæ˜¯ apiId å’Œ apiHashï¼‰
                api_id = account.get('apiId') or account.get('api_id')
                api_hash = account.get('apiHash') or account.get('api_hash')
                
                if not api_id or not api_hash:
                    self.send_event("sync-account-info-result", {
                        "success": False, 
                        "error": "è´¦æˆ·ç¼ºå°‘ API å‡­è¯ï¼Œè¯·åœ¨è´¦æˆ·è®¾ç½®ä¸­å¡«å†™ API ID å’Œ API Hash"
                    })
                    return
                
                # å°è¯•ç™»å½•/è¿æ¥
                try:
                    login_result = await self.telegram_manager.login_account(
                        phone=phone,
                        api_id=api_id,
                        api_hash=api_hash,
                        proxy=account.get('proxy')
                    )
                    
                    if not login_result.get('success') and login_result.get('status') != 'Online':
                        self.send_event("sync-account-info-result", {
                            "success": False, 
                            "error": f"æ— æ³•è¿æ¥è´¦æˆ·: {login_result.get('error', 'è¿æ¥å¤±è´¥')}"
                        })
                        return
                        
                    print(f"[Backend] Client connected for {phone}", file=sys.stderr)
                except Exception as conn_error:
                    self.send_event("sync-account-info-result", {
                        "success": False, 
                        "error": f"è¿æ¥è´¦æˆ·å¤±è´¥: {str(conn_error)}"
                    })
                    return
            
            # ç²å–å®Œæ•´ç”¨æˆ¶è³‡æ–™
            full_profile = await self.telegram_manager.get_full_user_profile(phone, download_avatar=True)
            
            if not full_profile.get('success'):
                self.send_event("sync-account-info-result", {
                    "success": False,
                    "error": full_profile.get('error', 'æ— æ³•è·å–ç”¨æˆ·ä¿¡æ¯')
                })
                return
            
            # æ›´æ–°æ•¸æ“šåº«
            await db.update_account(account_id, {
                "firstName": full_profile.get('firstName', ''),
                "lastName": full_profile.get('lastName', ''),
                "username": full_profile.get('username', ''),
                "bio": full_profile.get('bio', ''),
                "avatarPath": full_profile.get('avatarPath', ''),
                "telegramId": str(full_profile.get('id', ''))
            })
            
            print(f"[Backend] Account info synced for {phone}", file=sys.stderr)
            
            # åˆ·æ–°å¸³è™Ÿåˆ—è¡¨
            accounts = await db.get_all_accounts()
            self._cache.pop("accounts", None)
            self._cache_timestamps.pop("accounts", None)
            self.send_event("accounts-updated", accounts)
            
            # ç™¼é€æˆåŠŸçµæœ
            self.send_event("sync-account-info-result", {
                "success": True,
                "accountId": account_id,
                "phone": phone,
                "profile": full_profile
            })
            
            self.send_log(f"å¸³è™Ÿ {phone} ä¿¡æ¯å·²åŒæ­¥", "success")

        except Exception as e:
            print(f"[Backend] Error syncing account info: {e}", file=sys.stderr)
            self.send_event("sync-account-info-result", {
                "success": False,
                "error": str(e)
            })

    async def handle_logout_account(self, payload: Dict[str, Any]):
        """Handle logout-account command - é€€å‡ºè´¦æˆ·ï¼ˆæ–­å¼€è¿æ¥ä½†ä¿ç•™è´¦æˆ·ï¼‰"""
        import sys

        try:
            account_id = payload if isinstance(payload, int) else payload.get('id') or payload.get('accountId')

            if not account_id:
                self.send_event("logout-account-result", {
                    "success": False,
                    "error": "ç¼ºå°‘è´¦æˆ· ID"
                })
                return

            # è·å–è´¦æˆ·ä¿¡æ¯
            account = await db.get_account(account_id)
            if not account:
                self.send_event("logout-account-result", {
                    "success": False,
                    "error": "è´¦æˆ·ä¸å­˜åœ¨"
                })
                return

            phone = account.get('phone')
            print(f"[Backend] Logging out account {phone}...", file=sys.stderr)

            # æ–­å¼€å®¢æˆ·ç«¯è¿æ¥
            try:
                await self.telegram_manager.disconnect_account(phone, graceful=True)
                print(f"[Backend] Account {phone} disconnected successfully", file=sys.stderr)
            except Exception as e:
                print(f"[Backend] Warning: Error disconnecting account {phone}: {e}", file=sys.stderr)

            # æ›´æ–°æ•°æ®åº“çŠ¶æ€ä¸ºç¦»çº¿
            await db.update_account(account_id, {"status": "Offline"})

            # åˆ·æ–°è´¦æˆ·åˆ—è¡¨
            accounts = await db.get_all_accounts()
            self._cache.pop("accounts", None)
            self._cache_timestamps.pop("accounts", None)
            self.send_event("accounts-updated", accounts)

            # å‘é€æˆåŠŸç»“æœ
            self.send_event("logout-account-result", {
                "success": True,
                "accountId": account_id,
                "phone": phone
            })

            self.send_log(f"è´¦æˆ· {phone} å·²é€€å‡º", "success")

        except Exception as e:
            print(f"[Backend] Error logging out account: {e}", file=sys.stderr)
            self.send_event("logout-account-result", {
                "success": False,
                "error": str(e)
            })

    async def handle_save_tags(self, payload: Dict[str, Any]):
        """Save tags to settings"""
        try:
            tags = payload.get('tags', [])
            await db.save_setting('account_tags', json.dumps(tags))
            self.send_event("save-tags-result", {"success": True})
        except Exception as e:
            self.send_event("save-tags-result", {"success": False, "error": str(e)})

    async def handle_save_groups(self, payload: Dict[str, Any]):
        """Save groups to settings"""
        try:
            groups = payload.get('groups', [])
            await db.save_setting('account_groups', json.dumps(groups))
            self.send_event("save-groups-result", {"success": True})
        except Exception as e:
            self.send_event("save-groups-result", {"success": False, "error": str(e)})

    async def handle_get_tags(self, payload: Dict[str, Any]):
        """Get saved tags"""
        try:
            tags_json = await db.get_setting('account_tags')
            tags = json.loads(tags_json) if tags_json else []
            self.send_event("get-tags-result", {"success": True, "tags": tags})
        except Exception as e:
            self.send_event("get-tags-result", {"success": False, "error": str(e), "tags": []})

    async def handle_get_groups(self, payload: Dict[str, Any]):
        """Get saved groups"""
        try:
            groups_json = await db.get_setting('account_groups')
            groups = json.loads(groups_json) if groups_json else []
            self.send_event("get-groups-result", {"success": True, "groups": groups})
        except Exception as e:
            self.send_event("get-groups-result", {"success": False, "error": str(e), "groups": []})

    async def handle_save_personas(self, payload: Dict[str, Any]):
        """Save custom AI personas to settings"""
        try:
            personas = payload.get('personas', [])
            await db.save_setting('ai_personas', json.dumps(personas))
            self.send_event("save-personas-result", {"success": True})
        except Exception as e:
            self.send_event("save-personas-result", {"success": False, "error": str(e)})

    async def handle_get_personas(self, payload: Dict[str, Any]):
        """Get saved custom AI personas"""
        try:
            personas_json = await db.get_setting('ai_personas')
            personas = json.loads(personas_json) if personas_json else []
            self.send_event("get-personas-result", {"success": True, "personas": personas})
        except Exception as e:
            self.send_event("get-personas-result", {"success": False, "error": str(e), "personas": []})

    async def handle_batch_update_accounts(self, payload: Dict[str, Any]):
        """Handle batch-update-accounts command - æ‰¹é‡æ›´æ–°å¸³è™Ÿè¨­ç½®"""
        import sys
        
        try:
            account_ids = payload.get('accountIds', [])
            updates = payload.get('updates', {})
            
            if not account_ids:
                self.send_event("batch-update-accounts-result", {
                    "success": False,
                    "error": "æœªé¸æ“‡å¸³è™Ÿ"
                })
                return
            
            if not updates:
                self.send_event("batch-update-accounts-result", {
                    "success": False,
                    "error": "æœªæä¾›æ›´æ–°æ•¸æ“š"
                })
                return
            
            print(f"[Backend] Batch updating {len(account_ids)} accounts with: {list(updates.keys())}", file=sys.stderr)
            
            # æ‰¹é‡æ›´æ–°æ¯å€‹å¸³è™Ÿ
            success_count = 0
            for account_id in account_ids:
                try:
                    await db.update_account(account_id, updates)
                    success_count += 1
                except Exception as e:
                    print(f"[Backend] Error updating account {account_id}: {e}", file=sys.stderr)
            
            # åˆ·æ–°å¸³è™Ÿåˆ—è¡¨
            accounts = await db.get_all_accounts()
            self._cache.pop("accounts", None)
            self._cache_timestamps.pop("accounts", None)
            self.send_event("accounts-updated", accounts)
            
            # ç™¼é€æˆåŠŸçµæœ
            self.send_event("batch-update-accounts-result", {
                "success": True,
                "count": success_count,
                "total": len(account_ids)
            })
            
            self.send_log(f"æ‰¹é‡æ›´æ–°å®Œæˆ: {success_count}/{len(account_ids)} å€‹å¸³è™Ÿ", "success")

        except Exception as e:
            print(f"[Backend] Error in batch update: {e}", file=sys.stderr)
            self.send_event("batch-update-accounts-result", {
                "success": False,
                "error": str(e)
            })

    async def handle_bulk_assign_role(self, payload: Dict[str, Any]):
        """Handle bulk-assign-role command"""
        try:
            account_ids = payload.get('accountIds', [])
            role = payload.get('role')
            await db.bulk_update_accounts_role(account_ids, role)
            
            accounts = await db.get_all_accounts()
            # Invalidate cache
            self._cache.pop("accounts", None)
            self._cache_timestamps.pop("accounts", None)
            self.send_event("accounts-updated", accounts)
            await db.add_log(f"Bulk assigned role '{role}' to {len(account_ids)} accounts", "success")
        
        except Exception as e:
            self.send_log(f"Error bulk assigning role: {str(e)}", "error")
    
    async def handle_bulk_assign_group(self, payload: Dict[str, Any]):
        """Handle bulk-assign-group command"""
        try:
            account_ids = payload.get('accountIds', [])
            group = payload.get('group')
            await db.bulk_update_accounts_group(account_ids, group)
            
            accounts = await db.get_all_accounts()
            # Invalidate cache
            self._cache.pop("accounts", None)
            self._cache_timestamps.pop("accounts", None)
            self.send_event("accounts-updated", accounts)
            await db.add_log(f"Bulk assigned group '{group}' to {len(account_ids)} accounts", "success")
        
        except Exception as e:
            self.send_log(f"Error bulk assigning group: {str(e)}", "error")
    
    async def handle_bulk_delete_accounts(self, payload: Dict[str, Any]):
        """Handle bulk-delete-accounts command - completely remove accounts and all related resources"""
        try:
            import sys
            from pathlib import Path
            from config import SESSIONS_DIR
            
            account_ids = payload.get('accountIds', [])
            if not account_ids:
                self.send_log("æœªé€‰æ‹©è¦åˆ é™¤çš„è´¦æˆ·", "error")
                return
            
            print(f"[Backend] Bulk deleting {len(account_ids)} accounts", file=sys.stderr)
            
            # Delete from database (this also cleans up related data)
            deleted_phones = await db.bulk_delete_accounts(account_ids)
            print(f"[Backend] {len(deleted_phones)} accounts deleted from database", file=sys.stderr)
            
            # Remove clients from TelegramClientManager and delete session files
            for phone in deleted_phones:
                if phone:
                    # Ensure client is fully disconnected
                    try:
                        await self.ensure_client_disconnected(phone)
                        print(f"[Backend] Client disconnected and removed for {phone}", file=sys.stderr)
                    except Exception as e:
                        print(f"[Backend] Error removing client for {phone}: {e}", file=sys.stderr)
                    
                    # Delete session files with retry mechanism
                    try:
                        safe_phone = phone.replace("+", "").replace("-", "").replace(" ", "")
                        session_file = SESSIONS_DIR / f"{safe_phone}.session"
                        session_journal = SESSIONS_DIR / f"{safe_phone}.session.journal"
                        
                        if session_file.exists():
                            deleted = await self.safe_delete_session_file(session_file)
                            if deleted:
                                print(f"[Backend] Deleted session file: {session_file}", file=sys.stderr)
                            else:
                                print(f"[Backend] WARNING: Failed to delete session file after retries: {session_file}", file=sys.stderr)
                        
                        if session_journal.exists():
                            deleted = await self.safe_delete_session_file(session_journal)
                            if deleted:
                                print(f"[Backend] Deleted session journal: {session_journal}", file=sys.stderr)
                            else:
                                print(f"[Backend] WARNING: Failed to delete session journal after retries: {session_journal}", file=sys.stderr)
                    except Exception as e:
                        print(f"[Backend] Error deleting session files for {phone}: {e}", file=sys.stderr)
            
            # Update accounts list and send event
            accounts = await db.get_all_accounts()
            # Invalidate cache
            self._cache.pop("accounts", None)
            self._cache_timestamps.pop("accounts", None)
            self.send_event("accounts-updated", accounts)
            
            await db.add_log(f"æ‰¹é‡åˆ é™¤äº† {len(deleted_phones)} ä¸ªè´¦æˆ·", "success")
            self.send_log(f"å·²åˆ é™¤ {len(deleted_phones)} ä¸ªè´¦æˆ·", "success")
            print(f"[Backend] Bulk delete completed: {len(deleted_phones)} accounts removed", file=sys.stderr)
            
            accounts = await db.get_all_accounts()
            # Invalidate cache
            self._cache.pop("accounts", None)
            self._cache_timestamps.pop("accounts", None)
            self.send_event("accounts-updated", accounts)
            await db.add_log(f"Deleted {len(account_ids)} accounts", "success")
        
        except Exception as e:
            self.send_log(f"Error deleting accounts: {str(e)}", "error")
    
    async def handle_remove_account(self, payload: Dict[str, Any]):
        """Handle remove-account command - completely remove account and all related resources"""
        try:
            import sys
            from pathlib import Path
            from config import SESSIONS_DIR
            
            account_id = payload.get('id')
            if not account_id:
                self.send_log("è´¦æˆ·IDä¸èƒ½ä¸ºç©º", "error")
                return
            
            # Get account info before deleting (for cleanup)
            account = await db.get_account(account_id)
            if not account:
                self.send_log(f"è´¦æˆ· {account_id} ä¸å­˜åœ¨", "error")
                return
            
            phone = account.get('phone')
            api_id = account.get('apiId')
            print(f"[Backend] Removing account {account_id} (phone: {phone})", file=sys.stderr)
            
            # 0. é‡‹æ”¾ API æ†‘æ“šä½¿ç”¨è¨ˆæ•¸
            if api_id:
                try:
                    from api_credential_pool import get_api_credential_pool
                    data_dir = str(Path(config.DATA_PATH))
                    pool = get_api_credential_pool(data_dir)
                    if pool.release_credential(api_id):
                        print(f"[Backend] API credential {api_id} usage count decremented", file=sys.stderr)
                        # ç™¼é€æ›´æ–°çš„æ†‘æ“šä¿¡æ¯
                        credentials = pool.list_credentials()
                        self.send_event("api-credentials-updated", {"credentials": credentials})
                except Exception as e:
                    print(f"[Backend] Error releasing API credential: {e}", file=sys.stderr)
            
            # 1. Delete from database (this also cleans up related data)
            deleted_phone = await db.remove_account(account_id)
            if not deleted_phone:
                self.send_log(f"åˆ é™¤è´¦æˆ· {account_id} å¤±è´¥", "error")
                return
            
            print(f"[Backend] Account {account_id} deleted from database", file=sys.stderr)
            
            # 2. Remove client from TelegramClientManager (this will disconnect it)
            if phone:
                try:
                    await self.telegram_manager.remove_client(phone, wait_for_disconnect=True)
                    # Force garbage collection to release file handles
                    gc.collect()
                    await asyncio.sleep(0.3)  # Give OS time to release file handles
                    print(f"[Backend] Client disconnected and removed for {phone}", file=sys.stderr)
                except Exception as e:
                    print(f"[Backend] Error removing client from TelegramClientManager: {e}", file=sys.stderr)
                    # Continue with file deletion attempt anyway
            
            # 3. Delete session files (with retry mechanism)
            if phone:
                try:
                    # Sanitize phone number for filename
                    safe_phone = phone.replace("+", "").replace("-", "").replace(" ", "")
                    session_file = SESSIONS_DIR / f"{safe_phone}.session"
                    session_journal = SESSIONS_DIR / f"{safe_phone}.session.journal"
                    
                    # Delete session file with retry
                    if session_file.exists():
                        deleted = await self.safe_delete_session_file(session_file)
                        if deleted:
                            print(f"[Backend] Deleted session file: {session_file}", file=sys.stderr)
                        else:
                            print(f"[Backend] WARNING: Failed to delete session file after retries: {session_file}", file=sys.stderr)
                    
                    # Delete session journal file if exists
                    if session_journal.exists():
                        deleted = await self.safe_delete_session_file(session_journal)
                        if deleted:
                            print(f"[Backend] Deleted session journal file: {session_journal}", file=sys.stderr)
                        else:
                            print(f"[Backend] WARNING: Failed to delete session journal file after retries: {session_journal}", file=sys.stderr)
                    
                except Exception as e:
                    print(f"[Backend] Error deleting session files for {phone}: {e}", file=sys.stderr)
                    # Don't fail the whole operation if session file deletion fails
                    # The account is already deleted from database
            
            # 4. Update accounts list and send event
            accounts = await db.get_all_accounts()
            # Invalidate cache
            self._cache.pop("accounts", None)
            self._cache_timestamps.pop("accounts", None)
            self.send_event("accounts-updated", accounts)
            
            await db.add_log(f"è´¦æˆ· {phone} (ID: {account_id}) å·²å®Œå…¨åˆ é™¤", "success")
            self.send_log(f"è´¦æˆ· {phone} å·²å®Œå…¨åˆ é™¤", "success")
            print(f"[Backend] Account {account_id} ({phone}) completely removed", file=sys.stderr)
        
        except Exception as e:
            import sys
            import traceback
            error_msg = str(e)
            print(f"[Backend] Error removing account: {error_msg}", file=sys.stderr)
            traceback.print_exc(file=sys.stderr)
            self.send_log(f"åˆ é™¤è´¦æˆ·å¤±è´¥: {error_msg}", "error")
    
    async def check_monitoring_configuration(self) -> Dict[str, Any]:
        """
        å®Œæ•´é…ç½®æª¢æŸ¥ - åœ¨å•Ÿå‹•ç›£æ§å‰æª¢æ¸¬æ‰€æœ‰å¿…è¦é…ç½®
        
        Returns:
            Dict containing all check results and recommendations
        """
        checks = {
            "passed": True,
            "critical_issues": [],
            "warnings": [],
            "info": [],
            "details": {}
        }
        
        # ========== 1. æª¢æŸ¥ç›£æ§å¸³è™Ÿ ==========
        accounts = await db.get_all_accounts()
        listener_accounts = [a for a in accounts if a.get('role') == 'Listener']
        online_listeners = [a for a in listener_accounts if a.get('status') == 'Online']
        
        checks["details"]["listener_accounts"] = {
            "total": len(listener_accounts),
            "online": len(online_listeners),
            "accounts": [{"phone": a.get('phone'), "status": a.get('status')} for a in listener_accounts]
        }
        
        if not listener_accounts:
            checks["passed"] = False
            checks["critical_issues"].append({
                "code": "NO_LISTENER",
                "message": "æ²’æœ‰ç›£æ§å¸³è™Ÿï¼ˆListener è§’è‰²ï¼‰",
                "fix": "åœ¨ã€Œå¸³æˆ¶ç®¡ç†ã€ä¸­å°‡å¸³è™Ÿè§’è‰²è¨­ç‚ºã€ŒListenerã€"
            })
        elif not online_listeners:
            checks["passed"] = False
            checks["critical_issues"].append({
                "code": "LISTENER_OFFLINE",
                "message": "ç›£æ§å¸³è™Ÿå…¨éƒ¨é›¢ç·š",
                "fix": "é»æ“Šã€Œç™»å…¥ã€æŒ‰éˆ•ä½¿ç›£æ§å¸³è™Ÿä¸Šç·š"
            })
        else:
            checks["info"].append(f"âœ“ {len(online_listeners)} å€‹ç›£æ§å¸³è™Ÿåœ¨ç·š")
        
        # ========== 2. æª¢æŸ¥ç™¼é€å¸³è™Ÿ ==========
        sender_accounts = [a for a in accounts if a.get('role') == 'Sender']
        online_senders = [a for a in sender_accounts if a.get('status') == 'Online']
        
        checks["details"]["sender_accounts"] = {
            "total": len(sender_accounts),
            "online": len(online_senders),
            "accounts": [{"phone": a.get('phone'), "status": a.get('status'), 
                         "dailySendCount": a.get('dailySendCount', 0),
                         "dailySendLimit": a.get('dailySendLimit', 50)} for a in sender_accounts]
        }
        
        if not sender_accounts:
            checks["warnings"].append({
                "code": "NO_SENDER",
                "message": "æ²’æœ‰ç™¼é€å¸³è™Ÿï¼ˆSender è§’è‰²ï¼‰",
                "fix": "åœ¨ã€Œå¸³æˆ¶ç®¡ç†ã€ä¸­å°‡å¸³è™Ÿè§’è‰²è¨­ç‚ºã€ŒSenderã€ï¼Œå¦å‰‡ç„¡æ³•ç™¼é€æ¶ˆæ¯"
            })
        elif not online_senders:
            checks["warnings"].append({
                "code": "SENDER_OFFLINE",
                "message": "ç™¼é€å¸³è™Ÿå…¨éƒ¨é›¢ç·š",
                "fix": "é»æ“Šã€Œç™»å…¥ã€æŒ‰éˆ•ä½¿ç™¼é€å¸³è™Ÿä¸Šç·šï¼Œå¦å‰‡ç„¡æ³•ç™¼é€æ¶ˆæ¯"
            })
        else:
            # Check if any sender has remaining quota
            available_senders = [s for s in online_senders 
                                if s.get('dailySendCount', 0) < s.get('dailySendLimit', 50)]
            if not available_senders:
                checks["warnings"].append({
                    "code": "SENDER_LIMIT_REACHED",
                    "message": "æ‰€æœ‰ç™¼é€å¸³è™Ÿå·²é”æ¯æ—¥ç™¼é€é™é¡",
                    "fix": "ç­‰å¾…æ˜å¤©é‡ç½®é™é¡ï¼Œæˆ–å¢åŠ æ–°çš„ç™¼é€å¸³è™Ÿ"
                })
            else:
                checks["info"].append(f"âœ“ {len(available_senders)} å€‹ç™¼é€å¸³è™Ÿå¯ç”¨")
        
        # ========== 3. æª¢æŸ¥ç›£æ§ç¾¤çµ„ ==========
        monitored_groups = await db.get_all_monitored_groups()
        
        checks["details"]["monitored_groups"] = {
            "total": len(monitored_groups),
            "groups": [{"url": g.get('url'), "keywordSetIds": g.get('keywordSetIds', [])} 
                      for g in monitored_groups]
        }
        
        if not monitored_groups:
            checks["passed"] = False
            checks["critical_issues"].append({
                "code": "NO_GROUPS",
                "message": "æ²’æœ‰ç›£æ§ç¾¤çµ„",
                "fix": "åœ¨ã€Œè‡ªå‹•åŒ–ä¸­å¿ƒã€æ·»åŠ è¦ç›£æ§çš„ç¾¤çµ„ URL"
            })
        else:
            checks["info"].append(f"âœ“ {len(monitored_groups)} å€‹ç›£æ§ç¾¤çµ„")
        
        # ========== 4. æª¢æŸ¥é—œéµè©é›† ==========
        keyword_sets = await db.get_all_keyword_sets()
        
        # è¨ˆç®—ç¸½é—œéµè©æ•¸
        total_keywords = sum(len(ks.get('keywords', [])) for ks in keyword_sets)
        
        checks["details"]["keyword_sets"] = {
            "total": len(keyword_sets),
            "total_keywords": total_keywords,
            "sets": [{"id": ks.get('id'), "name": ks.get('name'), 
                     "keywords": ks.get('keywords', [])} for ks in keyword_sets]
        }
        
        if not keyword_sets:
            checks["passed"] = False
            checks["critical_issues"].append({
                "code": "NO_KEYWORDS",
                "message": "æ²’æœ‰é—œéµè©é›†",
                "fix": "åœ¨ã€Œè‡ªå‹•åŒ–ä¸­å¿ƒã€å‰µå»ºé—œéµè©é›†ä¸¦æ·»åŠ é—œéµè©"
            })
        elif total_keywords == 0:
            checks["passed"] = False
            checks["critical_issues"].append({
                "code": "EMPTY_KEYWORDS",
                "message": "é—œéµè©é›†æ²’æœ‰ä»»ä½•é—œéµè©",
                "fix": "åœ¨é—œéµè©é›†ä¸­æ·»åŠ è¦ç›£æ§çš„é—œéµè©"
            })
        else:
            checks["info"].append(f"âœ“ {len(keyword_sets)} å€‹é—œéµè©é›†ï¼Œå…± {total_keywords} å€‹é—œéµè©")
        
        # ========== 5. æª¢æŸ¥ç¾¤çµ„èˆ‡é—œéµè©ç¶å®š ==========
        groups_without_keywords = [g for g in monitored_groups if not g.get('keywordSetIds')]
        
        if groups_without_keywords and monitored_groups:
            checks["warnings"].append({
                "code": "GROUP_NO_KEYWORD",
                "message": f"{len(groups_without_keywords)} å€‹ç¾¤çµ„æœªç¶å®šé—œéµè©é›†",
                "fix": "åœ¨ã€Œç›£æ§ç¾¤çµ„ã€ä¸­ç‚ºç¾¤çµ„å‹¾é¸é—œéµè©é›†"
            })
        
        # ========== 6. æª¢æŸ¥èˆŠç‰ˆæ´»å‹•ï¼ˆCampaignï¼‰- åƒ…ä½œç‚ºå‘å¾Œå…¼å®¹ ==========
        # æ³¨æ„ï¼šæ–°ç³»çµ±ä½¿ç”¨ã€Œè§¸ç™¼è¦å‰‡ã€ï¼ŒèˆŠç‰ˆ Campaign å·²è¢«è§¸ç™¼è¦å‰‡å–ä»£
        campaigns = await db.get_all_campaigns()
        active_campaigns = [c for c in campaigns if c.get('isActive')]
        
        checks["details"]["campaigns"] = {
            "total": len(campaigns),
            "active": len(active_campaigns),
            "campaigns": [{
                "id": c.get('id'), 
                "name": c.get('name'), 
                "isActive": c.get('isActive'),
                "sourceGroupIds": c.get('trigger', {}).get('sourceGroupIds', []),
                "keywordSetIds": c.get('trigger', {}).get('keywordSetIds', []),
                "templateId": c.get('actions', [{}])[0].get('templateId', 0) if c.get('actions') else 0
            } for c in campaigns]
        }
        
        # ä¸å†å°èˆŠç‰ˆ Campaign é¡¯ç¤ºè­¦å‘Šï¼Œå› ç‚ºç”¨æˆ¶æ‡‰è©²ä½¿ç”¨ã€Œè§¸ç™¼è¦å‰‡ã€
        # å¦‚æœæœ‰èˆŠç‰ˆæ´»å‹•ï¼Œåªé¡¯ç¤ºç‚ºä¿¡æ¯æç¤º
        if active_campaigns:
            checks["info"].append(f"â„¹ {len(active_campaigns)} å€‹èˆŠç‰ˆæ´»å‹•ï¼ˆå»ºè­°é·ç§»åˆ°è§¸ç™¼è¦å‰‡ï¼‰")
        
        # ========== 7. æª¢æŸ¥æ¶ˆæ¯æ¨¡æ¿ ==========
        templates = await db.get_all_templates()
        active_templates = [t for t in templates if t.get('isActive', True)]
        
        checks["details"]["templates"] = {
            "total": len(templates),
            "active": len(active_templates)
        }
        
        if not templates:
            checks["warnings"].append({
                "code": "NO_TEMPLATE",
                "message": "æ²’æœ‰æ¶ˆæ¯æ¨¡æ¿",
                "fix": "åœ¨ã€Œè‡ªå‹•åŒ–ä¸­å¿ƒã€å‰µå»ºæ¶ˆæ¯æ¨¡æ¿"
            })
        else:
            checks["info"].append(f"âœ“ {len(templates)} å€‹æ¶ˆæ¯æ¨¡æ¿")
        
        # ========== 8. æª¢æŸ¥ AI è¨­ç½® ==========
        ai_settings = await db.get_ai_settings()
        ai_enabled = ai_settings.get('auto_chat_enabled', 0) == 1
        ai_greeting_enabled = ai_settings.get('auto_greeting', 0) == 1
        ai_mode = ai_settings.get('auto_chat_mode', 'semi')
        
        checks["details"]["ai_settings"] = {
            "auto_chat_enabled": ai_enabled,
            "auto_greeting": ai_greeting_enabled,
            "auto_chat_mode": ai_mode
        }
        
        if ai_enabled:
            mode_names = {'full': 'å…¨è‡ªå‹•', 'semi': 'åŠè‡ªå‹•', 'assist': 'è¼”åŠ©', 'keyword': 'é—œéµè©è§¸ç™¼'}
            checks["info"].append(f"âœ“ AI è‡ªå‹•èŠå¤©å·²é–‹å•Ÿ (æ¨¡å¼: {mode_names.get(ai_mode, ai_mode)})")
            if ai_greeting_enabled:
                checks["info"].append("âœ“ AI è‡ªå‹•å•å€™å·²é–‹å•Ÿ")
        else:
            checks["info"].append("â„¹ AI è‡ªå‹•èŠå¤©æœªé–‹å•Ÿï¼ˆå¯åœ¨è¨­ç½®ä¸­é–‹å•Ÿï¼‰")
        
        # ========== æª¢æŸ¥è§¸ç™¼è¦å‰‡ ==========
        trigger_rules = await db.get_all_trigger_rules()
        active_rules = [r for r in trigger_rules if r.get('is_active') or r.get('isActive')]
        
        checks["details"]["trigger_rules"] = {
            "total": len(trigger_rules),
            "active": len(active_rules)
        }
        
        if active_rules:
            checks["info"].append(f"âœ“ {len(active_rules)} æ¢è§¸ç™¼è¦å‰‡å·²å•Ÿç”¨")
        
        # ========== ç”Ÿæˆç¸½çµ ==========
        # åˆ¤æ–·æ˜¯å¦èƒ½ç™¼é€æ¶ˆæ¯ï¼šæœ‰åœ¨ç·šç™¼é€å¸³è™Ÿ ä¸” (æœ‰æ´»å‹• æˆ– æœ‰è§¸ç™¼è¦å‰‡ æˆ– AIèŠå¤©å·²å•Ÿç”¨)
        has_response_config = len(active_campaigns) > 0 or len(active_rules) > 0 or ai_enabled
        checks["summary"] = {
            "can_monitor": checks["passed"],
            "can_send_messages": len(online_senders) > 0 and has_response_config,
            "critical_count": len(checks["critical_issues"]),
            "warning_count": len(checks["warnings"]),
            "info_count": len(checks["info"])
        }
        
        return checks
    
    async def handle_start_monitoring(self):
        """Handle start-monitoring command with Pyrogram"""
        import sys  # åœ¨å‡½æ•¸é–‹é ­å°å…¥ï¼Œé¿å… UnboundLocalError
        print("[Backend] ğŸš€ handle_start_monitoring called", file=sys.stderr)
        
        try:
            if self.is_monitoring:
                self.send_log("Monitoring is already running", "warning")
                # ğŸ”§ P0ä¿®å¾©: å³ä½¿å·²åœ¨ç›£æ§ä¸­ï¼Œä¹Ÿç™¼é€ç‹€æ…‹åŒæ­¥äº‹ä»¶
                self.send_event("monitoring-status-changed", True)
                self.send_event("monitoring-started", {"success": True, "message": "ç›£æ§å·²åœ¨é‹è¡Œä¸­"})
                return {"success": True, "message": "ç›£æ§å·²åœ¨é‹è¡Œä¸­", "isMonitoring": True}
            
            # ========== å®Œæ•´é…ç½®æª¢æŸ¥ ==========
            self.send_log("æ­£åœ¨æª¢æŸ¥ç›£æ§é…ç½®...", "info")
            print("[Backend] æ­£åœ¨æª¢æŸ¥ç›£æ§é…ç½®...", file=sys.stderr)
            
            try:
                config_check = await self.check_monitoring_configuration()
                print(f"[Backend] é…ç½®æª¢æŸ¥çµæœ: passed={config_check.get('passed')}", file=sys.stderr)
            except Exception as check_error:
                import sys
                import traceback
                traceback.print_exc(file=sys.stderr)
                self.send_log(f"é…ç½®æª¢æŸ¥æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(check_error)}", "error")
                self.send_event("monitoring-start-failed", {
                    "reason": "exception",
                    "message": f"é…ç½®æª¢æŸ¥æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(check_error)}"
                })
                return {"success": False, "error": str(check_error), "isMonitoring": False}
            
            # ç™¼é€é…ç½®æª¢æŸ¥å ±å‘Šåˆ°å‰ç«¯
            self.send_event("monitoring-config-check", config_check)
            
            # é¡¯ç¤ºæª¢æŸ¥çµæœ
            for info in config_check.get("info", []):
                self.send_log(info, "info")
            
            for warning in config_check.get("warnings", []):
                self.send_log(f"âš  {warning['message']}", "warning")
            
            for issue in config_check.get("critical_issues", []):
                self.send_log(f"âœ— {issue['message']}", "error")
            
            # å¦‚æœæœ‰åš´é‡å•é¡Œï¼Œé˜»æ­¢å•Ÿå‹•
            if not config_check.get("passed", False):
                error_msg = "é…ç½®æª¢æŸ¥æœªé€šéï¼Œç„¡æ³•å•Ÿå‹•ç›£æ§ã€‚è«‹ä¿®å¾©ä¸Šè¿°å•é¡Œã€‚"
                self.send_log(error_msg, "error")
                self.send_event("monitoring-start-failed", {
                    "reason": "config_check_failed",
                    "message": "é…ç½®æª¢æŸ¥æœªé€šéï¼Œè«‹ä¿®å¾©å•é¡Œå¾Œé‡è©¦",
                    "issues": config_check.get("critical_issues", []),
                    "warnings": config_check.get("warnings", [])
                })
                print(f"[Backend] âŒ é…ç½®æª¢æŸ¥æœªé€šé: {config_check.get('critical_issues')}", file=sys.stderr)
                return {"success": False, "error": error_msg, "issues": config_check.get("critical_issues", []), "isMonitoring": False}
            
            # å¦‚æœæ²’æœ‰ç™¼é€èƒ½åŠ›ï¼Œçµ¦å‡ºè­¦å‘Šä½†ç¹¼çºŒ
            if not config_check.get("summary", {}).get("can_send_messages", False):
                self.send_log("âš  è­¦å‘Šï¼šç›£æ§å¯ä»¥é‹è¡Œï¼Œä½†æ²’æœ‰å¯ç”¨çš„ç™¼é€é…ç½®ã€‚Lead å°‡è¢«æ•ç²ä½†ä¸æœƒè‡ªå‹•ç™¼é€æ¶ˆæ¯ã€‚", "warning")
            
            # å¾é…ç½®æª¢æŸ¥ä¸­ç²å–æ•¸æ“š
            accounts = await db.get_all_accounts()
            listener_accounts = [a for a in accounts if a.get('role') == 'Listener' and a.get('status') == 'Online']
            monitored_groups = await db.get_all_monitored_groups()
            keyword_sets = await db.get_all_keyword_sets()
            
            # ========== æ–°å¢ï¼šæª¢æŸ¥ç›£æ§è™Ÿæ˜¯å¦å·²åŠ å…¥ç¾¤çµ„ ==========
            group_urls = [g.get('url') for g in monitored_groups if g.get('url')]
            self.send_log(f"æ­£åœ¨æª¢æŸ¥ {len(listener_accounts)} å€‹ç›£æ§è³¬è™Ÿå° {len(group_urls)} å€‹ç¾¤çµ„çš„æˆå“¡ç‹€æ…‹...", "info")
            
            # Check membership for all listener accounts
            all_membership_reports = []
            groups_needing_join = []  # Groups that need to be joined
            groups_accessible = []    # Groups that are accessible
            groups_cannot_join = []   # Groups that cannot be joined with reasons
            
            for account in listener_accounts:
                phone = account.get('phone')
                try:
                    report = await self.telegram_manager.check_all_groups_membership(phone, group_urls)
                    all_membership_reports.append(report)
                    
                    # Collect groups that are accessible (already member)
                    for group_info in report.get("member_of", []):
                        if group_info["url"] not in [g["url"] for g in groups_accessible]:
                            groups_accessible.append(group_info)
                    
                    # Collect groups that need joining
                    for group_info in report.get("can_join", []):
                        if group_info["url"] not in [g["url"] for g in groups_needing_join]:
                            groups_needing_join.append(group_info)
                    
                    # Collect groups that cannot be joined with reasons
                    for group_info in report.get("cannot_join", []):
                        if group_info["url"] not in [g["url"] for g in groups_cannot_join]:
                            groups_cannot_join.append(group_info)
                    
                except Exception as e:
                    import sys
                    print(f"[Backend] Error checking membership for {phone}: {e}", file=sys.stderr)
            
            # Send status report to frontend
            status_report = {
                "total_groups": len(group_urls),
                "accessible_groups": len(groups_accessible),
                "groups_needing_join": len(groups_needing_join),
                "groups_cannot_join": len(groups_cannot_join),
                "accessible_list": groups_accessible,
                "needing_join_list": groups_needing_join,
                "cannot_join_list": groups_cannot_join,
                "accounts_checked": len(listener_accounts)
            }
            
            self.send_event("monitoring-status-report", status_report)
            
            # Log status
            if groups_accessible:
                accessible_names = [g.get("title", g.get("url", "Unknown")) for g in groups_accessible[:3]]
                self.send_log(f"âœ“ å¯ç›£æ§ç¾¤çµ„: {len(groups_accessible)} å€‹ ({', '.join(accessible_names)}{'...' if len(groups_accessible) > 3 else ''})", "success")
            
            if groups_needing_join:
                needing_names = [g.get("url", "Unknown") for g in groups_needing_join[:3]]
                self.send_log(f"âš  éœ€è¦åŠ å…¥: {len(groups_needing_join)} å€‹ç¾¤çµ„ ({', '.join(needing_names)}{'...' if len(groups_needing_join) > 3 else ''})", "warning")
            
            # é¡¯ç¤ºç„¡æ³•åŠ å…¥çš„ç¾¤çµ„åŠåŸå› 
            if groups_cannot_join:
                for group_info in groups_cannot_join:
                    reason = group_info.get("reason", "æœªçŸ¥åŸå› ")
                    self.send_log(f"âœ— ç„¡æ³•åŠ å…¥ {group_info.get('url')}: {reason}", "error")
            
            # If no groups are accessible, try to auto-join
            if not groups_accessible and groups_needing_join:
                self.send_log(f"ç›£æ§è™ŸæœªåŠ å…¥ä»»ä½•ç¾¤çµ„ï¼Œæ­£åœ¨å˜—è©¦è‡ªå‹•åŠ å…¥ {len(groups_needing_join)} å€‹ç¾¤çµ„...", "info")
                # The start_monitoring will try to join groups automatically
            
            # If no groups can be monitored even after potential joins
            if not groups_accessible and not groups_needing_join:
                # ç”Ÿæˆè©³ç´°çš„éŒ¯èª¤ä¿¡æ¯
                error_details = []
                for g in groups_cannot_join:
                    error_details.append(f"{g.get('url')}: {g.get('reason', 'æœªçŸ¥åŸå› ')}")
                
                error_message = "ç„¡æ³•å•Ÿå‹•ç›£æ§: ç›£æ§è™Ÿç„¡æ³•è¨ªå•ä»»ä½•ç¾¤çµ„ã€‚"
                if error_details:
                    error_message += f"\nè©³æƒ…: {'; '.join(error_details)}"
                
                self.send_log(error_message, "error")
                self.send_event("monitoring-start-failed", {
                    "reason": "no_accessible_groups",
                    "message": "ç„¡æ³•å•Ÿå‹•ç›£æ§: ç›£æ§è™Ÿç„¡æ³•è¨ªå•ä»»ä½•ç¾¤çµ„ã€‚è«‹ç¢ºä¿ç›£æ§è™Ÿå·²åŠ å…¥è¦ç›£æ§çš„ç¾¤çµ„ã€‚",
                    "cannot_join_list": groups_cannot_join
                })
                print(f"[Backend] âŒ ç„¡æ³•è¨ªå•ä»»ä½•ç¾¤çµ„", file=sys.stderr)
                return {"success": False, "error": error_message, "reason": "no_accessible_groups", "isMonitoring": False}
            
            # ========== çµæŸæ–°å¢ ==========
            
            # Start monitoring for each account
            async def on_lead_captured(lead_data):
                """Callback when a lead is captured - optimized with batch query"""
                try:
                    # Batch check: get lead and DNC status in one query
                    existing_lead, is_dnc = await db.check_lead_and_dnc(lead_data['user_id'])
                    
                    if is_dnc:
                        return
                    
                    should_greet = False  # æ˜¯å¦æ‡‰è©²ç™¼é€å•å€™
                    
                    if existing_lead:
                        # Update existing lead
                        lead_id = existing_lead['id']
                        await db.add_interaction(
                            lead_id,
                            'Keyword Matched',
                            f"Matched keyword: {lead_data['triggered_keyword']}"
                        )
                        
                        # ç¢ºä¿ user_profile å­˜åœ¨ï¼ˆç”¨æ–¼æ¼æ–—çµ±è¨ˆï¼‰
                        user_id_str = str(lead_data['user_id'])
                        existing_profile = await db.get_user_profile(user_id_str)
                        if not existing_profile:
                            await db._connection.execute("""
                                INSERT INTO user_profiles 
                                (user_id, username, first_name, last_name, funnel_stage, interest_level, created_at)
                                VALUES (?, ?, ?, ?, 'new', 1, CURRENT_TIMESTAMP)
                            """, (
                                user_id_str,
                                lead_data.get('username', ''),
                                lead_data.get('first_name', ''),
                                lead_data.get('last_name', '')
                            ))
                            await db._connection.commit()
                        
                        # æª¢æŸ¥æ˜¯å¦å·²ç¶“å•å€™éæ­¤ç”¨æˆ¶ï¼ˆæª¢æŸ¥ç‹€æ…‹ï¼‰
                        lead_status = existing_lead.get('status', 'New')
                        if lead_status == 'New':
                            # é‚„æ²’æœ‰è¯ç¹«éï¼Œæ‡‰è©²ç™¼é€å•å€™
                            should_greet = True
                            self.send_log(f"ğŸ“Œ ç¾æœ‰ Lead @{lead_data.get('username')} å°šæœªå•å€™ï¼Œå°‡ç™¼é€å•å€™", "info")
                    else:
                        # Create new lead - å„ªå…ˆä½¿ç”¨ source_group_urlï¼ˆç¾¤çµ„ URLï¼‰
                        source_group_value = lead_data.get('source_group_url') or lead_data.get('source_group')
                        lead_id = await db.add_lead({
                            'userId': lead_data['user_id'],
                            'username': lead_data.get('username'),
                            'firstName': lead_data.get('first_name'),
                            'lastName': lead_data.get('last_name'),
                            'sourceGroup': source_group_value,  # å­˜å„² URL è€Œä¸æ˜¯ chat_id
                            'triggeredKeyword': lead_data['triggered_keyword'],
                            'onlineStatus': lead_data.get('online_status', 'Unknown')
                        })
                        
                        # é€²è¡Œæ„åœ–è©•åˆ†
                        from intent_scorer import score_lead_intent
                        message_text = lead_data.get('message_text', lead_data.get('triggered_keyword', ''))
                        intent_result = await score_lead_intent(message_text)
                        
                        # æ›´æ–° Lead çš„æ„åœ–åˆ†æ•¸
                        await db.update_lead(lead_id, {
                            'intent_score': intent_result['score'],
                            'intent_level': intent_result['level']
                        })
                        
                        self.send_log(f"ğŸ“Š æ„åœ–è©•åˆ†: {intent_result['score']}åˆ† ({intent_result['level']})", "info")
                        
                        # Send event with properly formatted data for frontend
                        import datetime
                        self.send_event("lead-captured", {
                            "id": lead_id,
                            "userId": lead_data['user_id'],
                            "username": lead_data.get('username') or '',
                            "firstName": lead_data.get('first_name') or '',
                            "lastName": lead_data.get('last_name') or '',
                            "sourceGroup": source_group_value,  # ä½¿ç”¨ URL
                            "triggeredKeyword": lead_data['triggered_keyword'],
                            "timestamp": lead_data.get('timestamp') or datetime.datetime.now().isoformat(),
                            "status": "New",
                            "onlineStatus": lead_data.get('online_status', 'Unknown'),
                            "interactionHistory": [],
                            "doNotContact": False,
                            "intentScore": intent_result['score'],
                            "intentLevel": intent_result['level'],
                            "intentSuggestions": intent_result['suggestions']
                        })
                        
                        self.send_log(f"âœ“ æ–°æ½›åœ¨å®¢æˆ¶å·²æ•ç²: @{lead_data.get('username') or lead_data.get('first_name')}", "success")
                        await db.add_log(f"New lead captured: {lead_data.get('username') or lead_data.get('first_name')}", "success")
                        
                        # åŒæ­¥åˆ° user_profiles è¡¨ï¼ˆç”¨æ–¼æ¼æ–—çµ±è¨ˆï¼‰
                        user_id_str = str(lead_data['user_id'])
                        existing_profile = await db.get_user_profile(user_id_str)
                        if not existing_profile:
                            await db._connection.execute("""
                                INSERT INTO user_profiles 
                                (user_id, username, first_name, last_name, funnel_stage, interest_level, created_at)
                                VALUES (?, ?, ?, ?, 'new', 1, CURRENT_TIMESTAMP)
                            """, (
                                user_id_str,
                                lead_data.get('username', ''),
                                lead_data.get('first_name', ''),
                                lead_data.get('last_name', '')
                            ))
                            await db._connection.commit()
                            self.send_log(f"ğŸ“Š å·²å‰µå»ºç”¨æˆ¶è³‡æ–™: @{lead_data.get('username')}", "info")
                        
                        # æ–° Lead ç¸½æ˜¯ç™¼é€å•å€™
                        should_greet = True
                    
                    # AI Auto Chat: Handle greeting (for new leads or existing leads not yet contacted)
                    if should_greet:
                        await self._handle_ai_auto_greeting(lead_data, lead_id)
                    
                    # åŸ·è¡ŒåŒ¹é…çš„è§¸ç™¼è¦å‰‡ï¼ˆæ–°ç³»çµ±ï¼‰
                    await self.execute_matching_trigger_rules(lead_id, lead_data)
                    
                    # Check for matching campaigns and execute them (èˆŠç³»çµ±ï¼Œä¿æŒå…¼å®¹)
                    await self.execute_matching_campaigns(lead_id, lead_data)
                
                except Exception as e:
                    import sys
                    import traceback
                    error_details = traceback.format_exc()
                    error_msg = f"Error processing captured lead: {str(e)}\n{error_details}"
                    print(f"[Backend] Error in lead_callback: {error_msg}", file=sys.stderr)
                    self.send_log(f"è™•ç†æ½›åœ¨å®¢æˆ¶æ™‚å‡ºéŒ¯: {str(e)}", "error")
                    # è¨˜éŒ„è©³ç´°éŒ¯èª¤åˆ°æ•¸æ“šåº«
                    await db.add_log(f"Lead callback error: {str(e)}", "error")
            
            # Start monitoring for each listener account
            successful_starts = 0
            failed_accounts = []
            
            for account in listener_accounts:
                phone = account.get('phone')
                group_urls = [g.get('url') for g in monitored_groups]
                keyword_sets_list = [
                    {
                        "id": ks.get('id'),
                        "keywords": ks.get('keywords', [])
                    }
                    for ks in keyword_sets
                ]
                
                try:
                    import sys
                    print(f"[Backend] Attempting to start monitoring for account {phone}", file=sys.stderr)
                    print(f"[Backend] Group URLs: {group_urls}", file=sys.stderr)
                    print(f"[Backend] Keyword sets count: {len(keyword_sets_list)}", file=sys.stderr)
                    
                    # å˜—è©¦å•Ÿå‹•ç›£æ§
                    result = await self.telegram_manager.start_monitoring(
                        phone=phone,
                        group_urls=group_urls,
                        keyword_sets=keyword_sets_list,
                        on_lead_captured=on_lead_captured
                    )
                    
                    print(f"[Backend] start_monitoring result for {phone}: {result} (type: {type(result)})", file=sys.stderr)
                    
                    # æª¢æŸ¥æ˜¯å¦æˆåŠŸå•Ÿå‹•ï¼ˆstart_monitoring è¿”å› True è¡¨ç¤ºæˆåŠŸï¼‰
                    if result is True:
                        successful_starts += 1
                        print(f"[Backend] âœ“ Successfully started monitoring for {phone}", file=sys.stderr)
                        
                        # è¨˜éŒ„ç›£æ§çš„ç¾¤çµ„ä¿¡æ¯
                        if hasattr(self.telegram_manager, 'monitoring_info') and phone in self.telegram_manager.monitoring_info:
                            monitoring_info = self.telegram_manager.monitoring_info[phone]
                            monitored_urls = monitoring_info.get('group_urls', [])
                            if monitored_urls:
                                self.send_log(f"è³¬æˆ¶ {phone} æˆåŠŸå•Ÿå‹•ç›£æ§ï¼Œç›£æ§ç¾¤çµ„: {', '.join(monitored_urls)}", "success")
                        
                        # å•Ÿå‹•ç€è¦½è¡Œç‚ºæ¨¡æ“¬å¾Œå°ä»»å‹™ï¼ˆè¡Œç‚ºæ¨¡æ“¬ï¼‰
                        try:
                            await self._start_browsing_simulation(account.get('id'), phone, group_urls)
                        except Exception as sim_error:
                            self.send_log(f"å•Ÿå‹•è¡Œç‚ºæ¨¡æ“¬å¤±æ•— ({phone}): {str(sim_error)}", "warning")
                    else:
                        failed_accounts.append(phone)
                        print(f"[Backend] âœ— Failed to start monitoring for {phone}, result: {result}", file=sys.stderr)
                        self.send_log(f"è³¬æˆ¶ {phone} ç›£æ§å•Ÿå‹•å¤±æ•—ï¼ˆè¿”å›å€¼: {result}ï¼‰", "warning")
                
                except Exception as account_error:
                    failed_accounts.append(phone)
                    import sys
                    import traceback
                    print(f"[Backend] âœ— Exception starting monitoring for {phone}: {account_error}", file=sys.stderr)
                    traceback.print_exc(file=sys.stderr)
                    self.send_log(f"è³¬æˆ¶ {phone} ç›£æ§å•Ÿå‹•å¤±æ•—: {str(account_error)}", "error")
            
            # åªæœ‰åœ¨è‡³å°‘ä¸€å€‹è³¬æˆ¶æˆåŠŸå•Ÿå‹•ç›£æ§æ™‚ï¼Œæ‰è¨­ç½®å…¨å±€ç›£æ§ç‹€æ…‹
            if successful_starts > 0:
                self.is_monitoring = True
                # Save monitoring state to database
                await db.set_monitoring_active(True)
                self.send_event("monitoring-status-changed", True)
                
                success_message = f"ç›£æ§å·²å•Ÿå‹•ï¼š{successful_starts} å€‹è³¬æˆ¶æ­£åœ¨ç›£æ§"
                if failed_accounts:
                    success_message += f"ï¼Œ{len(failed_accounts)} å€‹è³¬æˆ¶å•Ÿå‹•å¤±æ•—"
                
                await db.add_log(success_message, "success")
                self.send_log(success_message, "success")
                
                # ç‚ºæ‰€æœ‰åœ¨ç·šå¸³è™Ÿè¨»å†Šç§ä¿¡è™•ç†å™¨ï¼ˆç¢ºä¿ AI å¯ä»¥å›å¾©ç”¨æˆ¶ç§ä¿¡ï¼‰
                all_accounts = await db.get_all_accounts()
                online_clients = {}
                for acc in all_accounts:
                    if acc.get('status') == 'Online':
                        acc_phone = acc.get('phone')
                        acc_role = acc.get('role', 'Unassigned')
                        try:
                            await self.telegram_manager.register_private_message_handler(
                                phone=acc_phone,
                                account_role=acc_role
                            )
                            print(f"[Backend] âœ“ å·²ç‚ºå¸³è™Ÿ {acc_phone} è¨»å†Šç§ä¿¡è™•ç†å™¨", file=sys.stderr)
                            
                            # æ”¶é›†åœ¨ç·šå®¢æˆ¶ç«¯ç”¨æ–¼è¼ªè©¢
                            client = self.telegram_manager.get_client(acc_phone)
                            if client:
                                online_clients[acc_phone] = client
                        except Exception as e:
                            print(f"[Backend] âœ— è¨»å†Šç§ä¿¡è™•ç†å™¨å¤±æ•— ({acc_phone}): {e}", file=sys.stderr)
                
                # å•Ÿå‹•ç§ä¿¡è¼ªè©¢æœå‹™ï¼ˆé›™é‡ä¿éšªæ©Ÿåˆ¶ï¼‰
                if online_clients:
                    try:
                        # ğŸ†• åŒ…è£ event_callback ä»¥æ”¯æŒ AI åœ˜éšŠç›®æ¨™ç”¨æˆ¶ç›£è¯
                        def wrapped_event_callback(event_name: str, payload: Any):
                            self.send_event(event_name, payload)
                            # å¦‚æœæ˜¯ç§ä¿¡äº‹ä»¶ï¼Œæª¢æŸ¥æ˜¯å¦ç‚º AI åœ˜éšŠç›®æ¨™ç”¨æˆ¶
                            if event_name == "private-message-received":
                                asyncio.create_task(self.handle_ai_team_customer_reply(payload))
                        
                        private_message_poller.event_callback = wrapped_event_callback
                        await private_message_poller.start_polling(online_clients)
                        self.send_log(f"ğŸ”„ ç§ä¿¡è¼ªè©¢æœå‹™å·²å•Ÿå‹•ï¼Œç›£æ§ {len(online_clients)} å€‹å¸³è™Ÿ", "success")
                    except Exception as poller_err:
                        print(f"[Backend] âœ— å•Ÿå‹•ç§ä¿¡è¼ªè©¢æœå‹™å¤±æ•—: {poller_err}", file=sys.stderr)
                        self.send_log(f"ç§ä¿¡è¼ªè©¢æœå‹™å•Ÿå‹•å¤±æ•—: {poller_err}", "warning")
                
                # ğŸ”§ P0ä¿®å¾©: ç™¼é€ monitoring-started äº‹ä»¶
                self.send_event("monitoring-started", {
                    "success": True,
                    "message": success_message,
                    "successfulAccounts": successful_starts,
                    "failedAccounts": len(failed_accounts)
                })
                print(f"[Backend] âœ… ç›£æ§å•Ÿå‹•æˆåŠŸ: {success_message}", file=sys.stderr)
                return {"success": True, "message": success_message, "isMonitoring": True, "successfulAccounts": successful_starts}
            else:
                # æ‰€æœ‰è³¬æˆ¶éƒ½å¤±æ•—ï¼Œä¸è¨­ç½®ç›£æ§ç‹€æ…‹
                self.is_monitoring = False
                await db.set_monitoring_active(False)
                self.send_event("monitoring-status-changed", False)
                
                error_message = "ç›£æ§å•Ÿå‹•å¤±æ•—ï¼šæ‰€æœ‰ç›£è½è³¬æˆ¶éƒ½ç„¡æ³•å•Ÿå‹•ç›£æ§"
                if failed_accounts:
                    error_message += f"ã€‚å¤±æ•—çš„è³¬æˆ¶ï¼š{', '.join(failed_accounts)}"
                
                self.send_event("monitoring-start-failed", {
                    "reason": "all_accounts_failed",
                    "message": error_message,
                    "failed_accounts": failed_accounts
                })
                await db.add_log(error_message, "error")
                self.send_log(error_message, "error")
                print(f"[Backend] âŒ æ‰€æœ‰è³¬æˆ¶å•Ÿå‹•å¤±æ•—: {error_message}", file=sys.stderr)
                return {"success": False, "error": error_message, "reason": "all_accounts_failed", "isMonitoring": False}
        
        except Exception as e:
            # ç™¼ç”Ÿç•°å¸¸æ™‚ï¼Œç¢ºä¿ç›£æ§ç‹€æ…‹ç‚º False
            import traceback
            self.is_monitoring = False
            await db.set_monitoring_active(False)
            self.send_event("monitoring-status-changed", False)
            self.send_log(f"å•Ÿå‹•ç›£æ§æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}", "error")
            self.send_event("monitoring-start-failed", {
                "reason": "exception",
                "message": f"å•Ÿå‹•ç›£æ§æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}"
            })
            print(f"[Backend] âŒ å•Ÿå‹•ç›£æ§ç•°å¸¸: {str(e)}", file=sys.stderr)
            traceback.print_exc(file=sys.stderr)
            return {"success": False, "error": str(e), "reason": "exception", "isMonitoring": False}
    
    async def handle_stop_monitoring(self):
        """Handle stop-monitoring command"""
        try:
            self.is_monitoring = False
            # Save monitoring state to database
            await db.set_monitoring_active(False)
            
            # Stop monitoring for all listener accounts (keeps connection, just removes handlers)
            accounts = await db.get_all_accounts()
            listener_accounts = [a for a in accounts if a.get('role') == 'Listener']
            
            stopped_count = 0
            for account in listener_accounts:
                phone = account.get('phone')
                try:
                    # Use stop_monitoring to just remove handlers without disconnecting
                    await self.telegram_manager.stop_monitoring(phone)
                    stopped_count += 1
                except Exception as stop_error:
                    self.send_log(f"åœæ­¢ç›£æ§æ™‚ç™¼ç”ŸéŒ¯èª¤ ({phone}): {str(stop_error)}", "warning")
            
            self.send_event("monitoring-status-changed", False)
            # ğŸ”§ P0ä¿®å¾©: ç™¼é€ monitoring-stopped äº‹ä»¶
            self.send_event("monitoring-stopped", {"success": True, "stoppedCount": stopped_count})
            await db.add_log(f"Monitoring stopped for {stopped_count} account(s)", "info")
            self.send_log(f"ç›£æ§å·²åœæ­¢ï¼š{stopped_count} å€‹è³¬æˆ¶", "info")
            print(f"[Backend] âœ… ç›£æ§å·²åœæ­¢: {stopped_count} å€‹è³¬æˆ¶", file=sys.stderr)
            return {"success": True, "message": f"ç›£æ§å·²åœæ­¢ï¼š{stopped_count} å€‹è³¬æˆ¶", "isMonitoring": False}
        
        except Exception as e:
            self.send_log(f"Error stopping monitoring: {str(e)}", "error")
            return {"success": False, "error": str(e), "isMonitoring": self.is_monitoring}
    
    async def handle_get_monitoring_status(self):
        """Handle get-monitoring-status command - è¿”å›ç•¶å‰ç›£æ§ç‹€æ…‹"""
        import sys
        print(f"[Backend] handle_get_monitoring_status called, is_monitoring={self.is_monitoring}", file=sys.stderr)
        
        # ç™¼é€ monitoring-status äº‹ä»¶
        self.send_event("monitoring-status", {
            "isMonitoring": self.is_monitoring,
            "active": self.is_monitoring
        })
        
        return {
            "success": True,
            "isMonitoring": self.is_monitoring,
            "active": self.is_monitoring
        }
    
    async def handle_one_click_start(self, payload: Dict[str, Any] = None):
        """
        ä¸€éµå•Ÿå‹• v3.0ï¼šä¸¦è¡Œå„ªåŒ–ç‰ˆæœ¬
        - ä¸¦è¡Œé€£æ¥å¸³è™Ÿï¼ˆæœ€å¤š 3 å€‹åŒæ™‚ï¼‰
        - ä¸¦è¡ŒåŠ å…¥ç¾¤çµ„ï¼ˆæœ€å¤š 5 å€‹åŒæ™‚ï¼‰
        - å„ªåŒ–çš„éŒ¯èª¤è™•ç†å’Œé€²åº¦é¡¯ç¤º
        """
        import sys
        import time as time_module
        
        start_time = time_module.time()
        print(f"[Backend] === ä¸€éµå•Ÿå‹• v3.0 é–‹å§‹ ===", file=sys.stderr)
        
        # ğŸ†• å•Ÿç”¨æ—¥èªŒæ‰¹é‡æ¨¡å¼ï¼Œæ¸›å°‘ IPC èª¿ç”¨
        self.start_log_batch_mode()
        
        results = {
            'accounts': {'success': 0, 'failed': 0, 'total': 0, 'details': []},
            'monitoring': {'success': False, 'message': '', 'groups': 0},
            'ai': {'success': False, 'message': ''},
            'overall_success': False,
            'timing': {}  # ğŸ†• æ·»åŠ æ™‚é–“çµ±è¨ˆ
        }
        
        try:
            # === æ­¥é©Ÿ 0: é æª¢æŸ¥ ===
            step_start = time_module.time()
            self.send_event("one-click-start-progress", {
                "step": "precheck",
                "message": "ğŸ” æ­£åœ¨é€²è¡Œé æª¢æŸ¥... (é è¨ˆ 1 ç§’)",
                "progress": 5,
                "estimated_seconds": 1
            })
            
            accounts = await db.get_all_accounts()
            results['accounts']['total'] = len(accounts)
            
            if not accounts:
                self.send_event("one-click-start-progress", {
                    "step": "error",
                    "message": "âŒ æ²’æœ‰é…ç½®ä»»ä½•å¸³è™Ÿ",
                    "progress": 100
                })
                results['monitoring']['message'] = "æ²’æœ‰é…ç½®å¸³è™Ÿ"
                self.send_event("one-click-start-result", results)
                return
            
            # === æ­¥é©Ÿ 1: å¼·åˆ¶é©—è­‰ä¸¦é‡æ–°é€£æ¥æ‰€æœ‰å¸³è™Ÿ ===
            results['timing']['precheck'] = time_module.time() - step_start
            step_start = time_module.time()
            
            # é ä¼°æ™‚é–“ï¼šæ¯å€‹å¸³è™Ÿç´„ 2-5 ç§’ï¼Œä¸¦è¡Œè™•ç† 3 å€‹
            estimated_account_time = max(5, len(accounts) * 3 // 3)  # ä¸¦è¡Œå„ªåŒ–
            self.send_event("one-click-start-progress", {
                "step": "accounts",
                "message": f"ğŸ”‘ æ­£åœ¨ä¸¦è¡Œé€£æ¥ {len(accounts)} å€‹å¸³è™Ÿ... (é è¨ˆ {estimated_account_time} ç§’)",
                "progress": 10,
                "estimated_seconds": estimated_account_time
            })
            
            # ğŸ†• å„ªåŒ–ï¼šå®šç¾©å–®å€‹å¸³è™Ÿé€£æ¥å‡½æ•¸
            async def connect_single_account(account: dict) -> dict:
                """é€£æ¥å–®å€‹å¸³è™Ÿï¼Œè¿”å›çµæœ"""
                phone = account.get('phone')
                account_id = account.get('id')
                api_id = account.get('apiId')
                api_hash = account.get('apiHash')
                
                account_result = {
                    'phone': phone,
                    'success': False,
                    'message': ''
                }
                
                try:
                    if not api_id or not api_hash:
                        account_result['message'] = "æœªé…ç½® API"
                        return account_result
                    
                    # æª¢æŸ¥å¯¦éš›å®¢æˆ¶ç«¯ç‹€æ…‹
                    client = self.telegram_manager.get_client(phone)
                    is_actually_connected = False
                    
                    if client:
                        try:
                            is_actually_connected = client.is_connected
                        except:
                            is_actually_connected = False
                    
                    # å¦‚æœå®¢æˆ¶ç«¯ä¸å­˜åœ¨æˆ–æœªé€£æ¥ï¼Œå¼·åˆ¶é‡æ–°ç™»å…¥
                    if not client or not is_actually_connected:
                        login_result = await self.telegram_manager.login_account(
                            phone=phone,
                            api_id=api_id,
                            api_hash=api_hash
                        )
                        
                        if login_result.get('success') or login_result.get('status') == 'Online':
                            try:
                                client = self.telegram_manager.get_client(phone)
                                if client and client.is_connected:
                                    me = await client.get_me()
                                    if me:
                                        account_result['success'] = True
                                        account_result['message'] = f"å·²é€£æ¥ (@{me.username or me.first_name})"
                                        await db.update_account(account_id, {"status": "Online"})
                                    else:
                                        raise Exception("get_me() è¿”å›ç©º")
                                else:
                                    raise Exception("å®¢æˆ¶ç«¯æœªæ­£ç¢ºé€£æ¥")
                            except Exception as verify_err:
                                account_result['message'] = f"é©—è­‰å¤±æ•—: {verify_err}"
                                await db.update_account(account_id, {"status": "Offline"})
                        else:
                            if login_result.get('status') == 'Code Required':
                                account_result['message'] = "éœ€è¦é©—è­‰ç¢¼"
                            else:
                                account_result['message'] = login_result.get('error', 'ç™»å…¥å¤±æ•—')
                            await db.update_account(account_id, {"status": "Offline"})
                    else:
                        # å®¢æˆ¶ç«¯å·²é€£æ¥ï¼Œé©—è­‰æœƒè©±
                        try:
                            me = await client.get_me()
                            if me:
                                account_result['success'] = True
                                account_result['message'] = f"å·²åœ¨ç·š (@{me.username or me.first_name})"
                            else:
                                raise Exception("æœƒè©±ç„¡æ•ˆ")
                        except Exception:
                            try:
                                await client.disconnect()
                            except:
                                pass
                            
                            login_result = await self.telegram_manager.login_account(
                                phone=phone, api_id=api_id, api_hash=api_hash
                            )
                            
                            if login_result.get('success') or login_result.get('status') == 'Online':
                                account_result['success'] = True
                                account_result['message'] = "é‡æ–°é€£æ¥æˆåŠŸ"
                                await db.update_account(account_id, {"status": "Online"})
                            else:
                                account_result['message'] = "é‡é€£å¤±æ•—"
                                await db.update_account(account_id, {"status": "Offline"})
                    
                except Exception as acc_err:
                    account_result['message'] = str(acc_err)
                    try:
                        await db.update_account(account_id, {"status": "Offline"})
                    except:
                        pass
                
                return account_result
            
            # ğŸ†• ä¸¦è¡Œé€£æ¥å¸³è™Ÿï¼ˆé™åˆ¶ä¸¦ç™¼æ•¸ç‚º 3ï¼Œé¿å…éè¼‰ï¼‰
            semaphore = asyncio.Semaphore(3)
            completed_count = 0
            
            async def connect_with_progress(account: dict) -> dict:
                nonlocal completed_count
                async with semaphore:
                    result = await connect_single_account(account)
                    completed_count += 1
                    
                    # æ›´æ–°é€²åº¦
                    progress = 10 + int(completed_count / len(accounts) * 25)
                    status_icon = "âœ“" if result['success'] else "âœ—"
                    self.send_event("one-click-start-progress", {
                        "step": "account_connecting",
                        "message": f"ğŸ”‘ {status_icon} {result['phone']} ({completed_count}/{len(accounts)})",
                        "progress": progress
                    })
                    
                    log_type = "success" if result['success'] else "warning"
                    self.send_log(f"{status_icon} {result['phone']}: {result['message']}", log_type)
                    
                    return result
            
            print(f"[Backend] Connecting {len(accounts)} accounts in parallel (max 3 concurrent)...", file=sys.stderr)
            
            # ä½¿ç”¨ gather ä¸¦è¡Œé€£æ¥
            tasks = [connect_with_progress(acc) for acc in accounts]
            account_results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # è™•ç†çµæœ
            for i, result in enumerate(account_results):
                if isinstance(result, Exception):
                    result = {
                        'phone': accounts[i].get('phone'),
                        'success': False,
                        'message': str(result)
                    }
                
                if result.get('success'):
                    results['accounts']['success'] += 1
                else:
                    results['accounts']['failed'] += 1
                
                results['accounts']['details'].append(result)
            
            results['timing']['accounts'] = time_module.time() - step_start
            self.send_event("one-click-start-progress", {
                "step": "accounts_done",
                "message": f"âœ… å¸³è™Ÿé€£æ¥: {results['accounts']['success']}/{results['accounts']['total']} (ç”¨æ™‚ {results['timing']['accounts']:.1f}ç§’)",
                "progress": 40,
                "elapsed_seconds": results['timing']['accounts']
            })
            
            # å¦‚æœæ²’æœ‰æˆåŠŸé€£æ¥çš„å¸³è™Ÿï¼Œåœæ­¢
            if results['accounts']['success'] == 0:
                self.send_event("one-click-start-progress", {
                    "step": "error",
                    "message": "âŒ æ²’æœ‰æˆåŠŸé€£æ¥çš„å¸³è™Ÿï¼Œç„¡æ³•å•Ÿå‹•ç›£æ§",
                    "progress": 100
                })
                results['monitoring']['message'] = "æ²’æœ‰å¯ç”¨å¸³è™Ÿ"
                self.send_event("one-click-start-result", results)
                return
            
            # === æ­¥é©Ÿ 1.5: è‡ªå‹•åŠ å…¥ç¾¤çµ„ ===
            step_start = time_module.time()
            
            results['groups'] = {
                'success': [],
                'pending': [],
                'failed': []
            }
            
            try:
                groups = await db.get_all_groups()
                if groups:
                    # é ä¼°æ™‚é–“ï¼šä¸¦è¡Œè™•ç†ï¼Œæ¯ 5 å€‹ç¾¤çµ„ç´„ 3 ç§’
                    estimated_group_time = max(3, len(groups) * 2 // 5)
                    self.send_event("one-click-start-progress", {
                        "step": "groups",
                        "message": f"ğŸ‘¥ æ­£åœ¨ä¸¦è¡Œæª¢æŸ¥ {len(groups)} å€‹ç¾¤çµ„... (é è¨ˆ {estimated_group_time} ç§’)",
                        "progress": 42,
                        "estimated_seconds": estimated_group_time
                    })
                    # æ‰¾åˆ°ä¸€å€‹å¯ç”¨çš„ç›£æ§å¸³è™Ÿ
                    listener_account = None
                    for acc in results['accounts']['details']:
                        if acc.get('success'):
                            listener_account = acc.get('phone')
                            break
                    
                    if listener_account:
                        client = self.telegram_manager.get_client(listener_account)
                        if client and client.is_connected:
                            # è¨­ç½®äº‹ä»¶å›èª¿
                            group_join_service.event_callback = self.send_event
                            
                            # æ‰¹é‡åŠ å…¥ç¾¤çµ„
                            group_urls = [g.get('url') for g in groups if g.get('url')]
                            self.send_log(f"ğŸ”„ æª¢æŸ¥ {len(group_urls)} å€‹ç¾¤çµ„...", "info")
                            
                            join_report = await group_join_service.join_multiple_groups(
                                client=client,
                                group_urls=group_urls,
                                delay_between=1.5,
                                auto_verify=True
                            )
                            
                            results['groups']['success'] = join_report['success']
                            results['groups']['pending'] = join_report['pending']
                            results['groups']['failed'] = join_report['failed']
                            
                            # é¡¯ç¤ºè©³ç´°çµæœ
                            success_count = len(join_report['success'])
                            pending_count = len(join_report['pending'])
                            failed_count = len(join_report['failed'])
                            
                            if success_count > 0:
                                self.send_log(f"âœ“ æˆåŠŸåŠ å…¥/å·²åœ¨ {success_count} å€‹ç¾¤çµ„", "success")
                            if pending_count > 0:
                                self.send_log(f"â³ {pending_count} å€‹ç¾¤çµ„ç­‰å¾…å¯©æ‰¹", "info")
                            if failed_count > 0:
                                for fail in join_report['failed']:
                                    self.send_log(f"âœ— {fail['url']}: {fail['error']}", "warning")
                        else:
                            self.send_log("âš  æ²’æœ‰å¯ç”¨å®¢æˆ¶ç«¯æª¢æŸ¥ç¾¤çµ„", "warning")
                    else:
                        self.send_log("âš  æ²’æœ‰å¯ç”¨å¸³è™Ÿæª¢æŸ¥ç¾¤çµ„", "warning")
                else:
                    self.send_log("â„¹ æ²’æœ‰é…ç½®ç›£æ§ç¾¤çµ„", "info")
            except Exception as group_err:
                self.send_log(f"ç¾¤çµ„æª¢æŸ¥éŒ¯èª¤: {group_err}", "warning")
            
            results['timing']['groups'] = time_module.time() - step_start
            self.send_event("one-click-start-progress", {
                "step": "groups_done",
                "message": f"âœ… ç¾¤çµ„æª¢æŸ¥å®Œæˆ: {len(results['groups']['success'])} å€‹å¯ç”¨ (ç”¨æ™‚ {results['timing']['groups']:.1f}ç§’)",
                "progress": 48,
                "elapsed_seconds": results['timing']['groups']
            })
            
            # === æ­¥é©Ÿ 1.8: æª¢æŸ¥æ´»å‹•ï¼ˆCampaignsï¼‰é…ç½® ===
            self.send_event("one-click-start-progress", {
                "step": "campaigns_check",
                "message": "ğŸ“‹ æ­£åœ¨æª¢æŸ¥æ´»å‹•é…ç½®...",
                "progress": 49
            })
            
            # === æ­¥é©Ÿ 1.8: æª¢æŸ¥éŸ¿æ‡‰é…ç½®ï¼ˆè§¸ç™¼è¦å‰‡ + AI èŠå¤©ï¼‰===
            results['response_config'] = {
                'trigger_rules': {'total': 0, 'active': 0},
                'ai_chat': {'enabled': False, 'mode': 'semi'},
                'campaigns': {'total': 0, 'active': 0},
                'warnings': [],
                'valid': False,
                'source': None  # 'trigger_rules' | 'ai_chat' | 'campaigns' | None
            }
            
            try:
                # 1. æª¢æŸ¥è§¸ç™¼è¦å‰‡
                trigger_rules = await db.get_all_trigger_rules()
                active_rules = [r for r in trigger_rules if r.get('is_active', False)]
                results['response_config']['trigger_rules'] = {
                    'total': len(trigger_rules),
                    'active': len(active_rules)
                }
                
                # 2. æª¢æŸ¥ AI è‡ªå‹•èŠå¤©è¨­ç½®
                ai_settings = await db.get_ai_settings()
                ai_enabled = ai_settings.get('auto_chat_enabled', 0) == 1 if ai_settings else False
                ai_mode = ai_settings.get('auto_chat_mode', 'semi') if ai_settings else 'semi'
                results['response_config']['ai_chat'] = {
                    'enabled': ai_enabled,
                    'mode': ai_mode
                }
                
                # 3. æª¢æŸ¥èˆŠç‰ˆ Campaignï¼ˆå‘å¾Œå…¼å®¹ï¼‰
                campaigns = await db.get_all_campaigns()
                active_campaigns = [c for c in campaigns if c.get('isActive') or c.get('is_active')]
                results['response_config']['campaigns'] = {
                    'total': len(campaigns),
                    'active': len(active_campaigns)
                }
                
                # åˆ¤æ–·éŸ¿æ‡‰é…ç½®æ˜¯å¦æœ‰æ•ˆï¼ˆä»»ä¸€é …æ»¿è¶³å³å¯ï¼‰
                if len(active_rules) > 0:
                    results['response_config']['valid'] = True
                    results['response_config']['source'] = 'trigger_rules'
                    self.send_log(f"âœ“ éŸ¿æ‡‰é…ç½®: {len(active_rules)} æ¢è§¸ç™¼è¦å‰‡æ´»èº", "success")
                elif ai_enabled:
                    results['response_config']['valid'] = True
                    results['response_config']['source'] = 'ai_chat'
                    mode_text = 'å…¨è‡ªå‹•' if ai_mode == 'full' else 'åŠè‡ªå‹•'
                    self.send_log(f"âœ“ éŸ¿æ‡‰é…ç½®: AI è‡ªå‹•èŠå¤©å·²å•Ÿç”¨ï¼ˆ{mode_text}æ¨¡å¼ï¼‰", "success")
                elif len(active_campaigns) > 0:
                    results['response_config']['valid'] = True
                    results['response_config']['source'] = 'campaigns'
                    self.send_log(f"âœ“ éŸ¿æ‡‰é…ç½®: {len(active_campaigns)} å€‹æ´»å‹•é…ç½®", "success")
                else:
                    results['response_config']['warnings'].append("âš ï¸ æœªé…ç½®éŸ¿æ‡‰æ–¹å¼ï¼ˆè§¸ç™¼è¦å‰‡/AIèŠå¤©/æ´»å‹•ï¼‰")
                    self.send_log("âš  æœªé…ç½®éŸ¿æ‡‰æ–¹å¼ï¼ŒåŒ¹é…çš„æ¶ˆæ¯å°‡åªè¨˜éŒ„ä¸å›è¦†", "warning")
                    self.send_log("ğŸ’¡ å»ºè­°ï¼šå‰å¾€ã€Œè§¸ç™¼è¦å‰‡ã€é é¢é…ç½®ï¼Œæˆ–å•Ÿç”¨ AI è‡ªå‹•èŠå¤©", "info")
                
            except Exception as resp_err:
                results['response_config']['warnings'].append(f"æª¢æŸ¥éŸ¿æ‡‰é…ç½®æ™‚å‡ºéŒ¯: {resp_err}")
                self.send_log(f"âš  éŸ¿æ‡‰é…ç½®æª¢æŸ¥éŒ¯èª¤: {resp_err}", "warning")
            
            # å‘å¾Œå…¼å®¹ï¼šä¿ç•™ campaigns å­—æ®µï¼ˆåˆä½µè§¸ç™¼è¦å‰‡å’ŒèˆŠç‰ˆæ´»å‹•ï¼‰
            trigger_total = results['response_config']['trigger_rules']['total']
            trigger_active = results['response_config']['trigger_rules']['active']
            campaign_total = results['response_config']['campaigns']['total']
            campaign_active = results['response_config']['campaigns']['active']
            
            results['campaigns'] = {
                'total': trigger_total + campaign_total,
                'active': trigger_active + campaign_active,
                'warnings': results['response_config']['warnings'],
                'valid': results['response_config']['valid']
            }
            
            # === æ­¥é©Ÿ 2: å•Ÿç”¨ AI è‡ªå‹•èŠå¤©ï¼ˆå…ˆæ–¼ç›£æ§ï¼Œè®“é…ç½®æª¢æŸ¥èƒ½çœ‹åˆ° AI ç‹€æ…‹ï¼‰===
            self.send_event("one-click-start-progress", {
                "step": "ai",
                "message": "ğŸ¤– æ­£åœ¨å•Ÿç”¨ AI...",
                "progress": 50
            })
            
            try:
                # æ›´æ–°ç‚ºå•Ÿç”¨ç‹€æ…‹å’Œå…¨è‡ªå‹•æ¨¡å¼
                await db.update_ai_settings({
                    'auto_chat_enabled': 1,
                    'auto_chat_mode': 'full',
                    'auto_greeting': 1
                })
                
                # é‡æ–°è¼‰å…¥ AI è¨­ç½®åˆ°å…§å­˜
                await ai_auto_chat.initialize()
                
                # æª¢æŸ¥ AI ç«¯é»æ˜¯å¦å·²é…ç½®
                ai_endpoint = ai_auto_chat.local_ai_endpoint
                if ai_endpoint:
                    self.send_log(f"âœ“ AI ç«¯é»: {ai_endpoint}", "success")
                else:
                    self.send_log("âš  AI ç«¯é»æœªé…ç½®ï¼Œå°‡ä½¿ç”¨å‚™ç”¨å›è¦†", "warning")
                
                results['ai']['success'] = True
                results['ai']['message'] = f"AI å…¨è‡ªå‹•æ¨¡å¼å·²å•Ÿç”¨" + (f" (ç«¯é»: {ai_endpoint[:30]}...)" if ai_endpoint else " (å‚™ç”¨å›è¦†)")
                self.send_log("âœ“ AI è‡ªå‹•èŠå¤©å·²å•Ÿç”¨ (å…¨è‡ªå‹•æ¨¡å¼)", "success")
                
                # ç™¼é€ AI è¨­ç½®æ›´æ–°äº‹ä»¶
                self.send_event("ai-settings-updated", {
                    'auto_chat_enabled': True,
                    'auto_chat_mode': 'full',
                    'auto_greeting': True
                })
            except Exception as ai_err:
                results['ai']['message'] = str(ai_err)
                self.send_log(f"âœ— AI å•Ÿç”¨éŒ¯èª¤: {ai_err}", "error")
            
            self.send_event("one-click-start-progress", {
                "step": "ai_done",
                "message": f"{'âœ…' if results['ai']['success'] else 'âŒ'} {results['ai']['message']}",
                "progress": 60
            })
            
            # === æ­¥é©Ÿ 3: å•Ÿå‹•ç›£æ§ï¼ˆåœ¨ AI å•Ÿç”¨ä¹‹å¾Œï¼Œé…ç½®æª¢æŸ¥èƒ½æ­£ç¢ºé¡¯ç¤º AI ç‹€æ…‹ï¼‰===
            self.send_event("one-click-start-progress", {
                "step": "monitoring",
                "message": "ğŸ“¡ æ­£åœ¨å•Ÿå‹•ç›£æ§...",
                "progress": 65
            })
            
            try:
                await self.handle_start_monitoring()
                if self.is_monitoring:
                    results['monitoring']['success'] = True
                    results['monitoring']['message'] = "ç›£æ§å·²å•Ÿå‹•"
                    
                    # çµ±è¨ˆç›£æ§çš„ç¾¤çµ„æ•¸
                    groups = await db.get_all_groups()
                    results['monitoring']['groups'] = len(groups)
                else:
                    results['monitoring']['message'] = "ç›£æ§å•Ÿå‹•å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¾¤çµ„é…ç½®"
            except Exception as mon_err:
                results['monitoring']['message'] = str(mon_err)
                self.send_log(f"âœ— ç›£æ§å•Ÿå‹•éŒ¯èª¤: {mon_err}", "error")
            
            self.send_event("one-click-start-progress", {
                "step": "monitoring_done",
                "message": f"{'âœ…' if results['monitoring']['success'] else 'âš ï¸'} {results['monitoring']['message']}",
                "progress": 80
            })
            
            # === æ­¥é©Ÿ 4: å•Ÿå‹•ç§ä¿¡è¼ªè©¢ ===
            self.send_event("one-click-start-progress", {
                "step": "poller",
                "message": "ğŸ“¬ æ­£åœ¨å•Ÿå‹•ç§ä¿¡è¼ªè©¢...",
                "progress": 90
            })
            
            try:
                # æ”¶é›†æ‰€æœ‰åœ¨ç·šå®¢æˆ¶ç«¯
                online_clients = {}
                for acc in results['accounts']['details']:
                    if acc.get('success'):
                        phone = acc.get('phone')
                        client = self.telegram_manager.get_client(phone)
                        if client and client.is_connected:
                            online_clients[phone] = client
                
                if online_clients:
                    # ğŸ†• åŒ…è£ event_callback ä»¥æ”¯æŒ AI åœ˜éšŠç›®æ¨™ç”¨æˆ¶ç›£è½
                    def wrapped_event_callback_v2(event_name: str, payload: Any):
                        self.send_event(event_name, payload)
                        if event_name == "private-message-received":
                            asyncio.create_task(self.handle_ai_team_customer_reply(payload))
                    
                    private_message_poller.event_callback = wrapped_event_callback_v2
                    await private_message_poller.start_polling(online_clients)
                    self.send_log(f"âœ“ ç§ä¿¡è¼ªè©¢å·²å•Ÿå‹•ï¼Œç›£æ§ {len(online_clients)} å€‹å¸³è™Ÿ", "success")
                else:
                    self.send_log("âš  æ²’æœ‰å¯ç”¨çš„å®¢æˆ¶ç«¯ç”¨æ–¼ç§ä¿¡è¼ªè©¢", "warning")
            except Exception as poller_err:
                self.send_log(f"âœ— ç§ä¿¡è¼ªè©¢å•Ÿå‹•éŒ¯èª¤: {poller_err}", "warning")
            
            # === æ­¥é©Ÿ 5: å•Ÿå‹•é€£æ¥ç›£æ§ ===
            self.send_event("one-click-start-progress", {
                "step": "connection_monitor",
                "message": "ğŸ”„ æ­£åœ¨å•Ÿå‹•é€£æ¥ç›£æ§...",
                "progress": 95
            })
            
            try:
                connection_monitor.set_telegram_manager(self.telegram_manager)
                connection_monitor.event_callback = self.send_event
                await connection_monitor.start(check_interval=60)
                self.send_log("âœ“ é€£æ¥ç›£æ§å·²å•Ÿå‹•ï¼ˆæ¯60ç§’æª¢æŸ¥ï¼‰", "success")
            except Exception as monitor_err:
                self.send_log(f"âš  é€£æ¥ç›£æ§å•Ÿå‹•éŒ¯èª¤: {monitor_err}", "warning")
            
            # === æ­¥é©Ÿ 6: å•Ÿå‹•æ¼æ–—è‡ªå‹•æµè½‰ ===
            self.send_event("one-click-start-progress", {
                "step": "funnel",
                "message": "ğŸ¯ æ­£åœ¨å•Ÿå‹•æ¼æ–—è‡ªå‹•æµè½‰...",
                "progress": 97
            })
            
            results['funnel'] = {
                'success': False,
                'message': ''
            }
            
            try:
                # è¨­ç½®æ¼æ–—ç®¡ç†å™¨å›èª¿
                async def funnel_send_callback(target_user_id: str, message: str, **kwargs):
                    """æ¼æ–—è‡ªå‹•è·Ÿé€²ç™¼é€å›èª¿"""
                    # ç²å–ä»»ä¸€åœ¨ç·šå¸³è™Ÿ
                    for acc in results['accounts']['details']:
                        if acc.get('success'):
                            phone = acc.get('phone')
                            client = self.telegram_manager.get_client(phone)
                            if client and client.is_connected:
                                try:
                                    await client.send_message(int(target_user_id), message)
                                    self.send_log(f"[AutoFunnel] å·²ç™¼é€è·Ÿé€²æ¶ˆæ¯çµ¦ {target_user_id}", "info")
                                    return True
                                except Exception as send_err:
                                    self.send_log(f"[AutoFunnel] ç™¼é€å¤±æ•—: {send_err}", "warning")
                    return False
                
                auto_funnel.set_callbacks(
                    send_callback=funnel_send_callback,
                    log_callback=self.send_log,
                    event_callback=self.send_event
                )
                
                # ç¢ºä¿æ¼æ–—ç®¡ç†å™¨å·²å•Ÿå‹•
                if not auto_funnel.is_running:
                    await auto_funnel.start()
                
                results['funnel']['success'] = True
                results['funnel']['message'] = "æ¼æ–—è‡ªå‹•æµè½‰å·²å•Ÿç”¨"
                self.send_log("âœ“ æ¼æ–—è‡ªå‹•æµè½‰å·²å•Ÿå‹•ï¼ˆæ¯30åˆ†é˜æª¢æŸ¥è·Ÿé€²ï¼‰", "success")
                
            except Exception as funnel_err:
                results['funnel']['message'] = str(funnel_err)
                self.send_log(f"âš  æ¼æ–—ç®¡ç†å™¨å•Ÿå‹•éŒ¯èª¤: {funnel_err}", "warning")
            
            # === æ­¥é©Ÿ 7: ç”Ÿæˆè¨ºæ–·å ±å‘Š ===
            self.send_event("one-click-start-progress", {
                "step": "diagnosis",
                "message": "ğŸ“Š æ­£åœ¨ç”Ÿæˆè¨ºæ–·å ±å‘Š...",
                "progress": 98
            })
            
            # æ·»åŠ è¨ºæ–·ä¿¡æ¯åˆ°çµæœ
            results['diagnosis'] = {
                'issues': [],
                'recommendations': [],
                'readiness_score': 0
            }
            
            try:
                # è¨ˆç®—æº–å‚™åº¦åˆ†æ•¸
                score = 0
                max_score = 5
                
                # 1. å¸³è™Ÿæª¢æŸ¥ (1åˆ†)
                if results['accounts']['success'] > 0:
                    score += 1
                else:
                    results['diagnosis']['issues'].append("æ²’æœ‰å¯ç”¨çš„åœ¨ç·šå¸³è™Ÿ")
                    results['diagnosis']['recommendations'].append({
                        "action": "accounts",
                        "text": "å‰å¾€å¸³è™Ÿç®¡ç†é é¢æ·»åŠ ä¸¦ç™»å…¥ Telegram å¸³è™Ÿ"
                    })
                
                # 2. ç›£æ§æª¢æŸ¥ (1åˆ†)
                if results['monitoring']['success']:
                    score += 1
                else:
                    results['diagnosis']['issues'].append("ç›£æ§æœå‹™æœªå•Ÿå‹•")
                    results['diagnosis']['recommendations'].append({
                        "action": "groups",
                        "text": "ç¢ºä¿å·²é…ç½®ç›£æ§ç¾¤çµ„ï¼Œä¸¦æª¢æŸ¥å¸³è™Ÿæ˜¯å¦å·²åŠ å…¥é€™äº›ç¾¤çµ„"
                    })
                
                # 3. AI æª¢æŸ¥ (1åˆ†)
                if results['ai']['success']:
                    score += 1
                
                # 4. æ´»å‹•é…ç½®æª¢æŸ¥ (1åˆ†)
                if results['campaigns']['active'] > 0 and not results['campaigns']['warnings']:
                    score += 1
                elif results['campaigns']['active'] == 0:
                    results['diagnosis']['issues'].append("æ²’æœ‰é…ç½®è§¸ç™¼è¦å‰‡")
                    results['diagnosis']['recommendations'].append({
                        "action": "trigger-rules",
                        "text": "åœ¨ã€Œè§¸ç™¼è¦å‰‡ã€é é¢å‰µå»ºè¦å‰‡ï¼Œè¨­ç½®è§¸ç™¼æ¢ä»¶å’ŒéŸ¿æ‡‰å‹•ä½œ"
                    })
                elif results['campaigns']['warnings']:
                    results['diagnosis']['issues'].append("æ´»å‹•é…ç½®ä¸å®Œæ•´")
                
                # 5. é—œéµè©æª¢æŸ¥ (1åˆ†)
                keyword_sets = await db.get_all_keyword_sets()
                if keyword_sets and any(ks.get('keywords', []) for ks in keyword_sets):
                    score += 1
                else:
                    results['diagnosis']['issues'].append("æ²’æœ‰é…ç½®é—œéµè©")
                    results['diagnosis']['recommendations'].append({
                        "action": "keywords",
                        "text": "åœ¨é—œéµè©ç®¡ç†ä¸­å‰µå»ºé—œéµè©é›†ï¼Œç”¨æ–¼åŒ¹é…ç¾¤çµ„æ¶ˆæ¯"
                    })
                
                results['diagnosis']['readiness_score'] = int((score / max_score) * 100)
                
                # æ ¹æ“šåˆ†æ•¸çµ¦å‡ºç¸½é«”å»ºè­°
                if score == max_score:
                    results['diagnosis']['summary'] = "ç³»çµ±é…ç½®å®Œç¾ï¼æ‰€æœ‰åŠŸèƒ½å·²å°±ç·’ã€‚"
                elif score >= 4:
                    results['diagnosis']['summary'] = "ç³»çµ±åŸºæœ¬å°±ç·’ï¼Œå»ºè­°å®Œå–„å‰©é¤˜é…ç½®ã€‚"
                elif score >= 2:
                    results['diagnosis']['summary'] = "éœ€è¦å®Œæˆæ›´å¤šé…ç½®æ‰èƒ½æ­£å¸¸é‹è¡Œã€‚"
                else:
                    results['diagnosis']['summary'] = "é…ç½®ä¸å®Œæ•´ï¼Œè«‹æŒ‰å»ºè­°æ­¥é©Ÿå®Œæˆé…ç½®ã€‚"
                    
            except Exception as diag_err:
                print(f"[Backend] è¨ºæ–·å ±å‘Šç”ŸæˆéŒ¯èª¤: {diag_err}", file=sys.stderr)
            
            # === å®Œæˆ ===
            results['overall_success'] = (
                results['accounts']['success'] > 0 and
                results['monitoring']['success'] and
                results['ai']['success']
            )
            
            # ğŸ†• è¨ˆç®—ç¸½æ™‚é–“
            total_time = time_module.time() - start_time
            results['timing']['total'] = total_time
            
            # ğŸ†• åœæ­¢æ—¥èªŒæ‰¹é‡æ¨¡å¼ï¼Œåˆ·æ–°æ‰€æœ‰ç·©è¡æ—¥èªŒ
            self.stop_log_batch_mode()
            
            self.send_event("one-click-start-progress", {
                "step": "complete",
                "message": f"ğŸ‰ ä¸€éµå•Ÿå‹•å®Œæˆï¼(ç¸½ç”¨æ™‚ {total_time:.1f} ç§’)" if results['overall_success'] else f"âš ï¸ éƒ¨åˆ†åŠŸèƒ½å•Ÿå‹•å¤±æ•— (ç”¨æ™‚ {total_time:.1f} ç§’)",
                "progress": 100,
                "elapsed_seconds": total_time
            })
            
            self.send_event("one-click-start-result", results)
            
            # ğŸ”§ é—œéµä¿®å¾©ï¼šä¸€éµå•Ÿå‹•å®Œæˆå¾Œç™¼é€ accounts-updated æ›´æ–°å‰ç«¯ç‹€æ…‹
            accounts = await db.get_all_accounts()
            self._cache.pop("accounts", None)
            self._cache_timestamps.pop("accounts", None)
            self.send_event("accounts-updated", accounts)
            
            # ğŸ”§ P0 ä¿®å¾©ï¼šç¢ºä¿ç™¼é€ monitoring-status-changed äº‹ä»¶åŒæ­¥å‰ç«¯ç‹€æ…‹
            self.send_event("monitoring-status-changed", self.is_monitoring)
            print(f"[Backend] Sent monitoring-status-changed: {self.is_monitoring}", file=sys.stderr)
            
            print(f"[Backend] Sent accounts-updated after one-click start completion in {total_time:.1f}s", file=sys.stderr)
            
            summary = f"ä¸€éµå•Ÿå‹•å®Œæˆ ({total_time:.1f}ç§’) - å¸³è™Ÿ: {results['accounts']['success']}/{results['accounts']['total']}, "
            summary += f"ç›£æ§: {'âœ“' if results['monitoring']['success'] else 'âœ—'}, "
            summary += f"AI: {'âœ“' if results['ai']['success'] else 'âœ—'}"
            
            await db.add_log(summary, "success" if results['overall_success'] else "warning")
            self.send_log(summary, "success" if results['overall_success'] else "warning")
            
        except Exception as e:
            print(f"[Backend] ä¸€éµå•Ÿå‹•éŒ¯èª¤: {e}", file=sys.stderr)
            import traceback
            traceback.print_exc(file=sys.stderr)
            
            self.send_event("one-click-start-result", {
                **results,
                'error': str(e),
                'overall_success': False
            })
            self.send_log(f"ä¸€éµå•Ÿå‹•å¤±æ•—: {e}", "error")
    
    async def handle_one_click_stop(self):
        """
        ä¸€éµåœæ­¢ï¼šåœæ­¢ç›£æ§ â†’ é—œé–‰ AI
        """
        import sys
        print(f"[Backend] === ä¸€éµåœæ­¢é–‹å§‹ ===", file=sys.stderr)
        
        try:
            # åœæ­¢é€£æ¥ç›£æ§
            try:
                await connection_monitor.stop()
            except:
                pass
            
            # åœæ­¢ç§ä¿¡è¼ªè©¢
            try:
                await private_message_poller.stop_polling()
            except:
                pass
            
            # åœæ­¢ç›£æ§
            await self.handle_stop_monitoring()
            
            # é—œé–‰ AI è‡ªå‹•èŠå¤©
            await db.update_ai_settings({
                'auto_chat_enabled': 0
            })
            
            self.send_event("ai-settings-updated", {
                'auto_chat_enabled': False
            })
            
            self.send_event("one-click-stop-result", {
                'success': True,
                'message': "æ‰€æœ‰æœå‹™å·²åœæ­¢"
            })
            
            # åœæ­¢æ¼æ–—ç®¡ç†å™¨
            try:
                await auto_funnel.stop()
            except:
                pass
            
            self.send_log("ğŸ›‘ ä¸€éµåœæ­¢å®Œæˆï¼šç›£æ§å·²åœæ­¢ï¼ŒAI å·²é—œé–‰ï¼Œé€£æ¥ç›£æ§å·²åœæ­¢ï¼Œæ¼æ–—ç®¡ç†å·²åœæ­¢", "info")
            
        except Exception as e:
            self.send_log(f"ä¸€éµåœæ­¢éŒ¯èª¤: {e}", "error")
            self.send_event("one-click-stop-result", {
                'success': False,
                'error': str(e)
            })
    
    async def handle_get_system_status(self):
        """
        ç²å–ç³»çµ±ç‹€æ…‹ï¼šå¸³è™Ÿã€ç›£æ§ã€AI ç­‰
        """
        try:
            # ç²å–å¸³è™Ÿç‹€æ…‹
            accounts = await db.get_all_accounts()
            online_count = sum(1 for a in accounts if a.get('status') == 'Online')
            
            # ç²å–é—œéµè©é›†
            keyword_sets = await db.get_all_keyword_sets()
            
            # ç²å–ç¾¤çµ„
            groups = await db.get_all_groups()
            
            # ç²å–æ´»å‹•ï¼ˆèˆŠç‰ˆ Campaignsï¼‰
            campaigns = await db.get_all_campaigns()
            active_campaigns = sum(1 for c in campaigns if c.get('isActive') or c.get('is_active'))
            
            # ç²å–è§¸ç™¼è¦å‰‡ï¼ˆæ–°ç³»çµ±ï¼‰
            trigger_rules = await db.get_all_trigger_rules()
            active_rules = sum(1 for r in trigger_rules if r.get('is_active') or r.get('isActive'))
            
            # åˆä½µï¼šç¸½æ•¸ = campaigns + trigger_rules
            total_rules = len(campaigns) + len(trigger_rules)
            active_total = active_campaigns + active_rules
            
            # ç²å– AI è¨­ç½®
            ai_settings = await db.get_ai_settings()
            ai_enabled = ai_settings.get('auto_chat_enabled', 0) == 1 if ai_settings else False
            ai_mode = ai_settings.get('auto_chat_mode', 'semi') if ai_settings else 'semi'
            
            # ç²å–æ¨¡æ¿
            templates = await db.get_all_templates()
            active_templates = sum(1 for t in templates if t.get('isActive'))
            
            status = {
                'accounts': {
                    'total': len(accounts),
                    'online': online_count,
                    'offline': len(accounts) - online_count
                },
                'monitoring': {
                    'active': self.is_monitoring,
                    'groups': len(groups)
                },
                'ai': {
                    'enabled': ai_enabled,
                    'mode': ai_mode,
                    'endpoint': ai_settings.get('local_ai_endpoint', '') if ai_settings else ''
                },
                'keywords': {
                    'sets': len(keyword_sets),
                    'total': sum(len(ks.get('keywords', [])) for ks in keyword_sets)
                },
                'campaigns': {
                    'total': total_rules,  # åŒ…å« Campaigns + è§¸ç™¼è¦å‰‡
                    'active': active_total   # åŒ…å«æ´»èºçš„ Campaigns + è§¸ç™¼è¦å‰‡
                },
                'triggerRules': {
                    'total': len(trigger_rules),
                    'active': active_rules
                },
                'templates': {
                    'total': len(templates),
                    'active': active_templates
                },
                'poller': {
                    'running': private_message_poller._running if hasattr(private_message_poller, '_running') else False
                }
            }
            
            self.send_event("system-status", status)
            
        except Exception as e:
            import sys
            print(f"[Backend] ç²å–ç³»çµ±ç‹€æ…‹éŒ¯èª¤: {e}", file=sys.stderr)
            self.send_event("system-status", {'error': str(e)})
    
    # ==================== çŸ¥è­˜å­¸ç¿’åŠŸèƒ½ ====================
    
    async def handle_learn_from_history(self, payload: Dict[str, Any]):
        """å¾æ­·å²å°è©±ä¸­å­¸ç¿’çŸ¥è­˜"""
        try:
            from knowledge_learner import knowledge_learner
            
            # åˆå§‹åŒ– - ğŸ”§ Phase 1 å„ªåŒ–ï¼šé»˜èªç¦ç”¨ç¥ç¶“ç¶²çµ¡åµŒå…¥
            await knowledge_learner.initialize(use_neural=False)
            
            user_id = payload.get('user_id')
            limit = payload.get('limit', 100)
            
            self.send_log("ğŸ“ é–‹å§‹å¾æ­·å²å°è©±å­¸ç¿’çŸ¥è­˜...", "info")
            
            total_learned = 0
            
            if user_id:
                # å­¸ç¿’ç‰¹å®šç”¨æˆ¶çš„å°è©±
                cursor = await db._connection.execute("""
                    SELECT role, content, timestamp 
                    FROM chat_history 
                    WHERE user_id = ? 
                    ORDER BY timestamp ASC
                """, (user_id,))
                rows = await cursor.fetchall()
                
                if rows:
                    messages = [{'role': r['role'], 'content': r['content']} for r in rows]
                    profile = await db.get_user_profile(user_id)
                    outcome = profile.get('funnel_stage', 'new') if profile else 'new'
                    
                    result = await knowledge_learner.learn_from_conversation(
                        user_id=user_id,
                        messages=messages,
                        outcome=outcome
                    )
                    total_learned = result.get('total_knowledge', 0)
            else:
                # å­¸ç¿’æ‰€æœ‰æˆåŠŸå°è©±
                cursor = await db._connection.execute("""
                    SELECT DISTINCT user_id, funnel_stage 
                    FROM user_profiles 
                    WHERE funnel_stage IN ('converted', 'interested', 'negotiating')
                    LIMIT ?
                """, (limit,))
                users = await cursor.fetchall()
                
                for user in users:
                    uid = user['user_id']
                    outcome = user['funnel_stage']
                    
                    # ç²å–å°è©±æ­·å²
                    msg_cursor = await db._connection.execute("""
                        SELECT role, content, timestamp 
                        FROM chat_history 
                        WHERE user_id = ? 
                        ORDER BY timestamp ASC
                        LIMIT 50
                    """, (uid,))
                    rows = await msg_cursor.fetchall()
                    
                    if rows:
                        messages = [{'role': r['role'], 'content': r['content']} for r in rows]
                        result = await knowledge_learner.learn_from_conversation(
                            user_id=uid,
                            messages=messages,
                            outcome=outcome
                        )
                        total_learned += result.get('total_knowledge', 0)
            
            self.send_log(f"âœ“ å­¸ç¿’å®Œæˆï¼Œå…±æå– {total_learned} æ¢çŸ¥è­˜", "success")
            self.send_event("learn-from-history-result", {
                'success': True,
                'total_learned': total_learned
            })
            
        except Exception as e:
            self.send_log(f"å­¸ç¿’å¤±æ•—: {e}", "error")
            self.send_event("learn-from-history-result", {
                'success': False,
                'error': str(e)
            })
    
    async def handle_get_knowledge_stats(self):
        """ç²å–çŸ¥è­˜åº«çµ±è¨ˆ"""
        try:
            from knowledge_learner import knowledge_learner
            await knowledge_learner.initialize(use_neural=False)
            
            stats = await knowledge_learner.get_statistics()
            self.send_event("knowledge-stats", stats)
            
        except Exception as e:
            self.send_event("knowledge-stats", {'error': str(e)})
    
    async def handle_search_knowledge(self, payload: Dict[str, Any]):
        """æœç´¢çŸ¥è­˜åº«"""
        try:
            from knowledge_learner import knowledge_learner
            await knowledge_learner.initialize(use_neural=False)
            
            query = payload.get('query', '')
            limit = payload.get('limit', 5)
            
            results = await knowledge_learner.search_knowledge(query, limit)
            
            self.send_event("knowledge-search-result", {
                'success': True,
                'query': query,
                'results': results
            })
            
        except Exception as e:
            self.send_event("knowledge-search-result", {
                'success': False,
                'error': str(e)
            })
    
    async def _handle_ai_auto_greeting(self, lead_data: Dict[str, Any], lead_id: int):
        """Handle AI auto greeting for new leads based on settings"""
        import sys
        print(f"[Backend] _handle_ai_auto_greeting called for lead_id={lead_id}, user={lead_data.get('username')}", file=sys.stderr)
        self.send_log(f"[AI] é–‹å§‹è™•ç†è‡ªå‹•å•å€™ (Lead ID: {lead_id}, User: @{lead_data.get('username')})", "info")
        
        try:
            # Get AI settings
            settings = await db.get_ai_settings()
            print(f"[Backend] AI settings loaded: {settings}", file=sys.stderr)
            
            if not settings:
                self.send_log("[AI] AI è¨­ç½®æœªé…ç½®ï¼Œè·³éè‡ªå‹•å•å€™", "warning")
                return
            
            # ä½¿ç”¨æ­£ç¢ºçš„æ•¸æ“šåº«å­—æ®µåç¨± (æ•´æ•¸ 0/1)
            enabled = settings.get('auto_chat_enabled', 0) == 1
            auto_greeting = settings.get('auto_greeting', 0) == 1
            mode = settings.get('auto_chat_mode', 'semi')
            
            self.send_log(f"[AI] è¨­ç½®æª¢æŸ¥ - å•Ÿç”¨: {enabled}, è‡ªå‹•å•å€™: {auto_greeting}, æ¨¡å¼: {mode}", "info")
            
            if not enabled:
                self.send_log("[AI] AI è‡ªå‹•èŠå¤©æœªå•Ÿç”¨ï¼Œè·³éè‡ªå‹•å•å€™", "info")
                return
            
            if not auto_greeting:
                self.send_log("[AI] è‡ªå‹•å•å€™æœªå•Ÿç”¨ï¼Œè·³éè‡ªå‹•å•å€™", "info")
                return
            
            user_id = str(lead_data.get('user_id', ''))
            username = lead_data.get('username', '')
            first_name = lead_data.get('first_name', '')
            source_group = lead_data.get('source_group_url') or lead_data.get('source_group', '')
            
            # ä½¿ç”¨å¸³è™Ÿè¼ªæ›å™¨è‡ªå‹•é¸æ“‡ç™¼é€å¸³è™Ÿ
            sender_phone = ''
            if self.message_queue.account_rotator:
                selected_account = await self.message_queue.account_rotator.select_account()
                if selected_account:
                    sender_phone = selected_account.get('phone', '')
                    self.send_log(f"[AI] å¸³è™Ÿè¼ªæ›é¸æ“‡: {sender_phone} (è² è¼‰å‡è¡¡)", "info")
            
            # å›é€€åˆ°èˆŠé‚è¼¯ï¼ˆå¦‚æœè¼ªæ›å™¨æœªåˆå§‹åŒ–æˆ–ç„¡å¯ç”¨å¸³è™Ÿï¼‰
            if not sender_phone:
                accounts = await db.get_all_accounts()
                
                # First try to find an online sender account
                for acc in accounts:
                    role = str(acc.get('role', '')).lower()
                    status = str(acc.get('status', '')).lower()
                    if role == 'sender' and status == 'online':
                        sender_phone = acc.get('phone', '')
                        self.send_log(f"[AI] æ‰¾åˆ°ç™¼é€å¸³è™Ÿ: {sender_phone}", "info")
                        break
                
                # If no sender, use any online account
                if not sender_phone:
                    for acc in accounts:
                        status = str(acc.get('status', '')).lower()
                        if status == 'online':
                            sender_phone = acc.get('phone', '')
                            self.send_log(f"[AI] ä½¿ç”¨åœ¨ç·šå¸³è™Ÿ: {sender_phone}", "info")
                            break
                
                # Fallback to the monitoring account
                if not sender_phone:
                    sender_phone = lead_data.get('account_phone', '')
            
            if not sender_phone:
                self.send_log("[AI] æ²’æœ‰å¯ç”¨çš„ç™¼é€å¸³è™Ÿï¼Œè·³éè‡ªå‹•å•å€™", "warning")
                return
            
            self.send_log(f"[AI] æº–å‚™ç™¼é€å•å€™çµ¦ @{username or first_name}ï¼Œä½¿ç”¨å¸³è™Ÿ: {sender_phone}", "info")
            
            # Generate greeting using AI (å‚³éè§¸ç™¼é—œéµè©ç”¨æ–¼å€‹æ€§åŒ–å•å€™)
            triggered_keyword = lead_data.get('triggered_keyword', '')
            greeting = await ai_auto_chat.handle_auto_greeting(
                user_id=user_id,
                username=username,
                account_phone=sender_phone,
                source_group=source_group,
                first_name=first_name,
                triggered_keyword=triggered_keyword
            )
            
            if not greeting:
                self.send_log(f"[AI] æœªèƒ½ç”Ÿæˆå•å€™æ¶ˆæ¯", "warning")
                return
            
            self.send_log(f"[AI] ç”Ÿæˆå•å€™: {greeting[:50]}...", "info")
            
            if mode == 'full':
                # Full auto mode: Send immediately using self.message_queue
                from message_queue import MessagePriority
                
                # ğŸ”§ FIX: æ·»åŠ  source_group å’Œ target_username åƒæ•¸ï¼Œè§£æ±º PEER_ID_INVALID å•é¡Œ
                message_id = await self.message_queue.add_message(
                    phone=sender_phone,
                    user_id=user_id,
                    text=greeting,
                    source_group=source_group,  # ğŸ†• ä¾†æºç¾¤çµ„ï¼Œç”¨æ–¼è§£æç”¨æˆ¶
                    target_username=username,   # ğŸ†• ç”¨æˆ¶åä½œç‚ºå‚™é¸
                    priority=MessagePriority.HIGH  # High priority for greeting
                )
                
                self.send_log(f"[AI] âœ“ å·²è‡ªå‹•ç™¼é€å•å€™çµ¦ @{username or first_name} (æ¶ˆæ¯ID: {message_id}, ç¾¤çµ„: {source_group})", "success")
                await db.add_interaction(lead_id, 'AI Auto Greeting', greeting)
                
                # Update lead status to "å·²è¯ç¹«"
                await db.update_lead(lead_id, {'status': 'Contacted'})
                self.send_event("leads-updated", await db.get_all_leads())
                
            elif mode == 'semi':
                # Semi-auto mode: Send to frontend for confirmation
                self.send_event("ai-greeting-suggestion", {
                    "leadId": lead_id,
                    "userId": user_id,
                    "username": username,
                    "firstName": first_name,
                    "sourceGroup": source_group,
                    "suggestedGreeting": greeting,
                    "accountPhone": sender_phone
                })
                self.send_log(f"[AI] å·²ç”Ÿæˆå•å€™å»ºè­°çµ¦ @{username or first_name}ï¼Œç­‰å¾…ç¢ºèª", "info")
            
        except Exception as e:
            import traceback
            import sys
            error_details = traceback.format_exc()
            error_msg = f"[AI] Error in auto greeting: {e}\n{error_details}"
            print(error_msg, file=sys.stderr)
            self.send_log(f"AI è‡ªå‹•å•å€™å‡ºéŒ¯: {str(e)}", "error")
            await db.add_log(f"AI auto greeting error: {str(e)}", "error")
    
    async def execute_matching_campaigns(self, lead_id: int, lead_data: Dict[str, Any]):
        """Execute campaigns that match the captured lead"""
        try:
            # Get all active campaigns
            campaigns = await db.get_all_campaigns()
            # æ”¯æŒå…©ç¨®å­—æ®µåï¼šisActive (å‰ç«¯æ ¼å¼) å’Œ is_active (æ•¸æ“šåº«æ ¼å¼)
            active_campaigns = [c for c in campaigns if c.get('isActive') or c.get('is_active')]
            
            if not active_campaigns:
                self.send_log(f"[æ´»å‹•] æ²’æœ‰å•Ÿç”¨çš„æ´»å‹•ï¼Œè·³éåŸ·è¡Œã€‚é—œéµè©: {lead_data.get('triggered_keyword')}", "info")
                return
            
            self.send_log(f"[æ´»å‹•] æª¢æŸ¥ {len(active_campaigns)} å€‹å•Ÿç”¨çš„æ´»å‹•ï¼Œé—œéµè©: {lead_data.get('triggered_keyword')}", "info")
            
            # Get lead details
            lead = await db.get_lead(lead_id)
            if not lead:
                return
            
            source_group_id = None
            # Find source group ID from URL (prefer source_group_url, fallback to source_group)
            monitored_groups = await db.get_all_monitored_groups()
            group_url_to_match = lead_data.get('source_group_url') or lead_data.get('source_group')
            
            for group in monitored_groups:
                # Try matching by URL first
                if group_url_to_match and str(group.get('url')) == str(group_url_to_match):
                    source_group_id = group.get('id')
                    self.send_log(f"æ‰¾åˆ°åŒ¹é…çš„ç¾¤çµ„: {group.get('url')} (ID: {source_group_id})", "info")
                    break
            
            if not source_group_id:
                self.send_log(f"è­¦å‘Š: ç„¡æ³•æ‰¾åˆ°åŒ¹é…çš„ç¾¤çµ„ï¼ŒURL: {group_url_to_match}", "warning")
            
            # Get keyword set IDs that matched
            keyword_set_ids = []
            keyword_sets = await db.get_all_keyword_sets()
            triggered_keyword = lead_data.get('triggered_keyword', '')
            
            self.send_log(f"[æ´»å‹•] æŸ¥æ‰¾åŒ¹é…çš„é—œéµè©é›†ï¼Œè§¸ç™¼é—œéµè©: '{triggered_keyword}'", "info")
            
            for ks in keyword_sets:
                for keyword in ks.get('keywords', []):
                    keyword_text = keyword.get('keyword', '')
                    is_regex = keyword.get('isRegex', False)
                    
                    # æª¢æŸ¥åŒ¹é…ï¼ˆæ”¯æŒæ­£å‰‡ï¼‰
                    matched = False
                    if is_regex:
                        try:
                            import re
                            pattern = re.compile(keyword_text, re.IGNORECASE)
                            matched = bool(pattern.search(triggered_keyword))
                        except:
                            matched = keyword_text.lower() in triggered_keyword.lower()
                    else:
                        matched = keyword_text.lower() in triggered_keyword.lower()
                    
                    if matched:
                        keyword_set_ids.append(ks.get('id'))
                        self.send_log(f"[æ´»å‹•] é—œéµè© '{keyword_text}' åŒ¹é…ï¼Œé—œéµè©é›†ID: {ks.get('id')}", "info")
                        break
            
            # Check each campaign
            for campaign in active_campaigns:
                trigger = campaign.get('trigger', {})
                source_group_ids = trigger.get('sourceGroupIds', [])
                campaign_keyword_set_ids = trigger.get('keywordSetIds', [])
                
                # è©³ç´°æ—¥èªŒ
                self.send_log(f"[æ´»å‹•æª¢æŸ¥] æ´»å‹•: {campaign.get('name')}, ä¾†æºç¾¤çµ„IDs: {source_group_ids}, é—œéµè©é›†IDs: {campaign_keyword_set_ids}", "info")
                self.send_log(f"[æ´»å‹•æª¢æŸ¥] Leadä¾†æºç¾¤çµ„ID: {source_group_id}, Leadé—œéµè©é›†IDs: {keyword_set_ids}", "info")
                
                # Check if campaign matches
                # If no source groups specified, match all groups
                matches_source = not source_group_ids or (source_group_id and source_group_id in source_group_ids)
                # If no keyword sets specified, match all keywords
                matches_keyword = not campaign_keyword_set_ids or any(ks_id in campaign_keyword_set_ids for ks_id in keyword_set_ids)
                
                self.send_log(f"[æ´»å‹•æª¢æŸ¥] åŒ¹é…çµæœ: ä¾†æºç¾¤çµ„={matches_source}, é—œéµè©={matches_keyword}", "info")
                
                if matches_source and matches_keyword:
                    self.send_log(f"âœ“âœ“âœ“ æ´»å‹•åŒ¹é…æˆåŠŸ: {campaign.get('name')}ï¼Œé–‹å§‹åŸ·è¡Œ", "success")
                    # Execute campaign
                    await self.execute_campaign(campaign, lead_id, lead_data)
                else:
                    self.send_log(f"âœ— æ´»å‹•ä¸åŒ¹é…: {campaign.get('name')} (ä¾†æºç¾¤çµ„: {matches_source}, é—œéµè©: {matches_keyword})", "info")
        
        except Exception as e:
            self.send_log(f"Error executing matching campaigns: {str(e)}", "error")
    
    async def execute_campaign(self, campaign: Dict[str, Any], lead_id: int, lead_data: Dict[str, Any]):
        """Execute a single campaign for a lead"""
        try:
            import random
            
            # Get action from campaign (actions is a list)
            actions = campaign.get('actions', [])
            if actions and len(actions) > 0:
                action = actions[0]
            else:
                # Fallback to direct campaign fields (for backward compatibility)
                action = {
                    'templateId': campaign.get('actionTemplateId'),
                    'minDelaySeconds': campaign.get('actionMinDelaySeconds', 30),
                    'maxDelaySeconds': campaign.get('actionMaxDelaySeconds', 120)
                }
            
            template_id = action.get('templateId')
            
            if not template_id:
                self.send_log(f"Campaign {campaign.get('name')} has no template", "warning")
                return
            
            # Get template
            templates = await db.get_all_templates()
            template = next((t for t in templates if t.get('id') == template_id), None)
            
            if not template or not template.get('isActive'):
                self.send_log(f"æ¨¡æ¿ ID {template_id} ä¸å­˜åœ¨æˆ–æœªæ¿€æ´»ã€‚è¯·æ£€æŸ¥æ¨¡æ¿è®¾ç½®ã€‚", "warning")
                return
            
            # Generate message from template
            message = await self.generate_message_from_template(template, lead_data)
            
            if not message:
                self.send_log(f"Failed to generate message for campaign {campaign.get('name')}", "error")
                return
            
            # Calculate delay
            min_delay = action.get('minDelaySeconds', 30)
            max_delay = action.get('maxDelaySeconds', 120)
            delay = random.randint(min_delay, max_delay)
            
            # Schedule message sending using queue
            scheduled_time = datetime.now() + timedelta(seconds=delay)
            
            # Get sender accounts
            accounts = await db.get_all_accounts()
            sender_accounts = [a for a in accounts if a.get('role') == 'Sender' and a.get('status') == 'Online']
            
            if not sender_accounts:
                self.send_log(f"No online sender accounts available for campaign '{campaign.get('name')}'", "warning")
                await db.add_interaction(lead_id, 'Campaign Failed', "No online sender accounts available")
                return
            
            # Select account (round-robin or random)
            selected_account = random.choice(sender_accounts)
            
            # Add to message queue with scheduled time
            try:
                # ğŸ”§ FIX: ç²å– source_group å’Œ usernameï¼Œè§£æ±º PEER_ID_INVALID å•é¡Œ
                source_group = lead_data.get('source_group_url') or lead_data.get('source_group', '')
                target_username = lead_data.get('username', '')
                
                message_id = await self.message_queue.add_message(
                    phone=selected_account.get('phone'),
                    user_id=str(lead_data.get('user_id')),
                    text=message,
                    source_group=source_group,      # ğŸ†• ä¾†æºç¾¤çµ„
                    target_username=target_username, # ğŸ†• ç”¨æˆ¶åå‚™é¸
                    priority=MessagePriority.NORMAL,
                    scheduled_at=scheduled_time,
                    callback=self._on_message_sent_callback(lead_id)
                )
                
                # Update lead with campaign
                await db.update_lead(lead_id, {'campaignId': campaign.get('id')})
                await db.add_interaction(lead_id, 'Campaign Triggered', f"Campaign '{campaign.get('name')}' triggered, message queued (ID: {message_id})")
                
                self.send_log(f"Campaign '{campaign.get('name')}' triggered for lead {lead_id}, message queued (ID: {message_id}, group: {source_group})", "info")
            except Exception as e:
                self.send_log(f"Error queueing campaign message: {str(e)}", "error")
                await db.add_interaction(lead_id, 'Campaign Failed', f"Failed to queue message: {str(e)}")
        
        except Exception as e:
            self.send_log(f"Error executing campaign: {str(e)}", "error")
    
    # ============== è§¸ç™¼è¦å‰‡åŸ·è¡Œå¼•æ“ ==============
    
    async def execute_matching_trigger_rules(self, lead_id: int, lead_data: Dict[str, Any]):
        """åŸ·è¡ŒåŒ¹é…çš„è§¸ç™¼è¦å‰‡"""
        try:
            import sys
            print(f"[TriggerRules] ========== é–‹å§‹æª¢æŸ¥è§¸ç™¼è¦å‰‡ ==========", file=sys.stderr)
            
            # ç²å–æ‰€æœ‰å•Ÿç”¨çš„è§¸ç™¼è¦å‰‡
            rules = await db.get_active_trigger_rules()
            
            if not rules:
                self.send_log(f"[è§¸ç™¼è¦å‰‡] æ²’æœ‰å•Ÿç”¨çš„è§¸ç™¼è¦å‰‡", "info")
                return
            
            self.send_log(f"[è§¸ç™¼è¦å‰‡] æª¢æŸ¥ {len(rules)} å€‹è§¸ç™¼è¦å‰‡", "info")
            
            # ç²å–ä¾†æºç¾¤çµ„ ID
            monitored_groups = await db.get_all_monitored_groups()
            group_url_to_match = lead_data.get('source_group_url') or lead_data.get('source_group')
            source_group_id = None
            
            for group in monitored_groups:
                if group_url_to_match and str(group.get('url')) == str(group_url_to_match):
                    source_group_id = group.get('id')
                    break
            
            # ç²å–åŒ¹é…çš„é—œéµè©é›† ID
            keyword_sets = await db.get_all_keyword_sets()
            triggered_keyword = lead_data.get('triggered_keyword', '')
            matched_keyword_set_ids = []
            
            for ks in keyword_sets:
                for keyword in ks.get('keywords', []):
                    keyword_text = keyword.get('keyword', '')
                    is_regex = keyword.get('isRegex', False)
                    
                    matched = False
                    if is_regex:
                        try:
                            import re
                            pattern = re.compile(keyword_text, re.IGNORECASE)
                            matched = bool(pattern.search(triggered_keyword))
                        except:
                            matched = keyword_text.lower() in triggered_keyword.lower()
                    else:
                        matched = keyword_text.lower() in triggered_keyword.lower()
                    
                    if matched:
                        matched_keyword_set_ids.append(ks.get('id'))
                        break
            
            print(f"[TriggerRules] ä¾†æºç¾¤çµ„ID: {source_group_id}, åŒ¹é…çš„é—œéµè©é›†IDs: {matched_keyword_set_ids}", file=sys.stderr)
            
            # æŒ‰å„ªå…ˆç´šæ’åºï¼ˆå„ªå…ˆç´šé«˜çš„å…ˆåŸ·è¡Œï¼‰
            rules.sort(key=lambda r: r.get('priority', 2), reverse=True)
            
            # æª¢æŸ¥æ¯å€‹è¦å‰‡
            executed_rule = None
            for rule in rules:
                rule_name = rule.get('name', 'æœªå‘½åè¦å‰‡')
                rule_id = rule.get('id')
                
                # ç²å–è¦å‰‡é…ç½®
                source_type = rule.get('source_type', 'all')
                source_group_ids = rule.get('source_group_ids', [])
                keyword_set_ids = rule.get('keyword_set_ids', [])
                
                # æª¢æŸ¥ä¾†æºç¾¤çµ„åŒ¹é…
                matches_source = True
                if source_type == 'specific' and source_group_ids:
                    matches_source = source_group_id in source_group_ids
                
                # æª¢æŸ¥é—œéµè©é›†åŒ¹é…ï¼ˆå¿…é ˆæœ‰åŒ¹é…ï¼‰
                matches_keyword = any(ks_id in keyword_set_ids for ks_id in matched_keyword_set_ids)
                
                self.send_log(f"[è§¸ç™¼è¦å‰‡] æª¢æŸ¥ '{rule_name}': ä¾†æº={matches_source}, é—œéµè©={matches_keyword}", "info")
                
                if matches_source and matches_keyword:
                    # æª¢æŸ¥é¡å¤–æ¢ä»¶
                    conditions = rule.get('conditions', {})
                    conditions_met = await self._check_trigger_conditions(conditions, lead_data)
                    
                    if conditions_met:
                        self.send_log(f"âœ“âœ“âœ“ è§¸ç™¼è¦å‰‡åŒ¹é…æˆåŠŸ: {rule_name}ï¼Œé–‹å§‹åŸ·è¡Œ", "success")
                        await self.execute_trigger_rule(rule, lead_id, lead_data)
                        executed_rule = rule
                        # åªåŸ·è¡Œç¬¬ä¸€å€‹åŒ¹é…çš„è¦å‰‡ï¼ˆå„ªå…ˆç´šæœ€é«˜çš„ï¼‰
                        break
                    else:
                        self.send_log(f"[è§¸ç™¼è¦å‰‡] '{rule_name}' æ¢ä»¶æœªæ»¿è¶³ï¼Œè·³é", "info")
            
            if not executed_rule:
                self.send_log(f"[è§¸ç™¼è¦å‰‡] æ²’æœ‰åŒ¹é…çš„è§¸ç™¼è¦å‰‡", "info")
            
            print(f"[TriggerRules] ========== è§¸ç™¼è¦å‰‡æª¢æŸ¥å®Œæˆ ==========", file=sys.stderr)
            
        except Exception as e:
            import traceback
            error_details = traceback.format_exc()
            print(f"[TriggerRules] Error: {e}\n{error_details}", file=sys.stderr)
            self.send_log(f"åŸ·è¡Œè§¸ç™¼è¦å‰‡å‡ºéŒ¯: {str(e)}", "error")
    
    async def _check_trigger_conditions(self, conditions: Dict, lead_data: Dict) -> bool:
        """æª¢æŸ¥è§¸ç™¼æ¢ä»¶æ˜¯å¦æ»¿è¶³"""
        try:
            # å¦‚æœæ²’æœ‰é¡å¤–æ¢ä»¶ï¼Œé»˜èªæ»¿è¶³
            if not conditions:
                return True
            
            # æª¢æŸ¥æ™‚é–“ç¯„åœ
            time_range = conditions.get('timeRange')
            if time_range and time_range.get('enabled'):
                from datetime import datetime
                now = datetime.now()
                current_hour = now.hour
                start_hour = time_range.get('start', 0)
                end_hour = time_range.get('end', 24)
                
                if not (start_hour <= current_hour < end_hour):
                    self.send_log(f"[æ¢ä»¶æª¢æŸ¥] ä¸åœ¨å·¥ä½œæ™‚é–“ç¯„åœå…§ ({start_hour}:00 - {end_hour}:00)", "info")
                    return False
            
            # æª¢æŸ¥æ˜¯å¦åªé‡å°æ–°æˆå“¡
            if conditions.get('newMemberOnly'):
                # æª¢æŸ¥ç”¨æˆ¶æ˜¯å¦æ˜¯æ–°æˆå“¡ï¼ˆé€™è£¡ç°¡åŒ–ç‚ºæª¢æŸ¥æ˜¯å¦æ˜¯æ–° Leadï¼‰
                user_id = lead_data.get('user_id')
                existing_lead, _ = await db.check_lead_and_dnc(user_id)
                if existing_lead:
                    self.send_log(f"[æ¢ä»¶æª¢æŸ¥] ç”¨æˆ¶å·²å­˜åœ¨ï¼Œä¸æ˜¯æ–°æˆå“¡", "info")
                    return False
            
            # æª¢æŸ¥æ˜¯å¦æ’é™¤ç®¡ç†å“¡
            if conditions.get('excludeAdmin'):
                # é€™è£¡éœ€è¦å¾æ¶ˆæ¯ä¸­ç²å–ç”¨æˆ¶æ˜¯å¦æ˜¯ç®¡ç†å“¡çš„ä¿¡æ¯
                # ç°¡åŒ–è™•ç†ï¼Œæš«æ™‚è·³é
                pass
            
            # æª¢æŸ¥æ¯ç”¨æˆ¶åªè§¸ç™¼ä¸€æ¬¡
            if conditions.get('oncePerUser'):
                user_id = lead_data.get('user_id')
                existing_lead, _ = await db.check_lead_and_dnc(user_id)
                if existing_lead and existing_lead.get('status') != 'New':
                    self.send_log(f"[æ¢ä»¶æª¢æŸ¥] ç”¨æˆ¶å·²è¢«è¯ç¹«éï¼Œæ¯ç”¨æˆ¶åªè§¸ç™¼ä¸€æ¬¡", "info")
                    return False
            
            return True
            
        except Exception as e:
            self.send_log(f"æª¢æŸ¥è§¸ç™¼æ¢ä»¶å‡ºéŒ¯: {str(e)}", "error")
            return True  # å‡ºéŒ¯æ™‚é»˜èªæ»¿è¶³æ¢ä»¶
    
    async def execute_trigger_rule(self, rule: Dict, lead_id: int, lead_data: Dict):
        """åŸ·è¡Œå–®å€‹è§¸ç™¼è¦å‰‡"""
        import sys
        import random
        
        rule_id = rule.get('id')
        rule_name = rule.get('name', 'æœªå‘½åè¦å‰‡')
        response_type = rule.get('response_type', 'ai_chat')
        response_config = rule.get('response_config', {})
        
        print(f"[TriggerRules] åŸ·è¡Œè¦å‰‡: {rule_name} (ID: {rule_id}), éŸ¿æ‡‰é¡å‹: {response_type}", file=sys.stderr)
        self.send_log(f"[è§¸ç™¼è¦å‰‡] åŸ·è¡Œè¦å‰‡: {rule_name}, éŸ¿æ‡‰é¡å‹: {response_type}", "info")
        
        success = False
        
        try:
            # æ ¹æ“šéŸ¿æ‡‰é¡å‹åŸ·è¡Œä¸åŒçš„æ“ä½œ
            if response_type == 'ai_chat':
                # AI æ™ºèƒ½å°è©±
                success = await self._execute_ai_chat_response(rule, lead_id, lead_data)
                
            elif response_type == 'template':
                # å›ºå®šæ¨¡æ¿
                success = await self._execute_template_response(rule, lead_id, lead_data)
                
            elif response_type == 'script':
                # åŸ·è¡Œè…³æœ¬
                success = await self._execute_script_response(rule, lead_id, lead_data)
                
            elif response_type == 'record_only':
                # åƒ…è¨˜éŒ„
                success = await self._execute_record_only_response(rule, lead_id, lead_data)
            
            else:
                self.send_log(f"[è§¸ç™¼è¦å‰‡] æœªçŸ¥çš„éŸ¿æ‡‰é¡å‹: {response_type}", "warning")
                success = False
            
            # æ›´æ–°è¦å‰‡çµ±è¨ˆ
            await db.increment_trigger_rule_stats(rule_id, success)
            
            # åŸ·è¡Œé¡å¤–æ“ä½œ
            await self._execute_additional_actions(rule, lead_id, lead_data)
            
            # ç™¼é€åŸ·è¡Œçµæœäº‹ä»¶
            self.send_event("trigger-rule-executed", {
                "ruleId": rule_id,
                "ruleName": rule_name,
                "leadId": lead_id,
                "success": success,
                "responseType": response_type
            })
            
        except Exception as e:
            import traceback
            error_details = traceback.format_exc()
            print(f"[TriggerRules] åŸ·è¡Œè¦å‰‡å¤±æ•—: {e}\n{error_details}", file=sys.stderr)
            self.send_log(f"[è§¸ç™¼è¦å‰‡] åŸ·è¡Œå¤±æ•—: {str(e)}", "error")
            await db.increment_trigger_rule_stats(rule_id, False)
    
    async def _execute_ai_chat_response(self, rule: Dict, lead_id: int, lead_data: Dict) -> bool:
        """åŸ·è¡Œ AI å°è©±éŸ¿æ‡‰"""
        try:
            import sys
            
            response_config = rule.get('response_config', {})
            ai_mode = response_config.get('aiMode', 'global')  # global æˆ– semi
            
            self.send_log(f"[è§¸ç™¼è¦å‰‡] ä½¿ç”¨ AI å°è©±æ¨¡å¼: {ai_mode}", "info")
            
            # ç²å– AI è¨­ç½®
            settings = await db.get_ai_settings()
            if not settings:
                self.send_log("[è§¸ç™¼è¦å‰‡] AI è¨­ç½®æœªé…ç½®", "warning")
                return False
            
            # èª¿ç”¨ AI è‡ªå‹•å•å€™
            await self._handle_ai_auto_greeting(lead_data, lead_id)
            return True
            
        except Exception as e:
            self.send_log(f"[è§¸ç™¼è¦å‰‡] AI å°è©±éŸ¿æ‡‰å¤±æ•—: {str(e)}", "error")
            return False
    
    async def _execute_template_response(self, rule: Dict, lead_id: int, lead_data: Dict) -> bool:
        """åŸ·è¡Œæ¨¡æ¿éŸ¿æ‡‰"""
        try:
            import random
            
            response_config = rule.get('response_config', {})
            template_id = response_config.get('templateId')
            
            if not template_id:
                self.send_log("[è§¸ç™¼è¦å‰‡] æœªé…ç½®æ¨¡æ¿ ID", "warning")
                return False
            
            # ç²å–æ¨¡æ¿
            templates = await db.get_all_templates()
            template = next((t for t in templates if t.get('id') == template_id), None)
            
            if not template:
                self.send_log(f"[è§¸ç™¼è¦å‰‡] æ¨¡æ¿ ID {template_id} ä¸å­˜åœ¨", "warning")
                return False
            
            # ç”Ÿæˆæ¶ˆæ¯
            # æ”¯æŒ content å­—æ®µï¼ˆchat_templates è¡¨ï¼‰å’Œ prompt å­—æ®µï¼ˆèˆŠæ ¼å¼ï¼‰
            message_content = template.get('content') or template.get('prompt', '')
            
            # è®Šé‡æ›¿æ›
            message = await self.generate_message_from_template({'prompt': message_content}, lead_data)
            
            if not message:
                self.send_log("[è§¸ç™¼è¦å‰‡] ç”Ÿæˆæ¶ˆæ¯å¤±æ•—", "error")
                return False
            
            # è¨ˆç®—å»¶é²
            delay_min = rule.get('delay_min', 30)
            delay_max = rule.get('delay_max', 120)
            delay = random.randint(delay_min, delay_max)
            
            # ç²å–ç™¼é€å¸³è™Ÿ
            sender_phone = await self._get_sender_account_for_rule(rule)
            if not sender_phone:
                self.send_log("[è§¸ç™¼è¦å‰‡] æ²’æœ‰å¯ç”¨çš„ç™¼é€å¸³è™Ÿ", "warning")
                return False
            
            # åŠ å…¥æ¶ˆæ¯éšŠåˆ—
            scheduled_time = datetime.now() + timedelta(seconds=delay)
            
            # ğŸ”§ FIX: ç²å– source_group å’Œ usernameï¼Œè§£æ±º PEER_ID_INVALID å•é¡Œ
            source_group = lead_data.get('source_group_url') or lead_data.get('source_group', '')
            target_username = lead_data.get('username', '')
            
            message_id = await self.message_queue.add_message(
                phone=sender_phone,
                user_id=str(lead_data.get('user_id')),
                text=message,
                source_group=source_group,      # ğŸ†• ä¾†æºç¾¤çµ„
                target_username=target_username, # ğŸ†• ç”¨æˆ¶åå‚™é¸
                priority=MessagePriority.NORMAL,
                scheduled_at=scheduled_time,
                callback=self._on_message_sent_callback(lead_id)
            )
            
            template_name = template.get('name', 'æœªå‘½åæ¨¡æ¿')
            self.send_log(f"[è§¸ç™¼è¦å‰‡] âœ“ å·²æ’ç¨‹ç™¼é€æ¶ˆæ¯ (æ¨¡æ¿: {template_name}, å»¶é²: {delay}ç§’, ç¾¤çµ„: {source_group})", "success")
            await db.add_interaction(lead_id, 'Trigger Rule', f"è¦å‰‡ '{rule.get('name')}' è§¸ç™¼ï¼Œä½¿ç”¨æ¨¡æ¿ '{template_name}'")
            
            return True
            
        except Exception as e:
            self.send_log(f"[è§¸ç™¼è¦å‰‡] æ¨¡æ¿éŸ¿æ‡‰å¤±æ•—: {str(e)}", "error")
            return False
    
    async def _execute_script_response(self, rule: Dict, lead_id: int, lead_data: Dict) -> bool:
        """åŸ·è¡Œè…³æœ¬éŸ¿æ‡‰"""
        try:
            response_config = rule.get('response_config', {})
            script_id = response_config.get('scriptId')
            
            if not script_id:
                self.send_log("[è§¸ç™¼è¦å‰‡] æœªé…ç½®è…³æœ¬ ID", "warning")
                return False
            
            # TODO: å¯¦ç¾è…³æœ¬åŸ·è¡Œé‚è¼¯
            self.send_log(f"[è§¸ç™¼è¦å‰‡] è…³æœ¬åŸ·è¡ŒåŠŸèƒ½å°šæœªå¯¦ç¾ (Script ID: {script_id})", "warning")
            await db.add_interaction(lead_id, 'Trigger Rule', f"è¦å‰‡ '{rule.get('name')}' è§¸ç™¼ï¼Œè…³æœ¬åŸ·è¡Œå¾…å¯¦ç¾")
            
            return False
            
        except Exception as e:
            self.send_log(f"[è§¸ç™¼è¦å‰‡] è…³æœ¬éŸ¿æ‡‰å¤±æ•—: {str(e)}", "error")
            return False
    
    async def _execute_record_only_response(self, rule: Dict, lead_id: int, lead_data: Dict) -> bool:
        """åƒ…è¨˜éŒ„éŸ¿æ‡‰"""
        try:
            rule_name = rule.get('name', 'æœªå‘½åè¦å‰‡')
            
            self.send_log(f"[è§¸ç™¼è¦å‰‡] âœ“ å·²è¨˜éŒ„ (è¦å‰‡: {rule_name})", "success")
            await db.add_interaction(lead_id, 'Trigger Rule', f"è¦å‰‡ '{rule_name}' è§¸ç™¼ï¼Œåƒ…è¨˜éŒ„ä¸éŸ¿æ‡‰")
            
            # å¦‚æœé…ç½®äº†é€šçŸ¥
            if rule.get('notify_me'):
                self.send_event("trigger-rule-notification", {
                    "ruleId": rule.get('id'),
                    "ruleName": rule_name,
                    "leadId": lead_id,
                    "username": lead_data.get('username'),
                    "keyword": lead_data.get('triggered_keyword'),
                    "message": "é—œéµè©åŒ¹é…ï¼Œåƒ…è¨˜éŒ„"
                })
            
            return True
            
        except Exception as e:
            self.send_log(f"[è§¸ç™¼è¦å‰‡] è¨˜éŒ„éŸ¿æ‡‰å¤±æ•—: {str(e)}", "error")
            return False
    
    async def _get_sender_account_for_rule(self, rule: Dict) -> str:
        """ç‚ºè¦å‰‡ç²å–ç™¼é€å¸³è™Ÿ"""
        try:
            sender_type = rule.get('sender_type', 'auto')
            sender_account_ids = rule.get('sender_account_ids', [])
            
            accounts = await db.get_all_accounts()
            sender_accounts = [a for a in accounts if a.get('role') == 'Sender' and a.get('status') == 'Online']
            
            if not sender_accounts:
                return None
            
            if sender_type == 'specific' and sender_account_ids:
                # å¾æŒ‡å®šå¸³è™Ÿä¸­é¸æ“‡
                specific_accounts = [a for a in sender_accounts if a.get('id') in sender_account_ids]
                if specific_accounts:
                    import random
                    return random.choice(specific_accounts).get('phone')
            
            # è‡ªå‹•é¸æ“‡ï¼ˆä½¿ç”¨å¸³è™Ÿè¼ªæ›å™¨æˆ–éš¨æ©Ÿé¸æ“‡ï¼‰
            if self.message_queue.account_rotator:
                selected_account = await self.message_queue.account_rotator.select_account()
                if selected_account:
                    return selected_account.get('phone')
            
            # å›é€€åˆ°éš¨æ©Ÿé¸æ“‡
            import random
            return random.choice(sender_accounts).get('phone')
            
        except Exception as e:
            self.send_log(f"ç²å–ç™¼é€å¸³è™Ÿå¤±æ•—: {str(e)}", "error")
            return None
    
    async def _execute_additional_actions(self, rule: Dict, lead_id: int, lead_data: Dict):
        """åŸ·è¡Œé¡å¤–æ“ä½œ"""
        try:
            # è‡ªå‹•æ·»åŠ åˆ°æ½›åœ¨å®¢æˆ¶
            if rule.get('auto_add_lead'):
                # Lead å·²ç¶“åœ¨ on_lead_captured ä¸­æ·»åŠ ï¼Œé€™è£¡åªéœ€æ›´æ–°æ¨™ç±¤
                await db.update_lead(lead_id, {
                    'tags': f"auto,trigger-rule-{rule.get('id')}"
                })
            
            # ç™¼é€é€šçŸ¥
            if rule.get('notify_me'):
                self.send_event("trigger-rule-notification", {
                    "ruleId": rule.get('id'),
                    "ruleName": rule.get('name'),
                    "leadId": lead_id,
                    "username": lead_data.get('username'),
                    "keyword": lead_data.get('triggered_keyword'),
                    "message": f"è§¸ç™¼è¦å‰‡ '{rule.get('name')}' å·²åŸ·è¡Œ"
                })
                
        except Exception as e:
            self.send_log(f"åŸ·è¡Œé¡å¤–æ“ä½œå¤±æ•—: {str(e)}", "error")
    
    # ============== è§¸ç™¼è¦å‰‡åŸ·è¡Œå¼•æ“çµæŸ ==============
    
    async def generate_message_from_template(self, template: Dict[str, Any], lead_data: Dict[str, Any]) -> str:
        """Generate message from template using variable substitution"""
        try:
            import datetime
            import random
            
            prompt = template.get('prompt', '')
            
            # ç”¨æˆ¶ä¿¡æ¯è®Šé‡
            username = lead_data.get('username', '')
            first_name = lead_data.get('first_name', '')
            last_name = lead_data.get('last_name', '')
            name = first_name or username or 'User'  # å„ªå…ˆä½¿ç”¨åå­—
            
            # è§¸ç™¼ä¿¡æ¯è®Šé‡
            keyword = lead_data.get('triggered_keyword', '')
            user_message = lead_data.get('user_message', lead_data.get('message', ''))
            source_group = lead_data.get('source_group', '')
            group_name = lead_data.get('group_name', source_group)
            
            # æ™‚é–“è®Šé‡
            now = datetime.datetime.now()
            current_time = now.strftime('%H:%M')
            current_date = now.strftime('%Yå¹´%mæœˆ%dæ—¥')
            
            # éš¨æ©Ÿè¡¨æƒ…
            random_emojis = ['ğŸ˜Š', 'ğŸŒŸ', 'ğŸ’«', 'âœ¨', 'ğŸ‰', 'ğŸ‘‹', 'ğŸ’ª', 'ğŸ”¥', 'â¤ï¸', 'ğŸ™Œ', 'ğŸ˜„', 'ğŸ¤']
            random_emoji = random.choice(random_emojis)
            
            # è®Šé‡æ›¿æ›
            message = prompt
            message = message.replace('{username}', username or 'User')
            message = message.replace('{firstName}', first_name)
            message = message.replace('{lastName}', last_name)
            message = message.replace('{name}', name)
            message = message.replace('{keyword}', keyword)
            message = message.replace('{message}', user_message)
            message = message.replace('{sourceGroup}', source_group)
            message = message.replace('{groupName}', group_name)
            message = message.replace('{triggeredKeyword}', keyword)  # å…¼å®¹èˆŠè®Šé‡
            message = message.replace('{time}', current_time)
            message = message.replace('{date}', current_date)
            message = message.replace('{random}', random_emoji)
            
            # æ¸…ç†æœªæ›¿æ›çš„è®Šé‡ï¼ˆç”¨ç©ºå­—ç¬¦ä¸²æ›¿æ›ï¼‰
            import re
            message = re.sub(r'\{[^}]+\}', '', message)
            
            return message.strip()
        
        except Exception as e:
            self.send_log(f"Error generating message from template: {str(e)}", "error")
            return None
    
    async def send_campaign_message_after_delay(self, campaign: Dict[str, Any], lead_id: int, lead_data: Dict[str, Any], message: str, delay: int):
        """Send campaign message after delay"""
        try:
            import asyncio
            
            # Wait for delay
            await asyncio.sleep(delay)
            
            # Get sender accounts
            accounts = await db.get_all_accounts()
            sender_accounts = [a for a in accounts if a.get('role') == 'Sender' and a.get('status') == 'Online']
            
            if not sender_accounts:
                self.send_log(f"No online sender accounts available for campaign '{campaign.get('name')}'", "warning")
                await db.add_interaction(lead_id, 'Campaign Failed', "No online sender accounts available")
                return
            
            # Select account (round-robin or random)
            import random
            selected_account = random.choice(sender_accounts)
            
            # Check daily send limit (å·²äº’å‹•ç”¨æˆ¶ä¸å—é™é¡é™åˆ¶)
            user_id = lead_data.get('user_id')
            has_interacted = await self._user_has_interacted(user_id)
            
            if not has_interacted:
                # æœªäº’å‹•ç”¨æˆ¶éœ€è¦æª¢æŸ¥é™é¡
                if selected_account.get('dailySendCount', 0) >= selected_account.get('dailySendLimit', 50):
                    self.send_log(f"Account {selected_account.get('phone')} reached daily send limit", "warning")
                    # Try another account
                    available_accounts = [a for a in sender_accounts if a.get('dailySendCount', 0) < a.get('dailySendLimit', 50)]
                    if available_accounts:
                        selected_account = random.choice(available_accounts)
                    else:
                        await db.add_interaction(lead_id, 'Campaign Failed', "All sender accounts reached daily limit")
                        return
            else:
                # å·²äº’å‹•ç”¨æˆ¶ä¸å—é™é¡é™åˆ¶
                self.send_log(f"User {user_id} has interacted before, exempt from daily limit", "info")
            
            # Send message
            user_id = lead_data.get('user_id')
            result = await self.telegram_manager.send_message(
                phone=selected_account.get('phone'),
                user_id=user_id,
                text=message
            )
            
            if result.get('success'):
                # Update daily send count (å·²äº’å‹•ç”¨æˆ¶ä¸è¨ˆå…¥é™é¡)
                if not has_interacted:
                    await db.update_account(selected_account.get('id'), {
                        'dailySendCount': selected_account.get('dailySendCount', 0) + 1
                    })
                
                # Update lead
                await db.update_lead_status(lead_id, 'Contacted')
                await db.update_lead(lead_id, {'assignedTemplateId': campaign.get('actions', [{}])[0].get('templateId')})
                await db.add_interaction(lead_id, 'Message Sent', f"Message sent via campaign '{campaign.get('name')}'")
                
                self.send_log(f"Campaign message sent to lead {lead_id} via account {selected_account.get('phone')}", "success")
                
                # Send event
                self.send_event("message-sent", {
                    "leadId": lead_id,
                    "campaignId": campaign.get('id'),
                    "success": True
                })
            else:
                error_msg = result.get('error', 'Unknown error')
                await db.add_interaction(lead_id, 'Campaign Failed', f"Failed to send message: {error_msg}")
                self.send_log(f"Failed to send campaign message: {error_msg}", "error")
        
        except Exception as e:
            self.send_log(f"Error sending campaign message: {str(e)}", "error")
    
    async def daily_reset_task(self):
        """Background task to reset daily send counts at midnight"""
        try:
            while self.running:
                now = datetime.now()
                # Calculate next midnight
                next_midnight = now.replace(hour=0, minute=0, second=0, microsecond=0)
                if next_midnight <= now:
                    next_midnight = next_midnight + timedelta(days=1)
                
                # Wait until midnight
                wait_seconds = (next_midnight - now).total_seconds()
                await asyncio.sleep(wait_seconds)
                
                # Reset daily send counts
                if self.running:
                    await self.reset_daily_send_counts()
                    self.last_reset_date = datetime.now().date()
        
        except asyncio.CancelledError:
            pass
        except Exception as e:
            self.send_log(f"Error in daily reset task: {str(e)}", "error")
    
    async def reset_daily_send_counts(self):
        """Reset daily send counts for all accounts"""
        try:
            accounts = await db.get_all_accounts()
            for account in accounts:
                await db.update_account(account.get('id'), {'dailySendCount': 0})
            
            self.send_log(f"Daily send counts reset for {len(accounts)} accounts", "info")
            await db.add_log(f"Daily send counts reset for {len(accounts)} accounts", "info")
            
            # Send updated accounts
            accounts = await db.get_all_accounts()
            # Invalidate cache
            self._cache.pop("accounts", None)
            self._cache_timestamps.pop("accounts", None)
            self.send_event("accounts-updated", accounts)
        
        except Exception as e:
            self.send_log(f"Error resetting daily send counts: {str(e)}", "error")
    
    async def account_health_monitor_task(self):
        """Background task to periodically check account health and status"""
        try:
            while self.running:
                # Wait 5 minutes between checks
                await asyncio.sleep(300)  # 5 minutes
                
                if not self.running:
                    break
                
                # Check all online accounts
                await self.check_all_accounts_health()
        
        except asyncio.CancelledError:
            pass
        except Exception as e:
            self.send_log(f"Error in account health monitor task: {str(e)}", "error")
    
    async def check_all_accounts_health(self):
        """Check health and status of all accounts"""
        try:
            accounts = await db.get_all_accounts()
            online_accounts = [a for a in accounts if a.get('status') == 'Online']
            
            if not online_accounts:
                return
            
            self.send_log(f"Checking health for {len(online_accounts)} online accounts", "info")
            
            for account in online_accounts:
                try:
                    # Check account status
                    phone = account.get('phone')
                    status_result = await self.telegram_manager.check_account_status(phone)
                    
                    # Calculate health score (åŸæœ‰æ–¹æ³•)
                    health_score = await self.calculate_health_score(account, status_result)
                    
                    # å¢å¼ºçš„å¥åº·åˆ†æï¼ˆè´¦æˆ·å¥åº·ç›‘æ§å¢å¼ºï¼‰
                    if self.enhanced_health_monitor:
                        health_analysis = await self.enhanced_health_monitor.analyze_account_health(
                            account.get('id'),
                            account
                        )
                        
                        # ä½¿ç”¨å¢å¼ºçš„å¥åº·åˆ†æç»“æœæ›´æ–°å¥åº·åˆ†æ•°
                        if health_analysis.get('ban_risk_score') is not None:
                            # æ ¹æ®å°ç¦é£é™©è°ƒæ•´å¥åº·åˆ†æ•°
                            ban_risk = health_analysis.get('ban_risk_score', 0.0)
                            adjusted_score = health_score * (1.0 - ban_risk * 0.5)  # å°ç¦é£é™©è¶Šé«˜ï¼Œå¥åº·åˆ†æ•°è¶Šä½
                            health_score = max(0, min(100, int(adjusted_score)))
                        
                        # å‘é€å¥åº·åˆ†æäº‹ä»¶
                        self.send_event("account-health-analysis", {
                            "account_id": account.get('id'),
                            "phone": phone,
                            **health_analysis
                        })
                    
                    # Update account
                    updates = {
                        'status': status_result.get('status', account.get('status')),
                        'healthScore': health_score
                    }
                    await db.update_account(account.get('id'), updates)
                
                except Exception as e:
                    self.send_log(f"Error checking health for account {account.get('phone')}: {str(e)}", "error")
            
            # Send updated accounts
            accounts = await db.get_all_accounts()
            # Invalidate cache
            self._cache.pop("accounts", None)
            self._cache_timestamps.pop("accounts", None)
            self.send_event("accounts-updated", accounts)
        
        except Exception as e:
            self.send_log(f"Error checking all accounts health: {str(e)}", "error")
    
    async def queue_cleanup_task(self):
        """Background task to clean up old queue messages"""
        while self.running:
            try:
                await asyncio.sleep(3600)  # Run every hour
                await db.cleanup_old_queue_messages(days=7)
            except Exception as e:
                self.send_log(f"Error cleaning up queue messages: {str(e)}", "error")
                await asyncio.sleep(60)
    
    async def calculate_health_score(self, account: Dict[str, Any], status_result: Dict[str, Any]) -> int:
        """Calculate health score for an account"""
        try:
            base_score = 100
            
            # Status penalty
            status = status_result.get('status', 'Offline')
            if status == 'Banned':
                return 0
            elif status == 'Proxy Error':
                base_score -= 30
            elif status == 'Offline':
                base_score -= 20
            elif status != 'Online':
                base_score -= 10
            
            # Daily send limit penalty
            daily_send_count = account.get('dailySendCount', 0)
            daily_send_limit = account.get('dailySendLimit', 50)
            if daily_send_limit > 0:
                send_ratio = daily_send_count / daily_send_limit
                if send_ratio >= 1.0:
                    base_score -= 20  # Reached limit
                elif send_ratio >= 0.8:
                    base_score -= 10  # Near limit
            
            # Ensure score is between 0 and 100
            health_score = max(0, min(100, base_score))
            
            return int(health_score)
        
        except Exception as e:
            self.send_log(f"Error calculating health score: {str(e)}", "error")
            return account.get('healthScore', 100)
    
    async def handle_save_settings(self, payload: Dict[str, Any]):
        """Handle save-settings command"""
        try:
            settings = payload.get('settings', {})
            for key, value in settings.items():
                await db.set_setting(key, value)
            
            await db.add_log("Settings saved", "success")
            self.send_log("Settings saved successfully", "success")
            
            # Send updated settings
            all_settings = await db.get_all_settings()
            self.send_event("settings-updated", all_settings)
        
        except Exception as e:
            self.send_log(f"Error saving settings: {str(e)}", "error")
    
    async def handle_get_settings(self):
        """Handle get-settings command"""
        try:
            settings = await db.get_all_settings()
            self.send_event("settings-loaded", settings)
        
        except Exception as e:
            self.send_log(f"Error loading settings: {str(e)}", "error")
    
    async def handle_get_queue_status(self, payload: Dict[str, Any]):
        """Handle get-queue-status command"""
        try:
            phone = payload.get('phone')  # Optional, if None returns all
            status = await self.message_queue.get_queue_status(phone)
            self.send_event("queue-status", status)
        
        except Exception as e:
            self.send_log(f"Error getting queue status: {str(e)}", "error")
    
    async def handle_get_account_health_report(self, payload: Dict[str, Any]):
        """Handle get-account-health-report command - ç²å–å¸³è™Ÿå¥åº·å ±å‘Š"""
        try:
            if self.message_queue.account_rotator:
                report = self.message_queue.account_rotator.get_account_health_report()
                self.send_event("account-health-report", report)
            else:
                self.send_event("account-health-report", [])
        
        except Exception as e:
            self.send_log(f"Error getting account health report: {str(e)}", "error")
    
    async def handle_clear_queue(self, payload: Dict[str, Any]):
        """Handle clear-queue command"""
        try:
            phone = payload.get('phone')
            status_str = payload.get('status')  # Optional: 'pending', 'failed', etc.
            
            if not phone:
                self.send_log("Phone number required to clear queue", "error")
                return
            
            # Convert status string to enum if provided
            status = None
            if status_str:
                from message_queue import MessageStatus
                status_map = {
                    'pending': MessageStatus.PENDING,
                    'processing': MessageStatus.PROCESSING,
                    'failed': MessageStatus.FAILED,
                    'retrying': MessageStatus.RETRYING
                }
                status = status_map.get(status_str.lower())
            
            await self.message_queue.clear_queue(phone, status)
            await db.add_log(f"Queue cleared for {phone}", "info")
            self.send_log(f"Queue cleared for {phone}", "success")
            
            # Send updated status
            status = await self.message_queue.get_queue_status(phone)
            self.send_event("queue-status", status)
        
        except Exception as e:
            self.send_log(f"Error clearing queue: {str(e)}", "error")
    
    async def handle_pause_queue(self, payload: Dict[str, Any]):
        """Handle pause-queue command"""
        try:
            phone = payload.get('phone')
            if not phone:
                self.send_log("Phone number required to pause queue", "error")
                return
            
            await self.message_queue.pause_queue(phone)
            self.send_log(f"Queue paused for {phone}", "info")
            
            # Send updated queue status
            queue_status = await self.message_queue.get_queue_status(phone)
            queue_status['paused'] = True
            self.send_event("queue-status", queue_status)
        
        except Exception as e:
            self.send_log(f"Error pausing queue: {str(e)}", "error")
    
    async def handle_resume_queue(self, payload: Dict[str, Any]):
        """Handle resume-queue command"""
        try:
            phone = payload.get('phone')
            if not phone:
                self.send_log("Phone number required to resume queue", "error")
                return
            
            await self.message_queue.resume_queue(phone)
            self.send_log(f"Queue resumed for {phone}", "success")
            
            # Send updated queue status
            queue_status = await self.message_queue.get_queue_status(phone)
            queue_status['paused'] = False
            self.send_event("queue-status", queue_status)
        
        except Exception as e:
            self.send_log(f"Error resuming queue: {str(e)}", "error")
    
    async def handle_delete_queue_message(self, payload: Dict[str, Any]):
        """Handle delete-queue-message command"""
        try:
            phone = payload.get('phone')
            message_id = payload.get('messageId')
            
            if not phone or not message_id:
                self.send_log("Phone number and message ID required", "error")
                return
            
            success = await self.message_queue.delete_message(phone, message_id)
            if success:
                self.send_log(f"Message {message_id} deleted from queue", "success")
                # Send updated queue status
                queue_status = await self.message_queue.get_queue_status(phone)
                self.send_event("queue-status", queue_status)
            else:
                self.send_log(f"Message {message_id} not found in queue", "warning")
        
        except Exception as e:
            self.send_log(f"Error deleting queue message: {str(e)}", "error")
    
    async def handle_update_queue_message_priority(self, payload: Dict[str, Any]):
        """Handle update-queue-message-priority command"""
        try:
            phone = payload.get('phone')
            message_id = payload.get('messageId')
            priority_str = payload.get('priority')  # 'HIGH', 'NORMAL', 'LOW'
            
            if not phone or not message_id or not priority_str:
                self.send_log("Phone number, message ID, and priority required", "error")
                return
            
            from message_queue import MessagePriority
            priority_map = {
                'HIGH': MessagePriority.HIGH,
                'NORMAL': MessagePriority.NORMAL,
                'LOW': MessagePriority.LOW
            }
            priority = priority_map.get(priority_str.upper())
            
            if not priority:
                self.send_log(f"Invalid priority: {priority_str}", "error")
                return
            
            success = await self.message_queue.update_message_priority(phone, message_id, priority)
            if success:
                self.send_log(f"Message {message_id} priority updated to {priority_str}", "success")
                # Send updated queue status
                queue_status = await self.message_queue.get_queue_status(phone)
                self.send_event("queue-status", queue_status)
            else:
                self.send_log(f"Message {message_id} not found in queue", "warning")
        
        except Exception as e:
            self.send_log(f"Error updating message priority: {str(e)}", "error")
    
    async def handle_get_queue_messages(self, payload: Dict[str, Any]):
        """Handle get-queue-messages command"""
        try:
            phone = payload.get('phone')  # Optional
            status_str = payload.get('status')  # Optional
            limit = payload.get('limit', 100)
            
            status = None
            if status_str:
                from message_queue import MessageStatus
                status_map = {
                    'pending': MessageStatus.PENDING,
                    'processing': MessageStatus.PROCESSING,
                    'failed': MessageStatus.FAILED,
                    'retrying': MessageStatus.RETRYING,
                    'completed': MessageStatus.COMPLETED
                }
                status = status_map.get(status_str.lower())
            
            messages = await self.message_queue.get_queue_messages(phone, status, limit)
            self.send_event("queue-messages", {
                "phone": phone,
                "messages": messages,
                "count": len(messages)
            })
        
        except Exception as e:
            self.send_log(f"Error getting queue messages: {str(e)}", "error")
    
    async def handle_get_logs(self, payload: Dict[str, Any]):
        """Handle get-logs command with filtering"""
        try:
            limit = payload.get('limit', 100)
            log_type = payload.get('type')  # Optional: 'info', 'success', 'warning', 'error'
            start_date = payload.get('startDate')  # Optional: ISO format
            end_date = payload.get('endDate')  # Optional: ISO format
            search_query = payload.get('search')  # Optional: search string
            
            logs = await db.get_recent_logs(
                limit=limit,
                log_type=log_type,
                start_date=start_date,
                end_date=end_date,
                search_query=search_query
            )
            
            # Format timestamps
            for log in logs:
                if isinstance(log.get('timestamp'), str):
                    pass  # Already a string
                else:
                    log['timestamp'] = datetime.fromisoformat(log['timestamp']).isoformat() + "Z"
            
            # Get total count
            total_count = await db.get_logs_count(
                log_type=log_type,
                start_date=start_date,
                end_date=end_date,
                search_query=search_query
            )
            
            self.send_event("logs-loaded", {
                "logs": logs,
                "total": total_count,
                "limit": limit
            })
        
        except Exception as e:
            self.send_log(f"Error getting logs: {str(e)}", "error")
    
    async def handle_export_logs(self, payload: Dict[str, Any]):
        """Handle export-logs command"""
        try:
            import openpyxl
            from openpyxl import Workbook
            from pathlib import Path
            
            log_type = payload.get('type')
            start_date = payload.get('startDate')
            end_date = payload.get('endDate')
            search_query = payload.get('search')
            
            # Get all matching logs (no limit for export)
            logs = await db.get_recent_logs(
                limit=10000,  # Large limit for export
                log_type=log_type,
                start_date=start_date,
                end_date=end_date,
                search_query=search_query
            )
            
            # Create Excel workbook
            wb = Workbook()
            ws = wb.active
            ws.title = "Logs"
            
            # Headers
            ws.append(["ID", "Timestamp", "Type", "Message"])
            
            # Data
            for log in logs:
                ws.append([
                    log.get('id'),
                    log.get('timestamp'),
                    log.get('type'),
                    log.get('message')
                ])
            
            # Save to file
            export_dir = config.TEMPLATES_DIR.parent / "exports"
            export_dir.mkdir(exist_ok=True)
            
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"logs_export_{timestamp}.xlsx"
            filepath = export_dir / filename
            
            wb.save(filepath)
            
            await db.add_log(f"Logs exported to {filename}", "success")
            self.send_log(f"Logs exported to {filename}", "success")
            
            # Send file path to frontend
            self.send_event("logs-exported", {
                "filepath": str(filepath),
                "filename": filename,
                "count": len(logs)
            })
        
        except Exception as e:
            self.send_log(f"Error exporting logs: {str(e)}", "error")
    
    # ==================== Monitoring Management Handlers ====================
    
    async def handle_get_accounts(self):
        """ç²å–æ‰€æœ‰å¸³è™Ÿåˆ—è¡¨"""
        try:
            accounts = await db.get_all_accounts()
            self.send_event("accounts-updated", accounts)
            # åŒæ™‚è¿”å›æ•¸æ“šçµ¦ HTTP éŸ¿æ‡‰
            return {'success': True, 'accounts': accounts}
        except Exception as e:
            self.send_log(f"âŒ ç²å–å¸³è™Ÿåˆ—è¡¨å¤±æ•—: {e}", "error")
            self.send_event("accounts-updated", [])
            return {'success': False, 'error': str(e), 'accounts': []}
    
    async def handle_get_monitored_groups(self):
        """ç²å–æ‰€æœ‰ç›£æ§ç¾¤çµ„åˆ—è¡¨"""
        try:
            groups = await db.get_all_monitored_groups()
            self.send_event("get-groups-result", {"groups": groups})
        except Exception as e:
            self.send_log(f"âŒ ç²å–ç›£æ§ç¾¤çµ„å¤±æ•—: {e}", "error")
            self.send_event("get-groups-result", {"groups": [], "error": str(e)})
    
    async def handle_get_keyword_sets(self):
        """ç²å–æ‰€æœ‰é—œéµè©é›†åˆ—è¡¨
        
        ğŸ”§ ä¿®å¾©ï¼šåŒæ™‚å¾ JSON å­—æ®µå’Œ keywords é—œè¯è¡¨è®€å–ä¸¦åˆä½µ
        ğŸ”§ æ ¼å¼ï¼šåŒæ™‚åŒ…å« 'keyword' å’Œ 'text' å­—æ®µ
        """
        import sys
        try:
            rows = await db.fetch_all('SELECT * FROM keyword_sets ORDER BY created_at DESC')
            
            keyword_sets = []
            for row in rows:
                row_dict = dict(row) if hasattr(row, 'keys') else {
                    'id': row[0], 'name': row[1], 'description': row[2], 
                    'keywords': row[3], 'match_mode': row[4] if len(row) > 4 else 'fuzzy',
                    'is_active': row[5] if len(row) > 5 else 1
                }
                
                set_id = row_dict['id']
                formatted_keywords = []
                seen_texts = set()
                
                # ========== ä¾†æº 1: å¾ JSON å­—æ®µè§£æ ==========
                keywords_raw = row_dict.get('keywords', '[]')
                try:
                    if isinstance(keywords_raw, str):
                        json_keywords = json.loads(keywords_raw) if keywords_raw else []
                    else:
                        json_keywords = keywords_raw or []
                except:
                    json_keywords = []
                
                for i, kw in enumerate(json_keywords):
                    if isinstance(kw, dict):
                        text = kw.get('text', kw.get('keyword', ''))
                    elif isinstance(kw, str):
                        text = kw
                    else:
                        continue
                    
                    if text and text not in seen_texts:
                        seen_texts.add(text)
                        formatted_keywords.append({
                            'id': kw.get('id', f"kw-{set_id}-{i}") if isinstance(kw, dict) else f"kw-{set_id}-{i}",
                            'keyword': text,  # ğŸ”§ åŒ¹é…å™¨ä½¿ç”¨
                            'text': text,     # ğŸ”§ å‰ç«¯é¡¯ç¤º
                            'isRegex': kw.get('isRegex', False) if isinstance(kw, dict) else False,
                            'matchCount': kw.get('matchCount', 0) if isinstance(kw, dict) else 0
                        })
                
                # ========== ä¾†æº 2: å¾ keywords é—œè¯è¡¨è®€å–ï¼ˆèˆŠæ•¸æ“šï¼‰ ==========
                try:
                    table_keywords = await db.fetch_all(
                        'SELECT * FROM keywords WHERE keyword_set_id = ?',
                        (set_id,)
                    )
                    for j, tk in enumerate(table_keywords):
                        tk_dict = dict(tk) if hasattr(tk, 'keys') else {
                            'id': tk[0], 'keyword_set_id': tk[1], 'keyword': tk[2],
                            'match_type': tk[3] if len(tk) > 3 else 'contains'
                        }
                        text = tk_dict.get('keyword', '')
                        if text and text not in seen_texts:
                            seen_texts.add(text)
                            formatted_keywords.append({
                                'id': f"kw-table-{tk_dict.get('id', j)}",
                                'keyword': text,
                                'text': text,
                                'isRegex': tk_dict.get('match_type') == 'regex',
                                'matchCount': 0
                            })
                except Exception as table_err:
                    # keywords è¡¨å¯èƒ½ä¸å­˜åœ¨æˆ–å‡ºéŒ¯ï¼Œå¿½ç•¥
                    print(f"[Backend] Note: keywords table read failed for set {set_id}: {table_err}", file=sys.stderr)
                
                # æ§‹å»ºå‰ç«¯éœ€è¦çš„æ ¼å¼
                keyword_set = {
                    'id': str(set_id),
                    'name': row_dict.get('name', ''),
                    'description': row_dict.get('description', ''),
                    'keywords': formatted_keywords,
                    'matchMode': row_dict.get('match_mode', 'fuzzy'),
                    'isActive': bool(row_dict.get('is_active', 1)),
                    'totalMatches': sum(kw.get('matchCount', 0) for kw in formatted_keywords)
                }
                keyword_sets.append(keyword_set)
            
            print(f"[Backend] Returning {len(keyword_sets)} keyword sets", file=sys.stderr)
            for ks in keyword_sets:
                kw_texts = [k.get('text', k.get('keyword', '')) for k in ks.get('keywords', [])]
                print(f"[Backend]   - {ks.get('name')}: {len(ks.get('keywords', []))} keywords: {kw_texts}", file=sys.stderr)
            
            self.send_event("get-keyword-sets-result", {"keywordSets": keyword_sets})
            
        except Exception as e:
            import traceback
            print(f"[Backend] Error getting keyword sets: {e}", file=sys.stderr)
            print(traceback.format_exc(), file=sys.stderr)
            self.send_log(f"âŒ ç²å–é—œéµè©é›†å¤±æ•—: {e}", "error")
            self.send_event("get-keyword-sets-result", {"keywordSets": [], "error": str(e)})
    
    async def handle_save_keyword_set(self, payload: Dict[str, Any]):
        """ä¿å­˜é—œéµè©é›†"""
        import sys
        print(f"[Backend] ========== handle_save_keyword_set ==========", file=sys.stderr)
        print(f"[Backend] Payload: {payload}", file=sys.stderr)
        
        try:
            set_id = payload.get('id')
            name = payload.get('name', '').strip()
            description = payload.get('description', '')
            keywords = payload.get('keywords', [])
            is_active = payload.get('isActive', True)
            match_mode = payload.get('matchMode', 'fuzzy')  # ğŸ”§ æ–°å¢ï¼šç²å–åŒ¹é…æ¨¡å¼
            
            print(f"[Backend] set_id={set_id}, name={name}, keywords_count={len(keywords)}, match_mode={match_mode}", file=sys.stderr)
            
            if not name:
                self.send_event("save-keyword-set-result", {
                    "success": False,
                    "error": "è©é›†åç¨±ä¸èƒ½ç‚ºç©º"
                })
                return
            
            # ğŸ”§ å°‡é—œéµè©åˆ—è¡¨è½‰ç‚º JSON å­—ç¬¦ä¸²ï¼ˆä¿å­˜å®Œæ•´å°è±¡ï¼ŒåŒ…å« text å’Œ keyword å­—æ®µï¼‰
            keywords_list = []
            for k in keywords:
                if isinstance(k, dict):
                    text = k.get('text', k.get('keyword', ''))
                    keywords_list.append({
                        'text': text,
                        'keyword': text,  # ğŸ”§ åŒæ™‚ä¿å­˜ keyword å­—æ®µä¾›åŒ¹é…å™¨ä½¿ç”¨
                        'isRegex': k.get('isRegex', False)
                    })
                elif isinstance(k, str):
                    keywords_list.append({
                        'text': k,
                        'keyword': k,
                        'isRegex': False
                    })
            
            keywords_json = json.dumps(keywords_list, ensure_ascii=False)
            
            print(f"[Backend] keywords_json: {keywords_json}", file=sys.stderr)
            
            if set_id:
                # æ›´æ–°ç¾æœ‰è©é›†
                print(f"[Backend] Updating existing set id={set_id}", file=sys.stderr)
                await db.execute(
                    """UPDATE keyword_sets 
                       SET name=?, description=?, keywords=?, match_mode=?, is_active=?, updated_at=CURRENT_TIMESTAMP
                       WHERE id=?""",
                    (name, description, keywords_json, match_mode, 1 if is_active else 0, set_id)
                )
            else:
                # å‰µå»ºæ–°è©é›†
                print(f"[Backend] Creating new set", file=sys.stderr)
                cursor = await db.execute_insert(
                    """INSERT INTO keyword_sets (name, description, keywords, match_mode, is_active)
                       VALUES (?, ?, ?, ?, ?)""",
                    (name, description, keywords_json, match_mode, 1 if is_active else 0)
                )
                set_id = cursor
                print(f"[Backend] New set created with id={set_id}", file=sys.stderr)
            
            self.send_event("save-keyword-set-result", {"success": True, "id": set_id})
            self.send_log(f"âœ… å·²ä¿å­˜é—œéµè©é›†: {name} ({len(keywords_list)} å€‹é—œéµè©)", "success")
            
            # åˆ·æ–°åˆ—è¡¨
            await self.handle_get_keyword_sets()
            
        except Exception as e:
            self.send_log(f"âŒ ä¿å­˜é—œéµè©é›†å¤±æ•—: {e}", "error")
            self.send_event("save-keyword-set-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_delete_keyword_set(self, payload: Dict[str, Any]):
        """åˆªé™¤é—œéµè©é›†"""
        try:
            set_id = payload.get('id')
            
            if not set_id:
                self.send_event("delete-keyword-set-result", {
                    "success": False,
                    "error": "ç¼ºå°‘è©é›† ID"
                })
                return
            
            await db.execute("DELETE FROM keyword_sets WHERE id=?", (set_id,))
            
            self.send_event("delete-keyword-set-result", {"success": True})
            self.send_log(f"ğŸ—‘ï¸ å·²åˆªé™¤é—œéµè©é›† ID: {set_id}", "success")
            
            # åˆ·æ–°åˆ—è¡¨
            await self.handle_get_keyword_sets()
            
        except Exception as e:
            self.send_log(f"âŒ åˆªé™¤é—œéµè©é›†å¤±æ•—: {e}", "error")
            self.send_event("delete-keyword-set-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_bind_keyword_set(self, payload: Dict[str, Any]):
        """ç¶å®šé—œéµè©é›†åˆ°ç¾¤çµ„"""
        import json
        import sys
        
        print(f"[Backend] ========== handle_bind_keyword_set ==========", file=sys.stderr)
        print(f"[Backend] Payload: {payload}", file=sys.stderr)
        
        try:
            group_id = payload.get('groupId')
            keyword_set_id = payload.get('keywordSetId')
            
            print(f"[Backend] group_id={group_id}, keyword_set_id={keyword_set_id}", file=sys.stderr)
            
            if not group_id or not keyword_set_id:
                self.send_log("âŒ ç¶å®šå¤±æ•—: ç¼ºå°‘ç¾¤çµ„ ID æˆ–è©é›† ID", "error")
                self.send_event("bind-keyword-set-result", {"success": False, "error": "ç¼ºå°‘åƒæ•¸"})
                return
            
            # ç²å–ç•¶å‰ç¾¤çµ„çš„ç¶å®šè©é›†åˆ—è¡¨
            result = await db.fetch_one(
                "SELECT id, keyword_set_ids FROM monitored_groups WHERE id=?", (group_id,)
            )
            
            print(f"[Backend] Current group data: {result}", file=sys.stderr)
            
            if not result:
                self.send_log(f"âŒ æ‰¾ä¸åˆ°ç¾¤çµ„ ID: {group_id}", "error")
                self.send_event("bind-keyword-set-result", {"success": False, "error": "ç¾¤çµ„ä¸å­˜åœ¨"})
                return
            
            current_ids = []
            try:
                raw_ids = result.get('keyword_set_ids') or '[]'
                current_ids = json.loads(raw_ids) if isinstance(raw_ids, str) else raw_ids
                if not isinstance(current_ids, list):
                    current_ids = []
            except Exception as parse_err:
                print(f"[Backend] Parse error: {parse_err}", file=sys.stderr)
                current_ids = []
            
            print(f"[Backend] Current keyword_set_ids: {current_ids}", file=sys.stderr)
            
            # æ·»åŠ æ–°è©é›†ï¼ˆé¿å…é‡è¤‡ï¼Œçµ±ä¸€ç”¨æ•´æ•¸ï¼‰
            keyword_set_id_int = int(keyword_set_id)
            if keyword_set_id_int not in current_ids:
                current_ids.append(keyword_set_id_int)
                
                # æ›´æ–°æ•¸æ“šåº«
                new_ids_json = json.dumps(current_ids)
                print(f"[Backend] Updating to: {new_ids_json}", file=sys.stderr)
                
                await db.execute(
                    "UPDATE monitored_groups SET keyword_set_ids=?, updated_at=CURRENT_TIMESTAMP WHERE id=?",
                    (new_ids_json, group_id)
                )
                
                self.send_log(f"âœ… å·²ç¶å®šè©é›† {keyword_set_id} åˆ°ç¾¤çµ„ {group_id}", "success")
            else:
                self.send_log(f"â„¹ï¸ è©é›† {keyword_set_id} å·²ç¶“ç¶å®šåˆ°ç¾¤çµ„ {group_id}", "info")
            
            # é€šçŸ¥å‰ç«¯æ›´æ–°ä¸¦åˆ·æ–°ç¾¤çµ„åˆ—è¡¨
            self.send_event("bind-keyword-set-result", {
                "success": True, 
                "groupId": group_id, 
                "keywordSetId": keyword_set_id,
                "currentKeywordSetIds": current_ids
            })
            
            # åˆ·æ–°ç¾¤çµ„åˆ—è¡¨
            await self.handle_get_monitored_groups()
            
        except Exception as e:
            import traceback
            print(f"[Backend] Error: {traceback.format_exc()}", file=sys.stderr)
            self.send_log(f"âŒ ç¶å®šè©é›†å¤±æ•—: {e}", "error")
            self.send_event("bind-keyword-set-result", {"success": False, "error": str(e)})
    
    async def handle_unbind_keyword_set(self, payload: Dict[str, Any]):
        """è§£ç¶é—œéµè©é›†"""
        import json
        import sys
        
        print(f"[Backend] ========== handle_unbind_keyword_set ==========", file=sys.stderr)
        print(f"[Backend] Payload: {payload}", file=sys.stderr)
        
        try:
            group_id = payload.get('groupId')
            keyword_set_id = payload.get('keywordSetId')
            
            if not group_id or not keyword_set_id:
                self.send_log("âŒ è§£ç¶å¤±æ•—: ç¼ºå°‘ç¾¤çµ„ ID æˆ–è©é›† ID", "error")
                self.send_event("unbind-keyword-set-result", {"success": False, "error": "ç¼ºå°‘åƒæ•¸"})
                return
            
            # ç²å–ç•¶å‰ç¾¤çµ„çš„ç¶å®šè©é›†åˆ—è¡¨
            result = await db.fetch_one(
                "SELECT id, keyword_set_ids FROM monitored_groups WHERE id=?", (group_id,)
            )
            
            if not result:
                self.send_log(f"âŒ æ‰¾ä¸åˆ°ç¾¤çµ„ ID: {group_id}", "error")
                self.send_event("unbind-keyword-set-result", {"success": False, "error": "ç¾¤çµ„ä¸å­˜åœ¨"})
                return
            
            current_ids = []
            try:
                raw_ids = result.get('keyword_set_ids') or '[]'
                current_ids = json.loads(raw_ids) if isinstance(raw_ids, str) else raw_ids
                if not isinstance(current_ids, list):
                    current_ids = []
            except:
                current_ids = []
            
            # ç§»é™¤è©é›†ï¼ˆçµ±ä¸€ç”¨æ•´æ•¸æ¯”è¼ƒï¼‰
            keyword_set_id_int = int(keyword_set_id)
            current_ids = [x for x in current_ids if int(x) != keyword_set_id_int]
            
            # æ›´æ–°æ•¸æ“šåº«
            new_ids_json = json.dumps(current_ids)
            print(f"[Backend] Updating to: {new_ids_json}", file=sys.stderr)
            
            await db.execute(
                "UPDATE monitored_groups SET keyword_set_ids=?, updated_at=CURRENT_TIMESTAMP WHERE id=?",
                (new_ids_json, group_id)
            )
            
            self.send_log(f"âœ… å·²å¾ç¾¤çµ„ {group_id} è§£ç¶è©é›† {keyword_set_id}", "success")
            
            # é€šçŸ¥å‰ç«¯æ›´æ–°
            self.send_event("unbind-keyword-set-result", {
                "success": True, 
                "groupId": group_id, 
                "keywordSetId": keyword_set_id,
                "currentKeywordSetIds": current_ids
            })
            
            # åˆ·æ–°ç¾¤çµ„åˆ—è¡¨
            await self.handle_get_monitored_groups()
            
        except Exception as e:
            import traceback
            print(f"[Backend] Error: {traceback.format_exc()}", file=sys.stderr)
            self.send_log(f"âŒ è§£ç¶è©é›†å¤±æ•—: {e}", "error")
            self.send_event("unbind-keyword-set-result", {"success": False, "error": str(e)})

    # ==================== AI Generation Handlers ====================
    
    async def handle_ai_generate_message(self, payload: Dict[str, Any]):
        """AI ç”Ÿæˆæ‰¹é‡ç™¼é€æ¶ˆæ¯ - å„ªå…ˆä½¿ç”¨é…ç½®çš„ AIï¼Œå›é€€åˆ°æœ¬åœ°æ¨¡æ¿"""
        import sys
        import random
        import aiohttp
        
        try:
            topic = payload.get('topic', 'æ‰“æ‹›å‘¼')
            style = payload.get('style', 'friendly')
            count = payload.get('count', 5)
            context = payload.get('context', {})
            
            print(f"[AI] ç”Ÿæˆæ¶ˆæ¯: topic={topic}, style={style}, count={count}", file=sys.stderr)
            
            # å˜—è©¦ç²å–é…ç½®çš„ AI æ¨¡å‹
            ai_model = await self._get_default_ai_model()
            
            if ai_model:
                print(f"[AI] ä½¿ç”¨é…ç½®çš„ AI: {ai_model.get('displayName')} ({ai_model.get('provider')})", file=sys.stderr)
                self.send_log(f"ğŸ¤– ä½¿ç”¨ {ai_model.get('displayName')} ç”Ÿæˆæ¶ˆæ¯...", "info")
                
                # å˜—è©¦èª¿ç”¨çœŸæ­£çš„ AI
                try:
                    messages = await self._generate_messages_with_ai(
                        ai_model, topic, style, count
                    )
                    if messages:
                        self.send_event("ai-generate-message-result", {
                            "success": True,
                            "messages": messages,
                            "source": "ai",
                            "model": ai_model.get('displayName')
                        })
                        return
                except Exception as ai_error:
                    print(f"[AI] AI èª¿ç”¨å¤±æ•—ï¼Œå›é€€åˆ°æœ¬åœ°æ¨¡æ¿: {ai_error}", file=sys.stderr)
                    self.send_log(f"âš ï¸ AI èª¿ç”¨å¤±æ•—ï¼Œä½¿ç”¨æœ¬åœ°æ¨¡æ¿: {ai_error}", "warning")
            else:
                print(f"[AI] æœªé…ç½® AI æ¨¡å‹ï¼Œä½¿ç”¨æœ¬åœ°æ¨¡æ¿", file=sys.stderr)
            
            # å›é€€ï¼šä½¿ç”¨æœ¬åœ°æ¨¡æ¿
            messages = self._get_local_message_templates(topic, style, count)
            
            self.send_event("ai-generate-message-result", {
                "success": True,
                "messages": messages,
                "source": "local",
                "model": None
            })
            
        except Exception as e:
            print(f"[AI] ç”Ÿæˆæ¶ˆæ¯å¤±æ•—: {e}", file=sys.stderr)
            self.send_event("ai-generate-message-result", {
                "success": False,
                "error": str(e)
            })
    
    async def _get_default_ai_model(self) -> Optional[Dict[str, Any]]:
        """ç²å–é»˜èªçš„ AI æ¨¡å‹é…ç½®"""
        try:
            model = await db.fetch_one(
                """SELECT id, provider, model_name, display_name, api_key, api_endpoint,
                   is_local, is_default, is_connected
                   FROM ai_models WHERE is_default = 1 AND (api_key != '' OR is_local = 1)
                   ORDER BY priority DESC LIMIT 1"""
            )
            if model:
                return {
                    'id': model['id'],
                    'provider': model['provider'],
                    'modelName': model['model_name'],
                    'displayName': model['display_name'] or model['model_name'],
                    'apiKey': model['api_key'],
                    'apiEndpoint': model['api_endpoint'],
                    'isLocal': bool(model['is_local']),
                    'isConnected': bool(model['is_connected'])
                }
            
            # å¦‚æœæ²’æœ‰é»˜èªæ¨¡å‹ï¼Œå˜—è©¦ç²å–ä»»ä½•å¯ç”¨çš„æ¨¡å‹
            model = await db.fetch_one(
                """SELECT id, provider, model_name, display_name, api_key, api_endpoint,
                   is_local, is_default, is_connected
                   FROM ai_models WHERE (api_key != '' OR is_local = 1)
                   ORDER BY priority DESC, created_at DESC LIMIT 1"""
            )
            if model:
                return {
                    'id': model['id'],
                    'provider': model['provider'],
                    'modelName': model['model_name'],
                    'displayName': model['display_name'] or model['model_name'],
                    'apiKey': model['api_key'],
                    'apiEndpoint': model['api_endpoint'],
                    'isLocal': bool(model['is_local']),
                    'isConnected': bool(model['is_connected'])
                }
            return None
        except Exception as e:
            print(f"[AI] ç²å– AI æ¨¡å‹å¤±æ•—: {e}", file=__import__('sys').stderr)
            return None
    
    async def handle_ai_generate_text(self, payload: Dict[str, Any]):
        """
        ğŸ†• P0: é€šç”¨ AI æ–‡æœ¬ç”Ÿæˆ handler
        æ”¯æŒå¤šè§’è‰²å”ä½œç­‰æ¨¡å¡Šèª¿ç”¨ AI ç”Ÿæˆæ–‡æœ¬
        ğŸ”§ P1: æ·»åŠ é‡è©¦æ©Ÿåˆ¶
        """
        import sys
        import aiohttp
        
        # ğŸ”§ èª¿è©¦ï¼šç«‹å³æ‰“å°ç¢ºèªæ”¶åˆ°å‘½ä»¤
        print(f"[AI] ========== handle_ai_generate_text è¢«èª¿ç”¨ ==========", file=sys.stderr)
        print(f"[AI] payload keys: {list(payload.keys()) if payload else 'None'}", file=sys.stderr)
        
        try:
            prompt = payload.get('prompt', '')
            max_tokens = payload.get('maxTokens', 500)
            callback = payload.get('callback', 'ai:generate-text-result')
            response_format = payload.get('responseFormat', 'text')  # text æˆ– json
            
            print(f"[AI] callback={callback}, prompté•·åº¦={len(prompt)}", file=sys.stderr)
            
            if not prompt:
                print(f"[AI] éŒ¯èª¤ï¼šç¼ºå°‘ prompt åƒæ•¸", file=sys.stderr)
                self.send_event(callback, {"success": False, "error": "ç¼ºå°‘ prompt åƒæ•¸"})
                return
            
            print(f"[AI] é€šç”¨æ–‡æœ¬ç”Ÿæˆ: prompté•·åº¦={len(prompt)}, callback={callback}", file=sys.stderr)
            
            # ç²å– AI æ¨¡å‹
            ai_model = await self._get_default_ai_model()
            
            if not ai_model:
                print(f"[AI] æœªé…ç½® AI æ¨¡å‹ï¼Œç„¡æ³•ç”Ÿæˆ", file=sys.stderr)
                self.send_event(callback, {
                    "success": False,
                    "error": "æœªé…ç½® AI æ¨¡å‹",
                    "text": None
                })
                return
            
            print(f"[AI] ä½¿ç”¨æ¨¡å‹: {ai_model.get('displayName')} ({ai_model.get('provider')})", file=sys.stderr)
            
            # ğŸ”§ P1: æ·»åŠ é‡è©¦æ©Ÿåˆ¶ï¼ˆä½¿ç”¨é…ç½®å¸¸é‡ï¼‰
            from config import AIConfig
            result_text = None
            last_error = None
            
            for attempt in range(AIConfig.MAX_RETRIES + 1):
                if attempt > 0:
                    print(f"[AI] é‡è©¦ç¬¬ {attempt} æ¬¡...", file=sys.stderr)
                    await asyncio.sleep(AIConfig.RETRY_DELAY_SECONDS)
                
                result_text = await self._call_ai_for_text(ai_model, prompt, max_tokens)
                
                if result_text:
                    break
                else:
                    last_error = "AI ç”Ÿæˆå¤±æ•—"
            
            if result_text:
                print(f"[AI] ç”ŸæˆæˆåŠŸï¼Œé•·åº¦: {len(result_text)}", file=sys.stderr)
                self.send_event(callback, {
                    "success": True,
                    "text": result_text,
                    "model": ai_model.get('displayName'),
                    "provider": ai_model.get('provider')
                })
            else:
                print(f"[AI] æ‰€æœ‰å˜—è©¦éƒ½å¤±æ•—", file=sys.stderr)
                self.send_event(callback, {
                    "success": False,
                    "error": last_error or "AI ç”Ÿæˆå¤±æ•—",
                    "text": None
                })
                
        except Exception as e:
            print(f"[AI] é€šç”¨æ–‡æœ¬ç”ŸæˆéŒ¯èª¤: {e}", file=sys.stderr)
            import traceback
            traceback.print_exc()
            callback = payload.get('callback', 'ai:generate-text-result')
            self.send_event(callback, {
                "success": False,
                "error": str(e),
                "text": None
            })
    
    async def _call_ai_for_text(self, model: Dict[str, Any], prompt: str, max_tokens: int = 500) -> Optional[str]:
        """
        ğŸ†• é€šç”¨ AI èª¿ç”¨æ–¹æ³•
        ğŸ”§ P0: å¢åŠ è¶…æ™‚æ™‚é–“åˆ° 45 ç§’
        """
        import aiohttp
        import sys
        import time
        
        provider = model.get('provider', '').lower()
        api_key = model.get('apiKey', '')
        api_endpoint = model.get('apiEndpoint', '')
        model_name = model.get('modelName', '')
        is_local = model.get('isLocal', False)
        
        # ğŸ”§ P0: å¢åŠ è¶…æ™‚æ™‚é–“ï¼Œèˆ‡å‰ç«¯ä¸€è‡´ï¼ˆä½¿ç”¨é…ç½®å¸¸é‡ï¼‰
        from config import AIConfig
        timeout = aiohttp.ClientTimeout(total=AIConfig.API_TIMEOUT_SECONDS)
        start_time = time.time()
        print(f"[AI] é–‹å§‹èª¿ç”¨: provider={provider}, model={model_name}, endpoint={api_endpoint[:50] if api_endpoint else 'default'}...", file=sys.stderr)
        
        try:
            async with aiohttp.ClientSession(timeout=timeout) as session:
                if is_local or provider == 'ollama' or provider == 'custom':
                    # Ollama / æœ¬åœ°æ¨¡å‹
                    endpoint = api_endpoint or 'http://localhost:11434'
                    
                    # ğŸ”§ ä¿®å¾©: æª¢æŸ¥ç«¯é»æ˜¯å¦å·²åŒ…å« /api/chatï¼Œé¿å…é‡è¤‡æ·»åŠ 
                    if '/api/chat' in endpoint or '/api/generate' in endpoint:
                        chat_url = endpoint
                    else:
                        chat_url = f"{endpoint.rstrip('/')}/api/chat"
                    
                    print(f"[AI] æœ¬åœ° AI è«‹æ±‚ URL: {chat_url}", file=sys.stderr)
                    
                    async with session.post(chat_url, json={
                        "model": model_name or "llama3",
                        "messages": [{"role": "user", "content": prompt}],
                        "stream": False,
                        "options": {"num_predict": max_tokens}
                    }) as resp:
                        if resp.status == 200:
                            data = await resp.json()
                            return data.get('message', {}).get('content', '')
                
                elif provider == 'gemini' or provider == 'google':
                    # Google Gemini
                    endpoint = api_endpoint or 'https://generativelanguage.googleapis.com/v1beta'
                    url = f"{endpoint}/models/{model_name or 'gemini-pro'}:generateContent?key={api_key}"
                    
                    async with session.post(url, json={
                        "contents": [{"parts": [{"text": prompt}]}],
                        "generationConfig": {"maxOutputTokens": max_tokens}
                    }) as resp:
                        if resp.status == 200:
                            data = await resp.json()
                            candidates = data.get('candidates', [])
                            if candidates:
                                parts = candidates[0].get('content', {}).get('parts', [])
                                if parts:
                                    return parts[0].get('text', '')
                
                elif provider == 'openai' or provider == 'gpt':
                    # OpenAI GPT
                    endpoint = api_endpoint or 'https://api.openai.com/v1'
                    url = f"{endpoint.rstrip('/')}/chat/completions"
                    
                    headers = {
                        "Authorization": f"Bearer {api_key}",
                        "Content-Type": "application/json"
                    }
                    
                    async with session.post(url, headers=headers, json={
                        "model": model_name or "gpt-3.5-turbo",
                        "messages": [{"role": "user", "content": prompt}],
                        "max_tokens": max_tokens
                    }) as resp:
                        elapsed = time.time() - start_time
                        if resp.status == 200:
                            data = await resp.json()
                            choices = data.get('choices', [])
                            if choices:
                                content = choices[0].get('message', {}).get('content', '')
                                print(f"[AI] âœ“ OpenAI èª¿ç”¨æˆåŠŸï¼Œè€—æ™‚ {elapsed:.1f}ç§’ï¼Œè¿”å›é•·åº¦ {len(content)}", file=sys.stderr)
                                return content
                        else:
                            error_text = await resp.text()
                            print(f"[AI] âš ï¸ OpenAI è¿”å›éŒ¯èª¤: status={resp.status}, error={error_text[:200]}", file=sys.stderr)
                
                elif provider == 'deepseek':
                    # DeepSeek
                    endpoint = api_endpoint or 'https://api.deepseek.com/v1'
                    url = f"{endpoint.rstrip('/')}/chat/completions"
                    
                    headers = {
                        "Authorization": f"Bearer {api_key}",
                        "Content-Type": "application/json"
                    }
                    
                    async with session.post(url, headers=headers, json={
                        "model": model_name or "deepseek-chat",
                        "messages": [{"role": "user", "content": prompt}],
                        "max_tokens": max_tokens
                    }) as resp:
                        if resp.status == 200:
                            data = await resp.json()
                            choices = data.get('choices', [])
                            if choices:
                                return choices[0].get('message', {}).get('content', '')
                
                print(f"[AI] ä¸æ”¯æŒçš„ provider: {provider}", file=sys.stderr)
                return None
                
        except asyncio.TimeoutError:
            elapsed = time.time() - start_time
            print(f"[AI] âš ï¸ API èª¿ç”¨è¶…æ™‚: {elapsed:.1f}ç§’ (provider={provider})", file=sys.stderr)
            return None
        except Exception as e:
            elapsed = time.time() - start_time
            print(f"[AI] âŒ API èª¿ç”¨å¤±æ•—: {e} (è€—æ™‚ {elapsed:.1f}ç§’)", file=sys.stderr)
            return None
    
    async def _generate_messages_with_ai(self, model: Dict[str, Any], topic: str, style: str, count: int) -> List[str]:
        """ä½¿ç”¨é…ç½®çš„ AI ç”Ÿæˆæ¶ˆæ¯"""
        import aiohttp
        
        style_descriptions = {
            'friendly': 'å‹å¥½è¦ªåˆ‡ã€è¼•é¬†è‡ªç„¶',
            'formal': 'æ­£å¼å•†å‹™ã€å°ˆæ¥­ç¦®è²Œ',
            'humorous': 'å¹½é»˜é¢¨è¶£ã€è¼•é¬†èª¿ä¾ƒ',
            'concise': 'ç°¡æ½”æ˜äº†ã€ç›´å¥”ä¸»é¡Œ',
            'enthusiastic': 'ç†±æƒ…æ´‹æº¢ã€å……æ»¿æ´»åŠ›'
        }
        
        style_desc = style_descriptions.get(style, 'å‹å¥½è¦ªåˆ‡')
        
        prompt = f"""è«‹ç”Ÿæˆ {count} æ¢ä¸åŒçš„æ‰“æ‹›å‘¼æ¶ˆæ¯ï¼Œç”¨æ–¼åœ¨ Telegram ä¸Šå‘æ½›åœ¨å®¢æˆ¶ç™¼é€ç¬¬ä¸€æ¢æ¶ˆæ¯ã€‚

ä¸»é¡Œï¼š{topic}
é¢¨æ ¼è¦æ±‚ï¼š{style_desc}

è¦æ±‚ï¼š
1. æ¯æ¢æ¶ˆæ¯éƒ½è¦ä¸åŒï¼Œä½†ä¿æŒç›¸åŒçš„é¢¨æ ¼
2. æ¶ˆæ¯è¦è‡ªç„¶ã€çœŸèª ï¼Œä¸è¦åƒå»£å‘Š
3. ä½¿ç”¨è®Šé‡ {{firstName}} è¡¨ç¤ºå°æ–¹åå­—ï¼Œ{{greeting}} è¡¨ç¤ºå•å€™èªï¼ˆå¦‚"æ—©ä¸Šå¥½"ï¼‰
4. æ¯æ¢æ¶ˆæ¯ 20-50 å­—å·¦å³
5. åªè¼¸å‡ºæ¶ˆæ¯å…§å®¹ï¼Œæ¯æ¢æ¶ˆæ¯ä¸€è¡Œï¼Œä¸è¦ç·¨è™Ÿ

è«‹ç›´æ¥è¼¸å‡º {count} æ¢æ¶ˆæ¯ï¼š"""
        
        provider = model.get('provider', '').lower()
        api_key = model.get('apiKey', '')
        api_endpoint = model.get('apiEndpoint', '')
        model_name = model.get('modelName', '')
        is_local = model.get('isLocal', False)
        
        messages = []
        
        timeout = aiohttp.ClientTimeout(total=30)
        async with aiohttp.ClientSession(timeout=timeout) as session:
            if is_local or provider == 'ollama' or provider == 'custom':
                # æœ¬åœ° AI (Ollama)
                endpoint = api_endpoint or 'http://localhost:11434'
                chat_url = f"{endpoint.rstrip('/')}/api/chat"
                
                request_body = {
                    "model": model_name or "qwen2:7b",
                    "messages": [{"role": "user", "content": prompt}],
                    "stream": False
                }
                
                async with session.post(chat_url, json=request_body) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        content = data.get('message', {}).get('content', '')
                        messages = self._parse_ai_messages(content, count)
                    else:
                        raise Exception(f"Ollama è¿”å› {resp.status}")
                        
            elif provider == 'openai':
                # OpenAI API
                async with session.post(
                    'https://api.openai.com/v1/chat/completions',
                    headers={
                        'Authorization': f'Bearer {api_key}',
                        'Content-Type': 'application/json'
                    },
                    json={
                        'model': model_name or 'gpt-3.5-turbo',
                        'messages': [{'role': 'user', 'content': prompt}],
                        'max_tokens': 1000,
                        'temperature': 0.8
                    }
                ) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        content = data.get('choices', [{}])[0].get('message', {}).get('content', '')
                        messages = self._parse_ai_messages(content, count)
                    else:
                        error_data = await resp.text()
                        raise Exception(f"OpenAI è¿”å› {resp.status}: {error_data[:100]}")
            
            else:
                # é€šç”¨ OpenAI å…¼å®¹æ ¼å¼
                endpoint = api_endpoint or 'http://localhost:11434/v1'
                chat_url = f"{endpoint.rstrip('/')}/chat/completions"
                
                headers = {'Content-Type': 'application/json'}
                if api_key:
                    headers['Authorization'] = f'Bearer {api_key}'
                
                async with session.post(
                    chat_url,
                    headers=headers,
                    json={
                        'model': model_name,
                        'messages': [{'role': 'user', 'content': prompt}],
                        'max_tokens': 1000,
                        'temperature': 0.8
                    }
                ) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        content = data.get('choices', [{}])[0].get('message', {}).get('content', '')
                        messages = self._parse_ai_messages(content, count)
                    else:
                        raise Exception(f"API è¿”å› {resp.status}")
        
        return messages
    
    def _parse_ai_messages(self, content: str, count: int) -> List[str]:
        """è§£æ AI è¿”å›çš„æ¶ˆæ¯"""
        import re
        
        lines = content.strip().split('\n')
        messages = []
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            # ç§»é™¤ç·¨è™Ÿï¼ˆå¦‚ "1." æˆ– "1ã€" æˆ– "1)"ï¼‰
            line = re.sub(r'^[\d]+[\.\ã€\)\]\:]\s*', '', line)
            line = line.strip()
            if line and len(line) > 5:  # éæ¿¾å¤ªçŸ­çš„è¡Œ
                messages.append(line)
        
        return messages[:count] if messages else []
    
    def _get_local_message_templates(self, topic: str, style: str, count: int) -> List[str]:
        """ç²å–æœ¬åœ°æ¶ˆæ¯æ¨¡æ¿ï¼ˆå›é€€æ–¹æ¡ˆï¼‰"""
        import random
        
        style_templates = {
            'friendly': [
                "{greeting}ï¼æˆ‘æ˜¯åœ¨ç¾¤è£¡çœ‹åˆ°ä½ çš„ï¼Œæƒ³èªè­˜ä¸€ä¸‹~",
                "Hi {firstName}ï¼å¾ˆé«˜èˆˆèƒ½èªè­˜ä½ ï¼Œå¸Œæœ›ä»¥å¾Œå¤šå¤šäº¤æµ ğŸ˜Š",
                "{greeting}{firstName}ï¼Œæˆ‘è¦ºå¾—æˆ‘å€‘å¯èƒ½æœ‰å…±åŒè©±é¡Œï¼Œæ–¹ä¾¿èŠèŠå—ï¼Ÿ",
                "å—¨ï¼çœ‹åˆ°ä½ çš„è³‡æ–™è¦ºå¾—å¾ˆæœ‰è¶£ï¼Œæƒ³è·Ÿä½ äº¤å€‹æœ‹å‹~",
                f"{{greeting}}ï¼æˆ‘å°{topic}å¾ˆæ„Ÿèˆˆè¶£ï¼Œçœ‹åˆ°ä½ ä¹Ÿåœ¨é—œæ³¨é€™å€‹ï¼Ÿ"
            ],
            'formal': [
                "{greeting}ï¼Œå¾ˆé«˜èˆˆèªè­˜æ‚¨ã€‚æˆ‘æ³¨æ„åˆ°æˆ‘å€‘å¯èƒ½æœ‰å…±åŒçš„èˆˆè¶£é»ï¼Œä¸çŸ¥æ˜¯å¦æ–¹ä¾¿äº¤æµï¼Ÿ",
                f"æ‚¨å¥½ {{firstName}}ï¼Œå†’æ˜§æ‰“æ“¾ã€‚æˆ‘å°ˆæ³¨æ–¼{topic}é ˜åŸŸï¼Œå¸Œæœ›èƒ½èˆ‡æ‚¨å»ºç«‹è¯ç¹«ã€‚",
                "{greeting}ï¼Œæˆ‘æ˜¯é€šéç¾¤çµ„èªè­˜åˆ°æ‚¨çš„ã€‚å¦‚æœ‰åˆä½œæ©Ÿæœƒï¼ŒæœŸå¾…é€²ä¸€æ­¥æºé€šã€‚",
                "å°Šæ•¬çš„ {firstName}ï¼Œå¾ˆæ¦®å¹¸èƒ½å¤ èˆ‡æ‚¨å–å¾—è¯ç¹«ã€‚æœŸå¾…æœªä¾†æœ‰æ©Ÿæœƒåˆä½œã€‚",
                f"{{greeting}}ï¼Œæˆ‘å°{topic}å¾ˆæ„Ÿèˆˆè¶£ï¼Œçœ‹åˆ°æ‚¨ä¹Ÿåœ¨é€™å€‹é ˜åŸŸï¼Œæƒ³å‘æ‚¨è«‹æ•™ã€‚"
            ],
            'humorous': [
                "{greeting}ï¼æˆ‘ä¸æ˜¯æ¨éŠ·å“¡ï¼Œåªæ˜¯è¦ºå¾—ä½ çœ‹èµ·ä¾†å¾ˆé…·æƒ³èªè­˜ä¸€ä¸‹ ğŸ˜",
                "Hi {firstName}ï¼å‘½é‹çš„å®‰æ’è®“æˆ‘å€‘åœ¨èŒ«èŒ«ç¶²æµ·ä¸­ç›¸é‡ ğŸŒŠ",
                "{greeting}~æˆ‘ç™¼èª“æˆ‘ä¸æ˜¯æ©Ÿå™¨äººï¼Œåªæ˜¯ä¸€å€‹æƒ³äº¤æœ‹å‹çš„æ™®é€šäºº ğŸ¤–âŒ",
                "å˜¿ï¼å¦‚æœé€™æ¢æ¶ˆæ¯æ‰“æ“¾åˆ°ä½ äº†ï¼Œè«‹å‡è£æ²’çœ‹åˆ°ï¼ˆä½†å…¶å¯¦å¾ˆæœŸå¾…ä½ çš„å›å¾©ï¼‰",
                "{greeting}{firstName}ï¼äººç”Ÿä½•è™•ä¸ç›¸é€¢ï¼Œæ—¢ç„¶ç›¸é‡ä¸å¦‚åŠ å€‹å¥½å‹ï¼Ÿ"
            ],
            'concise': [
                "{greeting}ï¼Œèªè­˜ä¸€ä¸‹ï¼Ÿ",
                f"Hi {{firstName}}ï¼Œå°{topic}æœ‰èˆˆè¶£å—ï¼Ÿ",
                "{greeting}ï¼æ–¹ä¾¿èŠèŠå—ï¼Ÿ",
                "ä½ å¥½ï¼Œæƒ³è·Ÿä½ äº¤æµä¸€ä¸‹ã€‚",
                "{greeting}ï¼Œå¯ä»¥èªè­˜ä¸€ä¸‹å—ï¼Ÿ"
            ],
            'enthusiastic': [
                "{greeting}ï¼ï¼å¤ªé–‹å¿ƒèƒ½èªè­˜ä½ äº†ï¼ï¼ğŸ‰ğŸ‰ğŸ‰",
                "å“‡ï¼{firstName}ï¼çµ‚æ–¼æ‰¾åˆ°å¿—åŒé“åˆçš„æœ‹å‹äº†ï¼ï¼",
                f"{{greeting}}ï¼æˆ‘å°{topic}è¶…ç´šæœ‰ç†±æƒ…çš„ï¼Œå¸Œæœ›èƒ½è·Ÿä½ ä¸€èµ·è¨è«–ï¼ğŸ’ª",
                "å—¨å—¨å—¨ï¼{firstName}ï¼æ„Ÿè¦ºæˆ‘å€‘æœƒæˆç‚ºå¾ˆå¥½çš„æœ‹å‹ï¼âœ¨",
                f"å¤ªæ£’äº†ï¼{{greeting}}ï¼ä¸€ç›´åœ¨æ‰¾å°{topic}æ„Ÿèˆˆè¶£çš„äººï¼"
            ]
        }
        
        templates = style_templates.get(style, style_templates['friendly'])
        messages = templates[:count]
        random.shuffle(messages)
        return messages
    
    async def handle_ai_generate_group_names(self, payload: Dict[str, Any]):
        """AI ç”Ÿæˆç¾¤çµ„åç¨±"""
        import sys
        import random
        
        try:
            keywords = payload.get('keywords', '')
            style = payload.get('style', 'professional')
            count = payload.get('count', 5)
            
            print(f"[AI] ç”Ÿæˆç¾¤å: keywords={keywords}, style={style}", file=sys.stderr)
            
            # æ ¹æ“šé¢¨æ ¼å’Œé—œéµè©ç”Ÿæˆç¾¤å
            prefixes = {
                'professional': ['ğŸ¢', 'ğŸ’¼', 'ğŸ“Š', 'ğŸ¯', 'âš¡'],
                'lively': ['ğŸ”¥', 'ğŸ‰', 'âœ¨', 'ğŸ’«', 'ğŸŒŸ'],
                'mysterious': ['ğŸŒ™', 'ğŸ’', 'ğŸ”®', 'ğŸ‘‘', 'ğŸ­'],
                'simple': ['ğŸ“Œ', 'ğŸ“', 'ğŸ”—', 'â€¢', 'â†’']
            }
            
            suffixes = {
                'professional': ['äº¤æµç¾¤', 'ç ”è¨æœƒ', 'ç²¾è‹±ç¤¾', 'è¯ç›Ÿ', 'å•†å‹™åœˆ'],
                'lively': ['å—¨çš®ç¾¤', 'æ­¡æ¨‚ç‡Ÿ', 'ç‹‚æ­¡æ´¾', 'è¶´é«”', 'å¿«æ¨‚å±‹'],
                'mysterious': ['å…§éƒ¨ç¾¤', 'VIPå°ˆå±¬', 'ç§å¯†åœˆ', 'ç§˜å¯†åŸºåœ°', 'æ ¸å¿ƒç¾¤'],
                'simple': ['ç¾¤', 'äº¤æµ', 'è¨è«–çµ„', 'ç¤¾å€', 'é »é“']
            }
            
            prefix_list = prefixes.get(style, prefixes['professional'])
            suffix_list = suffixes.get(style, suffixes['professional'])
            
            names = []
            keyword_parts = [k.strip() for k in keywords.split(',') if k.strip()]
            main_keyword = keyword_parts[0] if keyword_parts else 'äº¤æµ'
            
            for i in range(count):
                prefix = prefix_list[i % len(prefix_list)]
                suffix = suffix_list[i % len(suffix_list)]
                
                # ç”Ÿæˆä¸åŒçµ„åˆ
                if i == 0:
                    name = f"{prefix} {main_keyword}{suffix}"
                elif i == 1:
                    name = f"{prefix} 2026{main_keyword}ç²¾è‹±{suffix}"
                elif i == 2:
                    year_suffix = ['ä¿±æ¨‚éƒ¨', 'è¯ç›Ÿ', 'åœˆå­'][i % 3]
                    name = f"{prefix} {main_keyword}{year_suffix}"
                elif i == 3:
                    name = f"{prefix} {main_keyword}æ„›å¥½è€…{suffix}"
                else:
                    name = f"{prefix} {main_keyword}é”äºº{suffix}"
                
                names.append(name)
            
            self.send_event("ai-generate-group-names-result", {
                "success": True,
                "names": names
            })
            
        except Exception as e:
            print(f"[AI] ç”Ÿæˆç¾¤åå¤±æ•—: {e}", file=sys.stderr)
            self.send_event("ai-generate-group-names-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_ai_generate_welcome(self, payload: Dict[str, Any]):
        """AI ç”Ÿæˆæ­¡è¿æ¶ˆæ¯"""
        import sys
        import random
        
        try:
            topic = payload.get('topic', 'æ­¡è¿')
            group_name = payload.get('groupName', 'æˆ‘å€‘çš„ç¾¤çµ„')
            
            print(f"[AI] ç”Ÿæˆæ­¡è¿æ¶ˆæ¯: topic={topic}, group={group_name}", file=sys.stderr)
            
            # æ­¡è¿æ¶ˆæ¯æ¨¡æ¿
            templates = [
                f"ğŸ‰ æ­¡è¿ {{name}} åŠ å…¥ã€Œ{group_name}ã€ï¼å¾ˆé«˜èˆˆèªè­˜ä½ ï¼Œæœ‰ä»»ä½•å•é¡Œéš¨æ™‚æå•å“¦~",
                f"ğŸ‘‹ Hi {{name}}ï¼æ­¡è¿ä¾†åˆ°ã€Œ{group_name}ã€ï¼å¸Œæœ›ä½ åœ¨é€™è£¡èƒ½æ‰¾åˆ°å¿—åŒé“åˆçš„æœ‹å‹ï¼",
                f"âœ¨ {{name}} ä½ å¥½ï¼æ­¡è¿åŠ å…¥æˆ‘å€‘ï¼é€™è£¡æ˜¯ã€Œ{group_name}ã€ï¼Œå¤§å®¶éƒ½å¾ˆå‹å–„çš„~",
                f"ğŸŒŸ ç†±çƒˆæ­¡è¿ {{name}}ï¼ã€Œ{group_name}ã€åˆå¤šäº†ä¸€ä½å°å¤¥ä¼´ï¼",
                f"ğŸ’« {{name}} æ­¡è¿å…¥ç¾¤ï¼ã€Œ{group_name}ã€æœŸå¾…èˆ‡ä½ ä¸€èµ·æˆé•·ï¼"
            ]
            
            message = random.choice(templates)
            
            self.send_event("ai-generate-welcome-result", {
                "success": True,
                "message": message
            })
            
        except Exception as e:
            print(f"[AI] ç”Ÿæˆæ­¡è¿æ¶ˆæ¯å¤±æ•—: {e}", file=sys.stderr)
            self.send_event("ai-generate-welcome-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_create_group(self, payload: Dict[str, Any]):
        """å‰µå»ºæ–°çš„ Telegram ç¾¤çµ„"""
        import sys
        
        try:
            name = payload.get('name', 'æ–°ç¾¤çµ„')
            description = payload.get('description', '')
            group_type = payload.get('type', 'supergroup')
            specified_phone = payload.get('accountPhone')  # å‰ç«¯æŒ‡å®šçš„å¸³è™Ÿ
            
            print(f"[Group] å‰µå»ºç¾¤çµ„: name={name}, type={group_type}, phone={specified_phone}", file=sys.stderr)
            self.send_log(f"ğŸ”¨ æ­£åœ¨å‰µå»ºç¾¤çµ„ã€Œ{name}ã€...", "info")
            
            # ç²å–å¯ç”¨å¸³è™Ÿï¼ˆæª¢æŸ¥ Online ç‹€æ…‹ï¼‰
            accounts = await db.get_all_accounts()
            online_accounts = [a for a in accounts if a.get('status') == 'Online']
            
            print(f"[Group] åœ¨ç·šå¸³è™Ÿ: {[(a.get('phone'), a.get('status')) for a in online_accounts]}", file=sys.stderr)
            
            if not online_accounts:
                self.send_event("create-group-result", {
                    "success": False,
                    "error": "æ²’æœ‰åœ¨ç·šçš„å¸³è™Ÿï¼Œè«‹å…ˆç™»å…¥å¸³è™Ÿ"
                })
                return
            
            # å„ªå…ˆä½¿ç”¨å‰ç«¯æŒ‡å®šçš„å¸³è™Ÿï¼Œå¦å‰‡ä½¿ç”¨ç¬¬ä¸€å€‹åœ¨ç·šå¸³è™Ÿ
            if specified_phone:
                account = next((a for a in online_accounts if a.get('phone') == specified_phone), None)
                if not account:
                    account = online_accounts[0]
            else:
                account = online_accounts[0]
            
            phone = account.get('phone')
            account_name = account.get('firstName', phone)
            
            print(f"[Group] ä½¿ç”¨å¸³è™Ÿ {phone} ({account_name}) å‰µå»ºç¾¤çµ„", file=sys.stderr)
            self.send_log(f"ğŸ“± ä½¿ç”¨å¸³è™Ÿ {account_name} å‰µå»ºç¾¤çµ„...", "info")
            
            # ğŸ”§ P1: ç™¼é€é€²åº¦äº‹ä»¶
            self.send_event("create-group-progress", {
                "step": "connecting",
                "message": f"æ­£åœ¨ä½¿ç”¨å¸³è™Ÿ {account_name} é€£æ¥ Telegram..."
            })
            
            # ç²å–å®¢æˆ¶ç«¯ - å¾ telegram_manager ç²å–
            client = None
            if hasattr(self.telegram_manager, 'clients'):
                # phone å¯èƒ½æœ‰æˆ–æ²’æœ‰ + å‰ç¶´ï¼Œå˜—è©¦å…©ç¨®æ ¼å¼
                client = self.telegram_manager.clients.get(phone)
                if not client and phone.startswith('+'):
                    client = self.telegram_manager.clients.get(phone[1:])
                if not client and not phone.startswith('+'):
                    client = self.telegram_manager.clients.get(f'+{phone}')
            
            if not client:
                self.send_event("create-group-result", {
                    "success": False,
                    "error": f"å¸³è™Ÿ {account_name} æœªé€£æ¥ï¼Œè«‹é‡æ–°ç™»å…¥"
                })
                return
            
            # æª¢æŸ¥å®¢æˆ¶ç«¯æ˜¯å¦å·²é€£æ¥
            if not client.is_connected:
                try:
                    await client.connect()
                except Exception as conn_err:
                    self.send_event("create-group-result", {
                        "success": False,
                        "error": f"ç„¡æ³•é€£æ¥å¸³è™Ÿ {account_name}: {conn_err}"
                    })
                    return
            
            from pyrogram.types import ChatPrivileges
            
            # ğŸ”§ P1: ç™¼é€é€²åº¦äº‹ä»¶ - é–‹å§‹å‰µå»º
            self.send_event("create-group-progress", {
                "step": "creating",
                "message": f"æ­£åœ¨å‰µå»º{'è¶…ç´š' if group_type == 'supergroup' else 'æ™®é€š'}ç¾¤çµ„ã€Œ{name}ã€..."
            })
            
            if group_type == 'supergroup':
                # å‰µå»ºè¶…ç´šç¾¤çµ„
                print(f"[Group] å‰µå»ºè¶…ç´šç¾¤çµ„...", file=sys.stderr)
                chat = await client.create_supergroup(name, description or "æ­¡è¿åŠ å…¥ï¼")
            else:
                # å‰µå»ºæ™®é€šç¾¤çµ„
                print(f"[Group] å‰µå»ºæ™®é€šç¾¤çµ„...", file=sys.stderr)
                chat = await client.create_group(name, [])
            
            print(f"[Group] ç¾¤çµ„å‰µå»ºæˆåŠŸ: id={chat.id}", file=sys.stderr)
            
            # ç²å–é‚€è«‹é€£çµ
            try:
                invite_link = await client.export_chat_invite_link(chat.id)
            except Exception as link_err:
                print(f"[Group] ç²å–é‚€è«‹é€£çµå¤±æ•—: {link_err}", file=sys.stderr)
                invite_link = f"https://t.me/{chat.username}" if hasattr(chat, 'username') and chat.username else ""
            
            self.send_log(f"âœ… ç¾¤çµ„ã€Œ{name}ã€å‰µå»ºæˆåŠŸï¼", "success")
            
            self.send_event("create-group-result", {
                "success": True,
                "groupId": str(chat.id),
                "groupName": name,
                "groupUrl": invite_link
            })
            
        except Exception as e:
            import traceback
            error_str = str(e)
            print(f"[Group] å‰µå»ºç¾¤çµ„å¤±æ•—: {traceback.format_exc()}", file=sys.stderr)
            
            # æä¾›æ›´å‹å¥½çš„éŒ¯èª¤ä¿¡æ¯
            if 'FLOOD' in error_str.upper():
                friendly_error = "è«‹æ±‚éæ–¼é »ç¹ï¼Œè«‹ç¨å¾Œå†è©¦"
            elif 'PEER_FLOOD' in error_str.upper():
                friendly_error = "å¸³è™Ÿè¢«é™åˆ¶å‰µå»ºç¾¤çµ„ï¼Œè«‹æ›´æ›å¸³è™Ÿæˆ–ç¨å¾Œå†è©¦"
            elif 'AUTH' in error_str.upper():
                friendly_error = "å¸³è™Ÿèªè­‰å¤±æ•—ï¼Œè«‹é‡æ–°ç™»å…¥"
            elif 'TIMEOUT' in error_str.upper() or 'timeout' in error_str.lower():
                friendly_error = "é€£æ¥è¶…æ™‚ï¼Œè«‹æª¢æŸ¥ç¶²çµ¡"
            else:
                friendly_error = error_str
            
            self.send_log(f"âŒ å‰µå»ºç¾¤çµ„å¤±æ•—: {friendly_error}", "error")
            self.send_event("create-group-result", {
                "success": False,
                "error": friendly_error
            })

    # ==================== ğŸ”§ ç¾¤èŠå”ä½œï¼šç¾¤çµ„ç®¡ç†æ–¹æ³• ====================
    
    async def handle_group_invite_user(self, payload: Dict[str, Any]):
        """é‚€è«‹ç”¨æˆ¶åŠ å…¥ç¾¤çµ„ï¼ˆç¾¤èŠå”ä½œç”¨ï¼‰"""
        import sys
        
        try:
            group_id = payload.get('groupId')
            inviter_phone = payload.get('inviterPhone')
            target_user_id = payload.get('targetUserId')
            target_username = payload.get('targetUsername')
            
            print(f"[GroupCollab] é‚€è«‹ç”¨æˆ¶: group={group_id}, user={target_user_id or target_username}", file=sys.stderr)
            
            if not group_id or not inviter_phone:
                result = {"success": False, "error": "ç¼ºå°‘å¿…è¦åƒæ•¸"}
                self.send_event("group:invite-user-result", result)
                return result
            
            # ç²å–å®¢æˆ¶ç«¯
            client = self.telegram_manager.clients.get(inviter_phone)
            if not client or not client.is_connected:
                result = {"success": False, "error": f"å¸³è™Ÿ {inviter_phone} æœªé€£æ¥"}
                self.send_event("group:invite-user-result", result)
                return result
            
            # é‚€è«‹ç”¨æˆ¶
            try:
                # ç²å–ç”¨æˆ¶ ID
                if target_username:
                    user = await client.get_users(target_username)
                    user_id = user.id if hasattr(user, 'id') else user
                elif target_user_id:
                    user_id = int(target_user_id)
                else:
                    result = {"success": False, "error": "æœªæä¾›ç”¨æˆ¶åæˆ–ç”¨æˆ¶ID"}
                    self.send_event("group:invite-user-result", result)
                    return result
                
                print(f"[GroupCollab] æº–å‚™é‚€è«‹ç”¨æˆ¶ ID: {user_id} åˆ°ç¾¤çµ„ {group_id}", file=sys.stderr)
                
                # ğŸ”§ P0 ä¿®å¾©: å‚³å…¥ç”¨æˆ¶ ID (int) è€Œé User å°è±¡
                await client.add_chat_members(int(group_id), user_id)
                
                print(f"[GroupCollab] æˆåŠŸé‚€è«‹ç”¨æˆ¶ {target_user_id or target_username}", file=sys.stderr)
                
                # ğŸ†• P0 å„ªåŒ–: è¨˜éŒ„æ“ä½œåˆ°å°è©±è¨˜æ†¶ç³»çµ±
                try:
                    from conversation_memory import get_memory_service
                    memory_service = get_memory_service()
                    await memory_service.record_action(
                        user_id=str(user_id),
                        action_type='group_invite',
                        action_details={
                            'group_id': str(group_id),
                            'group_name': payload.get('groupName', 'VIPæœå‹™ç¾¤'),
                            'invite_method': 'direct'
                        },
                        performed_by=inviter_phone
                    )
                except Exception as mem_err:
                    print(f"[GroupCollab] è¨˜éŒ„æ“ä½œå¤±æ•—: {mem_err}", file=sys.stderr)
                
                result = {"success": True, "message": "é‚€è«‹æˆåŠŸ", "userId": user_id}
                self.send_event("group:invite-user-result", result)
                return result
                
            except Exception as invite_error:
                error_str = str(invite_error)
                print(f"[GroupCollab] é‚€è«‹å¤±æ•—: {error_str}", file=sys.stderr)
                
                if 'PEER_FLOOD' in error_str.upper():
                    result = {"success": False, "error": "PEER_FLOOD:è«‹æ±‚éæ–¼é »ç¹"}
                elif 'USER_PRIVACY' in error_str.upper() or 'PRIVACY' in error_str.upper():
                    result = {"success": False, "error": "USER_PRIVACY:ç”¨æˆ¶éš±ç§è¨­ç½®ä¸å…è¨±é‚€è«‹"}
                elif 'USER_NOT_MUTUAL' in error_str.upper():
                    result = {"success": False, "error": "USER_NOT_MUTUAL:éœ€è¦å…ˆäº’ç›¸æ·»åŠ å¥½å‹"}
                elif 'USER_ALREADY_PARTICIPANT' in error_str.upper():
                    # ç”¨æˆ¶å·²åœ¨ç¾¤ä¸­ï¼Œè¦–ç‚ºæˆåŠŸ
                    result = {"success": True, "message": "ç”¨æˆ¶å·²åœ¨ç¾¤çµ„ä¸­"}
                    self.send_event("group:invite-user-result", result)
                    return result
                else:
                    result = {"success": False, "error": error_str}
                
                self.send_event("group:invite-user-result", result)
                return result
                    
        except Exception as e:
            import traceback
            print(f"[GroupCollab] é‚€è«‹ç”¨æˆ¶ç•°å¸¸: {traceback.format_exc()}", file=sys.stderr)
            result = {"success": False, "error": str(e)}
            self.send_event("group:invite-user-result", result)
            return result
    
    async def handle_group_add_member(self, payload: Dict[str, Any]):
        """æ·»åŠ æˆå“¡åˆ°ç¾¤çµ„ï¼ˆé‚€è«‹å…¶ä»–å¸³è™Ÿï¼‰"""
        import sys
        
        try:
            group_id = payload.get('groupId')
            adder_phone = payload.get('adderPhone')
            member_phone = payload.get('memberPhone')
            
            print(f"[GroupCollab] æ·»åŠ æˆå“¡: group={group_id}, member={member_phone}", file=sys.stderr)
            
            if not group_id or not adder_phone or not member_phone:
                result = {"success": False, "error": "ç¼ºå°‘å¿…è¦åƒæ•¸"}
                self.send_event("group:add-member-result", result)
                return result
            
            # ç²å–é‚€è«‹è€…å®¢æˆ¶ç«¯
            adder_client = self.telegram_manager.clients.get(adder_phone)
            if not adder_client or not adder_client.is_connected:
                result = {"success": False, "error": f"é‚€è«‹å¸³è™Ÿ {adder_phone} æœªé€£æ¥"}
                self.send_event("group:add-member-result", result)
                return result
            
            # ç²å–è¢«é‚€è«‹è€…å®¢æˆ¶ç«¯ä»¥ç²å–å…¶ Telegram ç”¨æˆ¶ä¿¡æ¯
            member_client = self.telegram_manager.clients.get(member_phone)
            if not member_client or not member_client.is_connected:
                result = {"success": False, "error": f"æˆå“¡å¸³è™Ÿ {member_phone} æœªé€£æ¥"}
                self.send_event("group:add-member-result", result)
                return result
            
            try:
                # ç²å–æˆå“¡çš„ Telegram ç”¨æˆ¶ ID
                member_me = await member_client.get_me()
                member_user_id = member_me.id
                
                # ä½¿ç”¨é‚€è«‹è€…å¸³è™Ÿæ·»åŠ æˆå“¡
                await adder_client.add_chat_members(int(group_id), member_user_id)
                
                print(f"[GroupCollab] æˆåŠŸæ·»åŠ æˆå“¡ {member_phone} (ID: {member_user_id})", file=sys.stderr)
                result = {"success": True, "message": "æ·»åŠ æˆåŠŸ", "memberId": member_user_id}
                self.send_event("group:add-member-result", result)
                return result
                
            except Exception as add_error:
                error_str = str(add_error)
                print(f"[GroupCollab] æ·»åŠ æˆå“¡å¤±æ•—: {error_str}", file=sys.stderr)
                result = {"success": False, "error": error_str}
                self.send_event("group:add-member-result", result)
                return result
                
        except Exception as e:
            import traceback
            print(f"[GroupCollab] æ·»åŠ æˆå“¡ç•°å¸¸: {traceback.format_exc()}", file=sys.stderr)
            result = {"success": False, "error": str(e)}
            self.send_event("group:add-member-result", result)
            return result
    
    async def handle_group_send_msg(self, payload: Dict[str, Any]):
        """åœ¨ç¾¤çµ„ä¸­ç™¼é€æ¶ˆæ¯ï¼ˆç¾¤èŠå”ä½œç”¨ï¼‰"""
        import sys
        
        try:
            group_id = payload.get('groupId')
            sender_phone = payload.get('senderPhone')
            content = payload.get('content')
            role_name = payload.get('roleName', '')
            
            print(f"[GroupCollab] ç™¼é€æ¶ˆæ¯: group={group_id}, sender={sender_phone}, role={role_name}", file=sys.stderr)
            
            if not group_id or not sender_phone or not content:
                return {"success": False, "error": "ç¼ºå°‘å¿…è¦åƒæ•¸"}
            
            # ç²å–å®¢æˆ¶ç«¯
            client = self.telegram_manager.clients.get(sender_phone)
            if not client or not client.is_connected:
                return {"success": False, "error": f"å¸³è™Ÿ {sender_phone} æœªé€£æ¥"}
            
            try:
                # ç™¼é€æ¶ˆæ¯
                message = await client.send_message(int(group_id), content)
                
                print(f"[GroupCollab] æ¶ˆæ¯ç™¼é€æˆåŠŸ: msg_id={message.id}", file=sys.stderr)
                
                # ç™¼é€äº‹ä»¶é€šçŸ¥å‰ç«¯
                self.send_event("group:message-sent", {
                    "groupId": group_id,
                    "senderPhone": sender_phone,
                    "roleName": role_name,
                    "content": content,
                    "messageId": message.id,
                    "timestamp": message.date.isoformat() if message.date else None
                })
                
                return {"success": True, "messageId": message.id}
                
            except Exception as send_error:
                error_str = str(send_error)
                print(f"[GroupCollab] ç™¼é€æ¶ˆæ¯å¤±æ•—: {error_str}", file=sys.stderr)
                return {"success": False, "error": error_str}
                
        except Exception as e:
            import traceback
            print(f"[GroupCollab] ç™¼é€æ¶ˆæ¯ç•°å¸¸: {traceback.format_exc()}", file=sys.stderr)
            return {"success": False, "error": str(e)}

    # ==================== ğŸ†• P1-2: ç¾¤èŠå”ä½œæ¶ˆæ¯ç›£è½ ====================
    
    # å­˜å„²æ´»èºçš„ç¾¤çµ„å”ä½œ
    _active_group_collabs: Dict[str, Dict[str, Any]] = {}
    
    async def handle_group_monitor_messages(self, payload: Dict[str, Any]):
        """
        ğŸ†• Phase 1 é‡æ§‹: ä½¿ç”¨è¼ªè©¢æ¨¡å¼ç›£æ§ç¾¤çµ„æ¶ˆæ¯
        
        Args:
            groupId: ç¾¤çµ„ ID
            roles: è§’è‰²é…ç½®åˆ—è¡¨ [{phone, roleId, roleName, prompt}, ...]
            mainAccountPhone: ä¸»å¸³è™Ÿé›»è©±
        """
        import sys
        
        try:
            group_id = payload.get('groupId')
            roles = payload.get('roles', [])
            main_phone = payload.get('mainAccountPhone')
            
            print(f"[GroupCollab] ğŸš€ å•Ÿå‹•ç¾¤çµ„ç›£æ§ (è¼ªè©¢æ¨¡å¼): group={group_id}, roles={len(roles)}", file=sys.stderr)
            
            if not group_id or not roles:
                return {"success": False, "error": "ç¼ºå°‘ç¾¤çµ„ ID æˆ–è§’è‰²é…ç½®"}
            
            # ğŸ”§ Phase 1: ä½¿ç”¨ç¾¤çµ„è¼ªè©¢å™¨æ›¿ä»£äº‹ä»¶é©…å‹•
            group_poller = get_group_poller()()
            if not group_poller:
                # åˆå§‹åŒ–è¼ªè©¢å™¨
                group_poller = get_init_group_poller()(self.send_event)
                print(f"[GroupCollab] âœ“ å·²åˆå§‹åŒ–ç¾¤çµ„è¼ªè©¢å™¨", file=sys.stderr)
            
            # æ”¶é›†æ‰€æœ‰åœ¨ç·šå®¢æˆ¶ç«¯
            online_clients = {}
            for role in roles:
                phone = role.get('phone')
                client = self.telegram_manager.clients.get(phone)
                if client and client.is_connected:
                    online_clients[phone] = client
                    print(f"[GroupCollab] âœ“ å¸³è™Ÿ {phone} ({role.get('roleName', 'æœªçŸ¥')}) å·²é€£æ¥", file=sys.stderr)
                else:
                    print(f"[GroupCollab] âš  å¸³è™Ÿ {phone} æœªé€£æ¥", file=sys.stderr)
            
            if not online_clients:
                return {"success": False, "error": "æ²’æœ‰å¯ç”¨çš„åœ¨ç·šå¸³è™Ÿ"}
            
            # å•Ÿå‹•ç¾¤çµ„å”ä½œè¼ªè©¢
            result = await group_poller.start_group_collab(
                group_id=group_id,
                roles=roles,
                clients=online_clients,
                main_phone=main_phone
            )
            
            # è¨˜éŒ„æ´»èºçš„å”ä½œï¼ˆå‚™ä»½ï¼‰
            self._active_group_collabs[str(group_id)] = {
                'roles': roles,
                'main_phone': main_phone,
                'started_at': datetime.now().isoformat(),
                'message_count': 0,
                'last_responder': None,
                'polling_mode': True  # æ¨™è¨˜ç‚ºè¼ªè©¢æ¨¡å¼
            }
            
            print(f"[GroupCollab] âœ… ç¾¤çµ„ {group_id} è¼ªè©¢ç›£æ§å·²å•Ÿå‹•", file=sys.stderr)
            
            self.send_event("group:monitoring-started", {
                "groupId": group_id,
                "rolesCount": len(roles),
                "onlineClients": len(online_clients),
                "mode": "polling"
            })
            
            return {"success": True, "message": f"å·²é–‹å§‹è¼ªè©¢ç›£æ§ç¾¤çµ„ {group_id}"}
            
        except Exception as e:
            import traceback
            print(f"[GroupCollab] å•Ÿå‹•ç¾¤çµ„ç›£æ§å¤±æ•—: {traceback.format_exc()}", file=sys.stderr)
            return {"success": False, "error": str(e)}
    
    async def _handle_collab_group_message(self, client, message, target_group_id: str):
        """
        ğŸ†• è™•ç†ç¾¤èŠå”ä½œä¸­çš„æ¶ˆæ¯
        """
        import sys
        from pyrogram.enums import ChatType
        
        try:
            # åªè™•ç†ç¾¤çµ„æ¶ˆæ¯
            if message.chat.type not in [ChatType.GROUP, ChatType.SUPERGROUP]:
                return
            
            # åªè™•ç†ç›®æ¨™ç¾¤çµ„
            if str(message.chat.id) != str(target_group_id):
                return
            
            # ç²å–å”ä½œé…ç½®
            collab = self._active_group_collabs.get(str(target_group_id))
            if not collab:
                return
            
            # ç²å–ç™¼é€è€…ä¿¡æ¯
            sender_id = message.from_user.id if message.from_user else None
            sender_name = message.from_user.first_name if message.from_user else "Unknown"
            message_text = message.text or message.caption or ""
            
            if not message_text:
                return
            
            # æª¢æŸ¥æ˜¯å¦æ˜¯è§’è‰²å¸³è™Ÿç™¼çš„æ¶ˆæ¯ï¼ˆä¸å›è¦†è‡ªå·±ï¼‰
            role_phones = [r.get('phone') for r in collab.get('roles', [])]
            for phone in role_phones:
                role_client = self.telegram_manager.clients.get(phone)
                if role_client:
                    try:
                        me = await role_client.get_me()
                        if me.id == sender_id:
                            return  # ä¸å›è¦†è‡ªå·±
                    except:
                        pass
            
            print(f"[GroupCollab] æ”¶åˆ°ç¾¤æ¶ˆæ¯: from={sender_name}, text={message_text[:50]}...", file=sys.stderr)
            
            # ğŸ”§ P2-1: é¸æ“‡åˆé©çš„è§’è‰²å›è¦†ï¼ˆé¿å…æ‰€æœ‰è§’è‰²åŒæ™‚å›è¦†ï¼‰
            responding_role = await self._select_responding_role(collab, message_text, sender_id)
            
            if not responding_role:
                print(f"[GroupCollab] ç„¡åˆé©è§’è‰²å›è¦†æ­¤æ¶ˆæ¯", file=sys.stderr)
                return
            
            # ç”Ÿæˆ AI å›è¦†
            role_phone = responding_role.get('phone')
            role_name = responding_role.get('roleName', 'åŠ©æ‰‹')
            role_prompt = responding_role.get('prompt', '')
            
            try:
                # ä½¿ç”¨ AI ç”Ÿæˆå›è¦†
                from ai_auto_chat import ai_auto_chat
                
                # ğŸ†• P0-2: æœç´¢çŸ¥è­˜åº«ï¼Œç²å–ç›¸é—œå°ˆæ¥­å…§å®¹
                knowledge_context = ""
                matched_knowledge = []  # ğŸ†• P1-2: è¨˜éŒ„åŒ¹é…çš„çŸ¥è­˜ç”¨æ–¼å¯è¦–åŒ–
                
                try:
                    # æ–¹æ³•1: å¾ RAG ç³»çµ±æœç´¢
                    from telegram_rag_system import telegram_rag
                    if telegram_rag:
                        rag_context = await telegram_rag.build_rag_context(
                            user_message=message_text,
                            user_id=str(sender_id),
                            max_items=3,
                            max_tokens=500
                        )
                        if rag_context:
                            knowledge_context = rag_context
                            matched_knowledge.append({
                                'source': 'RAG',
                                'content': rag_context[:100] + '...' if len(rag_context) > 100 else rag_context
                            })
                            print(f"[GroupCollab] ğŸ“š å¾ RAG æ‰¾åˆ°ç›¸é—œçŸ¥è­˜", file=sys.stderr)
                    
                    # æ–¹æ³•2: å¾çŸ¥è­˜åº«è¡¨æœç´¢ï¼ˆå‚™ç”¨ï¼‰
                    if not knowledge_context:
                        from database import db
                        knowledge_items = await db.search_knowledge(message_text, limit=3)
                        if knowledge_items:
                            kb_parts = ["ã€æ¥­å‹™çŸ¥è­˜åƒè€ƒã€‘"]
                            for item in knowledge_items:
                                kb_parts.append(f"- {item.get('title')}: {item.get('content')}")
                                # ğŸ†• P1-2: è¨˜éŒ„æ¯æ¢åŒ¹é…çš„çŸ¥è­˜
                                matched_knowledge.append({
                                    'source': 'KnowledgeBase',
                                    'id': item.get('id'),
                                    'title': item.get('title'),
                                    'content': item.get('content', '')[:80]
                                })
                            knowledge_context = "\n".join(kb_parts)
                            print(f"[GroupCollab] ğŸ“š å¾çŸ¥è­˜åº«è¡¨æ‰¾åˆ° {len(knowledge_items)} æ¢çŸ¥è­˜", file=sys.stderr)
                except Exception as kb_err:
                    print(f"[GroupCollab] çŸ¥è­˜åº«æœç´¢å¤±æ•—: {kb_err}", file=sys.stderr)
                
                # æ§‹å»ºç¾¤èŠå°ˆç”¨ promptï¼ˆåŒ…å«çŸ¥è­˜åº«å…§å®¹ï¼‰
                group_prompt = f"""ä½ æ˜¯ç¾¤çµ„ä¸­çš„ã€Œ{role_name}ã€ï¼Œæ­£åœ¨åƒèˆ‡å¤šè§’è‰²å”ä½œæœå‹™å®¢æˆ¶ã€‚

{role_prompt}

{knowledge_context}

ã€ç¾¤èŠè¦å‰‡ã€‘
1. å›è¦†ç°¡çŸ­è‡ªç„¶ï¼ˆ10-50å­—ï¼‰ï¼Œåƒç¾¤èŠä¸€æ¨£
2. ä¸è¦é‡è¤‡å…¶ä»–è§’è‰²èªªéçš„è©±
3. å¾ä½ çš„è§’è‰²è§’åº¦æä¾›åƒ¹å€¼
4. å¦‚æœçŸ¥è­˜åº«æœ‰ç›¸é—œå…§å®¹ï¼Œå„ªå…ˆåƒè€ƒçŸ¥è­˜åº«å›ç­”
5. èªæ°£è¼•é¬†ï¼Œåƒæœ‹å‹èŠå¤©
"""
                
                # ç”Ÿæˆå›è¦†
                response = await ai_auto_chat._generate_response_with_prompt(
                    user_id=str(sender_id),
                    user_message=message_text,
                    custom_prompt=group_prompt,
                    usage_type='groupChat'
                )
                
                if response:
                    # æ·»åŠ éš¨æ©Ÿå»¶é²ï¼Œæ›´è‡ªç„¶
                    import random
                    delay = random.uniform(2, 8)
                    await asyncio.sleep(delay)
                    
                    # ç™¼é€å›è¦†
                    role_client = self.telegram_manager.clients.get(role_phone)
                    if role_client and role_client.is_connected:
                        await role_client.send_message(int(target_group_id), response)
                        
                        print(f"[GroupCollab] {role_name} å›è¦†: {response[:50]}...", file=sys.stderr)
                        
                        # æ›´æ–°çµ±è¨ˆ
                        collab['message_count'] = collab.get('message_count', 0) + 1
                        collab['last_responder'] = role_name
                        
                        # ç™¼é€äº‹ä»¶ï¼ˆğŸ†• P1-2: åŒ…å«çŸ¥è­˜å¼•ç”¨ä¿¡æ¯ï¼‰
                        self.send_event("group:ai-reply-sent", {
                            "groupId": target_group_id,
                            "roleName": role_name,
                            "content": response,
                            "replyTo": message_text[:50],
                            "knowledgeUsed": matched_knowledge if matched_knowledge else None,
                            "hasKnowledgeRef": len(matched_knowledge) > 0
                        })
                        
            except Exception as ai_err:
                print(f"[GroupCollab] AI å›è¦†ç”Ÿæˆå¤±æ•—: {ai_err}", file=sys.stderr)
                
        except Exception as e:
            import traceback
            print(f"[GroupCollab] è™•ç†ç¾¤æ¶ˆæ¯å¤±æ•—: {traceback.format_exc()}", file=sys.stderr)
    
    async def _select_responding_role(
        self, 
        collab: Dict[str, Any], 
        message: str, 
        sender_id: int
    ) -> Optional[Dict[str, Any]]:
        """
        ğŸ†• P2-1: é¸æ“‡åˆé©çš„è§’è‰²å›è¦†ï¼ˆé¿å…åˆ·å±ï¼‰
        """
        import random
        
        roles = collab.get('roles', [])
        if not roles:
            return None
        
        last_responder = collab.get('last_responder')
        
        # è¦å‰‡ï¼š
        # 1. å¦‚æœåªæœ‰ä¸€å€‹è§’è‰²ï¼Œå°±ç”¨å®ƒ
        # 2. å¦‚æœä¸Šæ¬¡æ˜¯æŸè§’è‰²å›è¦†ï¼Œé€™æ¬¡å„ªå…ˆè®“å…¶ä»–è§’è‰²å›è¦†
        # 3. æ ¹æ“šæ¶ˆæ¯å…§å®¹åŒ¹é…è§’è‰²ï¼ˆé—œéµè©ï¼‰
        # ğŸ”§ Phase 8: ç§»é™¤è·³éæ¦‚ç‡ï¼Œç¢ºä¿ç¾¤èŠå”ä½œæ™‚ä¸€å®šæœ‰å›è¦†
        # 4. ä¸å†ä½¿ç”¨éš¨æ©Ÿè·³éï¼Œæ”¹ç‚ºå»¶é²å›è¦†æ§åˆ¶é »ç‡
        
        # ğŸ”§ Phase 8: æ·»åŠ èª¿è©¦æ—¥èªŒ
        import sys
        print(f"[GroupCollab] ğŸ” é¸æ“‡å›è¦†è§’è‰²: roles={len(roles)}, last_responder={last_responder}", file=sys.stderr)
        
        available_roles = roles.copy()
        
        # å„ªå…ˆè®“ä¸åŒè§’è‰²å›è¦†
        if last_responder and len(available_roles) > 1:
            available_roles = [r for r in available_roles if r.get('roleName') != last_responder]
            if not available_roles:
                available_roles = roles  # å¦‚æœéæ¿¾å¾Œæ²’æœ‰äº†ï¼Œæ¢å¾©å…¨éƒ¨
        
        # æ ¹æ“šæ¶ˆæ¯å…§å®¹åŒ¹é…è§’è‰²
        message_lower = message.lower()
        
        # ç°¡å–®çš„é—œéµè©åŒ¹é…
        keyword_role_map = {
            'åƒ¹æ ¼': ['è²»ç‡åˆ†æå¸«', 'é¡§å•'],
            'å¤šå°‘éŒ¢': ['è²»ç‡åˆ†æå¸«', 'é¡§å•'],
            'è²»ç”¨': ['è²»ç‡åˆ†æå¸«', 'é¡§å•'],
            'æ€éº¼ç”¨': ['æŠ€è¡“æ”¯æŒ', 'å®¢æœ'],
            'å¦‚ä½•': ['æŠ€è¡“æ”¯æŒ', 'å®¢æœ'],
            'å•é¡Œ': ['æŠ€è¡“æ”¯æŒ', 'å®¢æœ'],
            'å®‰å…¨': ['å®‰å…¨é¡§å•', 'é¡§å•'],
            'å¯é ': ['å®‰å…¨é¡§å•', 'é¡§å•'],
            'æ¨è–¦': ['ç†±å¿ƒç¾¤å‹', 'è€ç”¨æˆ¶'],
            'å¥½ç”¨': ['ç†±å¿ƒç¾¤å‹', 'è€ç”¨æˆ¶'],
        }
        
        matched_roles = []
        for keyword, role_names in keyword_role_map.items():
            if keyword in message_lower:
                for role in available_roles:
                    if any(name in role.get('roleName', '') for name in role_names):
                        matched_roles.append(role)
        
        if matched_roles:
            return random.choice(matched_roles)
        
        # æ²’æœ‰åŒ¹é…çš„ï¼Œéš¨æ©Ÿé¸ä¸€å€‹
        return random.choice(available_roles) if available_roles else None

    async def handle_pause_monitoring(self, payload: Dict[str, Any]):
        """æš«åœç›£æ§ç¾¤çµ„"""
        try:
            group_id = payload.get('groupId')
            
            if not group_id:
                return
            
            await db.execute(
                "UPDATE monitored_groups SET is_active=0 WHERE id=?", (group_id,)
            )
            
            self.send_log(f"â¸ï¸ å·²æš«åœç›£æ§ç¾¤çµ„ ID: {group_id}", "info")
            
            # åˆ·æ–°ç¾¤çµ„åˆ—è¡¨
            await self.handle_get_monitored_groups()
            
        except Exception as e:
            self.send_log(f"âŒ æš«åœç›£æ§å¤±æ•—: {e}", "error")
    
    async def handle_resume_monitoring(self, payload: Dict[str, Any]):
        """æ¢å¾©ç›£æ§ç¾¤çµ„"""
        try:
            group_id = payload.get('groupId')
            
            if not group_id:
                return
            
            await db.execute(
                "UPDATE monitored_groups SET is_active=1 WHERE id=?", (group_id,)
            )
            
            self.send_log(f"â–¶ï¸ å·²æ¢å¾©ç›£æ§ç¾¤çµ„ ID: {group_id}", "info")
            
            # åˆ·æ–°ç¾¤çµ„åˆ—è¡¨
            await self.handle_get_monitored_groups()
            
        except Exception as e:
            self.send_log(f"âŒ æ¢å¾©ç›£æ§å¤±æ•—: {e}", "error")
    
    async def handle_add_keyword_set(self, payload: Dict[str, Any]):
        """Handle add-keyword-set command"""
        try:
            name = payload.get('name')
            
            if not name:
                error_msg = "é—œéµè©é›†åç¨±ä¸èƒ½ç‚ºç©º"
                self.send_log(error_msg, "error")
                self.send_event("keyword-set-error", {
                    "success": False,
                    "error": error_msg,
                    "name": name
                })
                return
            
            # Validate keyword set name
            is_valid, error = KeywordValidator.validate_keyword_set_name(name)
            if not is_valid:
                self.send_log(f"é©—è­‰éŒ¯èª¤: {error}", "error")
                self.send_event("keyword-set-validation-error", {
                    "errors": [error],
                    "name": name
                })
                self.send_event("keyword-set-error", {
                    "success": False,
                    "error": error,
                    "name": name
                })
                handle_error(
                    AppError(ErrorType.VALIDATION_ERROR, error, {"name": name}),
                    {"command": "add-keyword-set", "payload": payload}
                )
                return
            
            # Check if keyword set already exists
            try:
                existing_sets = await db.get_all_keyword_sets()
                for existing_set in existing_sets:
                    if existing_set.get('name') == name:
                        error_msg = f"é—œéµè©é›† '{name}' å·²å­˜åœ¨"
                        self.send_log(error_msg, "error")
                        self.send_event("keyword-set-error", {
                            "success": False,
                            "error": error_msg,
                            "name": name
                        })
                        return
            except Exception as check_err:
                import sys
                print(f"[Backend] Error checking existing keyword sets: {check_err}", file=sys.stderr)
                # Continue anyway, let the database handle the uniqueness constraint
            
            # Add keyword set
            try:
                keyword_set_id = await db.add_keyword_set(name)
                await db.add_log(f"é—œéµè©é›† '{name}' å·²æ·»åŠ ", "success")
                self.send_log(f"é—œéµè©é›† '{name}' æ·»åŠ æˆåŠŸ (ID: {keyword_set_id})", "success")
                self._invalidate_cache("keyword_sets")
                await self.send_keyword_sets_update()
                # Send success event
                self.send_event("keyword-set-error", {
                    "success": True,
                    "message": f"é—œéµè©é›† '{name}' æ·»åŠ æˆåŠŸ",
                    "keywordSetId": keyword_set_id,
                    "name": name
                })
            except Exception as db_err:
                import sys
                import traceback
                error_str = str(db_err).lower()
                error_details = traceback.format_exc()
                print(f"[Backend] Database error adding keyword set: {error_details}", file=sys.stderr)
                
                # Check for specific database errors
                if "unique" in error_str or "already exists" in error_str:
                    error_msg = f"é—œéµè©é›† '{name}' å·²å­˜åœ¨"
                elif "database" in error_str and ("locked" in error_str or "corrupt" in error_str or "malformed" in error_str):
                    error_msg = f"æ•¸æ“šåº«éŒ¯èª¤ï¼šæ•¸æ“šåº«å¯èƒ½å·²æå£ï¼Œè«‹ä½¿ç”¨ rebuild_database.py é‡å»ºæ•¸æ“šåº«"
                elif "no such table" in error_str:
                    error_msg = f"æ•¸æ“šåº«éŒ¯èª¤ï¼šé—œéµè©é›†è¡¨ä¸å­˜åœ¨ï¼Œè«‹é‡å»ºæ•¸æ“šåº«"
                else:
                    error_msg = f"æ·»åŠ é—œéµè©é›†å¤±æ•—: {str(db_err)}"
                
                self.send_log(error_msg, "error")
                await db.add_log(f"æ·»åŠ é—œéµè©é›†å¤±æ•—: {error_msg}", "error")
                self.send_event("keyword-set-error", {
                    "success": False,
                    "error": error_msg,
                    "name": name,
                    "details": str(db_err)
                })
        
        except ValidationError as e:
            self.send_log(f"é©—è­‰éŒ¯èª¤: {e.message}", "error")
            self.send_event("keyword-set-validation-error", {
                "errors": [e.message],
                "field": e.field
            })
            self.send_event("keyword-set-error", {
                "success": False,
                "error": e.message,
                "field": e.field
            })
        except Exception as e:
            import sys
            import traceback
            error_details = traceback.format_exc()
            error_msg = f"æ·»åŠ é—œéµè©é›†æ™‚ç™¼ç”ŸæœªçŸ¥éŒ¯èª¤: {str(e)}"
            print(f"[Backend] Unexpected error adding keyword set: {error_details}", file=sys.stderr)
            self.send_log(error_msg, "error")
            self.send_event("keyword-set-error", {
                "success": False,
                "error": error_msg,
                "details": str(e)
            })
            handle_error(e, {"command": "add-keyword-set", "payload": payload})
    
    async def handle_remove_keyword_set(self, payload: Dict[str, Any]):
        """Handle remove-keyword-set command - idempotent operation"""
        import sys
        try:
            set_id = payload.get('id')
            
            if set_id is None:
                error_msg = "é—œéµè©é›† ID ä¸èƒ½ç‚ºç©º"
                print(f"[Backend] Remove keyword set error: {error_msg}", file=sys.stderr)
                self.send_log(error_msg, "error")
                self.send_event("keyword-set-error", {
                    "success": False,
                    "error": error_msg
                })
                return
            
            print(f"[Backend] Removing keyword set with ID: {set_id}", file=sys.stderr)
            
            # Delete from database (idempotent - won't error if already deleted)
            await db.remove_keyword_set(set_id)
            print(f"[Backend] Keyword set {set_id} delete operation completed", file=sys.stderr)
            
            # Invalidate cache and send update
            self._invalidate_cache("keyword_sets")
            print(f"[Backend] Cache invalidated, sending keyword sets update...", file=sys.stderr)
            
            await self.send_keyword_sets_update()
            print(f"[Backend] Keyword sets update sent", file=sys.stderr)
            
            # Send success event (always success since delete is idempotent)
            self.send_event("keyword-set-error", {
                "success": True,
                "message": f"é—œéµè©é›† {set_id} åˆªé™¤æˆåŠŸ"
            })
        
        except Exception as e:
            import traceback
            error_details = traceback.format_exc()
            error_msg = f"åˆªé™¤é—œéµè©é›†å¤±æ•—: {str(e)}"
            print(f"[Backend] Error removing keyword set: {error_details}", file=sys.stderr)
            self.send_log(error_msg, "error")
            self.send_event("keyword-set-error", {
                "success": False,
                "error": error_msg,
                "details": str(e)
            })
    
    async def handle_add_keyword(self, payload: Dict[str, Any]):
        """Handle add-keyword command"""
        try:
            set_id = payload.get('setId')
            keyword = payload.get('keyword')
            is_regex = payload.get('isRegex', False)
            
            # Validate keyword
            is_valid, error = validate_keyword(keyword, is_regex)
            if not is_valid:
                self.send_log(f"Validation error: {error}", "error")
                self.send_event("keyword-validation-error", {
                    "errors": [error],
                    "keyword": keyword,
                    "is_regex": is_regex
                })
                handle_error(
                    AppError(ErrorType.VALIDATION_ERROR, error, {"keyword": keyword, "is_regex": is_regex}),
                    {"command": "add-keyword", "payload": payload}
                )
                return
            
            # æª¢æŸ¥é—œéµè©æ˜¯å¦å·²å­˜åœ¨
            existing_keywords = await db.get_keywords_by_set(set_id)
            keyword_exists = any(
                k.get('keyword') == keyword and k.get('isRegex') == is_regex 
                for k in existing_keywords
            )
            
            if keyword_exists:
                self.send_log(f"Keyword '{keyword}' already exists in set {set_id}", "warning")
                # ä»ç„¶ç™¼é€æ›´æ–°äº‹ä»¶ä»¥ç¢ºä¿å‰ç«¯ç‹€æ…‹åŒæ­¥
                await self.send_keyword_sets_update()
                return
            
            keyword_id = await db.add_keyword(set_id, keyword, is_regex)
            await db.add_log(f"Keyword '{keyword}' added to set {set_id}", "success")
            self._invalidate_cache("keyword_sets")
            await self.send_keyword_sets_update()
        
        except ValidationError as e:
            self.send_log(f"Validation error: {e.message}", "error")
            self.send_event("keyword-validation-error", {
                "errors": [e.message],
                "field": e.field
            })
        except Exception as e:
            self.send_log(f"Error adding keyword: {str(e)}", "error")
            handle_error(e, {"command": "add-keyword", "payload": payload})
    
    async def handle_remove_keyword(self, payload: Dict[str, Any]):
        """Handle remove-keyword command"""
        try:
            keyword_id = payload.get('keywordId')
            set_id = payload.get('setId')
            
            if not keyword_id:
                self.send_log("Error: keywordId is required", "error")
                return
            
            await db.remove_keyword(keyword_id)
            await db.add_log(f"Keyword {keyword_id} removed", "success")
            
            # ç¢ºä¿ç™¼é€æ›´æ–°äº‹ä»¶
            self._invalidate_cache("keyword_sets")
            await self.send_keyword_sets_update()
        
        except Exception as e:
            self.send_log(f"Error removing keyword: {str(e)}", "error")
            # å³ä½¿ç™¼ç”ŸéŒ¯èª¤ï¼Œä¹Ÿç™¼é€æ›´æ–°äº‹ä»¶ä»¥ç¢ºä¿å‰ç«¯ç‹€æ…‹åŒæ­¥
            try:
                await self.send_keyword_sets_update()
            except:
                pass
    
    async def handle_add_group(self, payload: Dict[str, Any]):
        """Handle add-group command"""
        try:
            url = payload.get('url')
            name = payload.get('name', url)  # Use URL as name if not provided
            keyword_set_ids = payload.get('keywordSetIds', [])
            
            # Validate group URL
            is_valid, error = validate_group_url(url)
            if not is_valid:
                self.send_log(f"Validation error: {error}", "error")
                self.send_event("group-validation-error", {
                    "errors": [error],
                    "url": url
                })
                handle_error(
                    AppError(ErrorType.VALIDATION_ERROR, error, {"url": url}),
                    {"command": "add-group", "payload": payload}
                )
                return
            
            # Validate group name (optional)
            if name:
                is_valid, error = GroupValidator.validate_group_name(name)
                if not is_valid:
                    self.send_log(f"Validation error: {error}", "error")
                    self.send_event("group-validation-error", {
                        "errors": [error],
                        "name": name
                    })
                    handle_error(
                        AppError(ErrorType.VALIDATION_ERROR, error, {"name": name}),
                        {"command": "add-group", "payload": payload}
                    )
                    return
            
            # ========== æ–°å¢ï¼šé æª¢æŸ¥ç›£æ§è™Ÿå…¥ç¾¤ç‹€æ…‹ ==========
            membership_status = None
            accounts = await db.get_all_accounts()
            listener_accounts = [a for a in accounts if a.get('role') == 'Listener' and a.get('status') == 'Online']
            
            if listener_accounts:
                # Check if any listener account is in this group
                for account in listener_accounts:
                    phone = account.get('phone')
                    try:
                        check_result = await self.telegram_manager.check_group_membership(phone, url)
                        if check_result.get("is_member"):
                            membership_status = {
                                "is_member": True,
                                "account": phone,
                                "chat_title": check_result.get("chat_title"),
                                "members_count": check_result.get("members_count", 0)
                            }
                            # æ›´æ–°ç¾¤çµ„æˆå“¡æ•¸åˆ°æ•¸æ“šåº«
                            members_count = check_result.get("members_count", 0)
                            if members_count > 0:
                                await db.update_group_member_count(url, members_count)
                            break
                        elif check_result.get("can_join"):
                            membership_status = {
                                "is_member": False,
                                "can_join": True,
                                "is_private": check_result.get("is_private", False),
                                "reason": check_result.get("reason")
                            }
                    except Exception as e:
                        import sys
                        print(f"[Backend] Error checking membership for {url}: {e}", file=sys.stderr)
            
            # Send membership status event
            if membership_status:
                self.send_event("group-membership-status", {
                    "url": url,
                    "status": membership_status
                })
                
                if membership_status.get("is_member"):
                    self.send_log(f"âœ“ ç›£æ§è™Ÿå·²åœ¨ç¾¤çµ„ä¸­: {membership_status.get('chat_title', url)}", "success")
                elif membership_status.get("can_join"):
                    if membership_status.get("is_private"):
                        self.send_log(f"âš  ç›£æ§è™ŸæœªåŠ å…¥æ­¤ç¾¤çµ„ï¼ˆç§æœ‰ç¾¤ï¼‰ï¼Œéœ€è¦æ‰‹å‹•åŠ å…¥: {url}", "warning")
                    else:
                        self.send_log(f"â„¹ ç›£æ§è™ŸæœªåŠ å…¥æ­¤ç¾¤çµ„ï¼ˆå…¬é–‹ç¾¤ï¼‰ï¼Œå•Ÿå‹•ç›£æ§æ™‚å°‡è‡ªå‹•åŠ å…¥: {url}", "info")
            else:
                if listener_accounts:
                    self.send_log(f"âš  ç„¡æ³•æª¢æŸ¥ç¾¤çµ„æˆå“¡ç‹€æ…‹: {url}", "warning")
                else:
                    self.send_log(f"â„¹ æ²’æœ‰åœ¨ç·šç›£æ§è™Ÿï¼Œç„¡æ³•æª¢æŸ¥ç¾¤çµ„ç‹€æ…‹: {url}", "info")
            
            # ========== çµæŸæ–°å¢ ==========
            
            # ä½¿ç”¨å¾ Telegram ç²å–çš„ç¾¤çµ„æ¨™é¡Œï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰
            group_title = name  # é è¨­ä½¿ç”¨å‚³å…¥çš„ nameï¼ˆé€šå¸¸æ˜¯ URLï¼‰
            if membership_status and membership_status.get("chat_title"):
                group_title = membership_status.get("chat_title")
            
            # Check if group already exists
            existing = await db.get_group_by_url(url)
            if existing:
                # Update existing group
                group_id = await db.add_group(url, group_title, keyword_set_ids)
                await db.add_log(f"Group '{group_title}' updated (URL already exists)", "info")
            else:
                # Add new group
                group_id = await db.add_group(url, group_title, keyword_set_ids)
                await db.add_log(f"Group '{group_title}' added", "success")
            await self.send_groups_update()
        
        except ValidationError as e:
            self.send_log(f"Validation error: {e.message}", "error")
            self.send_event("group-validation-error", {
                "errors": [e.message],
                "field": e.field
            })
        except Exception as e:
            self.send_log(f"Error adding group: {str(e)}", "error")
            handle_error(e, {"command": "add-group", "payload": payload})
    
    async def handle_search_groups(self, payload: Dict[str, Any]):
        """
        ğŸ”§ P0: è™•ç† search-groups å‘½ä»¤ - æœç´¢ Telegram ç¾¤çµ„/é »é“
        
        å‰ç«¯ç™¼é€æ ¼å¼:
        {
            keyword: string,
            sources: string[],  // ['telegram', 'jiso', 'tgstat', 'local']
            account_id: number,
            account_phone: string,
            limit: number
        }
        """
        import sys
        print(f"[Backend] handle_search_groups called with payload: {payload}", file=sys.stderr)
        
        try:
            keyword = payload.get('keyword', '')
            sources = payload.get('sources', ['telegram'])
            account_phone = payload.get('account_phone')
            limit = payload.get('limit', 50)
            
            if not keyword:
                self.send_event("search-results", {
                    "success": False,
                    "error": "æœç´¢é—œéµè©ä¸èƒ½ç‚ºç©º",
                    "groups": []
                })
                return
            
            # ğŸ”§ P0: é¡¯ç¤ºæœç´¢æº
            sources_str = ', '.join(sources) if sources else 'telegram'
            self.send_log(f"ğŸ” é–‹å§‹æœç´¢ç¾¤çµ„: {keyword} (ä¾†æº: {sources_str})", "info")
            
            # ğŸ”§ P0: ç¢ºä¿è¨­ç½® Telegram å®¢æˆ¶ç«¯å’Œäº‹ä»¶å›èª¿
            group_search_service.set_clients(self.telegram_manager.clients)
            group_search_service.set_event_callback(self.send_event)
            jiso_search_service.set_clients(self.telegram_manager.clients)
            jiso_search_service.set_event_callback(self.send_event)
            
            # æª¢æŸ¥æ˜¯å¦æœ‰å¯ç”¨çš„é€£æ¥å¸³è™Ÿ
            connected_clients = {p: c for p, c in self.telegram_manager.clients.items() if c.is_connected}
            if not connected_clients:
                self.send_log("âš ï¸ æ²’æœ‰å·²é€£æ¥çš„å¸³è™Ÿå¯ç”¨æ–¼æœç´¢", "warning")
                self.send_event("search-results", {
                    "success": False,
                    "error": "æ²’æœ‰å·²é€£æ¥çš„å¸³è™Ÿï¼Œè«‹å…ˆç™»éŒ„å¸³è™Ÿ",
                    "groups": []
                })
                return
            
            print(f"[Backend] Available connected clients: {list(connected_clients.keys())}", file=sys.stderr)
            print(f"[Backend] Search sources: {sources}", file=sys.stderr)
            
            # ğŸ”§ P0: æ”¶é›†æ‰€æœ‰æœç´¢çµæœ
            all_groups = []
            seen_ids = set()
            
            # ğŸ”§ P0: æ ¹æ“š sources åƒæ•¸èª¿ç”¨ä¸åŒçš„æœç´¢æœå‹™
            try:
                # æœç´¢æº 1: Telegram å®˜æ–¹ API (telegram, official)
                if any(s in sources for s in ['telegram', 'official']):
                    self.send_log("ğŸ“± ä½¿ç”¨ Telegram å®˜æ–¹ API æœç´¢...", "info")
                    try:
                        telegram_results = await asyncio.wait_for(
                            group_search_service.search_groups(
                                query=keyword,
                                phone=account_phone,
                                limit=limit,
                                search_type='all'
                            ),
                            timeout=30.0
                        )
                        if telegram_results:
                            for r in telegram_results:
                                tid = str(r.telegram_id) if hasattr(r, 'telegram_id') else str(r.id)
                                if tid not in seen_ids:
                                    seen_ids.add(tid)
                                    all_groups.append({
                                        "id": r.id if hasattr(r, 'id') else None,
                                        "telegram_id": tid,
                                        "title": r.title if hasattr(r, 'title') else "æœªçŸ¥",
                                        "username": r.username if hasattr(r, 'username') else None,
                                        "description": r.description if hasattr(r, 'description') else None,
                                        "member_count": r.member_count if hasattr(r, 'member_count') else 0,
                                        "type": r.type if hasattr(r, 'type') else "group",
                                        "score": r.score if hasattr(r, 'score') else 0,
                                        "source": "telegram"
                                    })
                            self.send_log(f"ğŸ“± Telegram API æ‰¾åˆ° {len(telegram_results)} å€‹çµæœ", "info")
                            
                            # ğŸ”§ P1: æµå¼è¿”å› - Telegram çµæœå…ˆç™¼é€
                            if all_groups:
                                self.send_event("search-batch", {
                                    "success": True,
                                    "groups": all_groups.copy(),
                                    "source": "telegram",
                                    "total": len(all_groups),
                                    "isPartial": True,
                                    "message": f"å®˜æ–¹æœç´¢æ‰¾åˆ° {len(all_groups)} å€‹çµæœï¼Œæ­£åœ¨ç¹¼çºŒæœç´¢..."
                                })
                    except asyncio.TimeoutError:
                        self.send_log("âš ï¸ Telegram API æœç´¢è¶…æ™‚", "warning")
                    except Exception as e:
                        self.send_log(f"âš ï¸ Telegram API æœç´¢å¤±æ•—: {e}", "warning")
                
                # æœç´¢æº 2: Jiso ä¸­æ–‡æœç´¢ (jiso, chinese)
                if any(s in sources for s in ['jiso', 'chinese']):
                    self.send_log("ğŸ” ä½¿ç”¨æ¥µæœ (Jiso) ä¸­æ–‡æœç´¢...", "info")
                    jiso_start = time.time()
                    try:
                        # ğŸ”§ P0: å¢åŠ è¶…æ™‚æ™‚é–“åˆ° 90 ç§’ï¼ˆJiso æœç´¢åŒ…å«è©³æƒ…ç²å–ï¼Œéœ€è¦æ›´é•·æ™‚é–“ï¼‰
                        jiso_result = await asyncio.wait_for(
                            jiso_search_service.search(
                                keyword=keyword,
                                phone=account_phone,
                                limit=limit
                            ),
                            timeout=90.0
                        )
                        jiso_duration = time.time() - jiso_start
                        self.send_log(f"ğŸ” æ¥µæœæœç´¢å®Œæˆï¼Œè€—æ™‚: {jiso_duration:.1f}ç§’", "info")
                        
                        # ğŸ”§ P0: æ·»åŠ è©³ç´°æ—¥èªŒ
                        print(f"[Backend] Jiso result success={jiso_result.get('success')}, results_count={len(jiso_result.get('results', []))}", file=sys.stderr)
                        
                        if jiso_result.get('success') and jiso_result.get('results'):
                            jiso_groups = jiso_result['results']
                            added = 0
                            skipped_dup = 0
                            for g in jiso_groups:
                                # ğŸ”§ P0: ä½¿ç”¨å°ˆé–€çš„ dedup_key é€²è¡Œå»é‡
                                dedup_key = g.get('dedup_key', '')
                                username = g.get('username', '')
                                real_telegram_id = g.get('telegram_id')  # å¯èƒ½ç‚º None
                                
                                # å¦‚æœæ²’æœ‰ dedup_keyï¼Œä½¿ç”¨ username æˆ– link ä½œç‚ºå‚™é¸
                                if not dedup_key:
                                    if username:
                                        dedup_key = f"@{username}"
                                    elif g.get('link'):
                                        dedup_key = g.get('link')
                                    else:
                                        dedup_key = f"title:{g.get('title', '')}"
                                
                                if dedup_key and dedup_key not in seen_ids:
                                    seen_ids.add(dedup_key)
                                    # å¦‚æœæœ‰ username ä¹ŸåŠ å…¥å»é‡é›†åˆ
                                    if username and f"@{username}" not in seen_ids:
                                        seen_ids.add(f"@{username}")
                                    
                                    all_groups.append({
                                        "telegram_id": real_telegram_id,  # ğŸ”§ çœŸå¯¦ IDï¼ˆå¯ç‚º Noneï¼‰
                                        "title": g.get('title', 'æœªçŸ¥'),
                                        "username": username,
                                        "description": g.get('description'),
                                        "member_count": g.get('member_count', 0),
                                        "type": g.get('chat_type') or g.get('type', 'group'),
                                        "score": g.get('score', 0),
                                        "source": "jiso",
                                        "link": g.get('link')
                                    })
                                    added += 1
                                elif dedup_key:
                                    skipped_dup += 1
                            self.send_log(f"ğŸ” æ¥µæœæ‰¾åˆ° {len(jiso_groups)} å€‹çµæœï¼Œæ·»åŠ  {added} å€‹æ–°çµæœï¼ˆè·³é {skipped_dup} å€‹é‡è¤‡ï¼‰", "info")
                            
                            # ğŸ”§ P1: æµå¼è¿”å› - Jiso çµæœè¿½åŠ ç™¼é€
                            if added > 0:
                                self.send_event("search-batch", {
                                    "success": True,
                                    "groups": all_groups.copy(),
                                    "source": "jiso",
                                    "total": len(all_groups),
                                    "isPartial": True,
                                    "message": f"æ¥µæœæ–°å¢ {added} å€‹çµæœï¼Œå…± {len(all_groups)} å€‹"
                                })
                        else:
                            error_msg = jiso_result.get('error', 'ç„¡çµæœ')
                            self.send_log(f"ğŸ” æ¥µæœæœç´¢: {error_msg}", "info")
                    except asyncio.TimeoutError:
                        self.send_log("âš ï¸ æ¥µæœæœç´¢è¶…æ™‚", "warning")
                    except Exception as e:
                        self.send_log(f"âš ï¸ æ¥µæœæœç´¢å¤±æ•—: {e}", "warning")
                
                # æœç´¢æº 3: æœ¬åœ°è³‡æºåº« (local)
                if 'local' in sources:
                    self.send_log("ğŸ“‚ æœç´¢æœ¬åœ°è³‡æºåº«...", "info")
                    try:
                        # å¾è³‡æºç™¼ç¾æ•¸æ“šåº«æœç´¢
                        local_results = await resource_discovery.search_resources(keyword, limit=limit)
                        if local_results:
                            added = 0
                            for r in local_results:
                                tid = str(r.telegram_id) if r.telegram_id else ''
                                if tid and tid not in seen_ids:
                                    seen_ids.add(tid)
                                    all_groups.append({
                                        "id": r.id,
                                        "telegram_id": tid,
                                        "title": r.title or "æœªçŸ¥",
                                        "username": r.username,
                                        "description": r.description,
                                        "member_count": r.member_count or 0,
                                        "type": r.resource_type or "group",
                                        "score": r.overall_score or 0,
                                        "source": "local"
                                    })
                                    added += 1
                            self.send_log(f"ğŸ“‚ æœ¬åœ°è³‡æºåº«æ‰¾åˆ° {added} å€‹çµæœ", "info")
                    except Exception as e:
                        self.send_log(f"âš ï¸ æœ¬åœ°æœç´¢å¤±æ•—: {e}", "warning")
                
                # ğŸ”§ P0: æ·»åŠ è©³ç´°æ—¥èªŒ
                total_before_sort = len(all_groups)
                print(f"[Backend] ğŸ” åˆä½µå¾Œç¸½çµæœæ•¸: {total_before_sort}", file=sys.stderr)
                
                # ğŸ”§ P0: ç›¸é—œæ€§å„ªå…ˆæ’åº - æ¨™é¡ŒåŒ…å«é—œéµè©çš„æ’å‰é¢
                keyword_lower = keyword.lower()
                keywords = [k.strip().lower() for k in keyword.split() if k.strip()]
                
                def calculate_relevance_score(group):
                    """è¨ˆç®—ç›¸é—œæ€§åˆ†æ•¸"""
                    score = 0
                    title = (group.get('title') or '').lower()
                    username = (group.get('username') or '').lower()
                    description = (group.get('description') or '').lower()
                    
                    for kw in keywords:
                        # æ¨™é¡ŒåŒ…å«é—œéµè©ï¼š+1000 åˆ†
                        if kw in title:
                            score += 1000
                            # æ¨™é¡Œä»¥é—œéµè©é–‹é ­ï¼šé¡å¤– +500 åˆ†
                            if title.startswith(kw):
                                score += 500
                        # ç”¨æˆ¶ååŒ…å«é—œéµè©ï¼š+800 åˆ†
                        if kw in username:
                            score += 800
                        # æè¿°åŒ…å«é—œéµè©ï¼š+200 åˆ†
                        if kw in description:
                            score += 200
                    
                    return score
                
                # è¨ˆç®—æ¯å€‹çµæœçš„ç›¸é—œæ€§åˆ†æ•¸
                for g in all_groups:
                    g['_relevance_score'] = calculate_relevance_score(g)
                
                # å…ˆæŒ‰ç›¸é—œæ€§æ’åºï¼Œç›¸é—œæ€§ç›¸åŒæ™‚æŒ‰æˆå“¡æ•¸æ’åº
                all_groups.sort(key=lambda x: (x.get('_relevance_score', 0), x.get('member_count', 0)), reverse=True)
                
                # çµ±è¨ˆç›¸é—œæ€§
                highly_relevant = sum(1 for g in all_groups if g.get('_relevance_score', 0) >= 1000)
                self.send_log(f"ğŸ“Š æ’åº: {highly_relevant} å€‹é«˜åº¦ç›¸é—œï¼ˆæ¨™é¡Œå«é—œéµè©ï¼‰", "info")
                
                # ğŸ”§ P0: è»Ÿé™åˆ¶ - æœ€å¤šè¿”å› 500 å€‹ï¼ˆé¿å…å…§å­˜å•é¡Œï¼‰
                MAX_RESULTS = 500
                total_after_limit = min(len(all_groups), MAX_RESULTS)
                all_groups = all_groups[:MAX_RESULTS]
                
                # çµ±è¨ˆå„ä¾†æºçµæœæ•¸
                source_counts = {}
                for g in all_groups:
                    src = g.get('source', 'unknown')
                    source_counts[src] = source_counts.get(src, 0) + 1
                
                source_summary = ', '.join([f"{k}: {v}" for k, v in source_counts.items()])
                print(f"[Backend] ğŸ” æœ€çµ‚çµæœ: {len(all_groups)} å€‹ ({source_summary})", file=sys.stderr)
                
                # ğŸ†• ä¿å­˜æœç´¢æ­·å²ä¸¦æ¨™è¨˜æ–°/èˆŠçµæœ
                try:
                    from search_history_service import get_search_history_service
                    search_history = get_search_history_service()
                    
                    search_start_time = time.time()
                    history_result = search_history.save_search_with_results(
                        keyword=keyword,
                        results=all_groups,
                        account_phone=account_phone,
                        sources=sources,
                        duration_ms=(time.time() - search_start_time) * 1000
                    )
                    
                    new_count = history_result.get('new_count', 0)
                    existing_count = history_result.get('existing_count', 0)
                    
                    # æ›´æ–°çµæœæ·»åŠ æ–°/èˆŠæ¨™è¨˜
                    updated_groups = history_result.get('results', all_groups)
                    for g in updated_groups:
                        g['is_new'] = g.pop('_is_new', False)
                        g['member_change'] = g.pop('_member_change', 0)
                        # æ¸…ç†å…§éƒ¨å­—æ®µ
                        g.pop('_resource_id', None)
                        g.pop('_position', None)
                    
                    all_groups = updated_groups
                    
                    self.send_log(f"ğŸ“Š æ­·å²å°æ¯”: ğŸ†• æ–°ç™¼ç¾ {new_count} å€‹ï¼ŒğŸ”„ å·²çŸ¥ {existing_count} å€‹", "info")
                    
                except Exception as history_error:
                    print(f"[Backend] ä¿å­˜æœç´¢æ­·å²å¤±æ•—: {history_error}", file=sys.stderr)
                    # ç¹¼çºŒåŸ·è¡Œï¼Œä¸å½±éŸ¿æœç´¢çµæœè¿”å›
                    new_count = 0
                    existing_count = len(all_groups)
                
                self.send_log(f"âœ… æœç´¢å®Œæˆ: å…±æ‰¾åˆ° {len(all_groups)} å€‹çµæœ ({source_summary})", "success")
                
                # ğŸ”§ P0-1: èˆ‡ç›£æ§ç¾¤çµ„è¡¨åŒ¹é…ï¼Œæ¨™è¨˜å·²åŠ å…¥ç‹€æ…‹
                try:
                    joined_count = 0
                    # ç²å–æ‰€æœ‰ç›£æ§ç¾¤çµ„çš„ username å’Œ telegram_id
                    monitored_groups_data = await db.fetch_all(
                        "SELECT id, link, name, phone, telegram_id FROM monitored_groups WHERE is_active = 1"
                    )
                    
                    # å»ºç«‹ç´¢å¼•ç”¨æ–¼å¿«é€ŸåŒ¹é…
                    monitored_by_username = {}
                    monitored_by_telegram_id = {}
                    for mg in monitored_groups_data:
                        link = mg.get('link', '') or ''
                        tg_id = str(mg.get('telegram_id', '')) if mg.get('telegram_id') else ''
                        phone = mg.get('phone', '')
                        name = mg.get('name', '')
                        
                        # å¾ link æå– usernameï¼ˆæ ¼å¼: https://t.me/usernameï¼‰
                        if '/t.me/' in link:
                            username = link.split('/t.me/')[-1].strip('/')
                            if username:
                                monitored_by_username[username.lower()] = {'phone': phone, 'name': name}
                        elif link.startswith('@'):
                            username = link[1:]
                            if username:
                                monitored_by_username[username.lower()] = {'phone': phone, 'name': name}
                        
                        # é€šé telegram_id åŒ¹é…
                        if tg_id:
                            monitored_by_telegram_id[tg_id] = {'phone': phone, 'name': name}
                    
                    # æ¨™è¨˜æœç´¢çµæœä¸­å·²åŠ å…¥çš„ç¾¤çµ„
                    for g in all_groups:
                        username = (g.get('username') or '').lower().lstrip('@')
                        tg_id = str(g.get('telegram_id', '')) if g.get('telegram_id') else ''
                        
                        joined_info = None
                        if username and username in monitored_by_username:
                            joined_info = monitored_by_username[username]
                        elif tg_id and tg_id in monitored_by_telegram_id:
                            joined_info = monitored_by_telegram_id[tg_id]
                        
                        if joined_info:
                            g['status'] = 'joined'
                            g['joined_phone'] = joined_info.get('phone', '')
                            joined_count += 1
                        else:
                            g['status'] = 'discovered'
                            g['joined_phone'] = None
                    
                    if joined_count > 0:
                        self.send_log(f"ğŸ“Š ç‹€æ…‹åŒæ­¥: {joined_count} å€‹ç¾¤çµ„å·²åŠ å…¥ç›£æ§", "info")
                        
                except Exception as sync_err:
                    print(f"[Backend] ç›£æ§ç¾¤çµ„ç‹€æ…‹åŒæ­¥å¤±æ•—: {sync_err}", file=sys.stderr)
                    # ç¹¼çºŒåŸ·è¡Œï¼Œé»˜èªæ‰€æœ‰ç‚º discovered
                    for g in all_groups:
                        if 'status' not in g:
                            g['status'] = 'discovered'
                            g['joined_phone'] = None
                
                self.send_event("search-results", {
                    "success": True,
                    "keyword": keyword,
                    "groups": all_groups,
                    "total": len(all_groups),
                    "sources": sources,
                    "source_counts": source_counts,
                    "new_count": new_count,           # ğŸ†• æ–°ç™¼ç¾æ•¸é‡
                    "existing_count": existing_count  # ğŸ†• å·²çŸ¥æ•¸é‡
                })
                
            except asyncio.TimeoutError:
                self.send_log("âš ï¸ æœç´¢è¶…æ™‚", "warning")
                self.send_event("search-results", {
                    "success": False,
                    "error": "æœç´¢è¶…æ™‚ï¼Œè«‹ç¨å¾Œé‡è©¦",
                    "groups": []
                })
                
        except Exception as e:
            import traceback
            print(f"[Backend] search-groups error: {e}", file=sys.stderr)
            traceback.print_exc(file=sys.stderr)
            self.send_log(f"âŒ æœç´¢å¤±æ•—: {str(e)}", "error")
            self.send_event("search-results", {
                "success": False,
                "error": str(e),
                "groups": []
            })
    
    async def handle_join_group(self, payload: Dict[str, Any]):
        """Handle join-group command - manually join a group with a specific account"""
        import sys
        print(f"[Backend] handle_join_group called with payload: {payload}", file=sys.stderr)
        
        try:
            phone = payload.get('phone')
            group_url = payload.get('groupUrl')
            
            print(f"[Backend] Extracted phone={phone}, group_url={group_url}", file=sys.stderr)
            
            if not phone or not group_url:
                self.send_log("ç¼ºå°‘å¿…è¦åƒæ•¸ï¼ˆé›»è©±æˆ–ç¾¤çµ„ URLï¼‰", "error")
                self.send_event("group-join-result", {
                    "success": False,
                    "phone": phone,
                    "groupUrl": group_url,
                    "error": "ç¼ºå°‘å¿…è¦åƒæ•¸"
                })
                return
            
            self.send_log(f"æ­£åœ¨å˜—è©¦è®“ {phone} åŠ å…¥ç¾¤çµ„ {group_url}...", "info")
            
            # Use telegram manager to join the group
            result = await self.telegram_manager.join_group(phone, group_url)
            
            if result.get("success"):
                if result.get("already_member"):
                    self.send_log(f"âœ“ {phone} å·²ç¶“åœ¨ç¾¤çµ„ä¸­: {result.get('chat_title', group_url)}", "success")
                else:
                    self.send_log(f"âœ“ {phone} æˆåŠŸåŠ å…¥ç¾¤çµ„: {result.get('chat_title', group_url)}", "success")
                
                # Send success event
                self.send_event("group-join-result", {
                    "success": True,
                    "phone": phone,
                    "groupUrl": group_url,
                    "chatTitle": result.get("chat_title"),
                    "chatId": result.get("chat_id"),
                    "alreadyMember": result.get("already_member", False)
                })
            else:
                error_msg = result.get("error", "æœªçŸ¥éŒ¯èª¤")
                self.send_log(f"âœ— {phone} åŠ å…¥ç¾¤çµ„å¤±æ•—: {error_msg}", "error")
                
                # Send failure event
                self.send_event("group-join-result", {
                    "success": False,
                    "phone": phone,
                    "groupUrl": group_url,
                    "error": error_msg
                })
        
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_log(f"åŠ å…¥ç¾¤çµ„æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}", "error")
            self.send_event("group-join-result", {
                "success": False,
                "phone": payload.get('phone'),
                "groupUrl": payload.get('groupUrl'),
                "error": str(e)
            })
    
    async def handle_remove_group(self, payload: Dict[str, Any]):
        """Handle remove-group command - ç§»é™¤ç›£æ§ç¾¤çµ„"""
        try:
            # ğŸ†• æ”¯æŒå¤šç¨®åƒæ•¸åç¨±
            group_id = payload.get('id') or payload.get('groupId')
            
            if not group_id:
                self.send_log("âŒ ç§»é™¤ç¾¤çµ„å¤±æ•—: ç¼ºå°‘ç¾¤çµ„ ID", "error")
                self.send_event("remove-group-result", {"success": False, "error": "ç¼ºå°‘ç¾¤çµ„ ID"})
                return
            
            self.send_log(f"ğŸ—‘ï¸ æ­£åœ¨ç§»é™¤ç›£æ§ç¾¤çµ„: {group_id}", "info")
            
            # å˜—è©¦å¤šç¨®æ–¹å¼åˆªé™¤
            deleted = False
            
            # æ–¹å¼1: æŒ‰ ID åˆªé™¤ï¼ˆå¦‚æœæ˜¯æ•¸å­—ï¼‰
            if isinstance(group_id, int) or (isinstance(group_id, str) and group_id.lstrip('-').isdigit()):
                numeric_id = int(group_id) if isinstance(group_id, str) else group_id
                result = await db.execute('DELETE FROM monitored_groups WHERE id = ?', (numeric_id,))
                if result > 0:
                    deleted = True
                    self.send_log(f"âœ… å·²æŒ‰ ID åˆªé™¤: {numeric_id}", "success")
            
            # æ–¹å¼2: æŒ‰ telegram_id åˆªé™¤
            if not deleted:
                result = await db.execute('DELETE FROM monitored_groups WHERE telegram_id = ?', (str(group_id),))
                if result > 0:
                    deleted = True
                    self.send_log(f"âœ… å·²æŒ‰ telegram_id åˆªé™¤: {group_id}", "success")
            
            # æ–¹å¼3: æŒ‰ link åŒ…å«çš„æ¨™è­˜ç¬¦åˆªé™¤
            if not deleted:
                result = await db.execute('DELETE FROM monitored_groups WHERE link LIKE ?', (f'%{group_id}%',))
                if result > 0:
                    deleted = True
                    self.send_log(f"âœ… å·²æŒ‰ link åˆªé™¤: {group_id}", "success")
            
            # æ–¹å¼4: æŒ‰ name åˆªé™¤
            if not deleted:
                result = await db.execute('DELETE FROM monitored_groups WHERE name = ?', (str(group_id),))
                if result > 0:
                    deleted = True
                    self.send_log(f"âœ… å·²æŒ‰ name åˆªé™¤: {group_id}", "success")
            
            if deleted:
                await db.add_log(f"ç›£æ§ç¾¤çµ„å·²ç§»é™¤: {group_id}", "success")
                self.send_event("remove-group-result", {"success": True, "groupId": group_id})
            else:
                self.send_log(f"âš ï¸ æœªæ‰¾åˆ°è¦åˆªé™¤çš„ç¾¤çµ„: {group_id}", "warning")
                self.send_event("remove-group-result", {"success": False, "error": "æœªæ‰¾åˆ°ç¾¤çµ„"})
            
            # åˆ·æ–°å‰ç«¯ç¾¤çµ„åˆ—è¡¨
            await self.send_groups_update()
        
        except Exception as e:
            import traceback
            traceback.print_exc()
            self.send_log(f"âŒ ç§»é™¤ç¾¤çµ„å¤±æ•—: {str(e)}", "error")
            self.send_event("remove-group-result", {"success": False, "error": str(e)})
    
    async def handle_leave_group(self, payload: Dict[str, Any]):
        """å¾ Telegram é€€å‡ºç¾¤çµ„"""
        try:
            phone = payload.get('phone')
            group_id = payload.get('groupId')
            resource_id = payload.get('resourceId')
            
            if not phone or not group_id:
                raise ValueError("ç¼ºå°‘å¿…è¦åƒæ•¸ï¼šphone æˆ– groupId")
            
            self.send_log(f"ğŸšª æ­£åœ¨é€€å‡ºç¾¤çµ„: {group_id}", "info")
            
            # ç²å–å¸³è™Ÿçš„ Pyrogram client
            account = next((acc for acc in self.accounts if acc.get('phone') == phone), None)
            if not account:
                raise ValueError(f"æ‰¾ä¸åˆ°å¸³è™Ÿ: {phone}")
            
            client = account.get('client')
            if not client or not client.is_connected:
                raise ValueError(f"å¸³è™Ÿ {phone} æœªé€£æ¥")
            
            try:
                # ä½¿ç”¨ Pyrogram é€€å‡ºç¾¤çµ„
                await client.leave_chat(group_id)
                self.send_log(f"âœ… å·²é€€å‡ºç¾¤çµ„: {group_id}", "success")
            except Exception as leave_error:
                error_msg = str(leave_error)
                if 'not a member' in error_msg.lower() or 'not found' in error_msg.lower():
                    self.send_log(f"â„¹ï¸ å¸³è™Ÿä¸åœ¨æ­¤ç¾¤çµ„ä¸­", "info")
                else:
                    raise leave_error
            
            # å¾ç›£æ§åˆ—è¡¨ä¸­ç§»é™¤
            try:
                await db.remove_group(group_id)
            except Exception:
                pass  # å¯èƒ½ä¸åœ¨ç›£æ§åˆ—è¡¨ä¸­
            
            # æ›´æ–°è³‡æºç‹€æ…‹ç‚º discovered
            if resource_id:
                try:
                    await resource_discovery.db.execute(
                        "UPDATE discovered_resources SET status = 'discovered', joined_by_phone = NULL WHERE id = ?",
                        (resource_id,)
                    )
                    await resource_discovery.db._connection.commit()
                except Exception as db_error:
                    self.send_log(f"æ›´æ–°è³‡æºç‹€æ…‹å¤±æ•—: {db_error}", "warning")
            
            self.send_event("leave-group-complete", {
                "success": True,
                "groupId": group_id,
                "phone": phone
            })
            
            # åˆ·æ–°ç¾¤çµ„åˆ—è¡¨
            await self.send_groups_update()
            
        except Exception as e:
            self.send_log(f"âŒ é€€å‡ºç¾¤çµ„å¤±æ•—: {e}", "error")
            self.send_event("leave-group-complete", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_add_template(self, payload: Dict[str, Any]):
        """Handle add-template command"""
        try:
            # Validate template data
            is_valid, errors = validate_template(payload)
            if not is_valid:
                error_message = "Validation failed: " + "; ".join(errors)
                self.send_log(error_message, "error")
                self.send_event("template-validation-error", {
                    "errors": errors,
                    "template_data": payload
                })
                handle_error(
                    AppError(ErrorType.VALIDATION_ERROR, error_message, {"errors": errors}),
                    {"command": "add-template", "payload": payload}
                )
                return
            
            name = payload.get('name')
            prompt = payload.get('prompt')
            
            # Check if template with same name already exists
            existing = await db.get_template_by_name(name)
            if existing:
                # Template already exists, don't create duplicate
                self.send_log(f"Template '{name}' already exists (ID: {existing['id']})", "warning")
                self.send_event("template-already-exists", {
                    "templateId": existing['id'],
                    "name": name,
                    "message": f"æ¨¡æ¿ '{name}' å·²å­˜åœ¨ï¼Œæœªå‰µå»ºé‡è¤‡æ¨¡æ¿"
                })
            else:
                # Add new template
                template_id = await db.add_template(name, prompt)
                await db.add_log(f"Template '{name}' added", "success")
            
            await self.send_templates_update()
        
        except ValidationError as e:
            self.send_log(f"Validation error: {e.message}", "error")
            self.send_event("template-validation-error", {
                "errors": [e.message],
                "field": e.field
            })
        except Exception as e:
            self.send_log(f"Error adding template: {str(e)}", "error")
            handle_error(e, {"command": "add-template", "payload": payload})
    
    async def handle_remove_template(self, payload: Dict[str, Any]):
        """Handle remove-template command"""
        try:
            template_id = payload.get('id')
            await db.remove_template(template_id)
            await db.add_log(f"Template {template_id} removed", "success")
            await self.send_templates_update()
        
        except Exception as e:
            self.send_log(f"Error removing template: {str(e)}", "error")
    
    async def handle_toggle_template_status(self, payload: Dict[str, Any]):
        """Handle toggle-template-status command"""
        try:
            template_id = payload.get('id')
            await db.toggle_template_status(template_id)
            await db.add_log(f"Template {template_id} status toggled", "success")
            await self.send_templates_update()
        
        except Exception as e:
            self.send_log(f"Error toggling template status: {str(e)}", "error")
    
    async def handle_add_campaign(self, payload: Dict[str, Any]):
        """Handle add-campaign command"""
        try:
            # Validate campaign data
            is_valid, errors = validate_campaign(payload)
            if not is_valid:
                error_message = "Validation failed: " + "; ".join(errors)
                self.send_log(error_message, "error")
                self.send_event("campaign-validation-error", {
                    "errors": errors,
                    "campaign_data": payload
                })
                handle_error(
                    AppError(ErrorType.VALIDATION_ERROR, error_message, {"errors": errors}),
                    {"command": "add-campaign", "payload": payload}
                )
                return
            
            # æª¢æŸ¥æ´»å‹•æ˜¯å¦å·²å­˜åœ¨
            campaign_name = payload.get('name', '').strip()
            existing_campaigns = await db.get_all_campaigns()
            existing = next((c for c in existing_campaigns if c.get('name') == campaign_name), None)
            
            if existing:
                # æ´»å‹•å·²å­˜åœ¨ï¼Œç™¼é€è­¦å‘Šäº‹ä»¶
                self.send_log(f"Campaign '{campaign_name}' already exists (ID: {existing.get('id')})", "warning")
                self.send_event("campaign-already-exists", {
                    "campaignId": existing.get('id'),
                    "name": campaign_name,
                    "message": f"æ´»å‹• '{campaign_name}' å·²å­˜åœ¨ï¼Œæœªå‰µå»ºé‡è¤‡æ´»å‹•"
                })
                # ä»ç„¶ç™¼é€æ›´æ–°äº‹ä»¶ä»¥ç¢ºä¿å‰ç«¯ç‹€æ…‹åŒæ­¥
                await self.send_campaigns_update()
                return
            
            campaign_id = await db.add_campaign(payload)
            await db.add_log(f"Campaign '{campaign_name}' added", "success")
            await self.send_campaigns_update()
        
        except ValidationError as e:
            self.send_log(f"Validation error: {e.message}", "error")
            self.send_event("campaign-validation-error", {
                "errors": [e.message],
                "field": e.field
            })
        except Exception as e:
            self.send_log(f"Error adding campaign: {str(e)}", "error")
            handle_error(e, {"command": "add-campaign", "payload": payload})
            # å³ä½¿å‡ºéŒ¯ï¼Œä¹Ÿç™¼é€æ›´æ–°äº‹ä»¶ä»¥ç¢ºä¿å‰ç«¯ç‹€æ…‹åŒæ­¥
            try:
                await self.send_campaigns_update()
            except:
                pass
    
    async def handle_remove_campaign(self, payload: Dict[str, Any]):
        """Handle remove-campaign command"""
        try:
            campaign_id = payload.get('id')
            await db.remove_campaign(campaign_id)
            await db.add_log(f"Campaign {campaign_id} removed", "success")
            await self.send_campaigns_update()
        
        except Exception as e:
            self.send_log(f"Error removing campaign: {str(e)}", "error")
    
    async def handle_toggle_campaign_status(self, payload: Dict[str, Any]):
        """Handle toggle-campaign-status command"""
        try:
            campaign_id = payload.get('id')
            await db.toggle_campaign_status(campaign_id)
            await db.add_log(f"Campaign {campaign_id} status toggled", "success")
            await self.send_campaigns_update()
        
        except Exception as e:
            self.send_log(f"Error toggling campaign status: {str(e)}", "error")
    
    async def handle_send_message(self, payload: Dict[str, Any]):
        """Handle send-message command with message queue"""
        try:
            lead_id = payload.get('leadId')
            account_phone = payload.get('accountPhone')
            user_id = payload.get('userId')
            source_group = payload.get('sourceGroup')  # æºç¾¤çµ„ï¼ˆç”¨æ–¼ç²å–ç”¨æˆ¶ä¿¡æ¯ï¼‰
            message_text = payload.get('message')
            attachment = payload.get('attachment')
            priority = payload.get('priority', 'normal')  # high, normal, low
            scheduled_at = payload.get('scheduledAt')  # Optional ISO datetime string
            
            # å¿…é ˆæœ‰å¸³è™Ÿå’Œç”¨æˆ¶IDï¼Œæ¶ˆæ¯å…§å®¹æˆ–é™„ä»¶è‡³å°‘ä¸€å€‹
            if not account_phone or not user_id:
                self.send_log("Missing required parameters for sending message (accountPhone or userId)", "error")
                return
            
            if not message_text and not attachment:
                self.send_log("Missing message text or attachment", "error")
                return
            
            # å¦‚æœæ²’æœ‰æ–‡å­—æ¶ˆæ¯ï¼Œè¨­ç½®ç‚ºç©ºå­—ç¬¦ä¸²
            if not message_text:
                message_text = ""
            
            # å˜—è©¦ç²å–ç¾¤çµ„ URLï¼ˆç”¨æ–¼åŠ å…¥ç¾¤çµ„ï¼‰
            source_group_url = source_group
            if source_group:
                try:
                    source_group_str = str(source_group)
                    
                    # å¦‚æœå·²ç¶“æ˜¯ URLï¼Œç›´æ¥ä½¿ç”¨
                    if 't.me/' in source_group_str or source_group_str.startswith('@'):
                        source_group_url = source_group_str
                        print(f"[Backend] source_group is already a URL: {source_group_url}", file=sys.stderr)
                    else:
                        # source_group æ˜¯ Telegram chat_idï¼Œéœ€è¦å¾ monitoredGroups æŸ¥æ‰¾å°æ‡‰çš„ URL
                        # monitoredGroups å­˜å„²çš„æ˜¯ URLï¼Œè€Œä¸æ˜¯ chat_id
                        # æˆ‘å€‘éœ€è¦å¾ lead æ•¸æ“šä¸­ç²å– source_group_url
                        if lead_id:
                            lead = await db.get_lead(lead_id)
                            if lead:
                                # æª¢æŸ¥ lead ä¸­æ˜¯å¦æœ‰å­˜å„²ç¾¤çµ„ URL
                                lead_source = lead.get('source_group') or lead.get('sourceGroup')
                                if lead_source and ('t.me/' in str(lead_source) or str(lead_source).startswith('@')):
                                    source_group_url = str(lead_source)
                                    print(f"[Backend] Found group URL from lead: {source_group_url}", file=sys.stderr)
                                else:
                                    # å¦‚æœ lead ä¸­æ²’æœ‰ URLï¼Œå˜—è©¦å¾ monitoredGroups æŸ¥æ‰¾
                                    # ç”±æ–¼ monitoredGroups å­˜å„²çš„æ˜¯ URLï¼Œè€Œ source_group æ˜¯ chat_id
                                    # æˆ‘å€‘ç„¡æ³•ç›´æ¥åŒ¹é…ï¼Œåªèƒ½ä½¿ç”¨ç¬¬ä¸€å€‹åŒ¹é…çš„ URL
                                    monitored_groups = await db.get_all_monitored_groups()
                                    if monitored_groups:
                                        # ä½¿ç”¨ç¬¬ä¸€å€‹å¯ç”¨çš„ç¾¤çµ„ URL ä½œç‚ºå‚™é¸
                                        source_group_url = monitored_groups[0].get('url')
                                        print(f"[Backend] Using first monitored group URL as fallback: {source_group_url}", file=sys.stderr)
                        
                        if source_group_url == source_group:
                            print(f"[Backend] Could not find URL for chat_id {source_group}, using as-is", file=sys.stderr)
                except Exception as e:
                    print(f"[Backend] Error looking up group URL: {e}", file=sys.stderr)
            
            # ç²å–ç”¨æˆ¶åä½œç‚ºå‚™é¸ï¼ˆå¦‚æœé€šé userId ç„¡æ³•ç™¼é€ï¼‰
            # å„ªå…ˆä½¿ç”¨ payload ä¸­ç›´æ¥å‚³éçš„ username
            target_username = payload.get('username')
            if target_username:
                print(f"[Backend] Got target username from payload: @{target_username}", file=sys.stderr)
            elif lead_id:
                # å˜—è©¦å¾æ•¸æ“šåº«ä¸­æŸ¥è©¢ï¼ˆä½¿ç”¨ user_id è€Œé lead_idï¼‰
                try:
                    lead = await db.get_lead_by_user_id(str(user_id))
                    if lead:
                        target_username = lead.get('username')
                        if target_username:
                            print(f"[Backend] Got target username from database: @{target_username}", file=sys.stderr)
                except Exception as e:
                    print(f"[Backend] Error getting username from database: {e}", file=sys.stderr)
            
            # Convert priority
            if priority == 'high':
                msg_priority = MessagePriority.HIGH
            elif priority == 'low':
                msg_priority = MessagePriority.LOW
            else:
                msg_priority = MessagePriority.NORMAL
            
            # Parse scheduled time if provided
            scheduled_datetime = None
            if scheduled_at:
                try:
                    scheduled_datetime = datetime.fromisoformat(scheduled_at.replace('Z', '+00:00'))
                except:
                    pass
            
            # Add message to queue
            message_id = await self.message_queue.add_message(
                phone=account_phone,
                user_id=user_id,
                text=message_text,
                attachment=attachment,
                source_group=source_group_url,  # ä½¿ç”¨ URL è€Œé ID
                target_username=target_username,  # ç”¨æˆ¶åä½œç‚ºå‚™é¸
                priority=msg_priority,
                scheduled_at=scheduled_datetime,
                callback=self._on_message_sent_callback(lead_id)
            )
            
            await db.add_log(f"Message queued for lead {lead_id} (queue ID: {message_id})", "info")
            self.send_log(f"Message queued for lead {lead_id}", "success")
            
            # Send queued event
            self.send_event("message-queued", {
                "messageId": message_id,
                "leadId": lead_id,
                "accountPhone": account_phone,
                "userId": user_id
            })
        
        except Exception as e:
            self.send_log(f"Error queueing message: {str(e)}", "error")
    
    def _on_message_sent_callback(self, lead_id: int):
        """Create callback for when message is sent"""
        async def callback(message, result):
            if result.get('success'):
                await db.add_interaction(lead_id, 'Message Sent', message.text)
                await db.add_log(f"Message sent to lead {lead_id}", "success")
                
                # ğŸ†• è‡ªå‹•ç‹€æ…‹æµè½‰ï¼šç™¼é€æ¶ˆæ¯å¾Œè‡ªå‹•è®Šç‚ºã€Œå·²è¯ç¹«ã€
                lead = await db.get_lead(lead_id)
                status_changed = False
                if lead and lead.get('status') == 'New':
                    await db.update_lead_status(lead_id, 'Contacted')
                    status_changed = True
                    await db.add_log(f"Lead {lead_id} ç‹€æ…‹è‡ªå‹•æ›´æ–°: New â†’ Contacted", "info")
                
                # Send success event
                self.send_event("message-sent", {
                    "leadId": lead_id,
                    "accountPhone": message.phone,
                    "userId": message.user_id,
                    "success": True,
                    "messageId": message.id,
                    "statusChanged": status_changed  # ğŸ†• é€šçŸ¥å‰ç«¯ç‹€æ…‹å·²è®Šæ›´
                })
                
                # ğŸ†• å¦‚æœç‹€æ…‹è®Šæ›´ï¼Œé€šçŸ¥å‰ç«¯åˆ·æ–° leads æ•¸æ“š
                if status_changed:
                    await self.send_leads_update()
            else:
                error = result.get('error', 'Unknown error')
                await db.add_log(f"Failed to send message to lead {lead_id}: {error}", "error")
                
                # Send failure event
                self.send_event("message-sent", {
                    "leadId": lead_id,
                    "accountPhone": message.phone,
                    "userId": message.user_id,
                    "success": False,
                    "error": error,
                    "messageId": message.id
                })
        
        return callback
    
    async def handle_send_group_message(self, payload: Dict[str, Any]):
        """Handle send-group-message command - Send message to a group/chat"""
        import sys
        try:
            resource_id = payload.get('resourceId')
            telegram_id = payload.get('telegramId')
            content = payload.get('content')
            account_phone = payload.get('accountPhone')
            
            print(f"[Backend] send-group-message: resourceId={resource_id}, telegramId={telegram_id}, phone={account_phone}", file=sys.stderr)
            
            if not content:
                self.send_log("æ¶ˆæ¯å…§å®¹ä¸èƒ½ç‚ºç©º", "error")
                self.send_event("group-message-sent", {
                    "success": False,
                    "resourceId": resource_id,
                    "error": "æ¶ˆæ¯å…§å®¹ä¸èƒ½ç‚ºç©º"
                })
                return
            
            if not account_phone:
                self.send_log("è«‹é¸æ“‡ç™¼é€å¸³è™Ÿ", "error")
                self.send_event("group-message-sent", {
                    "success": False,
                    "resourceId": resource_id,
                    "error": "è«‹é¸æ“‡ç™¼é€å¸³è™Ÿ"
                })
                return
            
            # ç²å–ç¾¤çµ„ä¿¡æ¯
            chat_id = telegram_id
            if not chat_id and resource_id:
                # ğŸ”§ P2 ä¿®å¾©: å„ªå…ˆæª¢æŸ¥ resource_id æ˜¯å¦ç‚º Telegram chat ID
                resource_id_str = str(resource_id)
                
                # Telegram chat ID ç‰¹å¾µï¼šç´”æ•¸å­—æˆ–ä»¥è² è™Ÿé–‹é ­çš„æ•¸å­—ï¼ˆç¾¤çµ„IDé€šå¸¸æ˜¯è² æ•¸ï¼‰
                if resource_id_str.lstrip('-').isdigit():
                    # ç›´æ¥ä½¿ç”¨ç‚º chat_id
                    chat_id = int(resource_id_str)
                    print(f"[Backend] ä½¿ç”¨ resourceId ä½œç‚º chat_id: {chat_id}", file=sys.stderr)
                else:
                    # å˜—è©¦å¾æ•¸æ“šåº«ç²å–
                    try:
                        from resource_discovery import ResourceDiscoverySystem
                        resource_service = ResourceDiscoverySystem()
                        resource = await resource_service.get_resource_by_telegram_id(resource_id_str)
                        
                        if resource:
                            chat_id = resource.get('telegram_id') or resource.get('username')
                    except Exception as res_err:
                        print(f"[Backend] ç²å–è³‡æºå¤±æ•—: {res_err}", file=sys.stderr)
            
            if not chat_id:
                self.send_log("ç„¡æ³•ç²å–ç¾¤çµ„ ID", "error")
                self.send_event("group-message-sent", {
                    "success": False,
                    "resourceId": resource_id,
                    "error": "ç„¡æ³•ç²å–ç¾¤çµ„ ID"
                })
                return
            
            # ç²å–å®¢æˆ¶ç«¯
            if account_phone not in self.telegram_manager.clients:
                self.send_log(f"å¸³è™Ÿ {account_phone} æœªé€£æ¥", "error")
                self.send_event("group-message-sent", {
                    "success": False,
                    "resourceId": resource_id,
                    "error": f"å¸³è™Ÿ {account_phone} æœªé€£æ¥"
                })
                return
            
            client = self.telegram_manager.clients[account_phone]
            
            if not client.is_connected:
                await client.connect()
            
            self.send_log(f"ğŸ“¨ æ­£åœ¨ç™¼é€æ¶ˆæ¯åˆ°ç¾¤çµ„...", "info")
            
            # ç™¼é€æ¶ˆæ¯
            try:
                # è§£æ chat_id
                target_chat = chat_id
                if isinstance(chat_id, str) and chat_id.lstrip('-').isdigit():
                    target_chat = int(chat_id)
                
                message = await client.send_message(target_chat, content)
                
                self.send_log(f"âœ… æ¶ˆæ¯å·²ç™¼é€åˆ°ç¾¤çµ„", "success")
                self.send_event("group-message-sent", {
                    "success": True,
                    "resourceId": resource_id,
                    "messageId": message.id
                })
                
            except Exception as send_error:
                error_msg = str(send_error)
                print(f"[Backend] Error sending message: {send_error}", file=sys.stderr)
                
                # æª¢æŸ¥æ˜¯å¦æ˜¯æ¬Šé™å•é¡Œ
                if "CHAT_WRITE_FORBIDDEN" in error_msg:
                    error_msg = "æ²’æœ‰ç™¼é€æ¶ˆæ¯çš„æ¬Šé™ï¼ˆå¯èƒ½æ˜¯é »é“æˆ–ç¦è¨€ç¾¤çµ„ï¼‰"
                elif "CHAT_RESTRICTED" in error_msg:
                    error_msg = "ç¾¤çµ„å·²è¢«é™åˆ¶"
                elif "USER_BANNED" in error_msg:
                    error_msg = "å¸³è™Ÿå·²è¢«è©²ç¾¤çµ„å°ç¦"
                elif "SLOWMODE_WAIT" in error_msg:
                    error_msg = "æ…¢é€Ÿæ¨¡å¼é™åˆ¶ï¼Œè«‹ç¨å¾Œå†è©¦"
                
                self.send_log(f"âŒ ç™¼é€å¤±æ•—: {error_msg}", "error")
                self.send_event("group-message-sent", {
                    "success": False,
                    "resourceId": resource_id,
                    "error": error_msg
                })
        
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_log(f"âŒ ç™¼é€ç¾¤çµ„æ¶ˆæ¯å¤±æ•—: {str(e)}", "error")
            self.send_event("group-message-sent", {
                "success": False,
                "resourceId": payload.get('resourceId'),
                "error": str(e)
            })
    
    async def handle_update_lead_status(self, payload: Dict[str, Any]):
        """Handle update-lead-status command (å¸¶é›™å‘åŒæ­¥)"""
        try:
            lead_id = payload.get('leadId')
            new_status = payload.get('newStatus')
            await db.update_lead_status(lead_id, new_status)
            await db.add_interaction(lead_id, 'Status Change', f"Status changed to {new_status}")
            await db.add_log(f"Lead {lead_id} status updated to {new_status}", "success")
            await self.send_leads_update()
            
            # ğŸ†• åŒæ­¥åˆ°çµ±ä¸€è¯ç¹«äººè¡¨
            try:
                # ç²å– lead çš„ userId
                lead = await db.get_lead_by_id(lead_id)
                if lead:
                    user_id = str(lead.get('userId', lead.get('user_id', '')))
                    if user_id:
                        from unified_contacts import get_unified_contacts_manager, LEAD_STATUS_MAPPING
                        manager = get_unified_contacts_manager(db)
                        contact_status = LEAD_STATUS_MAPPING.get(new_status, 'new')
                        await manager.update_status([user_id], contact_status)
                        print(f"[Backend] Synced lead status to unified_contacts: {user_id} -> {contact_status}", file=sys.stderr)
            except Exception as sync_error:
                print(f"[Backend] Warning: Could not sync status to unified_contacts: {sync_error}", file=sys.stderr)
        
        except Exception as e:
            self.send_log(f"Error updating lead status: {str(e)}", "error")
    
    async def handle_get_leads_paginated(self, payload: Dict[str, Any]):
        """ğŸ†• åˆ†é ç²å– Leads æ•¸æ“š"""
        import sys
        try:
            page = payload.get('page', 1)
            page_size = payload.get('pageSize', 50)
            status = payload.get('status')
            search = payload.get('search')
            
            offset = (page - 1) * page_size
            
            result = await db.get_leads_paginated(
                limit=page_size,
                offset=offset,
                status=status,
                search=search
            )
            
            print(f"[Backend] get-leads-paginated: page={page}, pageSize={page_size}, total={result.get('total', 0)}", file=sys.stderr)
            
            self.send_event("leads-paginated", result)
            
        except Exception as e:
            print(f"[Backend] Error getting paginated leads: {e}", file=sys.stderr)
            self.send_event("leads-paginated", {
                'leads': [],
                'total': 0,
                'page': 1,
                'pageSize': 50,
                'hasMore': False,
                'error': str(e)
            })
    
    async def handle_add_lead(self, payload: Dict[str, Any]):
        """Handle add-lead command - å¾æˆå“¡è³‡æ–™åº«æ·»åŠ  Lead"""
        try:
            user_id = payload.get('user_id')
            username = payload.get('username')
            first_name = payload.get('first_name', '')
            last_name = payload.get('last_name', '')
            source_chat_title = payload.get('source_chat_title', '')
            source_chat_id = payload.get('source_chat_id', '')
            notes = payload.get('notes', '')
            
            # æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
            existing_lead = await db.get_lead_by_user_id(user_id)
            if existing_lead:
                self.send_log(f"âš ï¸ Lead @{username or user_id} å·²å­˜åœ¨", "warning")
                self.send_event("add-lead-result", {
                    "success": False,
                    "error": "Lead å·²å­˜åœ¨",
                    "existingLead": existing_lead
                })
                return
            
            # å‰µå»ºæ–°çš„ Lead
            import datetime
            lead_id = await db.add_lead({
                'userId': user_id,
                'username': username,
                'firstName': first_name,
                'lastName': last_name,
                'sourceGroup': source_chat_title,
                'triggeredKeyword': '',
                'onlineStatus': 'Unknown',
                'notes': notes
            })
            
            self.send_log(f"âœ… æˆåŠŸæ·»åŠ  Lead: {first_name or username or user_id}", "success")
            
            # ç™¼é€æˆåŠŸäº‹ä»¶
            self.send_event("add-lead-result", {
                "success": True,
                "leadId": lead_id,
                "lead": {
                    "id": lead_id,
                    "userId": user_id,
                    "username": username,
                    "firstName": first_name,
                    "lastName": last_name,
                    "sourceGroup": source_chat_title,
                    "triggeredKeyword": "",
                    "timestamp": datetime.datetime.now().isoformat(),
                    "status": "New",
                    "onlineStatus": "Unknown"
                }
            })
            
            # æ›´æ–° Leads åˆ—è¡¨
            await self.send_leads_update()
            
            # åŒæ™‚æ›´æ–°æˆå“¡è³‡æ–™åº«ä¸­çš„ç‹€æ…‹ï¼ˆæ¨™è¨˜ç‚ºå·²åŠ å…¥æ¼æ–—ï¼‰
            if source_chat_id:
                try:
                    await db._connection.execute('''
                        UPDATE extracted_members 
                        SET notes = notes || CASE WHEN notes != '' THEN '\n' ELSE '' END || 'å·²åŠ å…¥éŠ·å”®æ¼æ–—',
                            updated_at = datetime('now')
                        WHERE user_id = ?
                    ''', (user_id,))
                    await db._connection.commit()
                except Exception as sync_error:
                    print(f"[Backend] Warning: Could not sync member status: {sync_error}", file=sys.stderr)
            
            # ğŸ†• åŒæ­¥åˆ°çµ±ä¸€è¯ç¹«äººè¡¨
            try:
                from unified_contacts import get_unified_contacts_manager
                manager = get_unified_contacts_manager(db)
                await manager.sync_from_lead({
                    'userId': user_id,
                    'username': username,
                    'firstName': first_name,
                    'lastName': last_name,
                    'status': 'New',
                    'sourceChatTitle': source_chat_title,
                    'sourceChatId': source_chat_id
                })
                print(f"[Backend] Synced new lead to unified_contacts: {user_id}", file=sys.stderr)
            except Exception as sync_error:
                print(f"[Backend] Warning: Could not sync to unified_contacts: {sync_error}", file=sys.stderr)
        
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_log(f"âŒ æ·»åŠ  Lead å¤±æ•—: {str(e)}", "error")
            self.send_event("add-lead-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_add_to_dnc(self, payload: Dict[str, Any]):
        """Handle add-to-dnc command"""
        try:
            user_id = payload.get('userId')
            await db.add_to_dnc(user_id)
            await db.add_log(f"User {user_id} added to DNC list", "success")
            await self.send_leads_update()
        
        except Exception as e:
            self.send_log(f"Error adding to DNC: {str(e)}", "error")
    
    async def handle_clear_logs(self):
        """Handle clear-logs command"""
        try:
            await db.clear_logs()
            await db.add_log("Logs cleared", "info")
        
        except Exception as e:
            self.send_log(f"Error clearing logs: {str(e)}", "error")
    
    async def handle_load_accounts_from_excel(self, payload: Dict[str, Any]):
        """Handle load-accounts-from-excel command"""
        try:
            from openpyxl import load_workbook
            from pathlib import Path
            
            file_path = payload.get('filePath')
            if not file_path:
                self.send_log("No file path provided", "error")
                return
            
            file_path_obj = Path(file_path)
            if not file_path_obj.exists():
                self.send_log(f"File not found: {file_path}", "error")
                return
            
            # Load Excel file
            workbook = load_workbook(file_path_obj, data_only=True)
            sheet = workbook.active
            
            # Get headers (first row)
            headers = []
            for cell in sheet[1]:
                headers.append(cell.value.lower().replace(' ', '_') if cell.value else '')
            
            # Map column names
            column_map = {
                'phone': ['phone', 'phone_number', 'ç”µè¯å·ç '],
                'api_id': ['api_id', 'apiid', 'api_id'],
                'api_hash': ['api_hash', 'apihash', 'api_hash'],
                'proxy': ['proxy', 'ä»£ç†'],
                'group': ['group', 'group_name', 'åˆ†ç»„'],
                'two_factor_password': ['two_factor_password', '2fa', '2fa_password', 'two_factor', '2faå¯†ç '],
                'role': ['role', 'è§’è‰²']
            }
            
            # Find column indices
            column_indices = {}
            for key, possible_names in column_map.items():
                for idx, header in enumerate(headers):
                    if header in possible_names:
                        column_indices[key] = idx
                        break
            
            if 'phone' not in column_indices:
                self.send_log("Phone column not found in Excel file", "error")
                return
            
            # Read data rows
            imported_count = 0
            skipped_count = 0
            
            for row_idx, row in enumerate(sheet.iter_rows(min_row=2, values_only=False), start=2):
                # Skip empty rows
                if not row[column_indices['phone']].value:
                    continue
                
                try:
                    account_data = {
                        'phone': str(row[column_indices['phone']].value).strip(),
                        'apiId': str(row[column_indices.get('api_id', 0)].value).strip() if column_indices.get('api_id') and row[column_indices['api_id']].value else '',
                        'apiHash': str(row[column_indices.get('api_hash', 0)].value).strip() if column_indices.get('api_hash') and row[column_indices['api_hash']].value else '',
                        'proxy': str(row[column_indices.get('proxy', 0)].value).strip() if column_indices.get('proxy') and row[column_indices['proxy']].value else '',
                        'group': str(row[column_indices.get('group', 0)].value).strip() if column_indices.get('group') and row[column_indices['group']].value else '',
                        'twoFactorPassword': str(row[column_indices.get('two_factor_password', 0)].value).strip() if column_indices.get('two_factor_password') and row[column_indices['two_factor_password']].value else '',
                        'role': str(row[column_indices.get('role', 0)].value).strip() if column_indices.get('role') and row[column_indices['role']].value else 'Unassigned'
                    }
                    
                    # Validate phone number
                    if not account_data['phone']:
                        skipped_count += 1
                        continue
                    
                    # Check if account already exists
                    existing = await db.get_account_by_phone(account_data['phone'])
                    if existing:
                        # Update existing account
                        await db.update_account(existing['id'], {
                            'apiId': account_data.get('apiId'),
                            'apiHash': account_data.get('apiHash'),
                            'proxy': account_data.get('proxy'),
                            'group': account_data.get('group'),
                            'role': account_data.get('role', 'Unassigned')
                        })
                        imported_count += 1
                    else:
                        # Add new account
                        await db.add_account(account_data)
                        imported_count += 1
                
                except Exception as e:
                    self.send_log(f"Error processing row {row_idx}: {str(e)}", "warning")
                    skipped_count += 1
                    continue
            
            # Send updated accounts
            accounts = await db.get_all_accounts()
            # Invalidate cache
            self._cache.pop("accounts", None)
            self._cache_timestamps.pop("accounts", None)
            self.send_event("accounts-updated", accounts)
            
            self.send_log(f"Imported {imported_count} accounts from Excel (skipped {skipped_count})", "success")
            await db.add_log(f"Imported {imported_count} accounts from Excel", "success")
        
        except Exception as e:
            self.send_log(f"Error loading accounts from Excel: {str(e)}", "error")
    
    async def handle_export_leads_to_excel(self, payload: Dict[str, Any]):
        """Handle export-leads-to-excel command"""
        try:
            from openpyxl import Workbook
            from pathlib import Path
            from datetime import datetime
            
            file_path = payload.get('filePath')
            leads = payload.get('leads', [])
            
            if not file_path:
                self.send_log("No file path provided", "error")
                return
            
            if not leads:
                self.send_log("No leads to export", "warning")
                return
            
            # Create workbook
            workbook = Workbook()
            sheet = workbook.active
            sheet.title = "Leads"
            
            # Write headers
            headers = [
                'ID', 'User ID', 'Username', 'First Name', 'Last Name',
                'Source Group', 'Triggered Keyword', 'Status', 'Online Status',
                'Timestamp', 'Do Not Contact'
            ]
            sheet.append(headers)
            
            # Write data
            for lead in leads:
                row = [
                    lead.get('id', ''),
                    lead.get('userId', ''),
                    lead.get('username', ''),
                    lead.get('firstName', ''),
                    lead.get('lastName', ''),
                    lead.get('sourceGroup', ''),
                    lead.get('triggeredKeyword', ''),
                    lead.get('status', ''),
                    lead.get('onlineStatus', ''),
                    lead.get('timestamp', ''),
                    'Yes' if lead.get('doNotContact') else 'No'
                ]
                sheet.append(row)
            
            # Auto-adjust column widths
            for column in sheet.columns:
                max_length = 0
                column_letter = column[0].column_letter
                for cell in column:
                    try:
                        if len(str(cell.value)) > max_length:
                            max_length = len(str(cell.value))
                    except:
                        pass
                adjusted_width = min(max_length + 2, 50)
                sheet.column_dimensions[column_letter].width = adjusted_width
            
            # Save file
            file_path_obj = Path(file_path)
            workbook.save(file_path_obj)
            
            self.send_log(f"Exported {len(leads)} leads to Excel: {file_path}", "success")
            await db.add_log(f"Exported {len(leads)} leads to Excel", "success")
        
        except Exception as e:
            self.send_log(f"Error exporting leads to Excel: {str(e)}", "error")
    
    async def handle_reload_sessions_and_accounts(self):
        """Handle reload-sessions-and-accounts command - scan sessions directory and sync with database"""
        try:
            from pathlib import Path
            from config import SESSIONS_DIR
            import re
            
            self.send_log("Reloading sessions and accounts", "info")
            
            # Get all session files
            session_files = list(SESSIONS_DIR.glob("*.session"))
            
            if not session_files:
                self.send_log("No session files found", "info")
                accounts = await db.get_all_accounts()
                self.send_event("accounts-updated", accounts)
                return
            
            # Get all existing accounts
            existing_accounts = await db.get_all_accounts()
            existing_phones = {acc.get('phone') for acc in existing_accounts}
            
            imported_count = 0
            updated_count = 0
            
            # Process each session file
            for session_file in session_files:
                try:
                    # Extract phone number from filename (remove .session extension)
                    phone_number = session_file.stem
                    
                    # Try to normalize phone number (add + if missing)
                    if not phone_number.startswith('+'):
                        # Try to detect if it's a valid phone number
                        if phone_number.isdigit() and len(phone_number) >= 10:
                            # Assume it's a phone number without country code
                            # For now, keep as is - user can update manually
                            pass
                    
                    # Check if account exists
                    existing_account = await db.get_account_by_phone(phone_number)
                    
                    if existing_account:
                        # Update session file path if needed
                        updated_count += 1
                        self.send_log(f"Session found for existing account: {phone_number}", "info")
                    else:
                        # Create new account from session file
                        # Try to get account info from session file metadata if possible
                        # For now, create with minimal info
                        await db.add_account({
                            'phone': phone_number,
                            'apiId': '',  # Will need to be filled manually
                            'apiHash': '',  # Will need to be filled manually
                            'proxy': '',
                            'group': '',
                            'role': 'Unassigned',
                            'status': 'Offline'  # Will be updated when logged in
                        })
                        imported_count += 1
                        self.send_log(f"Created account from session file: {phone_number}", "info")
                
                except Exception as e:
                    self.send_log(f"Error processing session file {session_file.name}: {str(e)}", "warning")
                    continue
            
            # Check for accounts without session files
            accounts_without_sessions = []
            for account in existing_accounts:
                phone = account.get('phone')
                safe_phone = phone.replace("+", "").replace("-", "").replace(" ", "")
                session_file = SESSIONS_DIR / f"{safe_phone}.session"
                if not session_file.exists():
                    accounts_without_sessions.append(phone)
            
            # Send updated accounts
            accounts = await db.get_all_accounts()
            # Invalidate cache
            self._cache.pop("accounts", None)
            self._cache_timestamps.pop("accounts", None)
            self.send_event("accounts-updated", accounts)
            
            # Log summary
            summary = f"Reloaded sessions: {len(session_files)} session files found, {imported_count} new accounts created, {updated_count} existing accounts updated"
            if accounts_without_sessions:
                summary += f", {len(accounts_without_sessions)} accounts without session files"
            
            self.send_log(summary, "success")
            await db.add_log(summary, "info")
        
        except Exception as e:
            self.send_log(f"Error reloading sessions: {str(e)}", "error")
    
    async def handle_scan_orphan_sessions(self, payload: Dict[str, Any]):
        """æƒæå­¤ç«‹çš„ Session æ–‡ä»¶ï¼ˆæœ‰ session ä½†ç„¡æ•¸æ“šåº«è¨˜éŒ„ï¼‰"""
        try:
            from pathlib import Path
            from config import SESSIONS_DIR
            
            self.send_log("ğŸ” æ­£åœ¨æƒæå­¤ç«‹çš„ Session æ–‡ä»¶...", "info")
            
            # ç²å–æ‰€æœ‰ session æ–‡ä»¶
            session_files = list(SESSIONS_DIR.glob("*.session"))
            
            if not session_files:
                self.send_event("orphan-sessions-scanned", {
                    "success": True,
                    "orphan_sessions": [],
                    "message": "æ²’æœ‰æ‰¾åˆ° Session æ–‡ä»¶"
                })
                return
            
            # ç²å–æ•¸æ“šåº«ä¸­çš„å¸³è™Ÿ
            existing_accounts = await db.get_all_accounts()
            existing_phones = set()
            for acc in existing_accounts:
                phone = acc.get('phone', '')
                # æ¨™æº–åŒ–é›»è©±è™Ÿç¢¼
                safe_phone = phone.replace("+", "").replace("-", "").replace(" ", "")
                existing_phones.add(safe_phone)
                existing_phones.add(phone)
            
            # æŸ¥æ‰¾å­¤ç«‹çš„ session
            orphan_sessions = []
            for session_file in session_files:
                phone = session_file.stem
                # è·³éè‡¨æ™‚æ–‡ä»¶å’Œ journal æ–‡ä»¶
                if phone.endswith('-journal') or phone.startswith('.'):
                    continue
                    
                # æª¢æŸ¥æ˜¯å¦åœ¨æ•¸æ“šåº«ä¸­
                if phone not in existing_phones and f"+{phone}" not in existing_phones:
                    orphan_sessions.append({
                        "phone": phone,
                        "file_path": str(session_file),
                        "file_size": session_file.stat().st_size,
                        "modified_at": session_file.stat().st_mtime
                    })
            
            self.send_log(f"ğŸ“‚ ç™¼ç¾ {len(orphan_sessions)} å€‹å­¤ç«‹çš„ Session æ–‡ä»¶", "info")
            
            self.send_event("orphan-sessions-scanned", {
                "success": True,
                "orphan_sessions": orphan_sessions,
                "total_sessions": len(session_files),
                "existing_accounts": len(existing_accounts)
            })
            
        except Exception as e:
            self.send_log(f"Error scanning orphan sessions: {str(e)}", "error")
            self.send_event("orphan-sessions-scanned", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_recover_orphan_sessions(self, payload: Dict[str, Any]):
        """æ¢å¾©å­¤ç«‹çš„ Session æ–‡ä»¶ï¼Œå‰µå»ºå¸³è™Ÿè¨˜éŒ„"""
        try:
            from pathlib import Path
            from config import SESSIONS_DIR
            from api_credential_pool import get_api_credential_pool
            
            phones_to_recover = payload.get('phones', [])
            api_id = payload.get('apiId', '')
            api_hash = payload.get('apiHash', '')
            
            if not phones_to_recover:
                self.send_event("orphan-sessions-recovered", {
                    "success": False,
                    "error": "æ²’æœ‰é¸æ“‡è¦æ¢å¾©çš„å¸³è™Ÿ"
                })
                return
            
            # å¦‚æœæ²’æœ‰æä¾› API æ†‘æ“šï¼Œå˜—è©¦å¾ API æ± ç²å–æ¨è–¦çš„
            if not api_id or not api_hash:
                data_dir = str(Path(config.DATA_PATH))
                pool = get_api_credential_pool(data_dir)
                recommendation = pool.get_best_credential()
                if recommendation:
                    api_id = recommendation.get('api_id', '')
                    api_hash = recommendation.get('api_hash', '')
                    self.send_log(f"ä½¿ç”¨æ¨è–¦çš„ API æ†‘æ“š: {api_id}", "info")
            
            results = {
                "success_count": 0,
                "fail_count": 0,
                "accounts": []
            }
            
            for phone in phones_to_recover:
                try:
                    self.send_log(f"ğŸ”„ æ­£åœ¨æ¢å¾©å¸³è™Ÿ: {phone}...", "info")
                    
                    # æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
                    existing = await db.get_account_by_phone(phone)
                    if existing:
                        self.send_log(f"âš ï¸ å¸³è™Ÿ {phone} å·²å­˜åœ¨ï¼Œè·³é", "warning")
                        results["accounts"].append({
                            "phone": phone,
                            "success": False,
                            "error": "å¸³è™Ÿå·²å­˜åœ¨"
                        })
                        results["fail_count"] += 1
                        continue
                    
                    # é©—è­‰ session æ–‡ä»¶æ˜¯å¦å­˜åœ¨
                    session_file = SESSIONS_DIR / f"{phone}.session"
                    if not session_file.exists():
                        results["accounts"].append({
                            "phone": phone,
                            "success": False,
                            "error": "Session æ–‡ä»¶ä¸å­˜åœ¨"
                        })
                        results["fail_count"] += 1
                        continue
                    
                    # å˜—è©¦é€£æ¥ Telegram ç²å–ç”¨æˆ¶ä¿¡æ¯
                    user_info = {}
                    try:
                        if api_id and api_hash:
                            # å˜—è©¦ä½¿ç”¨ Pyrogram é€£æ¥é©—è­‰
                            from pyrogram import Client
                            
                            session_name = str(session_file).replace('.session', '')
                            client = Client(
                                name=session_name,
                                api_id=int(api_id),
                                api_hash=api_hash,
                                workdir=str(SESSIONS_DIR)
                            )
                            
                            await client.start()
                            me = await client.get_me()
                            
                            user_info = {
                                "firstName": me.first_name or "",
                                "lastName": me.last_name or "",
                                "username": me.username or "",
                                "telegramId": str(me.id),
                                "phone": me.phone_number or phone
                            }
                            
                            # ä¸‹è¼‰é ­åƒ
                            try:
                                if me.photo:
                                    avatar_path = Path(config.DATA_PATH) / "avatars" / f"{phone}.jpg"
                                    avatar_path.parent.mkdir(parents=True, exist_ok=True)
                                    await client.download_media(me.photo.big_file_id, file_name=str(avatar_path))
                                    user_info["avatarPath"] = str(avatar_path)
                            except Exception:
                                pass
                            
                            await client.stop()
                            self.send_log(f"âœ… é©—è­‰æˆåŠŸ: {user_info.get('firstName', '')} @{user_info.get('username', '')}", "success")
                    except Exception as e:
                        self.send_log(f"âš ï¸ ç„¡æ³•é©—è­‰ sessionï¼ˆå¯èƒ½å·²éæœŸï¼‰: {e}", "warning")
                        # ä»ç„¶å‰µå»ºå¸³è™Ÿï¼Œä½†æ¨™è¨˜ç‚ºé›¢ç·š
                    
                    # å‰µå»ºå¸³è™Ÿè¨˜éŒ„
                    account_data = {
                        'phone': phone if phone.startswith('+') else f"+{phone}",
                        'apiId': api_id,
                        'apiHash': api_hash,
                        'proxy': '',
                        'group': '',
                        'role': 'Unassigned',
                        'status': 'Online' if user_info else 'Offline',
                        'firstName': user_info.get('firstName', ''),
                        'lastName': user_info.get('lastName', ''),
                        'username': user_info.get('username', ''),
                        'telegramId': user_info.get('telegramId', ''),
                        'avatarPath': user_info.get('avatarPath', '')
                    }
                    
                    await db.add_account(account_data)
                    
                    results["success_count"] += 1
                    results["accounts"].append({
                        "phone": phone,
                        "success": True,
                        "user_info": user_info
                    })
                    
                    self.send_log(f"âœ… å¸³è™Ÿ {phone} æ¢å¾©æˆåŠŸ", "success")
                    
                except Exception as e:
                    self.send_log(f"âŒ æ¢å¾© {phone} å¤±æ•—: {e}", "error")
                    results["fail_count"] += 1
                    results["accounts"].append({
                        "phone": phone,
                        "success": False,
                        "error": str(e)
                    })
            
            # åˆ·æ–°å¸³è™Ÿåˆ—è¡¨
            accounts = await db.get_all_accounts()
            self._cache.pop("accounts", None)
            self._cache_timestamps.pop("accounts", None)
            self.send_event("accounts-updated", accounts)
            
            self.send_log(
                f"ğŸ“Š Session æ¢å¾©å®Œæˆ: æˆåŠŸ {results['success_count']}, å¤±æ•— {results['fail_count']}", 
                "success" if results['success_count'] > 0 else "warning"
            )
            
            self.send_event("orphan-sessions-recovered", {
                "success": True,
                **results
            })
            
        except Exception as e:
            self.send_log(f"Error recovering orphan sessions: {str(e)}", "error")
            self.send_event("orphan-sessions-recovered", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_import_session(self, payload: Dict[str, Any]):
        """Handle import-session command - import a session file or package"""
        import sys
        print(f"[Backend] handle_import_session called with payload: {payload}", file=sys.stderr)
        try:
            from pathlib import Path
            import shutil
            from session_package import SessionPackage, BatchSessionPackage
            
            file_path = payload.get('filePath')
            
            if not file_path:
                self.send_log("No file path provided", "error")
                return
            
            file_path = Path(file_path)
            if not file_path.exists():
                self.send_log(f"File not found: {file_path}", "error")
                return
            
            from config import SESSIONS_DIR
            
            # Check file type and handle accordingly
            if SessionPackage.is_package_file(file_path):
                # Import TG-Matrix session package (.tgpkg)
                success, message, account_data = SessionPackage.extract_package(file_path, SESSIONS_DIR)
                
                if not success:
                    self.send_log(message, "error")
                    self.send_event("session-import-result", {
                        "success": False,
                        "message": message
                    })
                    return
                
                # Check if account exists
                existing_account = await db.get_account_by_phone(account_data['phone'])
                if existing_account:
                    # Update existing account with new credentials
                    await db.update_account(existing_account['id'], {
                        'apiId': account_data.get('api_id') or account_data.get('apiId'),
                        'apiHash': account_data.get('api_hash') or account_data.get('apiHash'),
                        'proxy': account_data.get('proxy', existing_account.get('proxy', '')),
                        'status': 'Offline'
                    })
                    self.send_log(f"âœ… è³¬æˆ¶å·²æ›´æ–°: {account_data['phone']}", "success")
                else:
                    # Create new account
                    await db.add_account(account_data)
                    self.send_log(f"âœ… è³¬æˆ¶å·²å°å…¥: {account_data['phone']}", "success")
                
                self.send_event("session-import-result", {
                    "success": True,
                    "message": f"Session package imported: {account_data['phone']}",
                    "phone": account_data['phone']
                })
                
            elif str(file_path).lower().endswith('.tgbatch'):
                # Import batch package
                success, message, accounts_list = BatchSessionPackage.extract_batch_package(file_path, SESSIONS_DIR)
                
                if not success:
                    self.send_log(message, "error")
                    self.send_event("session-import-result", {
                        "success": False,
                        "message": message
                    })
                    return
                
                imported_count = 0
                for account_data in accounts_list:
                    existing_account = await db.get_account_by_phone(account_data['phone'])
                    if existing_account:
                        await db.update_account(existing_account['id'], {
                            'apiId': account_data.get('api_id') or account_data.get('apiId'),
                            'apiHash': account_data.get('api_hash') or account_data.get('apiHash'),
                            'proxy': account_data.get('proxy', ''),
                            'status': 'Offline'
                        })
                    else:
                        await db.add_account(account_data)
                    imported_count += 1
                
                self.send_log(f"âœ… æ‰¹é‡å°å…¥å®Œæˆ: {imported_count} å€‹è³¬æˆ¶", "success")
                self.send_event("session-import-result", {
                    "success": True,
                    "message": f"Batch import complete: {imported_count} accounts",
                    "count": imported_count
                })
                
            elif SessionPackage.is_legacy_session(file_path):
                # Legacy .session file - requires API credentials
                print(f"[Backend] Processing legacy session file: {file_path}", file=sys.stderr)
                phone_number = payload.get('phoneNumber', '')
                api_id = payload.get('apiId', '')
                api_hash = payload.get('apiHash', '')
                
                # Determine phone number from filename if not provided
                if not phone_number:
                    phone_number = file_path.stem.replace('+', '').replace('-', '').replace(' ', '')
                print(f"[Backend] Phone number from file: {phone_number}", file=sys.stderr)
                
                # Check if we have API credentials
                if not api_id or not api_hash:
                    print(f"[Backend] No API credentials provided, checking database...", file=sys.stderr)
                    # Try to get from existing account (æ•°æ®åº“å­—æ®µåæ˜¯ apiId å’Œ apiHash)
                    # Try with and without + prefix
                    existing_account = await db.get_account_by_phone(phone_number)
                    if not existing_account:
                        existing_account = await db.get_account_by_phone(f"+{phone_number}")
                    print(f"[Backend] Existing account found: {existing_account is not None}", file=sys.stderr)
                    
                    if existing_account and (existing_account.get('apiId') or existing_account.get('api_id')) and (existing_account.get('apiHash') or existing_account.get('api_hash')):
                        api_id = existing_account.get('apiId') or existing_account.get('api_id')
                        api_hash = existing_account.get('apiHash') or existing_account.get('api_hash')
                        print(f"[Backend] Using credentials from existing account", file=sys.stderr)
                    else:
                        # Try to get from API credential pool
                        print(f"[Backend] Trying API credential pool...", file=sys.stderr)
                        try:
                            from api_credential_pool import get_api_credential_pool
                            data_dir = str(Path(config.DATA_PATH))
                            pool = get_api_credential_pool(data_dir)
                            recommended = pool.get_recommended_credential()
                            if recommended:
                                api_id = recommended.api_id
                                api_hash = recommended.api_hash
                                print(f"[Backend] Using recommended API credential: {api_id}", file=sys.stderr)
                        except Exception as pool_err:
                            print(f"[Backend] Error getting API from pool: {pool_err}", file=sys.stderr)
                    
                    if not api_id or not api_hash:
                        # No credentials - notify frontend to ask user
                        print(f"[Backend] No credentials available, notifying frontend", file=sys.stderr)
                        self.send_event("session-import-needs-credentials", {
                            "filePath": str(file_path),
                            "phoneNumber": phone_number,
                            "message": "æ­¤ session æ–‡ä»¶éœ€è¦ API ID å’Œ API Hash æ‰èƒ½ä½¿ç”¨"
                        })
                        self.send_log("âš ï¸ å°å…¥èˆŠæ ¼å¼ session éœ€è¦æä¾› API ID å’Œ API Hash", "warning")
                        return
                
                # Copy session file (skip if source and target are the same)
                target_path = SESSIONS_DIR / f"{phone_number}.session"
                source_resolved = Path(file_path).resolve()
                target_resolved = target_path.resolve()
                
                if source_resolved != target_resolved:
                    # Only copy if different locations
                    try:
                        shutil.copy2(file_path, target_path)
                        print(f"[Backend] Session file copied to {target_path}", file=sys.stderr)
                    except PermissionError as pe:
                        print(f"[Backend] Permission error copying session: {pe}", file=sys.stderr)
                        # File might be locked, try to continue anyway if target exists
                        if not target_path.exists():
                            raise
                        print(f"[Backend] Target session already exists, continuing...", file=sys.stderr)
                else:
                    print(f"[Backend] Source and target are same, skipping copy", file=sys.stderr)
                
                # Create or update account (æ•°æ®åº“å­—æ®µåæ˜¯ apiId å’Œ apiHash)
                existing_account = await db.get_account_by_phone(phone_number)
                if existing_account:
                    await db.update_account(existing_account['id'], {
                        'apiId': api_id,
                        'apiHash': api_hash,
                        'status': 'Offline'
                    })
                else:
                    await db.add_account({
                        'phone': phone_number,
                        'apiId': api_id,
                        'apiHash': api_hash,
                        'proxy': payload.get('proxy', ''),
                        'group': payload.get('group', ''),
                        'role': payload.get('role', 'Unassigned'),
                        'status': 'Offline'
                    })
                
                self.send_log(f"âœ… Session å·²å°å…¥: {phone_number}", "success")
                self.send_event("session-import-result", {
                    "success": True,
                    "message": f"Session imported: {phone_number}",
                    "phone": phone_number
                })
            else:
                self.send_log(f"ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼: {file_path.suffix}", "error")
                self.send_event("session-import-result", {
                    "success": False,
                    "message": f"Unsupported file format: {file_path.suffix}"
                })
                return
            
            # Reload accounts
            accounts = await db.get_all_accounts()
            self._cache.pop("accounts", None)
            self._cache_timestamps.pop("accounts", None)
            self.send_event("accounts-updated", accounts)
        
        except Exception as e:
            self.send_log(f"Error importing session: {str(e)}", "error")
            self.send_event("session-import-result", {
                "success": False,
                "message": str(e)
            })
    
    async def handle_scan_tdata(self, payload: Dict[str, Any]):
        """æƒæ TData ç›®éŒ„ï¼Œè¿”å›å¸³è™Ÿåˆ—è¡¨"""
        try:
            from tdata_importer import get_tdata_importer
            
            path = payload.get('path', '')
            
            if not path:
                self.send_event("tdata-scan-result", {
                    "success": False,
                    "error": "æœªæä¾›è·¯å¾‘"
                })
                return
            
            importer = get_tdata_importer()
            result = importer.scan_tdata(path)
            
            self.send_event("tdata-scan-result", result)
            
            if result.get("success"):
                self.send_log(f"ğŸ“‚ ç™¼ç¾ {len(result.get('accounts', []))} å€‹å¸³è™Ÿ", "info")
            else:
                self.send_log(f"âŒ æƒæå¤±æ•—: {result.get('error', 'æœªçŸ¥éŒ¯èª¤')}", "error")
                
        except Exception as e:
            self.send_log(f"Error scanning TData: {str(e)}", "error")
            self.send_event("tdata-scan-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_import_tdata_account(self, payload: Dict[str, Any]):
        """å°å…¥å–®å€‹ TData å¸³è™Ÿ"""
        try:
            from tdata_importer import get_tdata_importer
            
            tdata_path = payload.get('tdataPath', '')
            account_index = payload.get('accountIndex', 0)
            api_id = payload.get('apiId')
            api_hash = payload.get('apiHash')
            
            if not tdata_path:
                self.send_event("tdata-import-result", {
                    "success": False,
                    "error": "æœªæä¾› TData è·¯å¾‘"
                })
                return
            
            self.send_log(f"ğŸ”„ æ­£åœ¨å°å…¥å¸³è™Ÿ #{account_index + 1}...", "info")
            
            importer = get_tdata_importer()
            result = await importer.import_account(
                tdata_path,
                account_index,
                api_id,
                api_hash
            )
            
            if result.get("success"):
                # æ·»åŠ å¸³è™Ÿåˆ°æ•¸æ“šåº«
                phone = result.get("phone", "").replace("+", "")
                existing = await db.get_account_by_phone(phone)
                
                if not existing:
                    await db.add_account({
                        'phone': phone,
                        'apiId': api_id or '',
                        'apiHash': api_hash or '',
                        'status': 'Offline',
                        'firstName': result.get('first_name', ''),
                        'lastName': result.get('last_name', ''),
                        'username': result.get('username', ''),
                        'telegramId': str(result.get('user_id', ''))
                    })
                
                self.send_log(f"âœ… å¸³è™Ÿå°å…¥æˆåŠŸ: {phone}", "success")
                
                # åˆ·æ–°å¸³è™Ÿåˆ—è¡¨
                accounts = await db.get_all_accounts()
                self.send_event("accounts-updated", accounts)
            else:
                self.send_log(f"âŒ å°å…¥å¤±æ•—: {result.get('error', 'æœªçŸ¥éŒ¯èª¤')}", "error")
            
            self.send_event("tdata-import-result", result)
            
        except Exception as e:
            self.send_log(f"Error importing TData account: {str(e)}", "error")
            self.send_event("tdata-import-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_import_tdata_batch(self, payload: Dict[str, Any]):
        """æ‰¹é‡å°å…¥ TData å¸³è™Ÿ"""
        try:
            from tdata_importer import get_tdata_importer
            
            tdata_path = payload.get('tdataPath', '')
            account_indices = payload.get('accountIndices', [])
            api_id = payload.get('apiId')
            api_hash = payload.get('apiHash')
            
            if not tdata_path or not account_indices:
                self.send_event("tdata-batch-result", {
                    "success": False,
                    "error": "æœªæä¾›å¿…è¦åƒæ•¸"
                })
                return
            
            self.send_log(f"ğŸ”„ é–‹å§‹æ‰¹é‡å°å…¥ {len(account_indices)} å€‹å¸³è™Ÿ...", "info")
            
            importer = get_tdata_importer()
            
            def progress_callback(current, total, message):
                self.send_event("tdata-import-progress", {
                    "current": current,
                    "total": total,
                    "message": message
                })
            
            result = await importer.import_batch(
                tdata_path,
                account_indices,
                api_id,
                api_hash,
                progress_callback
            )
            
            # æ·»åŠ æˆåŠŸçš„å¸³è™Ÿåˆ°æ•¸æ“šåº«
            for account in result.get("accounts", []):
                if account.get("success"):
                    phone = account.get("phone", "").replace("+", "")
                    existing = await db.get_account_by_phone(phone)
                    
                    if not existing:
                        await db.add_account({
                            'phone': phone,
                            'apiId': api_id or '',
                            'apiHash': api_hash or '',
                            'status': 'Offline',
                            'firstName': account.get('first_name', ''),
                            'lastName': account.get('last_name', ''),
                            'username': account.get('username', ''),
                            'telegramId': str(account.get('user_id', ''))
                        })
            
            self.send_log(
                f"ğŸ“Š æ‰¹é‡å°å…¥å®Œæˆ: æˆåŠŸ {result.get('success_count', 0)}, å¤±æ•— {result.get('fail_count', 0)}", 
                "success" if result.get('success_count', 0) > 0 else "warning"
            )
            
            # åˆ·æ–°å¸³è™Ÿåˆ—è¡¨
            accounts = await db.get_all_accounts()
            self.send_event("accounts-updated", accounts)
            
            self.send_event("tdata-batch-result", result)
            
        except Exception as e:
            self.send_log(f"Error batch importing TData: {str(e)}", "error")
            self.send_event("tdata-batch-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_default_tdata_path(self):
        """ç²å–ç³»çµ±é»˜èª TData è·¯å¾‘"""
        try:
            from tdata_importer import get_tdata_importer
            
            importer = get_tdata_importer()
            result = importer.check_default_tdata()
            
            self.send_event("default-tdata-path", result)
            
        except Exception as e:
            self.send_event("default-tdata-path", {
                "path": "",
                "exists": False,
                "error": str(e)
            })
    
    async def handle_export_session(self, payload: Dict[str, Any]):
        """Handle export-session command - export a session package with credentials"""
        try:
            from pathlib import Path
            from session_package import SessionPackage
            
            phone_number = payload.get('phoneNumber')
            export_path = payload.get('filePath')
            export_format = payload.get('format', 'package')  # 'package' or 'legacy'
            
            if not phone_number:
                self.send_log("No phone number provided", "error")
                return
            
            if not export_path:
                self.send_log("No export path provided", "error")
                return
            
            # Get account data
            account = await db.get_account_by_phone(phone_number)
            if not account:
                self.send_log(f"Account not found: {phone_number}", "error")
                return
            
            # Find session file
            from config import SESSIONS_DIR
            safe_phone = phone_number.replace("+", "").replace("-", "").replace(" ", "")
            session_file = SESSIONS_DIR / f"{safe_phone}.session"
            
            if not session_file.exists():
                self.send_log(f"Session file not found for {phone_number}", "error")
                return
            
            export_path_obj = Path(export_path)
            
            if export_format == 'package' or export_path.endswith('.tgpkg'):
                # Export as TG-Matrix session package (recommended)
                # æ•°æ®åº“å­—æ®µåæ˜¯ apiId å’Œ apiHash
                success, message = SessionPackage.create_package(
                    session_file_path=session_file,
                    api_id=account.get('apiId') or account.get('api_id', ''),
                    api_hash=account.get('apiHash') or account.get('api_hash', ''),
                    phone=phone_number,
                    output_path=export_path_obj,
                    proxy=account.get('proxy', ''),
                    role=account.get('role', 'Unassigned'),
                    group=account.get('group', ''),
                    daily_send_limit=account.get('dailySendLimit') or account.get('daily_send_limit', 50),
                    notes=account.get('notes', '')
                )
                
                if success:
                    self.send_log(f"âœ… Session åŒ…å·²å°å‡º: {phone_number}", "success")
                    self.send_event("session-exported", {
                        "phoneNumber": phone_number,
                        "filePath": str(export_path_obj) if not str(export_path_obj).endswith('.tgpkg') else str(export_path_obj),
                        "format": "package"
                    })
                else:
                    self.send_log(f"å°å‡ºå¤±æ•—: {message}", "error")
            else:
                # Legacy export (just session file, not recommended)
                import shutil
                shutil.copy2(session_file, export_path_obj)
                self.send_log(f"âš ï¸ Session æ–‡ä»¶å·²å°å‡º (ä¸åŒ…å« API æ†‘è­‰): {phone_number}", "warning")
                self.send_event("session-exported", {
                    "phoneNumber": phone_number,
                    "filePath": export_path,
                    "format": "legacy",
                    "warning": "ä¸åŒ…å« API æ†‘è­‰ï¼Œå°å…¥æ™‚éœ€è¦é‡æ–°è¼¸å…¥"
                })
        
        except Exception as e:
            self.send_log(f"Error exporting session: {str(e)}", "error")
    
    async def handle_export_sessions_batch(self, payload: Dict[str, Any]):
        """Handle batch export of multiple sessions"""
        try:
            from pathlib import Path
            from session_package import BatchSessionPackage
            from config import SESSIONS_DIR
            
            phone_numbers = payload.get('phoneNumbers', [])
            export_path = payload.get('filePath')
            
            if not phone_numbers:
                self.send_log("No accounts selected for export", "error")
                return
            
            if not export_path:
                self.send_log("No export path provided", "error")
                return
            
            # Get account data for all selected phones
            accounts_data = []
            for phone in phone_numbers:
                account = await db.get_account_by_phone(phone)
                if account:
                    accounts_data.append(account)
            
            if not accounts_data:
                self.send_log("No valid accounts found", "error")
                return
            
            export_path_obj = Path(export_path)
            success, message, count = BatchSessionPackage.create_batch_package(
                accounts_data=accounts_data,
                sessions_dir=SESSIONS_DIR,
                output_path=export_path_obj
            )
            
            if success:
                self.send_log(f"âœ… æ‰¹é‡å°å‡ºå®Œæˆ: {count} å€‹è³¬æˆ¶", "success")
                self.send_event("sessions-batch-exported", {
                    "count": count,
                    "filePath": str(export_path_obj)
                })
            else:
                self.send_log(f"æ‰¹é‡å°å‡ºå¤±æ•—: {message}", "error")
        
        except Exception as e:
            self.send_log(f"Error batch exporting sessions: {str(e)}", "error")
    
    async def handle_create_backup(self, payload: Dict[str, Any]):
        """Handle create-backup command"""
        try:
            if not self.backup_manager:
                self.send_log("å‚™ä»½ç®¡ç†å™¨æœªåˆå§‹åŒ–", "error")
                return
            
            backup_type = payload.get('type', 'manual')
            compress = payload.get('compress', True)
            backup_path = await self.backup_manager.create_backup(
                backup_type=backup_type,
                compress=compress
            )
            
            self.send_log(f"âœ“ å‚™ä»½å‰µå»ºæˆåŠŸ: {backup_path.name}", "success")
            self.send_event("backup-created", {
                "backupPath": str(backup_path),
                "backupName": backup_path.name,
                "size": backup_path.stat().st_size,
                "type": backup_type
            })
        except Exception as e:
            app_error = handle_error(e, {"command": "create-backup", "payload": payload})
            self.send_log(f"å‰µå»ºå‚™ä»½å¤±æ•—: {str(app_error)}", "error")
    
    async def handle_restore_backup(self, payload: Dict[str, Any]):
        """Handle restore-backup command"""
        try:
            from pathlib import Path
            backup_path_str = payload.get('backupPath')
            create_current_backup = payload.get('createCurrentBackup', True)
            
            if not backup_path_str:
                self.send_log("No backup path provided", "error")
                return
            
            backup_path = Path(backup_path_str)
            
            if not self.backup_manager:
                self.send_log("å‚™ä»½ç®¡ç†å™¨æœªåˆå§‹åŒ–", "error")
                return
            
            success = await self.backup_manager.restore_backup(backup_path, create_current_backup)
            
            if success:
                self.send_log(f"âœ“ æ•¸æ“šåº«å·²å¾å‚™ä»½æ¢å¾©: {backup_path.name}", "success")
                self.send_event("backup-restored", {
                    "backupPath": str(backup_path)
                })
                
                # Reload initial state after restore
                await self.handle_get_initial_state()
            else:
                self.send_log("æ¢å¾©å‚™ä»½å¤±æ•—", "error")
        except Exception as e:
            app_error = handle_error(e, {"command": "restore-backup", "payload": payload})
            self.send_log(f"Error restoring backup: {str(app_error)}", "error")
    
    async def handle_list_backups(self):
        """Handle list-backups command"""
        try:
            backup_manager = get_backup_manager()
            backups = backup_manager.list_backups()
            
            backup_list = []
            for backup in backups:
                backup_time = datetime.fromtimestamp(backup.stat().st_mtime)
                backup_list.append({
                    "name": backup.name,
                    "path": str(backup),
                    "size": backup.stat().st_size,
                    "sizeMB": round(backup.stat().st_size / (1024 * 1024), 2),
                    "timestamp": backup_time.isoformat()
                })
            
            self.send_event("backups-listed", {
                "backups": backup_list
            })
        except Exception as e:
            app_error = handle_error(e, {"command": "list-backups"})
            self.send_log(f"Error listing backups: {str(app_error)}", "error")
    
    async def handle_get_backup_info(self):
        """Handle get-backup-info command"""
        try:
            backup_manager = get_backup_manager()
            info = backup_manager.get_backup_info()
            self.send_event("backup-info", info)
        except Exception as e:
            app_error = handle_error(e, {"command": "get-backup-info"})
            self.send_log(f"Error getting backup info: {str(app_error)}", "error")
    
    async def handle_get_performance_summary(self):
        """Handle get-performance-summary command"""
        try:
            # ğŸ†• æ€§èƒ½å„ªåŒ–ï¼šä½¿ç”¨ç·©å­˜æ¸›å°‘é »ç¹æŸ¥è©¢
            cache = get_cache_manager()
            cache_key = "performance_summary"
            cached = cache.get("stats", cache_key)  # ğŸ”§ ä¿®å¾©ï¼šæ·»åŠ  namespace åƒæ•¸
            if cached:
                self.send_event("performance-summary", cached)
                return
            
            from performance_monitor import get_performance_monitor
            monitor = get_performance_monitor()
            if monitor:
                summary = monitor.get_performance_summary()
                # ç·©å­˜ 10 ç§’
                cache.set("stats", cache_key, summary, ttl=10)  # ğŸ”§ ä¿®å¾©ï¼šæ·»åŠ  namespace åƒæ•¸
                self.send_event("performance-summary", summary)
            else:
                self.send_log("Performance monitor not initialized", "warning")
                self.send_event("performance-summary", {})
        except Exception as e:
            app_error = handle_error(e, {"command": "get-performance-summary"})
            self.send_log(f"Error getting performance summary: {str(app_error)}", "error")
            self.send_event("performance-summary", {})
    
    async def handle_get_performance_metrics(self, payload: Dict[str, Any]):
        """Handle get-performance-metrics command"""
        try:
            # ğŸ†• æ€§èƒ½å„ªåŒ–ï¼šä½¿ç”¨ç·©å­˜
            cache = get_cache_manager()
            limit = payload.get('limit', 100)
            cache_key = f"performance_metrics_{limit}_{payload.get('startTime', '')}_{payload.get('endTime', '')}"
            cached = cache.get("stats", cache_key)  # ğŸ”§ ä¿®å¾©ï¼šæ·»åŠ  namespace åƒæ•¸
            if cached:
                self.send_event("performance-metrics", cached)
                return
            
            from performance_monitor import get_performance_monitor
            from datetime import datetime
            monitor = get_performance_monitor()
            if monitor:
                # Parse time filters from payload
                start_time = None
                end_time = None
                
                if payload.get('startTime'):
                    start_time = datetime.fromisoformat(payload['startTime'].replace('Z', '+00:00'))
                if payload.get('endTime'):
                    end_time = datetime.fromisoformat(payload['endTime'].replace('Z', '+00:00'))
                
                # Get metrics history with filters
                metrics = monitor.get_metrics_history(
                    start_time=start_time,
                    end_time=end_time,
                    limit=limit
                )
                
                # Convert datetime objects to ISO strings
                for metric in metrics:
                    if 'timestamp' in metric and isinstance(metric['timestamp'], datetime):
                        metric['timestamp'] = metric['timestamp'].isoformat()
                
                result = {"metrics": metrics}
                # ğŸ†• ç·©å­˜ 15 ç§’
                cache.set("stats", cache_key, result, ttl=15)  # ğŸ”§ ä¿®å¾©ï¼šæ·»åŠ  namespace åƒæ•¸
                self.send_event("performance-metrics", result)
            else:
                self.send_log("Performance monitor not initialized", "warning")
                self.send_event("performance-metrics", {"metrics": []})
        except Exception as e:
            app_error = handle_error(e, {"command": "get-performance-metrics", "payload": payload})
            self.send_log(f"Error getting performance metrics: {str(app_error)}", "error")
            self.send_event("performance-metrics", {"metrics": []})
    
    async def handle_get_sending_stats(self, payload: Dict[str, Any]):
        """Handle get-sending-stats command"""
        try:
            days = payload.get('days', 7)
            phone = payload.get('phone')  # Optional
            
            stats = await db.get_message_sending_stats(days, phone)
            self.send_event("sending-stats", {"stats": stats, "days": days, "phone": phone})
        except Exception as e:
            handle_error(e, {"command": "get-sending-stats", "payload": payload})
            self.send_log(f"Error getting sending stats: {str(e)}", "error")
    
    async def handle_get_queue_length_history(self, payload: Dict[str, Any]):
        """Handle get-queue-length-history command"""
        try:
            days = payload.get('days', 7)
            
            history = await db.get_queue_length_history(days)
            self.send_event("queue-length-history", {"history": history, "days": days})
        except Exception as e:
            handle_error(e, {"command": "get-queue-length-history", "payload": payload})
            self.send_log(f"Error getting queue length history: {str(e)}", "error")
    
    async def handle_get_account_sending_comparison(self, payload: Dict[str, Any]):
        """Handle get-account-sending-comparison command"""
        try:
            days = payload.get('days', 7)
            
            comparison = await db.get_account_sending_comparison(days)
            self.send_event("account-sending-comparison", {"comparison": comparison, "days": days})
        except Exception as e:
            handle_error(e, {"command": "get-account-sending-comparison", "payload": payload})
            self.send_log(f"Error getting account sending comparison: {str(e)}", "error")
    
    async def handle_get_campaign_performance_stats(self, payload: Dict[str, Any]):
        """Handle get-campaign-performance-stats command"""
        try:
            days = payload.get('days', 7)
            
            stats = await db.get_campaign_performance_stats(days)
            self.send_event("campaign-performance-stats", {"stats": stats, "days": days})
        except Exception as e:
            handle_error(e, {"command": "get-campaign-performance-stats", "payload": payload})
            self.send_log(f"Error getting campaign performance stats: {str(e)}", "error")
    
    async def handle_get_alerts(self, payload: Dict[str, Any]):
        """Handle get-alerts command"""
        try:
            limit = payload.get('limit', 50)
            level = payload.get('level')  # Optional: 'info', 'warning', 'error', 'critical'
            unresolved_only = payload.get('unresolvedOnly', False)
            
            if unresolved_only:
                alerts = await db.get_unresolved_alerts(limit)
            else:
                alerts = await db.get_recent_alerts(limit, level)
            
            self.send_event("alerts-loaded", {"alerts": alerts, "count": len(alerts)})
        except Exception as e:
            handle_error(e, {"command": "get-alerts", "payload": payload})
            self.send_log(f"Error getting alerts: {str(e)}", "error")
    
    async def handle_acknowledge_alert(self, payload: Dict[str, Any]):
        """Handle acknowledge-alert command"""
        try:
            alert_id = payload.get('alertId')
            if not alert_id:
                self.send_log("Alert ID required", "error")
                return
            
            await db.acknowledge_alert(alert_id)
            self.send_log(f"Alert {alert_id} acknowledged", "success")
            
            # Send updated alerts
            alerts = await db.get_recent_alerts(50)
            self.send_event("alerts-loaded", {"alerts": alerts, "count": len(alerts)})
        except Exception as e:
            handle_error(e, {"command": "acknowledge-alert", "payload": payload})
            self.send_log(f"Error acknowledging alert: {str(e)}", "error")
    
    async def handle_resolve_alert(self, payload: Dict[str, Any]):
        """Handle resolve-alert command"""
        try:
            alert_id = payload.get('alertId')
            if not alert_id:
                self.send_log("Alert ID required", "error")
                return
            
            await db.resolve_alert(alert_id)
            self.send_log(f"Alert {alert_id} resolved", "success")
            
            # Send updated alerts
            alerts = await db.get_recent_alerts(50)
            self.send_event("alerts-loaded", {"alerts": alerts, "count": len(alerts)})
        except Exception as e:
            handle_error(e, {"command": "resolve-alert", "payload": payload})
            self.send_log(f"Error resolving alert: {str(e)}", "error")
    
    async def handle_migration_status(self, payload: Dict[str, Any]):
        """Handle migration-status command"""
        try:
            from migrations.migration_manager import get_migration_manager
            migration_manager = get_migration_manager()
            
            if not migration_manager:
                self.send_log("Migration manager not initialized", "warning")
                self.send_event("migration-status", {
                    "error": "Migration manager not initialized"
                })
                return
            
            status = await migration_manager.status()
            self.send_event("migration-status", status)
        except Exception as e:
            handle_error(e, {"command": "migration-status", "payload": payload})
            self.send_log(f"Error getting migration status: {str(e)}", "error")
            self.send_event("migration-status", {"error": str(e)})
    
    async def handle_migrate(self, payload: Dict[str, Any]):
        """Handle migrate command"""
        try:
            from migrations.migration_manager import get_migration_manager
            migration_manager = get_migration_manager()
            
            if not migration_manager:
                self.send_log("Migration manager not initialized", "error")
                return
            
            target_version = payload.get('targetVersion')  # Optional
            
            success = await migration_manager.migrate(target_version)
            if success:
                status = await migration_manager.status()
                self.send_log("Migration completed successfully", "success")
                self.send_event("migration-completed", {
                    "message": "Migration completed successfully",
                    "status": status
                })
            else:
                self.send_log("Migration failed", "error")
                self.send_event("migration-completed", {
                    "error": "Migration failed"
                })
        except Exception as e:
            handle_error(e, {"command": "migrate", "payload": payload})
            self.send_log(f"Error running migration: {str(e)}", "error")
            self.send_event("migration-completed", {"error": str(e)})
    
    async def handle_rollback_migration(self, payload: Dict[str, Any]):
        """Handle rollback-migration command"""
        try:
            from migrations.migration_manager import get_migration_manager
            migration_manager = get_migration_manager()
            
            if not migration_manager:
                self.send_log("Migration manager not initialized", "error")
                return
            
            target_version = payload.get('targetVersion')
            if target_version is None:
                self.send_log("Missing targetVersion", "error")
                return
            
            success = await migration_manager.rollback(target_version)
            if success:
                status = await migration_manager.status()
                self.send_log(f"Rollback to version {target_version} completed successfully", "success")
                self.send_event("migration-rollback-completed", {
                    "message": f"Rollback to version {target_version} completed successfully",
                    "status": status
                })
            else:
                self.send_log("Rollback failed", "error")
                self.send_event("migration-rollback-completed", {
                    "error": "Rollback failed"
                })
        except Exception as e:
            handle_error(e, {"command": "rollback-migration", "payload": payload})
            self.send_log(f"Error rolling back migration: {str(e)}", "error")
            self.send_event("migration-rollback-completed", {"error": str(e)})
    
    async def run(self):
        """Main event loop - read commands from stdin"""
        await self.initialize()
        
        try:
            while self.running:
                # Read line from stdin (non-blocking)
                line = await asyncio.get_event_loop().run_in_executor(
                    None, sys.stdin.readline
                )
                
                if not line:
                    # EOF - stdin closed
                    break
                
                line = line.strip()
                if not line:
                    continue
                
                try:
                    # Parse JSON command
                    command_data = json.loads(line)
                    command = command_data.get('command')
                    payload = command_data.get('payload', {})
                    request_id = command_data.get('request_id')  # Optional request ID for acknowledgment
                    
                    # Handle command
                    await self.handle_command(command, payload, request_id)
                
                except json.JSONDecodeError as e:
                    self.send_log(f"Invalid JSON received: {str(e)}", "error")
                except Exception as e:
                    self.send_log(f"Unexpected error: {str(e)}", "error")
                    import traceback
                    traceback.print_exc()
        
        except KeyboardInterrupt:
            pass
        finally:
            await self.shutdown()


    # ==================== Local AI & Voice Services Handlers ====================
    
    async def handle_test_local_ai(self, payload: Dict[str, Any]):
        """Test connection to local AI service with detailed diagnostics"""
        import aiohttp
        import socket
        import time
        from urllib.parse import urlparse
        
        endpoint = payload.get('endpoint', 'http://localhost:3002')
        model = payload.get('model', '')
        
        diagnostics = {
            "endpoint": endpoint,
            "tcp_connection": False,
            "http_connection": False,
            "ai_response": False,
            "errors": []
        }
        
        try:
            # è§£æç«¯é»
            parsed = urlparse(endpoint)
            host = parsed.hostname
            port = parsed.port or (443 if parsed.scheme == 'https' else 80)
            
            print(f"[AI Test] Testing connection to {host}:{port}...", file=sys.stderr)
            
            # æ­¥é©Ÿ 1: æ¸¬è©¦ TCP é€£æ¥
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(5)
                result = sock.connect_ex((host, port))
                sock.close()
                
                if result == 0:
                    diagnostics["tcp_connection"] = True
                    print(f"[AI Test] âœ“ TCP connection to {host}:{port} successful", file=sys.stderr)
                else:
                    diagnostics["errors"].append(f"TCP é€£æ¥å¤±æ•— (éŒ¯èª¤ä»£ç¢¼: {result})")
                    print(f"[AI Test] âœ— TCP connection failed (error code: {result})", file=sys.stderr)
                    self.send_event("local-ai-test-result", {
                        "success": False,
                        "endpoint": endpoint,
                        "diagnostics": diagnostics,
                        "error": f"ç„¡æ³•é€£æ¥åˆ° {host}:{port}ã€‚è«‹æª¢æŸ¥ï¼š\n1. AI æœå‹™æ˜¯å¦æ­£åœ¨é‹è¡Œ\n2. é˜²ç«ç‰†æ˜¯å¦å…è¨±é€£æ¥\n3. ç¶²çµ¡æ˜¯å¦æ­£å¸¸"
                    })
                    return
            except socket.gaierror as e:
                diagnostics["errors"].append(f"DNS è§£æå¤±æ•—: {str(e)}")
                print(f"[AI Test] âœ— DNS resolution failed: {e}", file=sys.stderr)
                self.send_event("local-ai-test-result", {
                    "success": False,
                    "endpoint": endpoint,
                    "diagnostics": diagnostics,
                    "error": f"ç„¡æ³•è§£æä¸»æ©Ÿå {host}ã€‚è«‹æª¢æŸ¥ç¶²çµ¡è¨­ç½®"
                })
                return
            except socket.timeout:
                diagnostics["errors"].append("TCP é€£æ¥è¶…æ™‚")
                print(f"[AI Test] âœ— TCP connection timeout", file=sys.stderr)
                self.send_event("local-ai-test-result", {
                    "success": False,
                    "endpoint": endpoint,
                    "diagnostics": diagnostics,
                    "error": f"é€£æ¥ {host}:{port} è¶…æ™‚ã€‚è«‹æª¢æŸ¥é˜²ç«ç‰†è¨­ç½®"
                })
                return
            except Exception as e:
                diagnostics["errors"].append(f"TCP é€£æ¥éŒ¯èª¤: {str(e)}")
                print(f"[AI Test] âœ— TCP connection error: {e}", file=sys.stderr)
            
            # æ­¥é©Ÿ 2: æ¸¬è©¦ HTTP é€£æ¥
            timeout = aiohttp.ClientTimeout(total=30, connect=5)
            async with aiohttp.ClientSession(timeout=timeout) as session:
                # å˜—è©¦ GET è«‹æ±‚ï¼ˆOllama å¥åº·æª¢æŸ¥ï¼‰
                try:
                    health_url = endpoint.rstrip('/')
                    if not health_url.endswith('/api/tags') and not health_url.endswith('/v1/models'):
                        # å˜—è©¦ Ollama å¥åº·æª¢æŸ¥ç«¯é»
                        health_endpoints = [
                            f"{health_url}",
                            f"{health_url}/api/tags",
                            f"{health_url}/v1/models"
                        ]
                    else:
                        health_endpoints = [health_url]
                    
                    for health_endpoint in health_endpoints:
                        try:
                            async with session.get(health_endpoint, timeout=aiohttp.ClientTimeout(total=5)) as resp:
                                if resp.status in [200, 404, 405]:
                                    diagnostics["http_connection"] = True
                                    print(f"[AI Test] âœ“ HTTP connection successful: {health_endpoint} (status: {resp.status})", file=sys.stderr)
                                    break
                        except:
                            continue
                except Exception as e:
                    diagnostics["errors"].append(f"HTTP é€£æ¥æ¸¬è©¦å¤±æ•—: {str(e)}")
                    print(f"[AI Test] HTTP connection test failed: {e}", file=sys.stderr)
                
                # æ­¥é©Ÿ 3: æ¸¬è©¦å¯¦éš› AI è«‹æ±‚
                try:
                    chat_url = endpoint.rstrip('/')
                    if not chat_url.endswith('/v1/chat/completions'):
                        chat_url = chat_url.rstrip('/') + '/v1/chat/completions'
                    
                    test_payload = {
                        "messages": [{"role": "user", "content": "test"}],
                        "max_tokens": 10
                    }
                    if model:
                        test_payload["model"] = model
                    
                    print(f"[AI Test] Testing AI request to {chat_url}...", file=sys.stderr)
                    start_time = time.time()
                    
                    async with session.post(chat_url, json=test_payload, timeout=aiohttp.ClientTimeout(total=30)) as resp:
                        elapsed = time.time() - start_time
                        print(f"[AI Test] Response received in {elapsed:.2f}s, status: {resp.status}", file=sys.stderr)
                        
                        if resp.status == 200:
                            data = await resp.json()
                            if 'choices' in data or 'response' in data or 'content' in data:
                                diagnostics["ai_response"] = True
                                print(f"[AI Test] âœ“ AI service responded successfully", file=sys.stderr)
                                self.send_event("local-ai-test-result", {
                                    "success": True,
                                    "endpoint": endpoint,
                                    "diagnostics": diagnostics,
                                    "response_time": elapsed
                                })
                                self.send_log(f"âœ“ æœ¬åœ° AI é€£æ¥æˆåŠŸ: {endpoint} (éŸ¿æ‡‰æ™‚é–“: {elapsed:.2f}ç§’)", "success")
                                return
                            else:
                                diagnostics["errors"].append(f"AI éŸ¿æ‡‰æ ¼å¼ç•°å¸¸: {list(data.keys())}")
                        else:
                            error_text = await resp.text()
                            diagnostics["errors"].append(f"HTTP {resp.status}: {error_text[:200]}")
                            print(f"[AI Test] âœ— AI service returned error: {resp.status}", file=sys.stderr)
                            
                except asyncio.TimeoutError:
                    elapsed = time.time() - start_time if 'start_time' in locals() else 30
                    diagnostics["errors"].append(f"AI è«‹æ±‚è¶…æ™‚ ({elapsed:.1f}ç§’)")
                    print(f"[AI Test] âœ— AI request timeout after {elapsed:.2f}s", file=sys.stderr)
                except aiohttp.ClientConnectorError as e:
                    diagnostics["errors"].append(f"ç„¡æ³•é€£æ¥åˆ°ç«¯é»: {str(e)}")
                    print(f"[AI Test] âœ— Connection error: {e}", file=sys.stderr)
                except Exception as e:
                    diagnostics["errors"].append(f"AI è«‹æ±‚éŒ¯èª¤: {str(e)}")
                    print(f"[AI Test] âœ— AI request error: {e}", file=sys.stderr)
            
            # å¦‚æœæ‰€æœ‰æ¸¬è©¦éƒ½å¤±æ•—
            self.send_event("local-ai-test-result", {
                "success": False,
                "endpoint": endpoint,
                "diagnostics": diagnostics,
                "error": f"ç„¡æ³•é€£æ¥åˆ°æœ¬åœ° AI æœå‹™ã€‚è¨ºæ–·ä¿¡æ¯ï¼š\n" + "\n".join(diagnostics["errors"])
            })
            self.send_log(f"âœ— æœ¬åœ° AI é€£æ¥å¤±æ•—: {endpoint}", "error")
                
        except Exception as e:
            import traceback
            error_details = traceback.format_exc()
            print(f"[AI Test] Unexpected error: {error_details}", file=sys.stderr)
            diagnostics["errors"].append(f"æœªé æœŸçš„éŒ¯èª¤: {str(e)}")
            self.send_event("local-ai-test-result", {
                "success": False,
                "endpoint": endpoint,
                "diagnostics": diagnostics,
                "error": str(e)
            })
            self.send_log(f"âœ— æœ¬åœ° AI æ¸¬è©¦éŒ¯èª¤: {str(e)}", "error")

    async def handle_test_tts_service(self, payload: Dict[str, Any]):
        """Test connection to TTS service (GPT-SoVITS) - ğŸ”§ P2 å„ªåŒ–ï¼šçœŸæ­£çš„èªéŸ³ç”Ÿæˆæ¸¬è©¦"""
        import time as time_module
        endpoint = payload.get('endpoint', 'http://localhost:9881')
        
        diagnostics = {
            "endpoint": endpoint,
            "http_reachable": False,
            "tts_available": False,
            "voice_generation": False,
            "latency_ms": 0,
            "errors": []
        }
        
        try:
            import aiohttp
            start_time = time_module.time()
            
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=30)) as session:
                # æ­¥é©Ÿ 1: æ¸¬è©¦ HTTP å¯é”æ€§
                try:
                    async with session.get(f"{endpoint}/") as resp:
                        if resp.status in [200, 404, 405]:
                            diagnostics["http_reachable"] = True
                            print(f"[TTS Test] âœ“ HTTP å¯é”", file=sys.stderr)
                except Exception as e:
                    diagnostics["errors"].append(f"HTTP é€£æ¥å¤±æ•—: {str(e)}")
                    print(f"[TTS Test] âœ— HTTP é€£æ¥å¤±æ•—: {e}", file=sys.stderr)
                
                # æ­¥é©Ÿ 2: å˜—è©¦ç²å– TTS æœå‹™ç‹€æ…‹/å¯ç”¨èªéŸ³åˆ—è¡¨
                tts_api_endpoints = [
                    f"{endpoint}/",  # GPT-SoVITS æ ¹ç«¯é»
                    f"{endpoint}/tts",
                    f"{endpoint}/api/tts",
                    f"{endpoint}/v1/audio/speech",  # OpenAI å…¼å®¹
                ]
                
                for api_url in tts_api_endpoints:
                    try:
                        async with session.get(api_url, timeout=aiohttp.ClientTimeout(total=5)) as resp:
                            if resp.status in [200, 405]:  # GET å¯èƒ½è¿”å› 405ï¼Œä½†èªªæ˜ç«¯é»å­˜åœ¨
                                diagnostics["tts_available"] = True
                                print(f"[TTS Test] âœ“ TTS API å¯ç”¨: {api_url}", file=sys.stderr)
                                break
                    except:
                        continue
                
                # æ­¥é©Ÿ 3: å˜—è©¦çœŸæ­£çš„èªéŸ³ç”Ÿæˆæ¸¬è©¦
                if diagnostics["tts_available"] or diagnostics["http_reachable"]:
                    test_text = "æ¸¬è©¦"
                    tts_endpoints = [
                        (f"{endpoint}/", {"text": test_text, "text_language": "zh"}),  # GPT-SoVITS
                        (f"{endpoint}/tts", {"text": test_text}),
                        (f"{endpoint}/api/tts", {"text": test_text}),
                    ]
                    
                    for tts_url, payload_data in tts_endpoints:
                        try:
                            gen_start = time_module.time()
                            async with session.post(tts_url, json=payload_data, timeout=aiohttp.ClientTimeout(total=20)) as resp:
                                if resp.status == 200:
                                    content_type = resp.headers.get('content-type', '')
                                    if 'audio' in content_type or 'octet-stream' in content_type:
                                        diagnostics["voice_generation"] = True
                                        diagnostics["latency_ms"] = int((time_module.time() - gen_start) * 1000)
                                        print(f"[TTS Test] âœ“ èªéŸ³ç”ŸæˆæˆåŠŸï¼Œå»¶é²: {diagnostics['latency_ms']}ms", file=sys.stderr)
                                        break
                                    else:
                                        # å¯èƒ½è¿”å› JSON éŒ¯èª¤
                                        try:
                                            data = await resp.json()
                                            if 'audio' in data or 'wav' in str(data):
                                                diagnostics["voice_generation"] = True
                                                diagnostics["latency_ms"] = int((time_module.time() - gen_start) * 1000)
                                                break
                                        except:
                                            pass
                        except asyncio.TimeoutError:
                            diagnostics["errors"].append(f"èªéŸ³ç”Ÿæˆè¶…æ™‚")
                        except Exception as e:
                            # ç¹¼çºŒå˜—è©¦å…¶ä»–ç«¯é»
                            continue
                
                # è¨ˆç®—ç¸½å»¶é²
                total_latency = int((time_module.time() - start_time) * 1000)
                if diagnostics["latency_ms"] == 0:
                    diagnostics["latency_ms"] = total_latency
                
                # åˆ¤æ–·æˆåŠŸæ¨™æº–
                if diagnostics["voice_generation"]:
                    self.send_event("tts-test-result", {
                        "success": True,
                        "endpoint": endpoint,
                        "diagnostics": diagnostics,
                        "latencyMs": diagnostics["latency_ms"],
                        "message": f"èªéŸ³æœå‹™æ­£å¸¸ï¼Œç”Ÿæˆå»¶é² {diagnostics['latency_ms']}ms"
                    })
                    self.send_log(f"âœ“ TTS æœå‹™å®Œå…¨æ­£å¸¸: {endpoint} (å»¶é²: {diagnostics['latency_ms']}ms)", "success")
                elif diagnostics["tts_available"] or diagnostics["http_reachable"]:
                    self.send_event("tts-test-result", {
                        "success": True,
                        "endpoint": endpoint,
                        "diagnostics": diagnostics,
                        "latencyMs": total_latency,
                        "message": "æœå‹™å¯é”ï¼Œä½†ç„¡æ³•é©—è­‰èªéŸ³ç”Ÿæˆï¼ˆå¯èƒ½éœ€è¦é…ç½®èªéŸ³æ¨¡å‹ï¼‰"
                    })
                    self.send_log(f"âš  TTS æœå‹™å¯é”ä½†æœªé©—è­‰èªéŸ³ç”Ÿæˆ: {endpoint}", "warning")
                else:
                    self.send_event("tts-test-result", {
                        "success": False,
                        "endpoint": endpoint,
                        "diagnostics": diagnostics,
                        "error": "ç„¡æ³•é€£æ¥åˆ° TTS æœå‹™\n" + "\n".join(diagnostics["errors"])
                    })
                    self.send_log(f"âœ— TTS æœå‹™é€£æ¥å¤±æ•—: {endpoint}", "error")
                
        except Exception as e:
            import traceback
            print(f"[TTS Test] ç•°å¸¸: {traceback.format_exc()}", file=sys.stderr)
            self.send_event("tts-test-result", {
                "success": False,
                "endpoint": endpoint,
                "diagnostics": diagnostics,
                "error": str(e)
            })
            self.send_log(f"âœ— TTS æ¸¬è©¦éŒ¯èª¤: {str(e)}", "error")

    async def handle_test_stt_service(self, payload: Dict[str, Any]):
        """Test connection to STT service (Whisper)"""
        endpoint = payload.get('endpoint', 'http://localhost:9000')
        
        try:
            import aiohttp
            
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=10)) as session:
                test_urls = [
                    f"{endpoint}/",
                    f"{endpoint}/transcribe",
                    f"{endpoint}/api/transcribe",
                ]
                
                for test_url in test_urls:
                    try:
                        async with session.get(test_url) as response:
                            if response.status in [200, 404, 405]:
                                self.send_event("stt-test-result", {
                                    "success": True,
                                    "endpoint": endpoint,
                                    "status": response.status
                                })
                                self.send_log(f"âœ“ STT æœå‹™é€£æ¥æˆåŠŸ: {endpoint}", "success")
                                return
                    except:
                        continue
                
                self.send_event("stt-test-result", {
                    "success": False,
                    "endpoint": endpoint,
                    "error": "ç„¡æ³•é€£æ¥åˆ° STT æœå‹™"
                })
                self.send_log(f"âœ— STT æœå‹™é€£æ¥å¤±æ•—: {endpoint}", "error")
                
        except Exception as e:
            self.send_event("stt-test-result", {
                "success": False,
                "endpoint": endpoint,
                "error": str(e)
            })
            self.send_log(f"âœ— STT æ¸¬è©¦éŒ¯èª¤: {str(e)}", "error")

    async def handle_get_ai_settings(self, payload: Dict[str, Any] = None):
        """ç²å– AI è¨­ç½®ï¼ˆåŒ…æ‹¬ Gemini API Keyï¼‰"""
        try:
            # å¾æ•¸æ“šåº«ç²å–è¨­ç½®
            settings = await db.get_ai_settings()
            
            result = {
                'geminiApiKey': settings.get('gemini_api_key', ''),
                'localAiEndpoint': settings.get('local_ai_endpoint', 'http://localhost:11434'),
                'localAiModel': settings.get('local_ai_model', ''),
                'apiType': settings.get('api_type', 'gemini'),
            }
            
            self.send_event("ai-settings-loaded", result)
            
        except Exception as e:
            import sys
            print(f"[Backend] Error loading AI settings: {e}", file=sys.stderr)
            self.send_event("ai-settings-loaded", {})
    
    async def handle_save_ai_settings(self, payload: Dict[str, Any]):
        """Save AI and voice service settings"""
        try:
            # Store settings in memory (for legacy compatibility)
            settings = {
                "apiType": payload.get('apiType', 'gemini'),
                "apiKey": payload.get('apiKey', ''),
                "endpoint": payload.get('endpoint', ''),
                "localAiEndpoint": payload.get('localAiEndpoint', 'http://localhost:3002'),
                "localAiModel": payload.get('localAiModel', ''),
                "ttsEndpoint": payload.get('ttsEndpoint', 'http://localhost:9881'),
                "ttsEnabled": payload.get('ttsEnabled', False),
                "ttsVoice": payload.get('ttsVoice', ''),
                "sttEndpoint": payload.get('sttEndpoint', 'http://localhost:9000'),
                "sttEnabled": payload.get('sttEnabled', False)
            }
            
            # Store in self for later use
            self.ai_settings = settings
            
            # ğŸ”§ é—œéµä¿®å¾©ï¼šåŒæ™‚ä¿å­˜åˆ°æ•¸æ“šåº«ï¼ˆä½¿ç”¨ snake_case éµåï¼‰
            db_settings = {
                'local_ai_endpoint': payload.get('localAiEndpoint', ''),
                'local_ai_model': payload.get('localAiModel', ''),
                'gemini_api_key': payload.get('geminiApiKey', ''),  # æ·»åŠ  Gemini API Key ä¿å­˜
                'api_type': payload.get('apiType', 'gemini'),
            }
            await db.update_ai_settings(db_settings)
            
            # é‡æ–°è¼‰å…¥ AI æœå‹™è¨­ç½®
            await ai_auto_chat.initialize()
            
            # è¨­ç½® AI é…ç½®
            endpoint = payload.get('localAiEndpoint', '')
            model = payload.get('localAiModel', '')
            if endpoint:
                ai_auto_chat.set_ai_config(endpoint, model)
                self.send_log(f"âœ“ AI ç«¯é»å·²é…ç½®: {endpoint}", "success")
            
            self.send_event("ai-settings-saved", {"success": True})
            self.send_log("AI å’ŒèªéŸ³æœå‹™è¨­ç½®å·²ä¿å­˜åˆ°æ•¸æ“šåº«", "success")
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("ai-settings-saved", {"success": False, "error": str(e)})
            self.send_log(f"ä¿å­˜ AI è¨­ç½®å¤±æ•—: {str(e)}", "error")

    async def handle_set_autonomous_mode(self, payload: Dict[str, Any]):
        """ğŸ†• è¨­ç½® AI è‡ªä¸»æ¨¡å¼é–‹é—œ"""
        enabled = payload.get('enabled', False)
        
        try:
            # ä¿å­˜åˆ°æ•¸æ“šåº«
            await db.execute("""
                INSERT INTO ai_settings (key, value) VALUES ('autonomous_mode', ?)
                ON CONFLICT(key) DO UPDATE SET value = excluded.value, updated_at = CURRENT_TIMESTAMP
            """, ('1' if enabled else '0',))
            
            # æ›´æ–° AI æœå‹™
            if ai_auto_chat:
                ai_auto_chat.autonomous_mode = enabled
                self.send_log(f"AI è‡ªä¸»æ¨¡å¼å·²{'å•Ÿç”¨' if enabled else 'é—œé–‰'}", "success")
            
            self.send_event("autonomous-mode-updated", {
                "success": True,
                "enabled": enabled
            })
            
        except Exception as e:
            print(f"[Backend] Error setting autonomous mode: {e}", file=sys.stderr)
            self.send_event("autonomous-mode-updated", {
                "success": False,
                "error": str(e)
            })

    async def handle_get_customer_state(self, payload: Dict[str, Any]):
        """ğŸ†• ç²å–å®¢æˆ¶ç‹€æ…‹ï¼ˆAI è‡ªä¸»å¼•æ“ï¼‰"""
        user_id = payload.get('userId', '')
        
        try:
            if ai_auto_chat and ai_auto_chat.autonomous_engine:
                state = await ai_auto_chat.autonomous_engine.get_customer_state(user_id)
                if state:
                    from dataclasses import asdict
                    state_dict = asdict(state)
                    # è½‰æ›æšèˆ‰ç‚ºå­—ç¬¦ä¸²
                    state_dict['conversion_stage'] = state.conversion_stage.value
                    state_dict['customer_style'] = state.customer_style.value
                    self.send_event("customer-state", {
                        "success": True,
                        "state": state_dict
                    })
                else:
                    self.send_event("customer-state", {
                        "success": True,
                        "state": None
                    })
            else:
                self.send_event("customer-state", {
                    "success": False,
                    "error": "AI è‡ªä¸»å¼•æ“æœªåˆå§‹åŒ–"
                })
        except Exception as e:
            print(f"[Backend] Error getting customer state: {e}", file=sys.stderr)
            self.send_event("customer-state", {
                "success": False,
                "error": str(e)
            })

    async def handle_get_smart_system_stats(self, payload: Dict[str, Any]):
        """ğŸ†• ç²å–æ™ºèƒ½ç³»çµ±çµ±è¨ˆ"""
        stats = {
            'memories': 0,
            'tags': 0,
            'emotions': 0,
            'workflows': 0,
            'followups': 0,
            'knowledge': 0
        }
        
        try:
            # è¨˜æ†¶çµ±è¨ˆ
            try:
                result = await db.fetch_one("SELECT COUNT(*) as count FROM conversation_memories")
                stats['memories'] = result['count'] if result else 0
            except:
                pass
            
            # æ¨™ç±¤çµ±è¨ˆ
            try:
                result = await db.fetch_one("SELECT COUNT(*) as count FROM customer_tags")
                stats['tags'] = result['count'] if result else 0
            except:
                pass
            
            # æƒ…ç·’çµ±è¨ˆ
            try:
                result = await db.fetch_one("SELECT COUNT(*) as count FROM emotion_records")
                stats['emotions'] = result['count'] if result else 0
            except:
                pass
            
            # å·¥ä½œæµçµ±è¨ˆ
            try:
                result = await db.fetch_one("SELECT COUNT(*) as count FROM workflow_executions")
                stats['workflows'] = result['count'] if result else 0
            except:
                pass
            
            # è·Ÿé€²ä»»å‹™çµ±è¨ˆ
            try:
                result = await db.fetch_one("SELECT COUNT(*) as count FROM followup_tasks WHERE status = 'pending'")
                stats['followups'] = result['count'] if result else 0
            except:
                pass
            
            # çŸ¥è­˜å­¸ç¿’çµ±è¨ˆ
            try:
                result = await db.fetch_one("SELECT COUNT(*) as count FROM learned_knowledge")
                stats['knowledge'] = result['count'] if result else 0
            except:
                pass
            
            self.send_event("smart-system-stats", stats)
            print(f"[Backend] Smart system stats: {stats}", file=sys.stderr)
            
        except Exception as e:
            print(f"[Backend] Error getting smart system stats: {e}", file=sys.stderr)
            self.send_event("smart-system-stats", stats)

    async def handle_get_user_memories(self, payload: Dict[str, Any]):
        """ğŸ†• Phase1: ç²å–ç”¨æˆ¶è¨˜æ†¶"""
        user_id = payload.get('userId', '')
        current_message = payload.get('message', '')
        
        try:
            from conversation_memory import get_memory_service
            service = get_memory_service()
            
            memories = await service.recall_relevant_memories(user_id, current_message)
            summary = await service.get_conversation_summary(user_id)
            
            self.send_event("user-memories", {
                "success": True,
                "memories": memories,
                "summary": summary
            })
        except Exception as e:
            print(f"[Backend] Error getting user memories: {e}", file=sys.stderr)
            self.send_event("user-memories", {
                "success": False,
                "error": str(e)
            })

    async def handle_get_user_tags(self, payload: Dict[str, Any]):
        """ğŸ†• Phase1: ç²å–ç”¨æˆ¶æ¨™ç±¤"""
        user_id = payload.get('userId', '')
        
        try:
            from auto_tagging_service import get_tagging_service
            service = get_tagging_service()
            
            tags = await service.get_user_tags(user_id)
            
            self.send_event("user-tags", {
                "success": True,
                "data": tags
            })
        except Exception as e:
            print(f"[Backend] Error getting user tags: {e}", file=sys.stderr)
            self.send_event("user-tags", {
                "success": False,
                "error": str(e)
            })

    async def handle_add_user_tag(self, payload: Dict[str, Any]):
        """ğŸ†• Phase1: æ‰‹å‹•æ·»åŠ ç”¨æˆ¶æ¨™ç±¤"""
        user_id = payload.get('userId', '')
        tag_name = payload.get('tagName', '')
        category = payload.get('category', 'custom')
        
        try:
            from auto_tagging_service import get_tagging_service, TagCategory
            service = get_tagging_service()
            
            cat = TagCategory(category) if category in [e.value for e in TagCategory] else TagCategory.CUSTOM
            await service.add_manual_tag(user_id, tag_name, cat)
            
            self.send_event("user-tag-added", {
                "success": True,
                "tagName": tag_name
            })
            self.send_log(f"å·²ç‚ºç”¨æˆ¶ {user_id} æ·»åŠ æ¨™ç±¤: {tag_name}", "success")
        except Exception as e:
            print(f"[Backend] Error adding user tag: {e}", file=sys.stderr)
            self.send_event("user-tag-added", {
                "success": False,
                "error": str(e)
            })

    async def handle_remove_user_tag(self, payload: Dict[str, Any]):
        """ğŸ†• Phase1: ç§»é™¤ç”¨æˆ¶æ¨™ç±¤"""
        user_id = payload.get('userId', '')
        tag_id = payload.get('tagId', '')
        
        try:
            from auto_tagging_service import get_tagging_service
            service = get_tagging_service()
            
            await service.remove_tag(user_id, tag_id)
            
            self.send_event("user-tag-removed", {
                "success": True,
                "tagId": tag_id
            })
        except Exception as e:
            print(f"[Backend] Error removing user tag: {e}", file=sys.stderr)
            self.send_event("user-tag-removed", {
                "success": False,
                "error": str(e)
            })

    async def handle_get_users_by_tag(self, payload: Dict[str, Any]):
        """ğŸ†• Phase1: æ ¹æ“šæ¨™ç±¤æŸ¥è©¢ç”¨æˆ¶"""
        tag_name = payload.get('tagName')
        category = payload.get('category')
        intent_level = payload.get('intentLevel')
        
        try:
            from auto_tagging_service import get_tagging_service, TagCategory, IntentLevel
            service = get_tagging_service()
            
            cat = TagCategory(category) if category else None
            level = IntentLevel(intent_level) if intent_level else None
            
            users = await service.get_users_by_tag(tag_name, cat, level)
            
            self.send_event("users-by-tag", {
                "success": True,
                "users": users,
                "count": len(users)
            })
        except Exception as e:
            print(f"[Backend] Error getting users by tag: {e}", file=sys.stderr)
            self.send_event("users-by-tag", {
                "success": False,
                "error": str(e)
            })

    async def handle_get_customer_profile(self, payload: Dict[str, Any]):
        """ğŸ†• ç²å–å®¢æˆ¶ç•«åƒï¼ˆæ¨™ç±¤+æ„å‘ï¼‰"""
        user_id = payload.get('userId', '')
        
        try:
            from auto_tagging_service import get_tagging_service
            service = get_tagging_service()
            
            profile = await service.get_customer_profile(user_id)
            
            self.send_event("customer-profile", {
                "success": True,
                "profile": profile
            })
        except Exception as e:
            print(f"[Backend] Error getting customer profile: {e}", file=sys.stderr)
            self.send_event("customer-profile", {
                "success": False,
                "error": str(e)
            })

    async def handle_get_emotion_trend(self, payload: Dict[str, Any]):
        """ğŸ†• ç²å–æƒ…ç·’è¶¨å‹¢"""
        user_id = payload.get('userId', '')
        
        try:
            from emotion_analyzer import get_emotion_analyzer
            analyzer = get_emotion_analyzer()
            
            trend = await analyzer.get_emotion_trend(user_id)
            
            self.send_event("emotion-trend", {
                "success": True,
                "trend": trend
            })
        except Exception as e:
            print(f"[Backend] Error getting emotion trend: {e}", file=sys.stderr)
            self.send_event("emotion-trend", {
                "success": False,
                "error": str(e)
            })

    async def handle_get_workflow_rules(self, payload: Dict[str, Any]):
        """ğŸ†• ç²å–å·¥ä½œæµè¦å‰‡"""
        try:
            from automation_workflow import get_workflow_engine
            engine = get_workflow_engine()
            
            rules = await engine.get_rules()
            
            self.send_event("workflow-rules", {
                "success": True,
                "rules": rules
            })
        except Exception as e:
            print(f"[Backend] Error getting workflow rules: {e}", file=sys.stderr)
            self.send_event("workflow-rules", {
                "success": False,
                "error": str(e)
            })

    async def handle_get_followup_tasks(self, payload: Dict[str, Any]):
        """ğŸ†• ç²å–è·Ÿé€²ä»»å‹™"""
        try:
            from smart_timing_service import get_timing_service
            service = get_timing_service()
            
            tasks = await service.get_pending_followups()
            
            self.send_event("followup-tasks", {
                "success": True,
                "tasks": tasks
            })
        except Exception as e:
            print(f"[Backend] Error getting followup tasks: {e}", file=sys.stderr)
            self.send_event("followup-tasks", {
                "success": False,
                "error": str(e)
            })

    async def handle_get_learning_stats(self, payload: Dict[str, Any]):
        """ğŸ†• ç²å–çŸ¥è­˜å­¸ç¿’çµ±è¨ˆ"""
        try:
            from knowledge_learning import get_learning_service
            service = get_learning_service()
            
            stats = await service.get_learning_stats()
            
            self.send_event("learning-stats", {
                "success": True,
                "stats": stats
            })
        except Exception as e:
            print(f"[Backend] Error getting learning stats: {e}", file=sys.stderr)
            self.send_event("learning-stats", {
                "success": False,
                "error": str(e)
            })

    async def handle_get_knowledge_gaps(self, payload: Dict[str, Any]):
        """ğŸ†• ç²å–çŸ¥è­˜ç¼ºå£"""
        status = payload.get('status', 'pending')
        
        try:
            from knowledge_learning import get_learning_service
            service = get_learning_service()
            
            gaps = await service.get_knowledge_gaps(status)
            
            self.send_event("knowledge-gaps", {
                "success": True,
                "gaps": gaps
            })
        except Exception as e:
            print(f"[Backend] Error getting knowledge gaps: {e}", file=sys.stderr)
            self.send_event("knowledge-gaps", {
                "success": False,
                "error": str(e)
            })

    async def handle_schedule_followup(self, payload: Dict[str, Any]):
        """ğŸ†• æ‰‹å‹•æ’ç¨‹è·Ÿé€²"""
        user_id = payload.get('userId', '')
        reason = payload.get('reason', 'manual')
        hours = payload.get('hours', 24)
        message = payload.get('message', '')
        
        try:
            from smart_timing_service import get_timing_service, FollowUpReason
            service = get_timing_service()
            
            await service.schedule_followup(
                user_id,
                FollowUpReason(reason) if reason in [e.value for e in FollowUpReason] else FollowUpReason.NO_REPLY,
                hours,
                message
            )
            
            self.send_event("followup-scheduled", {
                "success": True,
                "userId": user_id,
                "hours": hours
            })
            self.send_log(f"å·²ç‚ºç”¨æˆ¶ {user_id} æ’ç¨‹ {hours} å°æ™‚å¾Œè·Ÿé€²", "success")
        except Exception as e:
            print(f"[Backend] Error scheduling followup: {e}", file=sys.stderr)
            self.send_event("followup-scheduled", {
                "success": False,
                "error": str(e)
            })

    async def handle_trigger_workflow(self, payload: Dict[str, Any]):
        """ğŸ†• æ‰‹å‹•è§¸ç™¼å·¥ä½œæµ"""
        event_type = payload.get('eventType', 'message_received')
        user_id = payload.get('userId', '')
        event_data = payload.get('data', {})
        
        try:
            from automation_workflow import get_workflow_engine, EventType
            engine = get_workflow_engine()
            
            triggered = await engine.trigger_event(
                EventType(event_type),
                user_id,
                event_data
            )
            
            self.send_event("workflow-triggered", {
                "success": True,
                "triggeredRules": triggered
            })
            if triggered:
                self.send_log(f"å·²è§¸ç™¼ {len(triggered)} å€‹å·¥ä½œæµè¦å‰‡", "success")
        except Exception as e:
            print(f"[Backend] Error triggering workflow: {e}", file=sys.stderr)
            self.send_event("workflow-triggered", {
                "success": False,
                "error": str(e)
            })

    async def handle_generate_with_local_ai(self, payload: Dict[str, Any]):
        """Generate text using local AI service"""
        endpoint = payload.get('endpoint', getattr(self, 'ai_settings', {}).get('localAiEndpoint', 'http://localhost:3002'))
        prompt = payload.get('prompt', '')
        model = payload.get('model', '')
        
        try:
            import aiohttp
            
            # Try OpenAI-compatible API format
            request_data = {
                "model": model or "default",
                "messages": [{"role": "user", "content": prompt}],
                "max_tokens": 500,
                "temperature": 0.7
            }
            
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=60)) as session:
                async with session.post(f"{endpoint}/v1/chat/completions", json=request_data) as response:
                    if response.status == 200:
                        result = await response.json()
                        generated_text = result.get('choices', [{}])[0].get('message', {}).get('content', '')
                        
                        self.send_event("local-ai-generation-result", {
                            "success": True,
                            "text": generated_text
                        })
                        return
                    else:
                        error_text = await response.text()
                        self.send_event("local-ai-generation-result", {
                            "success": False,
                            "error": f"API è¿”å› {response.status}: {error_text}"
                        })
                        
        except Exception as e:
            self.send_event("local-ai-generation-result", {
                "success": False,
                "error": str(e)
            })

    async def handle_text_to_speech(self, payload: Dict[str, Any]):
        """Convert text to speech using TTS service"""
        endpoint = payload.get('endpoint', getattr(self, 'ai_settings', {}).get('ttsEndpoint', 'http://localhost:9881'))
        text = payload.get('text', '')
        voice = payload.get('voice', '')
        
        try:
            import aiohttp
            
            # GPT-SoVITS API format
            request_data = {
                "text": text,
                "text_language": "zh",
                "ref_audio_path": voice if voice else None
            }
            
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:
                async with session.post(f"{endpoint}/", json=request_data) as response:
                    if response.status == 200:
                        audio_data = await response.read()
                        import base64
                        audio_base64 = base64.b64encode(audio_data).decode('utf-8')
                        
                        self.send_event("tts-result", {
                            "success": True,
                            "audio": audio_base64,
                            "format": "wav"
                        })
                    else:
                        error_text = await response.text()
                        self.send_event("tts-result", {
                            "success": False,
                            "error": f"TTS æœå‹™è¿”å› {response.status}: {error_text}"
                        })
                        
        except Exception as e:
            self.send_event("tts-result", {
                "success": False,
                "error": str(e)
            })

    async def handle_speech_to_text(self, payload: Dict[str, Any]):
        """Convert speech to text using STT service"""
        endpoint = payload.get('endpoint', getattr(self, 'ai_settings', {}).get('sttEndpoint', 'http://localhost:9000'))
        audio_data = payload.get('audio', '')  # Base64 encoded audio
        
        try:
            import aiohttp
            import base64
            
            # Decode audio
            audio_bytes = base64.b64decode(audio_data)
            
            # Create form data for Whisper API
            data = aiohttp.FormData()
            data.add_field('file', audio_bytes, filename='audio.wav', content_type='audio/wav')
            
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:
                async with session.post(f"{endpoint}/transcribe", data=data) as response:
                    if response.status == 200:
                        result = await response.json()
                        transcribed_text = result.get('text', '')
                        
                        self.send_event("stt-result", {
                            "success": True,
                            "text": transcribed_text
                        })
                    else:
                        error_text = await response.text()
                        self.send_event("stt-result", {
                            "success": False,
                            "error": f"STT æœå‹™è¿”å› {response.status}: {error_text}"
                        })
                        
        except Exception as e:
            self.send_event("stt-result", {
                "success": False,
                "error": str(e)
            })

    # ==================== Voice Clone Handlers ====================
    
    async def handle_upload_voice_sample(self, payload: Dict[str, Any]):
        """Upload and save a voice sample for cloning"""
        name = payload.get('name', 'unnamed')
        audio_data = payload.get('audioData', '')
        file_name = payload.get('fileName', 'audio.wav')
        file_type = payload.get('fileType', 'audio/wav')
        
        try:
            import base64
            import os
            
            # Create voice samples directory
            voice_dir = os.path.join(os.path.dirname(__file__), 'voice_samples')
            os.makedirs(voice_dir, exist_ok=True)
            
            # Generate unique filename
            import time
            unique_name = f"{int(time.time())}_{file_name}"
            file_path = os.path.join(voice_dir, unique_name)
            
            # Decode and save audio
            audio_bytes = base64.b64decode(audio_data)
            with open(file_path, 'wb') as f:
                f.write(audio_bytes)
            
            self.send_event("voice-sample-uploaded", {
                "success": True,
                "voiceId": str(int(time.time())),
                "name": name,
                "audioPath": unique_name,
                "filePath": file_path
            })
            self.send_log(f"âœ“ è²éŸ³æ¨£æœ¬å·²ä¿å­˜: {name}", "success")
            
        except Exception as e:
            self.send_event("voice-sample-uploaded", {
                "success": False,
                "error": str(e)
            })
            self.send_log(f"âœ— ä¿å­˜è²éŸ³æ¨£æœ¬å¤±æ•—: {str(e)}", "error")

    async def handle_delete_voice_sample(self, payload: Dict[str, Any]):
        """Delete a voice sample"""
        voice_id = payload.get('voiceId', '')
        
        try:
            import os
            
            # Find and delete the file
            voice_dir = os.path.join(os.path.dirname(__file__), 'voice_samples')
            
            # Try to find the file by ID (timestamp prefix)
            for filename in os.listdir(voice_dir):
                if filename.startswith(voice_id):
                    file_path = os.path.join(voice_dir, filename)
                    os.remove(file_path)
                    self.send_event("voice-sample-deleted", {"success": True, "voiceId": voice_id})
                    self.send_log(f"âœ“ è²éŸ³æ¨£æœ¬å·²åˆªé™¤", "success")
                    return
            
            self.send_event("voice-sample-deleted", {"success": True, "voiceId": voice_id})
            
        except Exception as e:
            self.send_event("voice-sample-deleted", {
                "success": False,
                "error": str(e)
            })

    async def handle_preview_voice_sample(self, payload: Dict[str, Any]):
        """Preview a voice sample (send audio data back)"""
        voice_id = payload.get('voiceId', '')
        audio_path = payload.get('audioPath', '')
        
        try:
            import os
            import base64
            
            voice_dir = os.path.join(os.path.dirname(__file__), 'voice_samples')
            file_path = os.path.join(voice_dir, audio_path)
            
            if os.path.exists(file_path):
                with open(file_path, 'rb') as f:
                    audio_data = base64.b64encode(f.read()).decode('utf-8')
                
                self.send_event("voice-sample-preview", {
                    "success": True,
                    "voiceId": voice_id,
                    "audio": audio_data
                })
            else:
                self.send_event("voice-sample-preview", {
                    "success": False,
                    "error": "éŸ³é »æ–‡ä»¶ä¸å­˜åœ¨"
                })
                
        except Exception as e:
            self.send_event("voice-sample-preview", {
                "success": False,
                "error": str(e)
            })

    async def handle_generate_cloned_voice(self, payload: Dict[str, Any]):
        """Generate speech using a cloned voice via remote TTS service"""
        endpoint = payload.get('endpoint', '')
        text = payload.get('text', '')
        voice_id = payload.get('voiceId', '')
        audio_path = payload.get('audioPath', '')
        
        try:
            import aiohttp
            import base64
            import os
            
            # Read the reference audio file
            voice_dir = os.path.join(os.path.dirname(__file__), 'voice_samples')
            ref_audio_path = os.path.join(voice_dir, audio_path)
            
            if not os.path.exists(ref_audio_path):
                self.send_event("cloned-voice-generated", {
                    "success": False,
                    "error": "åƒè€ƒéŸ³é »æ–‡ä»¶ä¸å­˜åœ¨"
                })
                return
            
            # Read reference audio
            with open(ref_audio_path, 'rb') as f:
                ref_audio_data = base64.b64encode(f.read()).decode('utf-8')
            
            # GPT-SoVITS API format
            request_data = {
                "text": text,
                "text_language": "zh",
                "refer_wav_base64": ref_audio_data,
                "prompt_text": "",  # Can be set to reference text if available
                "prompt_language": "zh"
            }
            
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=180)) as session:
                # Try different endpoint formats
                endpoints_to_try = [
                    f"{endpoint}/",
                    f"{endpoint}/tts",
                    f"{endpoint}/api/tts",
                    f"{endpoint}/v1/audio/speech"
                ]
                
                for api_url in endpoints_to_try:
                    try:
                        async with session.post(api_url, json=request_data) as response:
                            if response.status == 200:
                                content_type = response.headers.get('Content-Type', '')
                                
                                if 'audio' in content_type or 'octet-stream' in content_type:
                                    # Binary audio response
                                    audio_data = await response.read()
                                    audio_base64 = base64.b64encode(audio_data).decode('utf-8')
                                    
                                    self.send_event("cloned-voice-generated", {
                                        "success": True,
                                        "audio": audio_base64,
                                        "format": "wav"
                                    })
                                    self.send_log(f"âœ“ ä½¿ç”¨å…‹éš†è²éŸ³ç”ŸæˆèªéŸ³æˆåŠŸ", "success")
                                    return
                                else:
                                    # JSON response (might contain URL or base64)
                                    result = await response.json()
                                    if 'audio' in result:
                                        self.send_event("cloned-voice-generated", {
                                            "success": True,
                                            "audio": result['audio'],
                                            "format": result.get('format', 'wav')
                                        })
                                        self.send_log(f"âœ“ ä½¿ç”¨å…‹éš†è²éŸ³ç”ŸæˆèªéŸ³æˆåŠŸ", "success")
                                        return
                    except Exception as e:
                        continue
                
                self.send_event("cloned-voice-generated", {
                    "success": False,
                    "error": "ç„¡æ³•é€£æ¥åˆ° TTS æœå‹™æˆ–æ‰€æœ‰ç«¯é»éƒ½å¤±æ•—"
                })
                self.send_log(f"âœ— TTS ç”Ÿæˆå¤±æ•—: ç„¡æ³•é€£æ¥åˆ°æœå‹™", "error")
                        
        except Exception as e:
            self.send_event("cloned-voice-generated", {
                "success": False,
                "error": str(e)
            })
            self.send_log(f"âœ— å…‹éš†è²éŸ³ç”Ÿæˆå¤±æ•—: {str(e)}", "error")

    async def handle_list_voice_samples(self):
        """List all saved voice samples"""
        try:
            import os
            
            voice_dir = os.path.join(os.path.dirname(__file__), 'voice_samples')
            
            if not os.path.exists(voice_dir):
                self.send_event("voice-samples-list", {"success": True, "samples": []})
                return
            
            samples = []
            for filename in os.listdir(voice_dir):
                file_path = os.path.join(voice_dir, filename)
                if os.path.isfile(file_path):
                    stat = os.stat(file_path)
                    samples.append({
                        "id": filename.split('_')[0],
                        "name": '_'.join(filename.split('_')[1:]).rsplit('.', 1)[0],
                        "audioPath": filename,
                        "size": stat.st_size,
                        "createdAt": stat.st_ctime
                    })
            
            self.send_event("voice-samples-list", {
                "success": True,
                "samples": samples
            })
            
        except Exception as e:
            self.send_event("voice-samples-list", {
                "success": False,
                "error": str(e)
            })

    # ==================== AI Auto Chat Handlers ====================
    
    async def handle_get_ai_chat_settings(self):
        """Get AI auto chat settings"""
        try:
            settings = await db.get_ai_settings()
            self.send_event("ai-chat-settings", {
                "success": True,
                "settings": settings
            })
        except Exception as e:
            self.send_event("ai-chat-settings", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_update_ai_chat_settings(self, payload: Dict[str, Any]):
        """Update AI auto chat settings"""
        try:
            settings = payload.get('settings', {})
            await db.update_ai_settings(settings)
            
            # Update AI auto chat service
            await ai_auto_chat.update_settings(settings)
            
            # Update AI endpoint if provided
            if 'localAiEndpoint' in payload:
                ai_auto_chat.set_ai_config(
                    payload.get('localAiEndpoint', ''),
                    payload.get('localAiModel', '')
                )
            
            self.send_event("ai-chat-settings-updated", {"success": True})
            self.send_log("AI è‡ªå‹•èŠå¤©è¨­ç½®å·²æ›´æ–°", "success")
        except Exception as e:
            self.send_event("ai-chat-settings-updated", {
                "success": False,
                "error": str(e)
            })
            self.send_log(f"æ›´æ–° AI è¨­ç½®å¤±æ•—: {str(e)}", "error")
    
    async def handle_get_chat_history(self, payload: Dict[str, Any]):
        """Get chat history for a user"""
        try:
            user_id = payload.get('userId', '')
            limit = payload.get('limit', 50)
            
            if not user_id:
                self.send_event("chat-history", {"success": False, "error": "Missing userId"})
                return
            
            history = await db.get_chat_history(user_id, limit=limit)
            stats = await db.get_chat_stats(user_id)
            
            self.send_event("chat-history", {
                "success": True,
                "userId": user_id,
                "history": history,
                "stats": stats
            })
        except Exception as e:
            self.send_event("chat-history", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_user_context(self, payload: Dict[str, Any]):
        """Get full user context"""
        try:
            user_id = payload.get('userId', '')
            
            if not user_id:
                self.send_event("user-context", {"success": False, "error": "Missing userId"})
                return
            
            context = await ai_context.get_user_context(user_id)
            
            self.send_event("user-context", {
                "success": True,
                "userId": user_id,
                "context": context
            })
        except Exception as e:
            self.send_event("user-context", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_generate_ai_response(self, payload: Dict[str, Any]):
        """Generate AI response for a user message"""
        import time
        import sys
        start_time = time.time()
        
        print(f"[AI] handle_generate_ai_response called with payload keys: {payload.keys()}", file=sys.stderr)
        try:
            user_id = payload.get('userId', '')
            message = payload.get('message', '')
            system_prompt = payload.get('systemPrompt', '')
            endpoint = payload.get('localAiEndpoint', '')
            model = payload.get('localAiModel', '')
            
            print(f"[AI] Endpoint: {endpoint}, Model: {model}", file=sys.stderr)
            print(f"[AI] Message length: {len(message)}, System prompt length: {len(system_prompt)}", file=sys.stderr)
            
            if not message:
                self.send_event("ai-response", {"success": False, "error": "ç¼ºå°‘æ¶ˆæ¯å…§å®¹"})
                return
            
            if not endpoint:
                self.send_event("ai-response", {"success": False, "error": "æœªé…ç½® AI æœå‹™ç«¯é»"})
                return
            
            # å¦‚æœæä¾›äº†ç«¯é»ï¼Œç›´æ¥èª¿ç”¨æœ¬åœ° AI
            if endpoint:
                print(f"[AI] Calling local AI service at {endpoint}...", file=sys.stderr)
                response = await self._call_local_ai(endpoint, model, system_prompt, message)
            else:
                # ä½¿ç”¨ ai_auto_chat æœå‹™
                print(f"[AI] Using ai_auto_chat service...", file=sys.stderr)
                ai_auto_chat.set_ai_config(endpoint, model)
                response = await ai_auto_chat.get_suggested_response(user_id, message)
            
            elapsed = time.time() - start_time
            print(f"[AI] AI generation completed in {elapsed:.2f}s", file=sys.stderr)
            
            if response:
                print(f"[AI] Successfully generated response (length: {len(response)})", file=sys.stderr)
                self.send_event("ai-response", {
                    "success": True,
                    "userId": user_id,
                    "response": response
                })
            else:
                print(f"[AI] AI returned empty response", file=sys.stderr)
                self.send_event("ai-response", {
                    "success": False,
                    "error": "AI ç”Ÿæˆå¤±æ•—ï¼Œè¿”å›ç‚ºç©ºã€‚è«‹æª¢æŸ¥æœå‹™é…ç½®å’Œæ—¥èªŒ"
                })
        except asyncio.TimeoutError:
            elapsed = time.time() - start_time
            error_msg = f"AI ç”Ÿæˆè¶…æ™‚ï¼ˆ{elapsed:.1f}ç§’ï¼‰ï¼Œè«‹æª¢æŸ¥æœå‹™é€£æ¥"
            print(f"[AI] {error_msg}", file=sys.stderr)
            self.send_event("ai-response", {
                "success": False,
                "error": error_msg
            })
        except Exception as e:
            import traceback
            elapsed = time.time() - start_time
            error_details = traceback.format_exc()
            error_msg = f"AI ç”ŸæˆéŒ¯èª¤: {str(e)}"
            print(f"[AI] Error after {elapsed:.2f}s: {error_details}", file=sys.stderr)
            self.send_event("ai-response", {
                "success": False,
                "error": error_msg
            })
    
    async def _call_local_ai(self, endpoint: str, model: str, system_prompt: str, user_message: str) -> str:
        """ç›´æ¥èª¿ç”¨æœ¬åœ°/é ç¨‹ AI API"""
        import aiohttp
        import time
        import socket
        from urllib.parse import urlparse
        
        print(f"[AI] _call_local_ai called with endpoint: {endpoint}, model: {model}", file=sys.stderr)
        
        # é¦–å…ˆé€²è¡Œé€£æ¥è¨ºæ–·
        try:
            parsed = urlparse(endpoint)
            host = parsed.hostname
            port = parsed.port or (443 if parsed.scheme == 'https' else 80)
            
            print(f"[AI] Diagnosing connection to {host}:{port}...", file=sys.stderr)
            
            # æ¸¬è©¦ TCP é€£æ¥
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(5)
                result = sock.connect_ex((host, port))
                sock.close()
                
                if result == 0:
                    print(f"[AI] âœ“ TCP connection to {host}:{port} successful", file=sys.stderr)
                else:
                    print(f"[AI] âœ— TCP connection to {host}:{port} failed (error code: {result})", file=sys.stderr)
                    raise Exception(f"ç„¡æ³•é€£æ¥åˆ° AI æœå‹™ {host}:{port}ã€‚è«‹æª¢æŸ¥ï¼š\n1. AI æœå‹™æ˜¯å¦æ­£åœ¨é‹è¡Œ\n2. é˜²ç«ç‰†æ˜¯å¦å…è¨±é€£æ¥\n3. ç¶²çµ¡æ˜¯å¦æ­£å¸¸")
            except socket.gaierror as e:
                print(f"[AI] âœ— DNS resolution failed for {host}: {e}", file=sys.stderr)
                raise Exception(f"ç„¡æ³•è§£æä¸»æ©Ÿå {host}ã€‚è«‹æª¢æŸ¥ç¶²çµ¡è¨­ç½®æˆ– DNS é…ç½®")
            except socket.timeout:
                print(f"[AI] âœ— Connection timeout to {host}:{port}", file=sys.stderr)
                raise Exception(f"é€£æ¥ {host}:{port} è¶…æ™‚ã€‚è«‹æª¢æŸ¥ï¼š\n1. AI æœå‹™æ˜¯å¦æ­£åœ¨é‹è¡Œ\n2. é˜²ç«ç‰†æ˜¯å¦é˜»å¡äº†é€£æ¥\n3. ç¶²çµ¡è·¯ç”±æ˜¯å¦æ­£ç¢º")
            except Exception as e:
                print(f"[AI] âœ— Connection test failed: {e}", file=sys.stderr)
                raise Exception(f"é€£æ¥æ¸¬è©¦å¤±æ•—: {str(e)}")
        except Exception as diag_error:
            # è¨ºæ–·å¤±æ•—ï¼Œä½†ç¹¼çºŒå˜—è©¦å¯¦éš›è«‹æ±‚ï¼ˆå¯èƒ½è¨ºæ–·æœ‰èª¤ï¼‰
            print(f"[AI] Connection diagnosis failed, but continuing: {diag_error}", file=sys.stderr)
        
        messages = []
        if system_prompt:
            messages.append({"role": "system", "content": system_prompt})
        messages.append({"role": "user", "content": user_message})
        
        # å˜—è©¦ OpenAI å…¼å®¹æ ¼å¼
        request_body = {
            "messages": messages,
            "max_tokens": 500,
            "temperature": 0.7
        }
        if model:
            request_body["model"] = model
        
        # å¢åŠ è¶…æ™‚æ™‚é–“åˆ° 90 ç§’ï¼ˆAI ç”Ÿæˆå¯èƒ½éœ€è¦æ›´é•·æ™‚é–“ï¼‰
        timeout = aiohttp.ClientTimeout(total=90, connect=10)
        
        try:
            start_time = time.time()
            async with aiohttp.ClientSession() as session:
                # å˜—è©¦ /v1/chat/completions ç«¯é»
                chat_url = endpoint.rstrip('/')
                if not chat_url.endswith('/v1/chat/completions'):
                    chat_url = chat_url.rstrip('/') + '/v1/chat/completions'
                
                print(f"[AI] Attempting to call AI endpoint: {chat_url}", file=sys.stderr)
                print(f"[AI] Request body: model={model}, messages={len(messages)}, max_tokens=500", file=sys.stderr)
                
                try:
                    request_start = time.time()
                    async with session.post(chat_url, json=request_body, timeout=timeout) as resp:
                        connect_time = time.time() - request_start
                        print(f"[AI] Connection established in {connect_time:.2f}s, status: {resp.status}", file=sys.stderr)
                        
                        if resp.status == 200:
                            data_start = time.time()
                            data = await resp.json()
                            data_time = time.time() - data_start
                            total_time = time.time() - start_time
                            
                            print(f"[AI] Response received in {data_time:.2f}s, total time: {total_time:.2f}s", file=sys.stderr)
                            
                            if 'choices' in data and len(data['choices']) > 0:
                                content = data['choices'][0].get('message', {}).get('content', '')
                                print(f"[AI] âœ“ Successfully generated response (length: {len(content)})", file=sys.stderr)
                                return content
                            else:
                                print(f"[AI] âœ— Response missing 'choices' field. Full response: {data}", file=sys.stderr)
                                raise Exception(f"AI æœå‹™è¿”å›äº†ç„¡æ•ˆçš„éŸ¿æ‡‰æ ¼å¼: {list(data.keys())}")
                        else:
                            error_text = await resp.text()
                            print(f"[AI] âœ— Error response (status {resp.status}): {error_text[:500]}", file=sys.stderr)
                            raise Exception(f"AI æœå‹™è¿”å›éŒ¯èª¤ (HTTP {resp.status}): {error_text[:200]}")
                            
                except asyncio.TimeoutError:
                    elapsed = time.time() - start_time
                    print(f"[AI] âœ— Request timeout after {elapsed:.2f}s for endpoint: {chat_url}", file=sys.stderr)
                    raise Exception(f"AI æœå‹™éŸ¿æ‡‰è¶…æ™‚ï¼ˆ{elapsed:.1f}ç§’ï¼‰ã€‚å¯èƒ½åŸå› ï¼š\n1. AI æœå‹™éŸ¿æ‡‰éæ…¢\n2. ç¶²çµ¡å»¶é²éé«˜\n3. æ¨¡å‹åŠ è¼‰ä¸­\nè«‹æª¢æŸ¥ AI æœå‹™ç‹€æ…‹")
                except aiohttp.ClientConnectorError as e:
                    elapsed = time.time() - start_time
                    print(f"[AI] âœ— Connection error after {elapsed:.2f}s: {e}", file=sys.stderr)
                    raise Exception(f"ç„¡æ³•é€£æ¥åˆ° AI æœå‹™ ({host}:{port})ã€‚è«‹æª¢æŸ¥ï¼š\n1. AI æœå‹™æ˜¯å¦æ­£åœ¨é‹è¡Œ\n2. é˜²ç«ç‰†æ˜¯å¦å…è¨±é€£æ¥\n3. ç«¯é»åœ°å€æ˜¯å¦æ­£ç¢º")
                except aiohttp.ClientError as e:
                    elapsed = time.time() - start_time
                    print(f"[AI] âœ— Client error after {elapsed:.2f}s: {e}", file=sys.stderr)
                    # å¦‚æœ /v1/chat/completions å¤±æ•—ï¼Œå˜—è©¦ç›´æ¥ç«¯é»
                    if chat_url != endpoint:
                        print(f"[AI] Trying direct endpoint: {endpoint}", file=sys.stderr)
                        try:
                            async with session.post(endpoint, json=request_body, timeout=timeout) as resp2:
                                if resp2.status == 200:
                                    data = await resp2.json()
                                    # è™•ç†å„ç¨®éŸ¿æ‡‰æ ¼å¼
                                    if 'choices' in data:
                                        return data['choices'][0].get('message', {}).get('content', '')
                                    elif 'response' in data:
                                        return data['response']
                                    elif 'content' in data:
                                        return data['content']
                                    elif 'text' in data:
                                        return data['text']
                                else:
                                    error_text = await resp2.text()
                                    print(f"[AI] Direct endpoint error (status {resp2.status}): {error_text[:200]}", file=sys.stderr)
                        except Exception as e2:
                            print(f"[AI] Direct endpoint also failed: {e2}", file=sys.stderr)
                    raise Exception(f"ç¶²çµ¡éŒ¯èª¤: {str(e)}")
                    
        except asyncio.TimeoutError:
            raise Exception("AI æœå‹™éŸ¿æ‡‰è¶…æ™‚ï¼Œè«‹æª¢æŸ¥æœå‹™é€£æ¥æˆ–å¢åŠ è¶…æ™‚æ™‚é–“")
        except aiohttp.ClientError as e:
            error_msg = str(e)
            print(f"[AI] Network error: {error_msg}", file=sys.stderr)
            raise Exception(f"ç„¡æ³•é€£æ¥åˆ° AI æœå‹™ ({endpoint}): {error_msg}")
        except Exception as e:
            import traceback
            error_details = traceback.format_exc()
            print(f"[AI] Unexpected error: {error_details}", file=sys.stderr)
            raise
            raise
    
    async def handle_add_ai_memory(self, payload: Dict[str, Any]):
        """Add an AI memory for a user"""
        try:
            user_id = payload.get('userId', '')
            memory_type = payload.get('memoryType', 'fact')
            content = payload.get('content', '')
            importance = payload.get('importance', 0.5)
            
            if not user_id or not content:
                self.send_event("ai-memory-added", {"success": False, "error": "Missing userId or content"})
                return
            
            memory_id = await db.add_ai_memory(user_id, memory_type, content, importance)
            
            self.send_event("ai-memory-added", {
                "success": True,
                "memoryId": memory_id
            })
            self.send_log(f"ç‚ºç”¨æˆ¶ {user_id} æ·»åŠ äº†è¨˜æ†¶", "success")
        except Exception as e:
            self.send_event("ai-memory-added", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_ai_memories(self, payload: Dict[str, Any]):
        """Get AI memories for a user"""
        try:
            user_id = payload.get('userId', '')
            memory_type = payload.get('memoryType')
            limit = payload.get('limit', 10)
            
            if not user_id:
                self.send_event("ai-memories", {"success": False, "error": "Missing userId"})
                return
            
            memories = await db.get_ai_memories(user_id, memory_type, limit)
            
            self.send_event("ai-memories", {
                "success": True,
                "userId": user_id,
                "memories": memories
            })
        except Exception as e:
            self.send_event("ai-memories", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_analyze_conversation(self, payload: Dict[str, Any]):
        """Analyze conversation and provide insights"""
        try:
            user_id = payload.get('userId', '')
            lead_id = payload.get('leadId')
            
            if not user_id:
                self.send_event("conversation-analysis", {"success": False, "error": "Missing userId"})
                return
            
            # Get conversation history
            history = await db.get_chat_history(user_id, limit=50)
            
            # Analyze conversation
            analysis = await ai_context.analyze_conversation_stage(user_id, history)
            
            self.send_event("conversation-analysis", {
                "success": True,
                "userId": user_id,
                "leadId": lead_id,
                "analysis": analysis
            })
        except Exception as e:
            self.send_event("conversation-analysis", {
                "success": False,
                "error": str(e)
            })

    # ==================== AI Marketing Strategy Handlers ====================
    
    async def handle_generate_ai_strategy(self, payload: Dict[str, Any]):
        """ä½¿ç”¨ AI ç”Ÿæˆç‡ŸéŠ·ç­–ç•¥"""
        try:
            user_input = payload.get('userInput', '')
            
            if not user_input:
                self.send_event("ai-strategy-generated", {
                    "success": False,
                    "error": "è«‹è¼¸å…¥æ‚¨çš„éœ€æ±‚"
                })
                return
            
            # å˜—è©¦ä½¿ç”¨ AI ç”Ÿæˆç­–ç•¥
            try:
                from ai_context import ai_context
                
                prompt = f"""
                æ ¹æ“šç”¨æˆ¶çš„ç‡ŸéŠ·éœ€æ±‚ï¼Œç”Ÿæˆè©³ç´°çš„ç‡ŸéŠ·ç­–ç•¥ã€‚

                ç”¨æˆ¶éœ€æ±‚ï¼š{user_input}

                è«‹è¿”å› JSON æ ¼å¼çš„ç­–ç•¥ï¼ŒåŒ…å«ï¼š
                1. industry: è­˜åˆ¥çš„ç›®æ¨™è¡Œæ¥­
                2. targetAudience: ç›®æ¨™å—çœ¾æè¿°
                3. keywords: åˆ†ç‚º highIntentï¼ˆé«˜æ„å‘ï¼‰ã€mediumIntentï¼ˆä¸­æ„å‘ï¼‰ã€extendedï¼ˆæ“´å±•ï¼‰ä¸‰é¡é—œéµè©
                4. customerProfile: å®¢æˆ¶ç•«åƒï¼ŒåŒ…å« identityï¼ˆèº«ä»½ï¼‰ã€featuresï¼ˆç‰¹å¾µï¼‰ã€needsï¼ˆéœ€æ±‚ï¼‰
                5. recommendedGroups: å»ºè­°æœç´¢çš„ç¾¤çµ„é¡å‹
                6. messageTemplates: æ¶ˆæ¯æ¨¡æ¿ï¼ŒåŒ…å« firstTouchï¼ˆé¦–æ¬¡è§¸é”ï¼‰ã€followUpï¼ˆè·Ÿé€²ï¼‰ã€closingï¼ˆä¿ƒæˆï¼‰
                """
                
                response = await ai_context.generate_response(
                    user_id="system",
                    message=prompt,
                    context=[]
                )
                
                # å˜—è©¦è§£æ AI è¿”å›çš„ JSON
                import json
                import re
                
                # æå– JSON
                json_match = re.search(r'\{[\s\S]*\}', response)
                if json_match:
                    strategy = json.loads(json_match.group())
                    self.send_event("ai-strategy-generated", {
                        "success": True,
                        "strategy": strategy
                    })
                    return
                    
            except Exception as ai_error:
                print(f"[AI Strategy] AI generation failed: {ai_error}", file=sys.stderr)
            
            # å¦‚æœ AI ç”Ÿæˆå¤±æ•—ï¼Œè¿”å›éŒ¯èª¤è®“å‰ç«¯ä½¿ç”¨æœ¬åœ°æ¨¡æ¿
            self.send_event("ai-strategy-generated", {
                "success": False,
                "error": "AI æœå‹™æš«æ™‚ä¸å¯ç”¨ï¼Œå·²ä½¿ç”¨æœ¬åœ°æ¨¡æ¿"
            })
            
        except Exception as e:
            self.send_event("ai-strategy-generated", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_save_ai_strategy(self, payload: Dict[str, Any]):
        """ä¿å­˜ AI ç­–ç•¥"""
        try:
            name = payload.get('name', f"ç­–ç•¥_{datetime.now().strftime('%Y%m%d_%H%M%S')}")
            strategy = payload.get('strategy', {})
            
            # ä¿å­˜åˆ°æ•¸æ“šåº«
            await db.execute(
                """INSERT INTO ai_strategies (name, strategy_json, created_at) 
                   VALUES (?, ?, CURRENT_TIMESTAMP)
                   ON CONFLICT(name) DO UPDATE SET strategy_json = ?, updated_at = CURRENT_TIMESTAMP""",
                (name, json.dumps(strategy), json.dumps(strategy))
            )
            
            self.send_log(f"âœ… ç­–ç•¥å·²ä¿å­˜: {name}", "success")
            self.send_event("ai-strategy-saved", {"success": True, "name": name})
            
        except Exception as e:
            self.send_log(f"âŒ ä¿å­˜ç­–ç•¥å¤±æ•—: {e}", "error")
            self.send_event("ai-strategy-saved", {"success": False, "error": str(e)})
    
    async def handle_get_ai_strategies(self, payload: Dict[str, Any]):
        """ç²å–å·²ä¿å­˜çš„ç­–ç•¥åˆ—è¡¨"""
        try:
            strategies = await db.fetch_all(
                "SELECT * FROM ai_strategies ORDER BY created_at DESC LIMIT 50"
            )
            
            result = []
            for s in strategies:
                try:
                    result.append({
                        "id": s.get('id'),
                        "name": s.get('name'),
                        "strategy": json.loads(s.get('strategy_json', '{}')),
                        "createdAt": s.get('created_at'),
                        "stats": {
                            "totalLeads": 0,
                            "contacted": 0,
                            "converted": 0
                        }
                    })
                except:
                    pass
            
            self.send_event("ai-strategies-list", {"success": True, "strategies": result})
            
        except Exception as e:
            self.send_event("ai-strategies-list", {"success": False, "error": str(e)})
    
    async def handle_execute_ai_strategy(self, payload: Dict[str, Any]):
        """åŸ·è¡Œ AI ç‡ŸéŠ·ç­–ç•¥"""
        try:
            strategy = payload.get('strategy', {})
            
            self.send_log(f"ğŸš€ é–‹å§‹åŸ·è¡Œ AI ç­–ç•¥: {strategy.get('industry', 'æœªçŸ¥')}", "info")
            
            # 1. å‰µå»ºé—œéµè©é›†
            keywords = strategy.get('keywords', {})
            all_keywords = (
                keywords.get('highIntent', []) + 
                keywords.get('mediumIntent', []) + 
                keywords.get('extended', [])
            )
            
            if all_keywords:
                # ä¿å­˜ç‚ºé—œéµè©é›†
                keyword_set_name = f"AIç­–ç•¥_{strategy.get('industry', 'è‡ªå®šç¾©')}"
                await db.execute(
                    """INSERT INTO keyword_sets (name, keywords, is_active, created_at)
                       VALUES (?, ?, 1, CURRENT_TIMESTAMP)
                       ON CONFLICT(name) DO UPDATE SET keywords = ?, is_active = 1""",
                    (keyword_set_name, json.dumps(all_keywords), json.dumps(all_keywords))
                )
                self.send_log(f"âœ… å·²å‰µå»ºé—œéµè©é›†: {keyword_set_name} ({len(all_keywords)} å€‹é—œéµè©)", "success")
            
            # 2. ä¿å­˜æ¶ˆæ¯æ¨¡æ¿
            templates = strategy.get('messageTemplates', {})
            for template_type, content in templates.items():
                if content:
                    template_name = f"AI_{strategy.get('industry', '')}_{template_type}"
                    await db.execute(
                        """INSERT INTO message_templates (name, content, template_type, created_at)
                           VALUES (?, ?, ?, CURRENT_TIMESTAMP)
                           ON CONFLICT(name) DO UPDATE SET content = ?""",
                        (template_name, content, template_type, content)
                    )
            self.send_log(f"âœ… å·²å‰µå»ºæ¶ˆæ¯æ¨¡æ¿", "success")
            
            # 3. ç™¼é€åŸ·è¡Œç‹€æ…‹
            self.send_event("ai-execution-status", {
                "isExecuting": True,
                "phase": "initialized",
                "message": "ç­–ç•¥å·²åˆå§‹åŒ–ï¼Œæº–å‚™é–‹å§‹æœç´¢ç¾¤çµ„..."
            })
            
            # 4. é–‹å§‹æœç´¢ç¾¤çµ„ï¼ˆç•°æ­¥åŸ·è¡Œï¼‰
            asyncio.create_task(self._execute_ai_group_search(strategy))
            
            self.send_event("ai-strategy-executed", {"success": True})
            
        except Exception as e:
            self.send_log(f"âŒ åŸ·è¡Œç­–ç•¥å¤±æ•—: {e}", "error")
            self.send_event("ai-strategy-executed", {"success": False, "error": str(e)})
    
    async def _execute_ai_group_search(self, strategy: Dict[str, Any]):
        """ç•°æ­¥åŸ·è¡Œç¾¤çµ„æœç´¢"""
        try:
            keywords = strategy.get('keywords', {})
            search_keywords = keywords.get('highIntent', [])[:5]  # ä½¿ç”¨å‰5å€‹é«˜æ„å‘é—œéµè©æœç´¢
            
            total_found = 0
            for keyword in search_keywords:
                self.send_event("ai-execution-status", {
                    "isExecuting": True,
                    "phase": "searching",
                    "message": f"æ­£åœ¨æœç´¢é—œéµè©: {keyword}..."
                })
                
                # èª¿ç”¨ç¾¤çµ„æœç´¢æœå‹™
                try:
                    results = await group_search_service.search_groups(keyword, limit=10)
                    total_found += len(results) if results else 0
                    
                    self.send_event("ai-execution-stats", {
                        "groupsSearched": total_found,
                        "groupsJoined": 0,
                        "membersScanned": 0,
                        "leadsFound": 0,
                        "messagesSent": 0,
                        "responses": 0
                    })
                    
                    await asyncio.sleep(2)  # é¿å…é »ç¹è«‹æ±‚
                except Exception as search_error:
                    print(f"[AI Strategy] Search error for {keyword}: {search_error}", file=sys.stderr)
            
            self.send_event("ai-execution-status", {
                "isExecuting": True,
                "phase": "search_complete",
                "message": f"æœç´¢å®Œæˆï¼Œå…±ç™¼ç¾ {total_found} å€‹ç›¸é—œç¾¤çµ„"
            })
            
        except Exception as e:
            print(f"[AI Strategy] Group search failed: {e}", file=sys.stderr)
            self.send_event("ai-execution-status", {
                "isExecuting": False,
                "phase": "error",
                "message": f"æœç´¢å¤±æ•—: {str(e)}"
            })
    
    # ==================== Chat Template Handlers ====================
    
    async def handle_get_chat_templates(self):
        """ç²å–èŠå¤©æ¨¡æ¿åˆ—è¡¨"""
        import sys
        print("[Backend] handle_get_chat_templates called", file=sys.stderr)
        try:
            templates = await db.get_chat_templates()
            print(f"[Backend] Loaded {len(templates)} chat templates", file=sys.stderr)
            self.send_event("get-chat-templates-result", {
                "templates": templates,
                "success": True  # ğŸ”§ FIX: æ·»åŠ  success æ¨™èªŒ
            })
        except Exception as e:
            import traceback
            print(f"[Backend] âŒ Error getting chat templates: {e}", file=sys.stderr)
            traceback.print_exc(file=sys.stderr)
            self.send_log(f"âŒ ç²å–èŠå¤©æ¨¡æ¿å¤±æ•—: {e}", "error")
            self.send_event("get-chat-templates-result", {
                "templates": [],
                "success": False,
                "error": str(e)
            })
    
    async def handle_save_chat_template(self, payload: Dict[str, Any]):
        """ä¿å­˜èŠå¤©æ¨¡æ¿"""
        try:
            template_id = payload.get('id')
            name = payload.get('name', '')
            category = payload.get('category', 'custom')
            content = payload.get('content', '')
            variables = payload.get('variables', [])
            is_active = payload.get('isActive', True)
            
            if not name or not content:
                self.send_event("save-chat-template-result", {
                    "success": False,
                    "error": "æ¨¡æ¿åç¨±å’Œå…§å®¹ä¸èƒ½ç‚ºç©º"
                })
                return
            
            result = await db.save_chat_template(
                template_id=template_id,
                name=name,
                category=category,
                content=content,
                variables=variables,
                is_active=is_active
            )
            
            self.send_event("save-chat-template-result", result)
            
            if result.get('success'):
                self.send_log(f"âœ… å·²ä¿å­˜èŠå¤©æ¨¡æ¿: {name}", "success")
                # åˆ·æ–°æ¨¡æ¿åˆ—è¡¨
                await self.handle_get_chat_templates()
                
        except Exception as e:
            self.send_log(f"âŒ ä¿å­˜èŠå¤©æ¨¡æ¿å¤±æ•—: {e}", "error")
            self.send_event("save-chat-template-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_delete_chat_template(self, payload: Dict[str, Any]):
        """åˆªé™¤èŠå¤©æ¨¡æ¿"""
        try:
            template_id = payload.get('id')
            
            if not template_id:
                self.send_event("delete-chat-template-result", {
                    "success": False,
                    "error": "ç¼ºå°‘æ¨¡æ¿ ID"
                })
                return
            
            success = await db.delete_chat_template(template_id)
            
            self.send_event("delete-chat-template-result", {"success": success})
            
            if success:
                self.send_log(f"ğŸ—‘ï¸ å·²åˆªé™¤èŠå¤©æ¨¡æ¿ ID: {template_id}", "success")
                # åˆ·æ–°æ¨¡æ¿åˆ—è¡¨
                await self.handle_get_chat_templates()
                
        except Exception as e:
            self.send_log(f"âŒ åˆªé™¤èŠå¤©æ¨¡æ¿å¤±æ•—: {e}", "error")
            self.send_event("delete-chat-template-result", {
                "success": False,
                "error": str(e)
            })
    
    # ==================== Trigger Rules Handlers ====================
    
    async def handle_get_trigger_rules(self):
        """ç²å–æ‰€æœ‰è§¸ç™¼è¦å‰‡"""
        import sys
        print("[Backend] handle_get_trigger_rules called", file=sys.stderr)
        try:
            rules = await db.get_all_trigger_rules()
            print(f"[Backend] Loaded {len(rules)} trigger rules", file=sys.stderr)
            self.send_event("trigger-rules-result", {
                "success": True,
                "rules": rules
            })
        except Exception as e:
            import traceback
            print(f"[Backend] âŒ Error getting trigger rules: {e}", file=sys.stderr)
            traceback.print_exc(file=sys.stderr)
            self.send_log(f"âŒ ç²å–è§¸ç™¼è¦å‰‡å¤±æ•—: {e}", "error")
            self.send_event("trigger-rules-result", {
                "success": False,
                "rules": [],
                "error": str(e)
            })
    
    async def handle_get_trigger_rule(self, payload: Dict[str, Any]):
        """ç²å–å–®å€‹è§¸ç™¼è¦å‰‡"""
        try:
            rule_id = payload.get('id')
            if not rule_id:
                self.send_event("trigger-rule-result", {
                    "success": False,
                    "error": "ç¼ºå°‘è¦å‰‡ ID"
                })
                return
            
            rule = await db.get_trigger_rule(rule_id)
            self.send_event("trigger-rule-result", {
                "success": True,
                "rule": rule
            })
        except Exception as e:
            self.send_log(f"âŒ ç²å–è§¸ç™¼è¦å‰‡å¤±æ•—: {e}", "error")
            self.send_event("trigger-rule-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_save_trigger_rule(self, payload: Dict[str, Any]):
        """ä¿å­˜è§¸ç™¼è¦å‰‡ï¼ˆæ–°å¢æˆ–æ›´æ–°ï¼‰"""
        import sys
        print(f"[Backend] handle_save_trigger_rule called with payload: {payload}", file=sys.stderr)
        try:
            rule_id = payload.get('id')
            name = payload.get('name', '')
            
            if not name:
                self.send_event("save-trigger-rule-result", {
                    "success": False,
                    "error": "è¦å‰‡åç¨±ä¸èƒ½ç‚ºç©º"
                })
                return
            
            if not payload.get('keywordSetIds') or len(payload.get('keywordSetIds', [])) == 0:
                self.send_event("save-trigger-rule-result", {
                    "success": False,
                    "error": "è«‹è‡³å°‘é¸æ“‡ä¸€å€‹é—œéµè©é›†"
                })
                return
            
            if rule_id:
                # æ›´æ–°
                success = await db.update_trigger_rule(rule_id, payload)
                if success:
                    self.send_log(f"âœ… å·²æ›´æ–°è§¸ç™¼è¦å‰‡: {name}", "success")
                    self.send_event("save-trigger-rule-result", {
                        "success": True,
                        "id": rule_id,
                        "message": "è¦å‰‡å·²æ›´æ–°"
                    })
                else:
                    self.send_event("save-trigger-rule-result", {
                        "success": False,
                        "error": "æ›´æ–°å¤±æ•—"
                    })
            else:
                # æ–°å¢
                new_id = await db.add_trigger_rule(payload)
                self.send_log(f"âœ… å·²å‰µå»ºè§¸ç™¼è¦å‰‡: {name}", "success")
                self.send_event("save-trigger-rule-result", {
                    "success": True,
                    "id": new_id,
                    "message": "è¦å‰‡å·²å‰µå»º"
                })
            
            # åˆ·æ–°è¦å‰‡åˆ—è¡¨
            await self.handle_get_trigger_rules()
            
        except Exception as e:
            self.send_log(f"âŒ ä¿å­˜è§¸ç™¼è¦å‰‡å¤±æ•—: {e}", "error")
            self.send_event("save-trigger-rule-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_delete_trigger_rule(self, payload: Dict[str, Any]):
        """åˆªé™¤è§¸ç™¼è¦å‰‡"""
        try:
            rule_id = payload.get('id')
            
            if not rule_id:
                self.send_event("delete-trigger-rule-result", {
                    "success": False,
                    "error": "ç¼ºå°‘è¦å‰‡ ID"
                })
                return
            
            success = await db.delete_trigger_rule(rule_id)
            
            self.send_event("delete-trigger-rule-result", {"success": success})
            
            if success:
                self.send_log(f"ğŸ—‘ï¸ å·²åˆªé™¤è§¸ç™¼è¦å‰‡ ID: {rule_id}", "success")
                await self.handle_get_trigger_rules()
                
        except Exception as e:
            self.send_log(f"âŒ åˆªé™¤è§¸ç™¼è¦å‰‡å¤±æ•—: {e}", "error")
            self.send_event("delete-trigger-rule-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_toggle_trigger_rule(self, payload: Dict[str, Any]):
        """å•Ÿç”¨/åœç”¨è§¸ç™¼è¦å‰‡"""
        try:
            rule_id = payload.get('id')
            is_active = payload.get('isActive', True)
            
            if not rule_id:
                self.send_event("toggle-trigger-rule-result", {
                    "success": False,
                    "error": "ç¼ºå°‘è¦å‰‡ ID"
                })
                return
            
            success = await db.toggle_trigger_rule(rule_id, is_active)
            
            self.send_event("toggle-trigger-rule-result", {"success": success})
            
            if success:
                status = "å•Ÿç”¨" if is_active else "åœç”¨"
                self.send_log(f"âœ… å·²{status}è§¸ç™¼è¦å‰‡ ID: {rule_id}", "success")
                await self.handle_get_trigger_rules()
                
        except Exception as e:
            self.send_log(f"âŒ åˆ‡æ›è§¸ç™¼è¦å‰‡ç‹€æ…‹å¤±æ•—: {e}", "error")
            self.send_event("toggle-trigger-rule-result", {
                "success": False,
                "error": str(e)
            })
    
    # ==================== Collected Users Handlers (å»£å‘Šè­˜åˆ¥) ====================
    
    async def handle_get_collected_users(self, payload: Dict[str, Any]):
        """ç²å–æ”¶é›†çš„ç”¨æˆ¶åˆ—è¡¨"""
        import sys
        print("[Backend] handle_get_collected_users called", file=sys.stderr)
        try:
            filters = payload.get('filters', {})
            limit = payload.get('limit', 100)
            offset = payload.get('offset', 0)
            
            users = await db.get_collected_users(filters=filters, limit=limit, offset=offset)
            total = await db.get_collected_users_count(filters=filters)
            
            print(f"[Backend] Returning {len(users)} collected users (total: {total})", file=sys.stderr)
            
            self.send_event("collected-users-result", {
                "success": True,
                "users": users,
                "total": total,
                "limit": limit,
                "offset": offset
            })
        except Exception as e:
            import traceback
            print(f"[Backend] Error getting collected users: {e}", file=sys.stderr)
            traceback.print_exc(file=sys.stderr)
            self.send_event("collected-users-result", {
                "success": False,
                "users": [],
                "total": 0,
                "error": str(e)
            })
    
    async def handle_get_collected_users_stats(self):
        """ç²å–æ”¶é›†ç”¨æˆ¶çµ±è¨ˆ"""
        import sys
        print("[Backend] handle_get_collected_users_stats called", file=sys.stderr)
        try:
            stats = await db.get_collected_users_stats()
            print(f"[Backend] Collected users stats: {stats}", file=sys.stderr)
            
            self.send_event("collected-users-stats-result", {
                "success": True,
                "stats": stats
            })
        except Exception as e:
            print(f"[Backend] Error getting collected users stats: {e}", file=sys.stderr)
            self.send_event("collected-users-stats-result", {
                "success": False,
                "stats": {},
                "error": str(e)
            })
    
    async def handle_mark_user_as_ad(self, payload: Dict[str, Any]):
        """æ¨™è¨˜ç”¨æˆ¶ç‚ºå»£å‘Šè™Ÿ"""
        try:
            telegram_id = payload.get('telegramId')
            is_ad = payload.get('isAd', True)
            
            if not telegram_id:
                self.send_event("mark-user-as-ad-result", {
                    "success": False,
                    "error": "ç¼ºå°‘ç”¨æˆ¶ ID"
                })
                return
            
            success = await db.mark_user_as_ad(telegram_id, is_ad)
            
            if success:
                action = "æ¨™è¨˜ç‚ºå»£å‘Šè™Ÿ" if is_ad else "å–æ¶ˆå»£å‘Šè™Ÿæ¨™è¨˜"
                self.send_log(f"âœ… å·²{action}: {telegram_id}", "success")
            
            self.send_event("mark-user-as-ad-result", {
                "success": success,
                "telegramId": telegram_id,
                "isAd": is_ad
            })
        except Exception as e:
            self.send_log(f"âŒ æ¨™è¨˜ç”¨æˆ¶å¤±æ•—: {e}", "error")
            self.send_event("mark-user-as-ad-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_blacklist_user(self, payload: Dict[str, Any]):
        """å°‡ç”¨æˆ¶åŠ å…¥/ç§»å‡ºé»‘åå–®"""
        try:
            telegram_id = payload.get('telegramId')
            blacklist = payload.get('blacklist', True)
            
            if not telegram_id:
                self.send_event("blacklist-user-result", {
                    "success": False,
                    "error": "ç¼ºå°‘ç”¨æˆ¶ ID"
                })
                return
            
            success = await db.blacklist_user(telegram_id, blacklist)
            
            if success:
                action = "åŠ å…¥é»‘åå–®" if blacklist else "ç§»å‡ºé»‘åå–®"
                self.send_log(f"âœ… å·²{action}: {telegram_id}", "success")
            
            self.send_event("blacklist-user-result", {
                "success": success,
                "telegramId": telegram_id,
                "blacklisted": blacklist
            })
        except Exception as e:
            self.send_log(f"âŒ é»‘åå–®æ“ä½œå¤±æ•—: {e}", "error")
            self.send_event("blacklist-user-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_user_message_samples(self, payload: Dict[str, Any]):
        """ç²å–ç”¨æˆ¶æ¶ˆæ¯æ¨£æœ¬"""
        try:
            telegram_id = payload.get('telegramId')
            limit = payload.get('limit', 10)
            
            if not telegram_id:
                self.send_event("user-message-samples-result", {
                    "success": False,
                    "error": "ç¼ºå°‘ç”¨æˆ¶ ID"
                })
                return
            
            samples = await db.get_user_message_samples(telegram_id, limit)
            
            self.send_event("user-message-samples-result", {
                "success": True,
                "telegramId": telegram_id,
                "samples": samples
            })
        except Exception as e:
            self.send_event("user-message-samples-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_recalculate_user_risk(self, payload: Dict[str, Any]):
        """é‡æ–°è¨ˆç®—ç”¨æˆ¶é¢¨éšªè©•åˆ†"""
        try:
            telegram_id = payload.get('telegramId')
            
            if not telegram_id:
                self.send_event("recalculate-risk-result", {
                    "success": False,
                    "error": "ç¼ºå°‘ç”¨æˆ¶ ID"
                })
                return
            
            # ç²å–ç”¨æˆ¶ä¿¡æ¯
            users = await db.get_collected_users({'telegram_id': telegram_id}, limit=1)
            if not users:
                self.send_event("recalculate-risk-result", {
                    "success": False,
                    "error": "ç”¨æˆ¶ä¸å­˜åœ¨"
                })
                return
            
            user = users[0]
            
            # ç²å–æ¶ˆæ¯æ¨£æœ¬
            messages = await db.get_user_message_samples(telegram_id, limit=10)
            
            # é‡æ–°è¨ˆç®—é¢¨éšª
            from ad_detection_service import ad_detection_service
            result = ad_detection_service.calculate_risk_score(user, messages)
            
            # æ›´æ–°æ•¸æ“šåº«
            await db.update_user_risk_score(
                telegram_id=telegram_id,
                risk_score=result.risk_score,
                risk_factors={'factors': result.risk_factors},
                value_level=result.value_level
            )
            
            self.send_event("recalculate-risk-result", {
                "success": True,
                "telegramId": telegram_id,
                "riskScore": result.risk_score,
                "riskLevel": result.risk_level,
                "valueLevel": result.value_level,
                "isLikelyAd": result.is_likely_ad
            })
            
            self.send_log(f"âœ… å·²é‡æ–°è¨ˆç®—é¢¨éšªè©•åˆ†: {telegram_id} -> {result.risk_score:.2f}", "success")
            
        except Exception as e:
            import traceback
            traceback.print_exc()
            self.send_event("recalculate-risk-result", {
                "success": False,
                "error": str(e)
            })
    
    # ==================== AI Model Configuration Handlers ====================
    
    async def handle_save_ai_model(self, payload: Dict[str, Any]):
        """ä¿å­˜ AI æ¨¡å‹é…ç½®åˆ°æ•¸æ“šåº«"""
        try:
            provider = payload.get('provider', '')
            model_name = payload.get('modelName', '')
            display_name = payload.get('displayName', model_name)
            api_key = payload.get('apiKey', '')
            api_endpoint = payload.get('apiEndpoint', '')
            is_local = 1 if payload.get('isLocal', False) else 0
            is_default = 1 if payload.get('isDefault', False) else 0
            priority = payload.get('priority', 0)
            config_json = json.dumps(payload.get('config', {}))
            
            if not provider or not model_name:
                self.send_event("ai-model-saved", {
                    "success": False,
                    "error": "ä¾›æ‡‰å•†å’Œæ¨¡å‹åç¨±ä¸èƒ½ç‚ºç©º"
                })
                return
            
            # å¦‚æœè¨­ç‚ºé»˜èªï¼Œå…ˆå–æ¶ˆå…¶ä»–é»˜èª
            if is_default:
                await db.execute("UPDATE ai_models SET is_default = 0")
            
            # æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
            existing = await db.fetch_one(
                "SELECT id FROM ai_models WHERE provider = ? AND model_name = ?",
                (provider, model_name)
            )
            
            if existing:
                # æ›´æ–°ç¾æœ‰è¨˜éŒ„
                await db.execute(
                    """UPDATE ai_models SET 
                       display_name = ?, api_key = ?, api_endpoint = ?, 
                       is_local = ?, is_default = ?, priority = ?, config_json = ?,
                       updated_at = CURRENT_TIMESTAMP
                       WHERE id = ?""",
                    (display_name, api_key, api_endpoint, is_local, is_default, priority, config_json, existing['id'])
                )
                model_id = existing['id']
            else:
                # æ’å…¥æ–°è¨˜éŒ„
                await db.execute(
                    """INSERT INTO ai_models 
                       (provider, model_name, display_name, api_key, api_endpoint, 
                        is_local, is_default, priority, config_json, created_at, updated_at)
                       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)""",
                    (provider, model_name, display_name, api_key, api_endpoint, 
                     is_local, is_default, priority, config_json)
                )
                model_id = (await db.fetch_one("SELECT last_insert_rowid() as id"))['id']
            
            self.send_log(f"âœ… AI æ¨¡å‹å·²ä¿å­˜: {display_name} ({provider})", "success")
            self.send_event("ai-model-saved", {
                "success": True,
                "modelId": model_id,
                "provider": provider,
                "modelName": model_name
            })
            
            # åŒæ™‚ç™¼é€æ›´æ–°å¾Œçš„æ¨¡å‹åˆ—è¡¨
            await self.handle_get_ai_models()
            
        except Exception as e:
            self.send_log(f"âŒ ä¿å­˜ AI æ¨¡å‹å¤±æ•—: {e}", "error")
            self.send_event("ai-model-saved", {"success": False, "error": str(e)})
    
    async def handle_get_ai_models(self):
        """ç²å–æ‰€æœ‰å·²ä¿å­˜çš„ AI æ¨¡å‹é…ç½®"""
        try:
            models = await db.fetch_all(
                """SELECT id, provider, model_name, display_name, api_key, api_endpoint,
                   is_local, is_default, priority, is_connected, last_tested_at, config_json,
                   created_at, updated_at
                   FROM ai_models ORDER BY is_default DESC, priority DESC, created_at DESC"""
            )
            
            result = []
            for model in models:
                # éš±è— API Key çš„å¤§éƒ¨åˆ†å…§å®¹
                api_key = model.get('api_key', '') or ''
                masked_key = f"{api_key[:8]}...{api_key[-4:]}" if len(api_key) > 12 else '***'
                
                result.append({
                    "id": model['id'],
                    "provider": model['provider'],
                    "modelName": model['model_name'],
                    "displayName": model['display_name'] or model['model_name'],
                    "apiKey": api_key,  # å®Œæ•´ key ç”¨æ–¼å‰ç«¯ä½¿ç”¨
                    "apiKeyMasked": masked_key,  # é¡¯ç¤ºç”¨
                    "apiEndpoint": model['api_endpoint'],
                    "isLocal": bool(model['is_local']),
                    "isDefault": bool(model['is_default']),
                    "priority": model['priority'],
                    "isConnected": bool(model['is_connected']),
                    "lastTestedAt": model['last_tested_at'],
                    "config": json.loads(model['config_json'] or '{}'),
                    "createdAt": model['created_at'],
                    "updatedAt": model['updated_at']
                })
            
            self.send_event("ai-models-list", {
                "success": True,
                "models": result,
                "count": len(result)
            })
            
        except Exception as e:
            self.send_log(f"âŒ ç²å– AI æ¨¡å‹åˆ—è¡¨å¤±æ•—: {e}", "error")
            self.send_event("ai-models-list", {"success": False, "error": str(e), "models": []})
    
    async def handle_update_ai_model(self, payload: Dict[str, Any]):
        """æ›´æ–° AI æ¨¡å‹é…ç½®"""
        try:
            model_id = payload.get('id')
            if not model_id:
                self.send_event("ai-model-updated", {"success": False, "error": "ç¼ºå°‘æ¨¡å‹ ID"})
                return
            
            updates = []
            params = []
            
            if 'displayName' in payload:
                updates.append("display_name = ?")
                params.append(payload['displayName'])
            if 'apiKey' in payload:
                updates.append("api_key = ?")
                params.append(payload['apiKey'])
            if 'apiEndpoint' in payload:
                updates.append("api_endpoint = ?")
                params.append(payload['apiEndpoint'])
            if 'isDefault' in payload:
                if payload['isDefault']:
                    await db.execute("UPDATE ai_models SET is_default = 0")
                updates.append("is_default = ?")
                params.append(1 if payload['isDefault'] else 0)
            if 'priority' in payload:
                updates.append("priority = ?")
                params.append(payload['priority'])
            if 'isConnected' in payload:
                updates.append("is_connected = ?")
                params.append(1 if payload['isConnected'] else 0)
                updates.append("last_tested_at = CURRENT_TIMESTAMP")
            
            if updates:
                updates.append("updated_at = CURRENT_TIMESTAMP")
                params.append(model_id)
                await db.execute(
                    f"UPDATE ai_models SET {', '.join(updates)} WHERE id = ?",
                    tuple(params)
                )
            
            self.send_event("ai-model-updated", {"success": True, "modelId": model_id})
            await self.handle_get_ai_models()
            
        except Exception as e:
            self.send_event("ai-model-updated", {"success": False, "error": str(e)})
    
    async def handle_delete_ai_model(self, payload: Dict[str, Any]):
        """åˆªé™¤ AI æ¨¡å‹é…ç½®"""
        try:
            model_id = payload.get('id')
            if not model_id:
                self.send_event("ai-model-deleted", {"success": False, "error": "ç¼ºå°‘æ¨¡å‹ ID"})
                return
            
            await db.execute("DELETE FROM ai_models WHERE id = ?", (model_id,))
            
            self.send_log(f"âœ… AI æ¨¡å‹å·²åˆªé™¤: ID={model_id}", "success")
            self.send_event("ai-model-deleted", {"success": True, "modelId": model_id})
            await self.handle_get_ai_models()
            
        except Exception as e:
            self.send_event("ai-model-deleted", {"success": False, "error": str(e)})
    
    async def handle_test_ai_model(self, payload: Dict[str, Any]):
        """æ¸¬è©¦ AI æ¨¡å‹é€£æ¥ - æ”¯æŒå¤šç¨® API æ ¼å¼"""
        try:
            import sys
            model_id = payload.get('id')
            provider = payload.get('provider', '')
            api_key = payload.get('apiKey', '')
            api_endpoint = payload.get('apiEndpoint', '')
            model_name = payload.get('modelName', '')
            is_local = payload.get('isLocal', False)
            
            import time as time_module
            test_start_time = time_module.time()
            
            print(f"[AI Test] é–‹å§‹æ¸¬è©¦: provider={provider}, endpoint={api_endpoint}, model={model_name}, isLocal={is_local}", file=sys.stderr)
            self.send_log(f"ğŸ”— æ­£åœ¨æ¸¬è©¦ AI æ¨¡å‹é€£æ¥: {model_name}...", "info")
            
            is_connected = False
            error_message = None
            response_preview = None
            latency_ms = 0
            
            try:
                if is_local or provider == 'ollama' or provider == 'custom':
                    # æ¸¬è©¦æœ¬åœ°/è‡ªå®šç¾© AI - å˜—è©¦å¤šç¨®æ ¼å¼
                    import aiohttp
                    test_url = api_endpoint or 'http://localhost:11434/api/chat'
                    print(f"[AI Test] æ¸¬è©¦ URL: {test_url}", file=sys.stderr)
                    
                    async with aiohttp.ClientSession() as session:
                        # ğŸ”§ P2 å„ªåŒ–ï¼šå…ˆæŸ¥è©¢å¯ç”¨æ¨¡å‹åˆ—è¡¨ï¼ˆåƒ… Ollamaï¼‰
                        available_models = []
                        is_ollama = ':11434' in test_url or '.ts.net' in test_url or provider == 'ollama'
                        if is_ollama:
                            try:
                                tags_url = test_url.rstrip('/').replace('/api/chat', '') + '/api/tags'
                                async with session.get(tags_url, timeout=aiohttp.ClientTimeout(total=5)) as tags_resp:
                                    if tags_resp.status == 200:
                                        tags_data = await tags_resp.json()
                                        models = tags_data.get('models', [])
                                        available_models = [m.get('name', '') for m in models[:10]]  # æœ€å¤šé¡¯ç¤º 10 å€‹
                                        print(f"[AI Test] å¯ç”¨æ¨¡å‹: {available_models}", file=sys.stderr)
                            except Exception as e:
                                print(f"[AI Test] ç„¡æ³•ç²å–æ¨¡å‹åˆ—è¡¨: {e}", file=sys.stderr)
                        
                        # é¦–å…ˆå˜—è©¦ OpenAI å…¼å®¹æ ¼å¼
                        try:
                            # ğŸ”§ FIX: æ™ºèƒ½åˆ¤æ–· URL æ ¼å¼
                            # ç¢ºå®š URL æ ¼å¼
                            if '/v1/chat/completions' in test_url:
                                chat_url = test_url
                            elif test_url.endswith('/chat'):
                                # å¯èƒ½æ˜¯ OpenAI å…¼å®¹çš„ /chat ç«¯é»
                                chat_url = test_url
                            elif test_url.endswith('/api/chat'):
                                # Ollama æ ¼å¼
                                chat_url = test_url
                            elif ':11434' in test_url or provider == 'ollama' or '.ts.net' in test_url:
                                # ğŸ”§ FIX: æª¢æ¸¬åˆ° Ollama ç«¯å£æˆ– Tailscale åŸŸåï¼Œä½¿ç”¨ Ollama API æ ¼å¼
                                chat_url = test_url.rstrip('/') + '/api/chat'
                                print(f"[AI Test] æª¢æ¸¬åˆ° Ollama/Tailscale ç«¯é»ï¼Œä½¿ç”¨ /api/chat", file=sys.stderr)
                            else:
                                chat_url = test_url.rstrip('/') + '/v1/chat/completions'
                            
                            headers = {'Content-Type': 'application/json'}
                            if api_key:
                                headers['Authorization'] = f'Bearer {api_key}'
                            
                            # ğŸ”§ FIX: æ ¹æ“šç«¯é»é¡å‹é¸æ“‡è«‹æ±‚æ ¼å¼
                            is_ollama_endpoint = '/api/chat' in chat_url or ':11434' in chat_url or '.ts.net' in chat_url
                            
                            # ğŸ”§ P0 å„ªåŒ–ï¼šä½¿ç”¨æ›´æ˜ç¢ºçš„æ¸¬è©¦æ¶ˆæ¯ï¼Œè¦æ±‚ AI å›è¦†ç‰¹å®šå…§å®¹
                            test_message = "é€™æ˜¯ä¸€å€‹é€£æ¥æ¸¬è©¦ã€‚è«‹å›è¦†ã€Œé€£æ¥æˆåŠŸã€ä¸‰å€‹å­—ã€‚"
                            
                            if is_ollama_endpoint:
                                # Ollama åŸç”Ÿæ ¼å¼
                                request_body = {
                                    "model": model_name or "llama3",
                                    "messages": [{"role": "user", "content": test_message}],
                                    "stream": False,
                                    "options": {"num_predict": 50}  # å¢åŠ  token æ•¸é‡ä»¥ç²å¾—å®Œæ•´å›è¦†
                                }
                                print(f"[AI Test] ä½¿ç”¨ Ollama æ ¼å¼: {chat_url}", file=sys.stderr)
                            else:
                                # OpenAI å…¼å®¹æ ¼å¼
                                request_body = {
                                    "model": model_name or "default",
                                    "messages": [{"role": "user", "content": test_message}],
                                    "max_tokens": 50,  # å¢åŠ  token æ•¸é‡
                                    "stream": False
                                }
                                print(f"[AI Test] ä½¿ç”¨ OpenAI æ ¼å¼: {chat_url}", file=sys.stderr)
                            async with session.post(
                                chat_url,
                                headers=headers,
                                json=request_body,
                                timeout=aiohttp.ClientTimeout(total=15)
                            ) as resp:
                                print(f"[AI Test] éŸ¿æ‡‰ç‹€æ…‹: {resp.status}", file=sys.stderr)
                                if resp.status == 200:
                                    data = await resp.json()
                                    # ğŸ”§ P0 å„ªåŒ–ï¼šè¨ˆç®—å»¶é²æ™‚é–“
                                    latency_ms = int((time_module.time() - test_start_time) * 1000)
                                    
                                    # OpenAI æ ¼å¼éŸ¿æ‡‰
                                    content = data.get('choices', [{}])[0].get('message', {}).get('content', '')
                                    # Ollama æ ¼å¼éŸ¿æ‡‰
                                    if not content:
                                        content = data.get('message', {}).get('content', '')
                                    # å…¶ä»–æ ¼å¼
                                    if not content:
                                        content = data.get('response', '') or data.get('content', '')
                                    
                                    if content:
                                        is_connected = True
                                        response_preview = content[:100] + ('...' if len(content) > 100 else '')
                                        print(f"[AI Test] âœ“ æˆåŠŸï¼å»¶é²: {latency_ms}msï¼ŒéŸ¿æ‡‰: {response_preview}", file=sys.stderr)
                                    else:
                                        # æœ‰éŸ¿æ‡‰ä½†æ²’æœ‰å…§å®¹ï¼Œå¯èƒ½æ ¼å¼ä¸å°
                                        is_connected = True  # è‡³å°‘é€£æ¥æˆåŠŸäº†
                                        response_preview = f"API å¯é” (éŸ¿æ‡‰æ ¼å¼: {list(data.keys())[:3]})"
                                        print(f"[AI Test] âœ“ é€£æ¥æˆåŠŸä½†éŸ¿æ‡‰æ ¼å¼æœªçŸ¥ï¼Œå»¶é²: {latency_ms}ms", file=sys.stderr)
                                else:
                                    resp_text = await resp.text()
                                    error_message = f"HTTP {resp.status}: {resp_text[:100]}"
                                    print(f"[AI Test] å¤±æ•—: {error_message}", file=sys.stderr)
                        except Exception as e1:
                            print(f"[AI Test] OpenAI æ ¼å¼å¤±æ•—: {e1}", file=sys.stderr)
                            
                            # å˜—è©¦ Ollama åŸç”Ÿæ ¼å¼
                            try:
                                ollama_url = api_endpoint or 'http://localhost:11434/api/chat'
                                if not ollama_url.endswith('/api/chat'):
                                    ollama_url = ollama_url.rstrip('/') + '/api/chat'
                                
                                print(f"[AI Test] å˜—è©¦ Ollama æ ¼å¼: {ollama_url}", file=sys.stderr)
                                async with session.post(
                                    ollama_url,
                                    json={
                                        "model": model_name or "qwen2:7b",
                                        "messages": [{"role": "user", "content": "Hi"}],
                                        "stream": False,
                                        "options": {"num_predict": 10}
                                    },
                                    timeout=aiohttp.ClientTimeout(total=15)
                                ) as resp:
                                    if resp.status == 200:
                                        data = await resp.json()
                                        content = data.get('message', {}).get('content', '')
                                        if content:
                                            is_connected = True
                                            response_preview = content[:50]
                                    else:
                                        error_message = f"HTTP {resp.status}"
                            except Exception as e2:
                                error_message = f"é€£æ¥å¤±æ•—: {str(e1)[:50]}; {str(e2)[:50]}"
                                print(f"[AI Test] æ‰€æœ‰æ ¼å¼éƒ½å¤±æ•—: {error_message}", file=sys.stderr)
                                
                elif provider == 'openai':
                    import aiohttp
                    # è‡ªå‹•æ ¼å¼åŒ–æ¨¡å‹åç¨±ï¼ˆè½‰å°å¯«ï¼Œè™•ç†å¸¸è¦‹è®Šé«”ï¼‰
                    normalized_model = model_name.lower().strip()
                    model_name_map = {
                        'gpt4o': 'gpt-4o',
                        'gpt-4o': 'gpt-4o',
                        'gpt4': 'gpt-4',
                        'gpt-4': 'gpt-4',
                        'gpt4turbo': 'gpt-4-turbo',
                        'gpt-4-turbo': 'gpt-4-turbo',
                        'gpt35turbo': 'gpt-3.5-turbo',
                        'gpt-3.5-turbo': 'gpt-3.5-turbo',
                        'gpt3.5': 'gpt-3.5-turbo',
                        'gpt-4o-mini': 'gpt-4o-mini',
                        'gpt4omini': 'gpt-4o-mini',
                    }
                    actual_model = model_name_map.get(normalized_model.replace(' ', '').replace('-', ''), normalized_model)
                    print(f"[AI Test] OpenAI æ¨¡å‹åç¨±æ˜ å°„: {model_name} -> {actual_model}", file=sys.stderr)
                    
                    async with aiohttp.ClientSession() as session:
                        async with session.post(
                            'https://api.openai.com/v1/chat/completions',
                            headers={
                                'Authorization': f'Bearer {api_key}',
                                'Content-Type': 'application/json'
                            },
                            json={
                                "model": actual_model,
                                "messages": [{"role": "user", "content": "Hi"}],
                                "max_tokens": 5
                            },
                            timeout=aiohttp.ClientTimeout(total=15)
                        ) as resp:
                            print(f"[AI Test] OpenAI éŸ¿æ‡‰ç‹€æ…‹: {resp.status}", file=sys.stderr)
                            if resp.status == 200:
                                data = await resp.json()
                                content = data.get('choices', [{}])[0].get('message', {}).get('content', '')
                                is_connected = True
                                response_preview = f"OpenAI ({actual_model}) é€£æ¥æˆåŠŸ" + (f": {content[:30]}..." if content else "")
                            else:
                                data = await resp.json()
                                api_error = data.get('error', {})
                                error_code = api_error.get('code', '')
                                error_msg = api_error.get('message', f"HTTP {resp.status}")
                                
                                # æä¾›æ›´å‹å¥½çš„éŒ¯èª¤æç¤º
                                if resp.status == 401:
                                    error_message = "API Key ç„¡æ•ˆæˆ–å·²éæœŸï¼Œè«‹åœ¨ OpenAI å¾Œå°ç¢ºèª Key ç‹€æ…‹"
                                elif resp.status == 429:
                                    # 429 è¡¨ç¤ºé™æµï¼Œä½†æ¨¡å‹å’Œ Key éƒ½æ˜¯æœ‰æ•ˆçš„
                                    is_connected = True
                                    response_preview = f"OpenAI ({actual_model}) å¯ç”¨ï¼ˆç•¶å‰é™æµä¸­ï¼‰"
                                    print(f"[AI Test] âœ“ OpenAI {actual_model} è¢«é™æµï¼Œä½†ç¢ºèªå¯ç”¨", file=sys.stderr)
                                elif resp.status == 403:
                                    error_message = "API Key æ²’æœ‰æ¬Šé™ï¼Œå¯èƒ½éœ€è¦ä»˜è²»å¸³æˆ¶"
                                elif 'model' in error_msg.lower() and 'not found' in error_msg.lower():
                                    error_message = f"æ¨¡å‹ {actual_model} ä¸å­˜åœ¨æˆ–æ‚¨çš„å¸³æˆ¶ç„¡æ¬Šä½¿ç”¨"
                                else:
                                    error_message = error_msg
                                
                                if error_message:
                                    print(f"[AI Test] OpenAI éŒ¯èª¤: {error_message} (åŸå§‹: {error_msg})", file=sys.stderr)
                                
                elif provider == 'claude':
                    import aiohttp
                    # è‡ªå‹•æ ¼å¼åŒ–æ¨¡å‹åç¨±
                    normalized_model = model_name.lower().strip()
                    claude_model_map = {
                        'claude': 'claude-3-5-sonnet-latest',
                        'claude3': 'claude-3-5-sonnet-latest',
                        'claude-3': 'claude-3-5-sonnet-latest',
                        'claude-3-opus': 'claude-3-opus-latest',
                        'claude3opus': 'claude-3-opus-latest',
                        'claude-3-sonnet': 'claude-3-5-sonnet-latest',
                        'claude3sonnet': 'claude-3-5-sonnet-latest',
                        'claude-3-haiku': 'claude-3-haiku-20240307',
                        'claude3haiku': 'claude-3-haiku-20240307',
                        'claude-3.5-sonnet': 'claude-3-5-sonnet-latest',
                        'claude-3-5-sonnet': 'claude-3-5-sonnet-latest',
                    }
                    actual_model = claude_model_map.get(normalized_model.replace(' ', '').replace('-', '').replace('.', ''), model_name)
                    print(f"[AI Test] Claude æ¨¡å‹åç¨±æ˜ å°„: {model_name} -> {actual_model}", file=sys.stderr)
                    
                    async with aiohttp.ClientSession() as session:
                        async with session.post(
                            'https://api.anthropic.com/v1/messages',
                            headers={
                                'x-api-key': api_key,
                                'anthropic-version': '2023-06-01',
                                'Content-Type': 'application/json'
                            },
                            json={
                                "model": actual_model,
                                "max_tokens": 5,
                                "messages": [{"role": "user", "content": "Hi"}]
                            },
                            timeout=aiohttp.ClientTimeout(total=15)
                        ) as resp:
                            print(f"[AI Test] Claude éŸ¿æ‡‰ç‹€æ…‹: {resp.status}", file=sys.stderr)
                            if resp.status == 200:
                                is_connected = True
                                response_preview = "Claude é€£æ¥æˆåŠŸ"
                            else:
                                data = await resp.json()
                                error_message = data.get('error', {}).get('message', f"HTTP {resp.status}")
                                if 'authentication' in error_message.lower():
                                    error_message = "API Key ç„¡æ•ˆ"
                                print(f"[AI Test] Claude éŒ¯èª¤: {error_message}", file=sys.stderr)
                                
                elif provider == 'gemini':
                    import aiohttp
                    # Gemini æ¨¡å‹åç¨±åˆ—è¡¨ï¼ˆå˜—è©¦å¤šå€‹è®Šé«”ï¼‰
                    gemini_models_to_try = []
                    normalized = model_name.lower().strip()
                    
                    # æ·»åŠ ç”¨æˆ¶è¼¸å…¥çš„æ¨¡å‹å
                    gemini_models_to_try.append(model_name)
                    
                    # æ·»åŠ å¸¸è¦‹è®Šé«”
                    if 'flash' in normalized:
                        gemini_models_to_try.extend([
                            'gemini-1.5-flash-latest',
                            'gemini-1.5-flash',
                            'gemini-1.5-flash-001',
                            'gemini-2.0-flash-exp'
                        ])
                    elif 'pro' in normalized:
                        gemini_models_to_try.extend([
                            'gemini-1.5-pro-latest',
                            'gemini-1.5-pro',
                            'gemini-1.5-pro-001',
                            'gemini-pro'
                        ])
                    else:
                        gemini_models_to_try.extend([
                            'gemini-1.5-flash-latest',
                            'gemini-1.5-pro-latest'
                        ])
                    
                    # å»é‡
                    gemini_models_to_try = list(dict.fromkeys(gemini_models_to_try))
                    print(f"[AI Test] Gemini å°‡å˜—è©¦æ¨¡å‹åˆ—è¡¨: {gemini_models_to_try}", file=sys.stderr)
                    
                    async with aiohttp.ClientSession() as session:
                        for try_model in gemini_models_to_try:
                            url = f'https://generativelanguage.googleapis.com/v1beta/models/{try_model}:generateContent?key={api_key}'
                            print(f"[AI Test] å˜—è©¦ Gemini æ¨¡å‹: {try_model}", file=sys.stderr)
                            try:
                                async with session.post(
                                    url,
                                    json={
                                        "contents": [{"role": "user", "parts": [{"text": "Hi"}]}],
                                        "generationConfig": {"maxOutputTokens": 10}
                                    },
                                    timeout=aiohttp.ClientTimeout(total=10)
                                ) as resp:
                                    print(f"[AI Test] Gemini {try_model} éŸ¿æ‡‰ç‹€æ…‹: {resp.status}", file=sys.stderr)
                                    if resp.status == 200:
                                        data = await resp.json()
                                        content = data.get('candidates', [{}])[0].get('content', {}).get('parts', [{}])[0].get('text', '')
                                        is_connected = True
                                        response_preview = f"Gemini ({try_model}) é€£æ¥æˆåŠŸ" + (f": {content[:30]}..." if content else "")
                                        print(f"[AI Test] âœ“ Gemini é€£æ¥æˆåŠŸ: {try_model}", file=sys.stderr)
                                        break
                                    elif resp.status == 400:
                                        data = await resp.json()
                                        err = data.get('error', {}).get('message', '')
                                        if 'API_KEY_INVALID' in err or 'API key' in err:
                                            error_message = "API Key ç„¡æ•ˆï¼Œè«‹æª¢æŸ¥ Google AI Studio ä¸­çš„ API Key"
                                            break
                                    elif resp.status == 403:
                                        error_message = "API Key æ²’æœ‰æ¬Šé™ä½¿ç”¨ Gemini APIï¼Œè«‹åœ¨ Google AI Studio ä¸­å•Ÿç”¨"
                                        break
                                    elif resp.status == 429:
                                        # 429 è¡¨ç¤ºé™æµï¼Œä½†æ¨¡å‹å­˜åœ¨ä¸”å¯ç”¨
                                        is_connected = True
                                        response_preview = f"Gemini ({try_model}) å¯ç”¨ï¼ˆç•¶å‰é™æµä¸­ï¼‰"
                                        print(f"[AI Test] âœ“ Gemini {try_model} è¢«é™æµï¼Œä½†ç¢ºèªå¯ç”¨", file=sys.stderr)
                                        break
                            except Exception as try_e:
                                print(f"[AI Test] Gemini {try_model} å˜—è©¦å¤±æ•—: {try_e}", file=sys.stderr)
                                continue
                        
                        if not is_connected and not error_message:
                            error_message = f"æ‰€æœ‰ Gemini æ¨¡å‹è®Šé«”éƒ½ç„¡æ³•é€£æ¥ï¼Œè«‹ç¢ºèª API Key æ­£ç¢ºä¸”å·²å•Ÿç”¨ Generative Language API"
                else:
                    error_message = f"æœªçŸ¥ä¾›æ‡‰å•†: {provider}"
                    
            except asyncio.TimeoutError:
                error_message = "é€£æ¥è¶…æ™‚ï¼Œè«‹æª¢æŸ¥ç¶²çµ¡é€£æ¥æˆ– API ç«¯é»æ˜¯å¦æ­£ç¢º"
            except Exception as test_error:
                error_str = str(test_error)
                error_type = type(test_error).__name__
                # ğŸ”§ å‹å¥½åŒ–å¸¸è¦‹éŒ¯èª¤ä¿¡æ¯
                if 'ClientConnectorError' in error_type or 'ConnectionRefused' in error_str or 'Cannot connect' in error_str:
                    error_message = "ç„¡æ³•é€£æ¥åˆ° AI æœå‹™ï¼Œè«‹ç¢ºèªæœå‹™å·²å•Ÿå‹•ä¸”ç«¯é»æ­£ç¢º"
                elif 'Name or service not known' in error_str or 'getaddrinfo failed' in error_str:
                    error_message = "ç„¡æ•ˆçš„ API ç«¯é»åœ°å€ï¼Œè«‹æª¢æŸ¥ URL æ ¼å¼"
                elif 'SSL' in error_str or 'certificate' in error_str.lower():
                    error_message = "SSL/TLS è­‰æ›¸é©—è­‰å¤±æ•—ï¼Œå¯èƒ½éœ€è¦ä¿¡ä»»è‡ªç°½åè­‰æ›¸"
                elif 'ClientError' in error_type:
                    error_message = f"ç¶²çµ¡è«‹æ±‚å¤±æ•—ï¼š{error_str[:50]}"
                else:
                    error_message = f"æ¸¬è©¦å¤±æ•—ï¼š{error_str[:100]}"
            
            # æ›´æ–°æ•¸æ“šåº«ä¸­çš„é€£æ¥ç‹€æ…‹
            if model_id:
                await db.execute(
                    "UPDATE ai_models SET is_connected = ?, last_tested_at = CURRENT_TIMESTAMP WHERE id = ?",
                    (1 if is_connected else 0, model_id)
                )
            
            if is_connected:
                self.send_log(f"âœ… AI æ¨¡å‹é€£æ¥æˆåŠŸ: {model_name}" + (f" - {response_preview}" if response_preview else ""), "success")
            else:
                self.send_log(f"âŒ AI æ¨¡å‹é€£æ¥å¤±æ•—: {model_name} - {error_message}", "error")
            
            # ğŸ”§ P0+P2 å„ªåŒ–ï¼šåŒ…å«å»¶é²æ™‚é–“å’Œå¯ç”¨æ¨¡å‹åˆ—è¡¨
            self.send_event("ai-model-tested", {
                "success": True,
                "modelId": model_id,
                "isConnected": is_connected,
                "error": error_message,
                "responsePreview": response_preview,
                "modelName": model_name,
                "latencyMs": latency_ms if 'latency_ms' in dir() else None,
                "availableModels": available_models if 'available_models' in dir() else []
            })
            
        except Exception as e:
            import traceback
            print(f"[AI Test] æ¸¬è©¦éç¨‹ç•°å¸¸: {traceback.format_exc()}", file=__import__('sys').stderr)
            self.send_event("ai-model-tested", {"success": False, "error": str(e)})
    
    async def handle_set_default_ai_model(self, payload: Dict[str, Any]):
        """è¨­ç½®é»˜èª AI æ¨¡å‹"""
        try:
            model_id = payload.get('id')
            if not model_id:
                self.send_event("ai-model-default-set", {"success": False, "error": "ç¼ºå°‘æ¨¡å‹ ID"})
                return
            
            # å…ˆå–æ¶ˆæ‰€æœ‰é»˜èª
            await db.execute("UPDATE ai_models SET is_default = 0")
            # è¨­ç½®æ–°é»˜èª
            await db.execute("UPDATE ai_models SET is_default = 1 WHERE id = ?", (model_id,))
            
            self.send_log(f"âœ… å·²è¨­ç½®é»˜èª AI æ¨¡å‹: ID={model_id}", "success")
            self.send_event("ai-model-default-set", {"success": True, "modelId": model_id})
            await self.handle_get_ai_models()
            
        except Exception as e:
            self.send_event("ai-model-default-set", {"success": False, "error": str(e)})
    
    async def handle_save_model_usage(self, payload: Dict[str, Any]):
        """ä¿å­˜æ¨¡å‹ç”¨é€”åˆ†é…"""
        try:
            intent_recognition = payload.get('intentRecognition', '')
            daily_chat = payload.get('dailyChat', '')
            multi_role_script = payload.get('multiRoleScript', '')
            
            # ä¿å­˜åˆ° ai_settings è¡¨
            await db.execute("""
                INSERT INTO ai_settings (key, value) VALUES ('model_usage', ?)
                ON CONFLICT(key) DO UPDATE SET value = excluded.value, updated_at = CURRENT_TIMESTAMP
            """, (json.dumps({
                'intentRecognition': intent_recognition,
                'dailyChat': daily_chat,
                'multiRoleScript': multi_role_script
            }),))
            
            print(f"[AI] æ¨¡å‹ç”¨é€”åˆ†é…å·²ä¿å­˜: intent={intent_recognition}, chat={daily_chat}, multi={multi_role_script}", file=sys.stderr)
            self.send_event("model-usage-saved", {"success": True})
            
        except Exception as e:
            print(f"[AI] ä¿å­˜æ¨¡å‹ç”¨é€”åˆ†é…å¤±æ•—: {e}", file=sys.stderr)
            self.send_event("model-usage-saved", {"success": False, "error": str(e)})
    
    async def handle_get_model_usage(self, data=None):
        """ç²å–æ¨¡å‹ç”¨é€”åˆ†é…"""
        try:
            row = await db.fetch_one(
                "SELECT value FROM ai_settings WHERE key = 'model_usage'"
            )
            
            if row and row.get('value'):
                usage = json.loads(row['value'])
            else:
                usage = {
                    'intentRecognition': '',
                    'dailyChat': '',
                    'multiRoleScript': ''
                }
            
            print(f"[AI] æ¨¡å‹ç”¨é€”åˆ†é…å·²åŠ è¼‰: {usage}", file=sys.stderr)
            self.send_event("model-usage-loaded", {"success": True, "usage": usage})
            
        except Exception as e:
            print(f"[AI] ç²å–æ¨¡å‹ç”¨é€”åˆ†é…å¤±æ•—: {e}", file=sys.stderr)
            self.send_event("model-usage-loaded", {"success": False, "error": str(e)})
    
    async def handle_save_conversation_strategy(self, payload: Dict[str, Any]):
        """ğŸ”§ ä¿å­˜å°è©±ç­–ç•¥"""
        try:
            style = payload.get('style', 'friendly')
            response_length = payload.get('responseLength', 'medium')
            use_emoji = payload.get('useEmoji', True)
            custom_persona = payload.get('customPersona', '')
            
            # ä¿å­˜åˆ° ai_settings è¡¨
            await db.execute("""
                INSERT INTO ai_settings (key, value) VALUES ('conversation_strategy', ?)
                ON CONFLICT(key) DO UPDATE SET value = excluded.value, updated_at = CURRENT_TIMESTAMP
            """, (json.dumps({
                'style': style,
                'responseLength': response_length,
                'useEmoji': use_emoji,
                'customPersona': custom_persona
            }),))
            
            # åŒæ™‚æ›´æ–° system_promptï¼ˆå¦‚æœæœ‰è‡ªå®šç¾©äººè¨­ï¼‰
            if custom_persona:
                await db.execute("""
                    INSERT INTO ai_settings (key, value) VALUES ('system_prompt', ?)
                    ON CONFLICT(key) DO UPDATE SET value = excluded.value, updated_at = CURRENT_TIMESTAMP
                """, (custom_persona,))
            
            print(f"[AI] å°è©±ç­–ç•¥å·²ä¿å­˜: style={style}, length={response_length}, emoji={use_emoji}", file=sys.stderr)
            self.send_event("conversation-strategy-saved", {"success": True})
            
        except Exception as e:
            print(f"[AI] ä¿å­˜å°è©±ç­–ç•¥å¤±æ•—: {e}", file=sys.stderr)
            self.send_event("conversation-strategy-saved", {"success": False, "error": str(e)})
    
    async def handle_get_conversation_strategy(self):
        """ğŸ”§ ç²å–å°è©±ç­–ç•¥"""
        try:
            row = await db.fetch_one(
                "SELECT value FROM ai_settings WHERE key = 'conversation_strategy'"
            )
            
            if row and row.get('value'):
                strategy = json.loads(row['value'])
            else:
                strategy = {
                    'style': 'friendly',
                    'responseLength': 'medium',
                    'useEmoji': True,
                    'customPersona': ''
                }
            
            print(f"[AI] å°è©±ç­–ç•¥å·²åŠ è¼‰: {strategy}", file=sys.stderr)
            self.send_event("conversation-strategy-loaded", {"success": True, "strategy": strategy})
            
        except Exception as e:
            print(f"[AI] ç²å–å°è©±ç­–ç•¥å¤±æ•—: {e}", file=sys.stderr)
            self.send_event("conversation-strategy-loaded", {"success": False, "error": str(e)})
    
    # ==================== Knowledge Base Handlers ====================
    
    async def handle_init_knowledge_base(self):
        """Initialize knowledge base"""
        try:
            await search_engine.initialize()
            stats = await search_engine.get_stats()
            
            self.send_event("knowledge-base-initialized", {
                "success": True,
                "stats": stats
            })
            self.send_log("çŸ¥è­˜åº«åˆå§‹åŒ–æˆåŠŸ", "success")
        except Exception as e:
            self.send_event("knowledge-base-initialized", {
                "success": False,
                "error": str(e)
            })
            self.send_log(f"çŸ¥è­˜åº«åˆå§‹åŒ–å¤±æ•—: {str(e)}", "error")
    
    async def handle_get_knowledge_stats(self):
        """Get knowledge base statistics"""
        try:
            stats = await search_engine.get_stats()
            self.send_event("knowledge-stats", {
                "success": True,
                "stats": stats
            })
        except Exception as e:
            self.send_event("knowledge-stats", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_add_document(self, payload: Dict[str, Any]):
        """Add a document to knowledge base"""
        try:
            file_path = payload.get('filePath')
            title = payload.get('title')
            category = payload.get('category', 'general')
            tags = payload.get('tags', [])
            content = payload.get('content')  # For direct text input
            
            if content and title:
                result = await document_manager.add_document_from_text(
                    title=title,
                    content=content,
                    category=category,
                    tags=tags
                )
            elif file_path:
                result = await document_manager.add_document(
                    file_path=file_path,
                    title=title,
                    category=category,
                    tags=tags
                )
            else:
                result = {"success": False, "error": "No file or content provided"}
            
            self.send_event("document-added", result)
            if result.get('success'):
                self.send_log(f"æ–‡æª”å·²æ·»åŠ : {result.get('title')}", "success")
        except Exception as e:
            self.send_event("document-added", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_add_knowledge_base(self, payload: Dict[str, Any]):
        """ğŸ†• æ·»åŠ çŸ¥è­˜åº«"""
        import sys
        print(f"[Backend] handle_add_knowledge_base called with: {payload}", file=sys.stderr)
        
        try:
            # ğŸ”§ FIX: ä¿ç•™å‰ç«¯å‚³å…¥çš„ ID
            frontend_id = payload.get('id', '')
            name = payload.get('name', '')
            description = payload.get('description', '')
            category = payload.get('category', 'general')
            
            if not name:
                self.send_event("knowledge-base-added", {
                    "success": False,
                    "error": "çŸ¥è­˜åº«åç¨±ä¸èƒ½ç‚ºç©º"
                })
                return
            
            # ğŸ”§ ç¢ºä¿çŸ¥è­˜åº«è¡¨å­˜åœ¨
            await db._ensure_knowledge_tables()
            
            # æ·»åŠ åˆ°æ•¸æ“šåº«
            print(f"[Backend] Adding knowledge item: {name}", file=sys.stderr)
            db_id = await db.add_knowledge_item(
                title=f"[çŸ¥è­˜åº«] {name}",
                content=description or f"çŸ¥è­˜åº«ï¼š{name}",
                category=category,
                priority=1
            )
            
            print(f"[Backend] Knowledge item added with db_id: {db_id}, frontend_id: {frontend_id}", file=sys.stderr)
            
            # ğŸ”§ FIX: è¿”å›å‰ç«¯å‚³å…¥çš„ IDï¼Œä¿æŒä¸€è‡´æ€§
            self.send_event("knowledge-base-added", {
                "success": True,
                "id": frontend_id or f"kb_{db_id}",
                "dbId": db_id,
                "name": name
            })
            self.send_log(f"âœ“ çŸ¥è­˜åº«ã€Œ{name}ã€å·²å‰µå»º", "success")
            
        except Exception as e:
            import traceback
            print(f"[Backend] Error in handle_add_knowledge_base: {e}", file=sys.stderr)
            traceback.print_exc(file=sys.stderr)
            self.send_event("knowledge-base-added", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_add_knowledge_item(self, payload: Dict[str, Any]):
        """ğŸ†• æ·»åŠ çŸ¥è­˜åº«æ¢ç›®"""
        try:
            title = payload.get('title', '')
            content = payload.get('content', '')
            category = payload.get('category', 'general')
            keywords = payload.get('keywords', '')
            priority = payload.get('priority', 1)
            
            if not title or not content:
                self.send_event("knowledge-item-added", {
                    "success": False,
                    "error": "æ¨™é¡Œå’Œå…§å®¹ä¸èƒ½ç‚ºç©º"
                })
                return
            
            item_id = await db.add_knowledge_item(
                title=title,
                content=content,
                category=category,
                keywords=keywords,
                priority=priority
            )
            
            self.send_event("knowledge-item-added", {
                "success": True,
                "id": item_id,
                "title": title
            })
            self.send_log(f"âœ“ çŸ¥è­˜æ¢ç›®ã€Œ{title}ã€å·²æ·»åŠ ", "success")
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("knowledge-item-added", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_knowledge_items(self, payload: Dict[str, Any]):
        """ğŸ†• ç²å–çŸ¥è­˜åº«æ¢ç›®åˆ—è¡¨"""
        try:
            category = payload.get('category')
            active_only = payload.get('activeOnly', True)
            
            items = await db.get_knowledge_items(category=category, active_only=active_only)
            
            self.send_event("knowledge-items", {
                "success": True,
                "items": items
            })
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("knowledge-items", {
                "success": False,
                "items": [],
                "error": str(e)
            })
    
    async def handle_ai_generate_knowledge(self, payload: Dict[str, Any]):
        """ğŸ†• AI è‡ªå‹•ç”ŸæˆçŸ¥è­˜åº«å…§å®¹"""
        import sys
        print(f"[Backend] handle_ai_generate_knowledge called with: {payload}", file=sys.stderr)
        
        try:
            kb_id = payload.get('kbId', '')
            business_desc = payload.get('businessDescription', '')
            
            if not business_desc:
                self.send_event("ai-knowledge-generated", {
                    "success": False,
                    "error": "è«‹æä¾›æ¥­å‹™æè¿°"
                })
                return
            
            # æ§‹å»ºç”ŸæˆçŸ¥è­˜çš„ prompt
            prompt = f"""è«‹æ ¹æ“šä»¥ä¸‹æ¥­å‹™æè¿°ï¼Œç”Ÿæˆçµæ§‹åŒ–çš„çŸ¥è­˜åº«å…§å®¹ã€‚

æ¥­å‹™æè¿°ï¼š{business_desc}

è«‹ç”Ÿæˆä»¥ä¸‹é¡åˆ¥çš„çŸ¥è­˜ï¼ˆæ¯å€‹é¡åˆ¥ 3-5 æ¢ï¼‰ï¼š

1. ã€ç”¢å“çŸ¥è­˜ã€‘- é—œæ–¼ç”¢å“/æœå‹™çš„è©³ç´°ä¿¡æ¯
2. ã€å¸¸è¦‹å•ç­”ã€‘- å®¢æˆ¶å¸¸å•çš„å•é¡Œå’Œæ¨™æº–ç­”æ¡ˆï¼ˆQ: å•é¡Œ A: ç­”æ¡ˆ æ ¼å¼ï¼‰
3. ã€éŠ·å”®è©±è¡“ã€‘- æ¨éŠ·å’Œèªªæœå®¢æˆ¶çš„è©±è¡“
4. ã€ç•°è­°è™•ç†ã€‘- è™•ç†å®¢æˆ¶ç–‘æ…®å’Œç•°è­°çš„å›æ‡‰

è«‹ä»¥ JSON æ ¼å¼è¿”å›ï¼Œçµæ§‹å¦‚ä¸‹ï¼š
{{
  "items": [
    {{"category": "product", "title": "æ¨™é¡Œ", "content": "è©³ç´°å…§å®¹"}},
    {{"category": "faq", "title": "Q: å•é¡Œ", "content": "A: ç­”æ¡ˆ"}},
    {{"category": "sales", "title": "è©±è¡“æ¨™é¡Œ", "content": "è©±è¡“å…§å®¹"}},
    {{"category": "objection", "title": "ç•°è­°é¡å‹", "content": "è™•ç†æ–¹å¼"}}
  ]
}}

åªè¿”å› JSONï¼Œä¸è¦å…¶ä»–æ–‡å­—ã€‚"""
            
            # ä½¿ç”¨ AI ç”Ÿæˆ
            if ai_auto_chat and hasattr(ai_auto_chat, '_generate_response_with_prompt'):
                response = await ai_auto_chat._generate_response_with_prompt(
                    user_id="system",
                    user_message=prompt,
                    custom_prompt="ä½ æ˜¯ä¸€å€‹å°ˆæ¥­çš„æ¥­å‹™çŸ¥è­˜ç”ŸæˆåŠ©æ‰‹ï¼Œæ“…é•·ç‚ºå„é¡æ¥­å‹™ç”Ÿæˆçµæ§‹åŒ–çš„çŸ¥è­˜åº«å…§å®¹ã€‚è«‹åªè¿”å› JSON æ ¼å¼çš„çµæœã€‚",
                    usage_type="knowledge"
                )
            else:
                # Fallback: ä½¿ç”¨é»˜èªçš„çŸ¥è­˜æ¨¡æ¿
                response = self._generate_default_knowledge(business_desc)
            
            # è§£æ AI éŸ¿æ‡‰
            items = self._parse_ai_knowledge_response(response)
            
            if items:
                # ä¿å­˜åˆ°æ•¸æ“šåº«
                for item in items:
                    await db.add_knowledge_item(
                        title=item.get('title', ''),
                        content=item.get('content', ''),
                        category=item.get('category', 'custom'),
                        priority=1
                    )
                
                print(f"[Backend] AI generated {len(items)} knowledge items", file=sys.stderr)
                
                self.send_event("ai-knowledge-generated", {
                    "success": True,
                    "kbId": kb_id,
                    "items": items,
                    "count": len(items)
                })
                self.send_log(f"âœ¨ AI å·²ç”Ÿæˆ {len(items)} æ¢çŸ¥è­˜", "success")
            else:
                self.send_event("ai-knowledge-generated", {
                    "success": False,
                    "error": "AI ç”Ÿæˆå¤±æ•—ï¼Œè«‹é‡è©¦"
                })
                
        except Exception as e:
            import traceback
            print(f"[Backend] Error in handle_ai_generate_knowledge: {e}", file=sys.stderr)
            traceback.print_exc(file=sys.stderr)
            self.send_event("ai-knowledge-generated", {
                "success": False,
                "error": str(e)
            })
    
    def _parse_ai_knowledge_response(self, response: str) -> list:
        """è§£æ AI ç”Ÿæˆçš„çŸ¥è­˜éŸ¿æ‡‰"""
        import json
        import re
        
        try:
            # å˜—è©¦ç›´æ¥è§£æ JSON
            if '{' in response and '}' in response:
                # æå– JSON éƒ¨åˆ†
                json_match = re.search(r'\{[\s\S]*\}', response)
                if json_match:
                    data = json.loads(json_match.group())
                    return data.get('items', [])
        except json.JSONDecodeError:
            pass
        
        # å¦‚æœè§£æå¤±æ•—ï¼Œå˜—è©¦æŒ‰è¡Œè§£æ
        items = []
        lines = response.split('\n')
        current_category = 'custom'
        
        for line in lines:
            line = line.strip()
            if 'ã€ç”¢å“çŸ¥è­˜ã€‘' in line or 'ã€äº§å“çŸ¥è¯†ã€‘' in line:
                current_category = 'product'
            elif 'ã€å¸¸è¦‹å•ç­”ã€‘' in line or 'ã€å¸¸è§é—®ç­”ã€‘' in line:
                current_category = 'faq'
            elif 'ã€éŠ·å”®è©±è¡“ã€‘' in line or 'ã€é”€å”®è¯æœ¯ã€‘' in line:
                current_category = 'sales'
            elif 'ã€ç•°è­°è™•ç†ã€‘' in line or 'ã€å¼‚è®®å¤„ç†ã€‘' in line:
                current_category = 'objection'
            elif line and not line.startswith('#') and len(line) > 10:
                items.append({
                    'category': current_category,
                    'title': line[:50],
                    'content': line
                })
        
        return items[:20]  # é™åˆ¶æœ€å¤š 20 æ¢
    
    def _generate_default_knowledge(self, business_desc: str) -> str:
        """ç”Ÿæˆé»˜èªçŸ¥è­˜æ¨¡æ¿"""
        return f'''{{
  "items": [
    {{"category": "product", "title": "æœå‹™ä»‹ç´¹", "content": "æˆ‘å€‘æä¾› {business_desc} ç›¸é—œæœå‹™ï¼Œè‡´åŠ›æ–¼ç‚ºå®¢æˆ¶æä¾›å°ˆæ¥­ã€é«˜æ•ˆçš„è§£æ±ºæ–¹æ¡ˆã€‚"}},
    {{"category": "product", "title": "æœå‹™å„ªå‹¢", "content": "æˆ‘å€‘æ“æœ‰å°ˆæ¥­åœ˜éšŠã€è±å¯Œç¶“é©—ï¼Œç¢ºä¿æœå‹™è³ªé‡å’Œå®¢æˆ¶æ»¿æ„åº¦ã€‚"}},
    {{"category": "faq", "title": "Q: å¦‚ä½•é–‹å§‹ä½¿ç”¨ï¼Ÿ", "content": "A: æ‚¨å¯ä»¥ç›´æ¥è¯ç¹«æˆ‘å€‘çš„å®¢æœï¼Œæˆ‘å€‘æœƒç‚ºæ‚¨è©³ç´°ä»‹ç´¹æµç¨‹ã€‚"}},
    {{"category": "faq", "title": "Q: æœå‹™è²»ç”¨å¦‚ä½•ï¼Ÿ", "content": "A: æˆ‘å€‘æä¾›å…·æœ‰ç«¶çˆ­åŠ›çš„åƒ¹æ ¼ï¼Œå…·é«”è²»ç”¨æ ¹æ“šæ‚¨çš„éœ€æ±‚è€Œå®šã€‚"}},
    {{"category": "sales", "title": "é–‹å ´è©±è¡“", "content": "æ‚¨å¥½ï¼å¾ˆé«˜èˆˆç‚ºæ‚¨æœå‹™ã€‚è«‹å•æœ‰ä»€éº¼å¯ä»¥å¹«åŠ©æ‚¨çš„ï¼Ÿ"}},
    {{"category": "sales", "title": "å„ªå‹¢ä»‹ç´¹", "content": "æˆ‘å€‘çš„æœå‹™å·²ç¶“å¹«åŠ©çœ¾å¤šå®¢æˆ¶è§£æ±ºå•é¡Œï¼Œæ‚¨å¯ä»¥æ”¾å¿ƒé¸æ“‡ã€‚"}},
    {{"category": "objection", "title": "åƒ¹æ ¼ç•°è­°", "content": "æˆ‘ç†è§£æ‚¨å°åƒ¹æ ¼çš„é—œæ³¨ã€‚æˆ‘å€‘çš„åƒ¹æ ¼æ˜¯åŸºæ–¼å„ªè³ªæœå‹™åˆ¶å®šçš„ï¼Œæ‚¨å¯ä»¥å…ˆé«”é©—ä¸€ä¸‹ã€‚"}},
    {{"category": "objection", "title": "ä¿¡ä»»ç•°è­°", "content": "æˆ‘å€‘å·²ç¶“æœå‹™å¤šå¹´ï¼Œæœ‰å¤§é‡æˆåŠŸæ¡ˆä¾‹ï¼Œæ‚¨å¯ä»¥æŸ¥çœ‹æˆ‘å€‘çš„å®¢æˆ¶è©•åƒ¹ã€‚"}}
  ]
}}'''
    
    async def handle_apply_industry_template(self, payload: Dict[str, Any]):
        """ğŸ†• æ‡‰ç”¨è¡Œæ¥­æ¨¡æ¿"""
        import sys
        print(f"[Backend] handle_apply_industry_template called with: {payload}", file=sys.stderr)
        
        try:
            kb_id = payload.get('kbId', '')
            template_id = payload.get('templateId', '')
            
            # è¡Œæ¥­æ¨¡æ¿å®šç¾©
            templates = {
                'payment': {
                    'name': 'è·¨å¢ƒæ”¯ä»˜',
                    'items': [
                        {'category': 'product', 'title': 'Uå…Œæ›æœå‹™', 'content': 'æˆ‘å€‘æä¾› USDT å…Œæ›äººæ°‘å¹£æœå‹™ï¼ŒåŒ¯ç‡å¯¦æ™‚æ›´æ–°ï¼Œåˆ°è³¬å¿«é€Ÿå®‰å…¨ã€‚'},
                        {'category': 'product', 'title': 'ä»£æ”¶ä»£ä»˜', 'content': 'æ”¯æŒå¾®ä¿¡ã€æ”¯ä»˜å¯¶ã€éŠ€è¡Œå¡å¤šç¨®æ”¶ä»˜æ¬¾æ–¹å¼ï¼Œæ‰‹çºŒè²»ä½å»‰ã€‚'},
                        {'category': 'product', 'title': 'æœå‹™æ™‚é–“', 'content': 'æˆ‘å€‘æä¾› 24 å°æ™‚åœ¨ç·šå®¢æœï¼Œéš¨æ™‚ç‚ºæ‚¨è§£ç­”å•é¡Œã€‚'},
                        {'category': 'faq', 'title': 'Q: å¤šä¹…åˆ°è³¬ï¼Ÿ', 'content': 'A: é€šå¸¸ 5-30 åˆ†é˜å…§åˆ°è³¬ï¼Œå¤§é¡å¯èƒ½éœ€è¦ 1-2 å°æ™‚ã€‚'},
                        {'category': 'faq', 'title': 'Q: æœ€ä½å…Œæ›é‡‘é¡ï¼Ÿ', 'content': 'A: æœ€ä½ 100 USDT èµ·å…Œï¼Œæœ€é«˜ä¸é™ã€‚'},
                        {'category': 'faq', 'title': 'Q: åŒ¯ç‡æ€éº¼ç®—ï¼Ÿ', 'content': 'A: å¯¦æ™‚åŒ¯ç‡ï¼Œä»¥äº¤æ˜“ç¢ºèªæ™‚çš„åƒ¹æ ¼ç‚ºæº–ã€‚'},
                        {'category': 'sales', 'title': 'å„ªå‹¢ä»‹ç´¹', 'content': 'æˆ‘å€‘çš„åŒ¯ç‡æ¯”å¸‚å ´å¹³å‡é«˜ 0.3-0.5%ï¼Œè€Œä¸”åˆ°è³¬é€Ÿåº¦å¿«ï¼Œå·²æœå‹™è¶…é 10 è¬å®¢æˆ¶ã€‚'},
                        {'category': 'sales', 'title': 'å¼•å°ä¸‹å–®', 'content': 'ç¾åœ¨ä¸‹å–®é‚„æœ‰å„ªæƒ å“¦ï¼Œæ‚¨è¦å…Œæ›å¤šå°‘ï¼Ÿæˆ‘å¹«æ‚¨è¨ˆç®—ä¸€ä¸‹ã€‚'},
                        {'category': 'objection', 'title': 'æ“”å¿ƒå®‰å…¨', 'content': 'æˆ‘å€‘å·²ç¶“é‹ç‡Ÿ 3 å¹´å¤šï¼Œå¾æœªå‡ºç¾éè³‡é‡‘å•é¡Œï¼Œæ‚¨å¯ä»¥å…ˆå°é¡é«”é©—ã€‚'},
                        {'category': 'objection', 'title': 'è¦ºå¾—è²´', 'content': 'æˆ‘å€‘çš„åƒ¹æ ¼å·²ç¶“å¾ˆå„ªæƒ äº†ï¼Œè€Œä¸”ä¿è­‰è³‡é‡‘å®‰å…¨å’Œåˆ°è³¬é€Ÿåº¦ã€‚'}
                    ]
                },
                'ecommerce': {
                    'name': 'é›»å•†é›¶å”®',
                    'items': [
                        {'category': 'product', 'title': 'å•†å“å“è³ª', 'content': 'æ‰€æœ‰å•†å“å‡ç‚ºæ­£å“ä¿è­‰ï¼Œæ”¯æŒä¸ƒå¤©ç„¡ç†ç”±é€€æ›ã€‚'},
                        {'category': 'product', 'title': 'é…é€æœå‹™', 'content': 'å…¨åœ‹åŒ…éƒµï¼Œä¸€èˆ¬ 3-5 å¤©é€é”ï¼Œéƒ¨åˆ†åœ°å€å¯æ¬¡æ—¥é”ã€‚'},
                        {'category': 'faq', 'title': 'Q: å¦‚ä½•ä¸‹å–®ï¼Ÿ', 'content': 'A: é¸æ“‡å•†å“å¾Œç›´æ¥ä¸‹å–®ï¼Œæ”¯æŒå¾®ä¿¡ã€æ”¯ä»˜å¯¶ä»˜æ¬¾ã€‚'},
                        {'category': 'faq', 'title': 'Q: å¯ä»¥é€€è²¨å—ï¼Ÿ', 'content': 'A: æ”¯æŒä¸ƒå¤©ç„¡ç†ç”±é€€æ›ï¼Œé‹è²»æˆ‘å€‘æ‰¿æ“”ã€‚'},
                        {'category': 'sales', 'title': 'ä¿ƒéŠ·æ´»å‹•', 'content': 'ç¾åœ¨ä¸‹å–®æ»¿ 199 æ¸› 20ï¼Œé‚„æœ‰æ›´å¤šå„ªæƒ ç­‰æ‚¨ç™¼ç¾ï¼'},
                        {'category': 'objection', 'title': 'åƒ¹æ ¼ç•°è­°', 'content': 'æˆ‘å€‘æ˜¯å» å®¶ç›´éŠ·ï¼Œåƒ¹æ ¼å·²ç¶“å¾ˆå„ªæƒ äº†ï¼Œå“è³ªæœ‰ä¿éšœã€‚'}
                    ]
                },
                'education': {
                    'name': 'åœ¨ç·šæ•™è‚²',
                    'items': [
                        {'category': 'product', 'title': 'èª²ç¨‹ä»‹ç´¹', 'content': 'æˆ‘å€‘æä¾›å°ˆæ¥­çš„åœ¨ç·šèª²ç¨‹ï¼Œç”±è³‡æ·±è¬›å¸«æˆèª²ï¼Œéš¨æ™‚éš¨åœ°å­¸ç¿’ã€‚'},
                        {'category': 'product', 'title': 'å­¸ç¿’æ”¯æŒ', 'content': 'é…å‚™å°ˆå±¬å­¸ç¿’é¡§å•ï¼Œèª²å¾Œç­”ç–‘ï¼Œç¢ºä¿å­¸ç¿’æ•ˆæœã€‚'},
                        {'category': 'faq', 'title': 'Q: èª²ç¨‹æœ‰æ•ˆæœŸï¼Ÿ', 'content': 'A: è³¼è²·å¾Œæ°¸ä¹…æœ‰æ•ˆï¼Œå¯åè¦†è§€çœ‹å­¸ç¿’ã€‚'},
                        {'category': 'faq', 'title': 'Q: å¯ä»¥è©¦è½å—ï¼Ÿ', 'content': 'A: å¯ä»¥ï¼Œæˆ‘å€‘æä¾›å…è²»è©¦è½èª²ç¨‹ï¼Œæ»¿æ„å¾Œå†è³¼è²·ã€‚'},
                        {'category': 'sales', 'title': 'èª²ç¨‹æ¨è–¦', 'content': 'é€™é–€èª²ç¨‹æ˜¯æˆ‘å€‘çš„æ˜æ˜Ÿèª²ç¨‹ï¼Œå·²å¹«åŠ©æ•¸è¬å­¸å“¡æå‡æŠ€èƒ½ã€‚'},
                        {'category': 'objection', 'title': 'æ²’æ™‚é–“å­¸', 'content': 'æˆ‘å€‘çš„èª²ç¨‹æ”¯æŒç¢ç‰‡åŒ–å­¸ç¿’ï¼Œæ¯å¤© 15 åˆ†é˜å°±èƒ½æœ‰æ”¶ç©«ã€‚'}
                    ]
                },
                'realestate': {
                    'name': 'æˆ¿ç”¢ä¸­ä»‹',
                    'items': [
                        {'category': 'product', 'title': 'æˆ¿æºä»‹ç´¹', 'content': 'æˆ‘å€‘æœ‰è±å¯Œçš„æˆ¿æºè³‡æºï¼Œæ¶µè“‹æ–°æˆ¿ã€äºŒæ‰‹æˆ¿ã€ç§Ÿæˆ¿ç­‰ã€‚'},
                        {'category': 'faq', 'title': 'Q: çœ‹æˆ¿éœ€è¦è²»ç”¨å—ï¼Ÿ', 'content': 'A: çœ‹æˆ¿å®Œå…¨å…è²»ï¼Œæˆäº¤å¾Œæ‰æ”¶å–æœå‹™è²»ã€‚'},
                        {'category': 'sales', 'title': 'æ¨è–¦æˆ¿æº', 'content': 'æ ¹æ“šæ‚¨çš„éœ€æ±‚ï¼Œæˆ‘æ¨è–¦é€™å¥—æˆ¿å­ï¼Œä½ç½®å¥½ã€åƒ¹æ ¼åˆé©ã€‚'},
                        {'category': 'objection', 'title': 'åƒ¹æ ¼å¤ªé«˜', 'content': 'é€™å€‹åƒ¹æ ¼åœ¨é€™å€‹åœ°æ®µå·²ç¶“å¾ˆå„ªæƒ äº†ï¼Œè€Œä¸”é‚„æœ‰è«‡åƒ¹ç©ºé–“ã€‚'}
                    ]
                },
                'finance': {
                    'name': 'é‡‘èç†è²¡',
                    'items': [
                        {'category': 'product', 'title': 'ç†è²¡ç”¢å“', 'content': 'æˆ‘å€‘æä¾›å¤šç¨®ç†è²¡ç”¢å“ï¼Œæ”¶ç›Šç©©å¥ï¼Œé¢¨éšªå¯æ§ã€‚'},
                        {'category': 'faq', 'title': 'Q: æ”¶ç›Šç‡å¤šå°‘ï¼Ÿ', 'content': 'A: æ ¹æ“šç”¢å“ä¸åŒï¼Œå¹´åŒ–æ”¶ç›Š 3%-8% ä¸ç­‰ã€‚'},
                        {'category': 'sales', 'title': 'ç”¢å“æ¨è–¦', 'content': 'æ¨è–¦é€™æ¬¾ç©©å¥å‹ç†è²¡ï¼Œé©åˆæ‚¨çš„é¢¨éšªåå¥½ã€‚'},
                        {'category': 'objection', 'title': 'æ“”å¿ƒé¢¨éšª', 'content': 'é€™æ¬¾ç”¢å“é¢¨éšªç­‰ç´šè¼ƒä½ï¼Œæœ¬é‡‘æœ‰ä¿éšœã€‚'}
                    ]
                },
                'healthcare': {
                    'name': 'é†«ç™‚å¥åº·',
                    'items': [
                        {'category': 'product', 'title': 'æœå‹™ä»‹ç´¹', 'content': 'æˆ‘å€‘æä¾›å°ˆæ¥­çš„å¥åº·è«®è©¢å’Œé ç´„æ›è™Ÿæœå‹™ã€‚'},
                        {'category': 'faq', 'title': 'Q: å¦‚ä½•é ç´„ï¼Ÿ', 'content': 'A: æ‚¨å¯ä»¥ç›´æ¥å‘Šè¨´æˆ‘éœ€è¦çš„ç§‘å®¤å’Œæ™‚é–“ï¼Œæˆ‘å¹«æ‚¨é ç´„ã€‚'},
                        {'category': 'sales', 'title': 'æœå‹™æ¨è–¦', 'content': 'å»ºè­°æ‚¨åšä¸€å€‹å…¨é¢é«”æª¢ï¼Œæ—©ç™¼ç¾æ—©æ²»ç™‚ã€‚'}
                    ]
                },
                'travel': {
                    'name': 'æ—…éŠæœå‹™',
                    'items': [
                        {'category': 'product', 'title': 'æœå‹™å…§å®¹', 'content': 'æˆ‘å€‘æä¾›æ©Ÿç¥¨ã€é…’åº—ã€è¡Œç¨‹è¦åŠƒä¸€ç«™å¼æœå‹™ã€‚'},
                        {'category': 'faq', 'title': 'Q: å¯ä»¥å®šåˆ¶è¡Œç¨‹å—ï¼Ÿ', 'content': 'A: å¯ä»¥ï¼Œæˆ‘å€‘æä¾›å€‹æ€§åŒ–å®šåˆ¶æœå‹™ã€‚'},
                        {'category': 'sales', 'title': 'ç·šè·¯æ¨è–¦', 'content': 'é€™æ¢ç·šè·¯å¾ˆå—æ­¡è¿ï¼Œé¢¨æ™¯å„ªç¾ï¼Œåƒ¹æ ¼å¯¦æƒ ã€‚'}
                    ]
                },
                'legal': {
                    'name': 'æ³•å¾‹è«®è©¢',
                    'items': [
                        {'category': 'product', 'title': 'æœå‹™ç¯„åœ', 'content': 'æˆ‘å€‘æä¾›æ°‘äº‹ã€å•†äº‹ã€åˆ‘äº‹ç­‰å„é¡æ³•å¾‹è«®è©¢æœå‹™ã€‚'},
                        {'category': 'faq', 'title': 'Q: è«®è©¢æ”¶è²»å—ï¼Ÿ', 'content': 'A: åˆæ¬¡è«®è©¢å…è²»ï¼Œå¾ŒçºŒæœå‹™æ ¹æ“šæ¡ˆä»¶è¤‡é›œç¨‹åº¦å ±åƒ¹ã€‚'},
                        {'category': 'sales', 'title': 'æœå‹™æ¨è–¦', 'content': 'å»ºè­°æ‚¨å…ˆæè¿°ä¸€ä¸‹æƒ…æ³ï¼Œæˆ‘å€‘çš„å¾‹å¸«æœƒçµ¦æ‚¨å°ˆæ¥­å»ºè­°ã€‚'}
                    ]
                }
            }
            
            template = templates.get(template_id)
            if not template:
                self.send_event("industry-template-applied", {
                    "success": False,
                    "error": f"æœªæ‰¾åˆ°æ¨¡æ¿: {template_id}"
                })
                return
            
            # ä¿å­˜åˆ°æ•¸æ“šåº«
            for item in template['items']:
                await db.add_knowledge_item(
                    title=item['title'],
                    content=item['content'],
                    category=item['category'],
                    priority=1
                )
            
            self.send_event("industry-template-applied", {
                "success": True,
                "kbId": kb_id,
                "templateId": template_id,
                "templateName": template['name'],
                "items": template['items']
            })
            self.send_log(f"ğŸ“š å·²æ‡‰ç”¨ã€Œ{template['name']}ã€æ¨¡æ¿", "success")
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("industry-template-applied", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_learn_from_chat_history(self, payload: Dict[str, Any]):
        """ğŸ†• å¾èŠå¤©è¨˜éŒ„å­¸ç¿’"""
        import sys
        print(f"[Backend] handle_learn_from_chat_history called with: {payload}", file=sys.stderr)
        
        try:
            kb_id = payload.get('kbId', '')
            days = payload.get('days', 7)
            
            # å¾æ•¸æ“šåº«ç²å–èŠå¤©è¨˜éŒ„
            from datetime import datetime, timedelta
            start_date = datetime.now() - timedelta(days=days)
            
            # ç²å–æœ€è¿‘çš„å„ªè³ªå›è¦†
            effective_responses = await db.get_effective_responses(
                min_score=0.7,
                limit=20
            ) if hasattr(db, 'get_effective_responses') else []
            
            if not effective_responses:
                self.send_event("chat-learning-complete", {
                    "success": True,
                    "kbId": kb_id,
                    "items": [],
                    "message": "æœªç™¼ç¾å¯å­¸ç¿’çš„å„ªè³ªå›è¦†"
                })
                return
            
            # è½‰æ›ç‚ºçŸ¥è­˜æ¢ç›®
            items = []
            for resp in effective_responses[:10]:  # æœ€å¤šå– 10 æ¢
                items.append({
                    'category': 'custom',
                    'title': f"å„ªè³ªå›è¦† - {resp.get('context', '')[:20]}...",
                    'content': resp.get('response', '')
                })
                
                # ä¿å­˜åˆ°æ•¸æ“šåº«
                await db.add_knowledge_item(
                    title=items[-1]['title'],
                    content=items[-1]['content'],
                    category='custom',
                    priority=2  # å­¸ç¿’çš„çŸ¥è­˜å„ªå…ˆç´šç¨é«˜
                )
            
            self.send_event("chat-learning-complete", {
                "success": True,
                "kbId": kb_id,
                "items": items,
                "count": len(items)
            })
            self.send_log(f"ğŸ’¬ å¾èŠå¤©è¨˜éŒ„å­¸ç¿’äº† {len(items)} æ¢çŸ¥è­˜", "success")
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("chat-learning-complete", {
                "success": False,
                "error": str(e)
            })
    
    # ==================== ğŸ§  RAG çŸ¥è­˜å¤§è…¦ 2.0 ====================
    
    async def handle_rag_initialize(self, payload: Dict[str, Any]):
        """åˆå§‹åŒ– RAG ç³»çµ±"""
        import sys
        print(f"[Backend] ğŸ§  RAG Initialize", file=sys.stderr)
        
        try:
            from telegram_rag_system import telegram_rag
            
            use_chromadb = payload.get('useChromadb', True)
            # ğŸ”§ Phase 1 å„ªåŒ–ï¼šé»˜èªç¦ç”¨ç¥ç¶“ç¶²çµ¡åµŒå…¥ï¼Œç¯€çœ 300-500MB å…§å­˜
            use_neural = payload.get('useNeural', False)
            
            success = await telegram_rag.initialize(
                use_chromadb=use_chromadb,
                use_neural=use_neural
            )
            
            self.send_event("rag-initialized", {
                "success": success,
                "chromadbEnabled": telegram_rag.use_chromadb,
                "neuralEmbedding": telegram_rag.use_neural_embedding
            })
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("rag-initialized", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_rag_search(self, payload: Dict[str, Any]):
        """RAG èªç¾©æœç´¢"""
        import sys
        print(f"[Backend] ğŸ§  RAG Search: {payload}", file=sys.stderr)
        
        try:
            from telegram_rag_system import telegram_rag, KnowledgeType
            
            query = payload.get('query', '')
            limit = payload.get('limit', 5)
            knowledge_type = payload.get('knowledgeType')
            min_score = payload.get('minScore', 0.3)
            
            # è½‰æ›é¡å‹
            kt = None
            if knowledge_type:
                try:
                    kt = KnowledgeType(knowledge_type)
                except:
                    pass
            
            results = await telegram_rag.search(
                query=query,
                limit=limit,
                knowledge_type=kt,
                min_score=min_score
            )
            
            # è½‰æ›çµæœ
            result_list = []
            for r in results:
                result_list.append({
                    'item': {
                        'id': r.item.id,
                        'knowledge_type': r.item.knowledge_type.value,
                        'question': r.item.question,
                        'answer': r.item.answer,
                        'context': r.item.context,
                        'keywords': r.item.keywords,
                        'success_score': r.item.success_score,
                        'use_count': r.item.use_count
                    },
                    'similarity': r.similarity,
                    'source': r.source
                })
            
            self.send_event("rag-search-results", {
                "success": True,
                "query": query,
                "results": result_list
            })
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("rag-search-results", {
                "success": False,
                "error": str(e),
                "results": []
            })
    
    async def handle_rag_get_stats(self, payload: Dict[str, Any]):
        """ç²å– RAG çµ±è¨ˆ"""
        import sys
        print(f"[Backend] ğŸ§  RAG Get Stats", file=sys.stderr)
        
        try:
            from telegram_rag_system import telegram_rag
            
            stats = await telegram_rag.get_statistics()
            
            self.send_event("rag-stats-updated", {
                "success": True,
                "stats": stats
            })
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("rag-stats-updated", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_rag_add_knowledge(self, payload: Dict[str, Any]):
        """æ·»åŠ çŸ¥è­˜åˆ° RAG"""
        import sys
        print(f"[Backend] ğŸ§  RAG Add Knowledge: {payload}", file=sys.stderr)
        
        try:
            from telegram_rag_system import telegram_rag, KnowledgeType
            
            knowledge_type = payload.get('knowledgeType', 'qa')
            question = payload.get('question', '')
            answer = payload.get('answer', '')
            context = payload.get('context', '')
            
            try:
                kt = KnowledgeType(knowledge_type)
            except:
                kt = KnowledgeType.QA
            
            knowledge_id = await telegram_rag.add_manual_knowledge(
                knowledge_type=kt,
                question=question,
                answer=answer,
                context=context
            )
            
            self.send_event("rag-knowledge-added", {
                "success": knowledge_id is not None,
                "knowledgeId": knowledge_id,
                "knowledgeType": knowledge_type
            })
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("rag-knowledge-added", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_rag_record_feedback(self, payload: Dict[str, Any]):
        """è¨˜éŒ„ RAG åé¥‹"""
        import sys
        print(f"[Backend] ğŸ§  RAG Record Feedback: {payload}", file=sys.stderr)
        
        try:
            from telegram_rag_system import telegram_rag
            
            knowledge_id = payload.get('knowledgeId')
            is_positive = payload.get('isPositive', True)
            
            await telegram_rag.record_feedback(
                knowledge_id=knowledge_id,
                is_positive=is_positive
            )
            
            self.send_event("rag-feedback-recorded", {
                "success": True,
                "knowledgeId": knowledge_id
            })
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("rag-feedback-recorded", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_rag_build_from_conversation(self, payload: Dict[str, Any]):
        """ğŸŒŸ å°è©±å¼æ§‹å»ºçŸ¥è­˜åº«ï¼ˆæ”¯æŒç›´æ¥æ–‡æª”è§£æï¼‰"""
        import sys
        import re
        print(f"[Backend] ğŸ§  RAG Build From Conversation: {payload}", file=sys.stderr)
        
        try:
            from telegram_rag_system import telegram_rag, KnowledgeType
            
            business_desc = payload.get('businessDescription', '')
            industry = payload.get('industry', '')
            target_audience = payload.get('targetAudience', '')
            key_products = payload.get('keyProducts', [])
            unique_advantages = payload.get('uniqueAdvantages', [])
            
            # ç™¼é€é€²åº¦æ›´æ–°
            def send_progress(step, total, action, items):
                self.send_event("rag-build-progress", {
                    "progress": {
                        "step": step,
                        "totalSteps": total,
                        "currentAction": action,
                        "itemsGenerated": items
                    }
                })
            
            total_items = 0
            
            # ğŸ†• P1-1: å…ˆç›´æ¥è§£ææ–‡æª”å…§å®¹ï¼Œæå–çµæ§‹åŒ–çŸ¥è­˜ï¼ˆä¸ä¾è³´ AIï¼‰
            send_progress(1, 6, "è§£ææ–‡æª”å…§å®¹...", 0)
            try:
                direct_items = self._parse_document_to_knowledge(business_desc)
                if direct_items:
                    print(f"[RAG] ğŸ“„ å¾æ–‡æª”ç›´æ¥è§£æå‡º {len(direct_items)} æ¢çŸ¥è­˜", file=sys.stderr)
                    
                    # ğŸ†• P0-3: åˆ†é¡æ˜ å°„
                    category_to_type = {
                        'product': KnowledgeType.PRODUCT,
                        'price': KnowledgeType.PRODUCT,
                        'process': KnowledgeType.SCRIPT,
                        'faq': KnowledgeType.FAQ,
                        'resource': KnowledgeType.PRODUCT
                    }
                    
                    for item in direct_items:
                        # ç²å–åˆ†é¡å°æ‡‰çš„çŸ¥è­˜é¡å‹
                        category = item.get('category', 'product')
                        knowledge_type = category_to_type.get(category, KnowledgeType.PRODUCT)
                        
                        await telegram_rag.add_manual_knowledge(
                            knowledge_type=knowledge_type,
                            question=item.get('question', ''),
                            answer=item.get('answer', ''),
                            context=item.get('context', business_desc[:200])
                        )
                        total_items += 1
                    print(f"[RAG] âœ“ æˆåŠŸå°å…¥ {total_items} æ¢æ–‡æª”çŸ¥è­˜", file=sys.stderr)
            except Exception as parse_err:
                print(f"[RAG] æ–‡æª”è§£æå¤±æ•—: {parse_err}", file=sys.stderr)
            
            send_progress(1, 6, "è§£ææ–‡æª”å…§å®¹...", total_items)
            
            # Step 2: åˆ†ææ¥­å‹™ï¼ˆAI è£œå……ï¼‰
            send_progress(2, 6, "åˆ†ææ¥­å‹™é¡å‹...", total_items)
            await asyncio.sleep(0.5)
            
            # Step 3: ç”Ÿæˆç”¢å“çŸ¥è­˜ï¼ˆAI è£œå……ï¼‰
            send_progress(3, 6, "ç”Ÿæˆç”¢å“çŸ¥è­˜...", total_items)
            
            # ä½¿ç”¨ AI ç”ŸæˆçŸ¥è­˜
            if ai_auto_chat and hasattr(ai_auto_chat, '_generate_response_with_prompt'):
                product_prompt = f"""æ ¹æ“šä»¥ä¸‹æ¥­å‹™æè¿°ï¼Œç”Ÿæˆ 5 æ¢ç”¢å“çŸ¥è­˜ï¼ˆJSON æ ¼å¼ï¼‰:

æ¥­å‹™æè¿°: {business_desc}
è¡Œæ¥­: {industry}
ç›®æ¨™å®¢æˆ¶: {target_audience}
ä¸»è¦ç”¢å“: {', '.join(key_products) if key_products else 'æœªæŒ‡å®š'}
ç«¶çˆ­å„ªå‹¢: {', '.join(unique_advantages) if unique_advantages else 'æœªæŒ‡å®š'}

è«‹è¿”å› JSON æ ¼å¼:
{{"items": [
  {{"type": "product", "question": "ç”¢å“å•é¡Œ", "answer": "è©³ç´°å›ç­”"}},
  ...
]}}"""
                
                product_response = await ai_auto_chat._generate_response_with_prompt(
                    user_id="system",
                    user_message=product_prompt,
                    custom_prompt="ä½ æ˜¯å°ˆæ¥­çš„æ¥­å‹™çŸ¥è­˜ç”ŸæˆåŠ©æ‰‹ï¼Œæ“…é•·å‰µå»ºéŠ·å”®å’Œå®¢æœçŸ¥è­˜åº«ã€‚è«‹ç”¨ç¹é«”ä¸­æ–‡å›ç­”ã€‚",
                    usage_type="knowledge"
                )
                
                # è§£æä¸¦ä¿å­˜
                product_items = self._parse_rag_knowledge_response(product_response)
                for item in product_items:
                    await telegram_rag.add_manual_knowledge(
                        knowledge_type=KnowledgeType.PRODUCT,
                        question=item.get('question', ''),
                        answer=item.get('answer', '')
                    )
                    total_items += 1
            
            send_progress(3, 6, "ç”Ÿæˆç”¢å“çŸ¥è­˜...", total_items)
            
            # Step 4: ç”Ÿæˆå¸¸è¦‹å•ç­”
            send_progress(4, 6, "ç”Ÿæˆå¸¸è¦‹å•ç­”...", total_items)
            
            if ai_auto_chat and hasattr(ai_auto_chat, '_generate_response_with_prompt'):
                faq_prompt = f"""æ ¹æ“šä»¥ä¸‹æ¥­å‹™æè¿°ï¼Œç”Ÿæˆ 5 æ¢å¸¸è¦‹å•ç­”ï¼ˆJSON æ ¼å¼ï¼‰:

æ¥­å‹™æè¿°: {business_desc}

è«‹è¿”å› JSON æ ¼å¼:
{{"items": [
  {{"type": "faq", "question": "å®¢æˆ¶å¸¸è¦‹å•é¡Œ", "answer": "å°ˆæ¥­å›ç­”"}},
  ...
]}}"""
                
                faq_response = await ai_auto_chat._generate_response_with_prompt(
                    user_id="system",
                    user_message=faq_prompt,
                    custom_prompt="ä½ æ˜¯å°ˆæ¥­çš„æ¥­å‹™çŸ¥è­˜ç”ŸæˆåŠ©æ‰‹ã€‚è«‹ç”¨ç¹é«”ä¸­æ–‡å›ç­”ã€‚",
                    usage_type="knowledge"
                )
                
                faq_items = self._parse_rag_knowledge_response(faq_response)
                for item in faq_items:
                    await telegram_rag.add_manual_knowledge(
                        knowledge_type=KnowledgeType.FAQ,
                        question=item.get('question', ''),
                        answer=item.get('answer', '')
                    )
                    total_items += 1
            
            send_progress(4, 6, "ç”Ÿæˆå¸¸è¦‹å•ç­”...", total_items)
            
            # Step 5: ç”ŸæˆéŠ·å”®è©±è¡“
            send_progress(5, 6, "ç”ŸæˆéŠ·å”®è©±è¡“...", total_items)
            
            if ai_auto_chat and hasattr(ai_auto_chat, '_generate_response_with_prompt'):
                script_prompt = f"""æ ¹æ“šä»¥ä¸‹æ¥­å‹™æè¿°ï¼Œç”Ÿæˆ 5 æ¢éŠ·å”®è©±è¡“ï¼ˆJSON æ ¼å¼ï¼‰:

æ¥­å‹™æè¿°: {business_desc}
ç«¶çˆ­å„ªå‹¢: {', '.join(unique_advantages) if unique_advantages else 'æœªæŒ‡å®š'}

è«‹è¿”å› JSON æ ¼å¼:
{{"items": [
  {{"type": "script", "question": "å ´æ™¯/è§¸ç™¼", "answer": "è©±è¡“å…§å®¹"}},
  ...
]}}"""
                
                script_response = await ai_auto_chat._generate_response_with_prompt(
                    user_id="system",
                    user_message=script_prompt,
                    custom_prompt="ä½ æ˜¯å°ˆæ¥­çš„éŠ·å”®è©±è¡“å°ˆå®¶ã€‚è«‹ç”¨ç¹é«”ä¸­æ–‡å›ç­”ã€‚",
                    usage_type="knowledge"
                )
                
                script_items = self._parse_rag_knowledge_response(script_response)
                for item in script_items:
                    await telegram_rag.add_manual_knowledge(
                        knowledge_type=KnowledgeType.SCRIPT,
                        question=item.get('question', ''),
                        answer=item.get('answer', '')
                    )
                    total_items += 1
            
            send_progress(5, 6, "ç”ŸæˆéŠ·å”®è©±è¡“...", total_items)
            
            # Step 6: ç”Ÿæˆç•°è­°è™•ç†
            send_progress(6, 6, "ç”Ÿæˆç•°è­°è™•ç†...", total_items)
            
            if ai_auto_chat and hasattr(ai_auto_chat, '_generate_response_with_prompt'):
                objection_prompt = f"""æ ¹æ“šä»¥ä¸‹æ¥­å‹™æè¿°ï¼Œç”Ÿæˆ 5 æ¢ç•°è­°è™•ç†è©±è¡“ï¼ˆJSON æ ¼å¼ï¼‰:

æ¥­å‹™æè¿°: {business_desc}

è«‹è¿”å› JSON æ ¼å¼:
{{"items": [
  {{"type": "objection", "question": "å®¢æˆ¶ç•°è­°", "answer": "è™•ç†è©±è¡“"}},
  ...
]}}"""
                
                objection_response = await ai_auto_chat._generate_response_with_prompt(
                    user_id="system",
                    user_message=objection_prompt,
                    custom_prompt="ä½ æ˜¯å°ˆæ¥­çš„ç•°è­°è™•ç†å°ˆå®¶ã€‚è«‹ç”¨ç¹é«”ä¸­æ–‡å›ç­”ã€‚",
                    usage_type="knowledge"
                )
                
                objection_items = self._parse_rag_knowledge_response(objection_response)
                for item in objection_items:
                    await telegram_rag.add_manual_knowledge(
                        knowledge_type=KnowledgeType.OBJECTION,
                        question=item.get('question', ''),
                        answer=item.get('answer', '')
                    )
                    total_items += 1
            
            send_progress(6, 6, "å®Œæˆï¼", total_items)
            
            self.send_event("rag-build-complete", {
                "success": True,
                "totalItems": total_items,
                "businessDescription": business_desc
            })
            self.send_log(f"ğŸ§  çŸ¥è­˜å¤§è…¦æ§‹å»ºå®Œæˆï¼Œå…± {total_items} æ¢çŸ¥è­˜", "success")
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("rag-build-complete", {
                "success": False,
                "error": str(e)
            })
    
    def _parse_rag_knowledge_response(self, response: str) -> list:
        """è§£æ AI ç”Ÿæˆçš„çŸ¥è­˜ JSON"""
        import json
        import re
        
        # ğŸ”§ P0 ä¿®å¾©ï¼šç©ºå€¼æª¢æŸ¥ï¼Œé¿å… NoneType éŒ¯èª¤
        if not response:
            print("[RAG] âš ï¸ AI å›æ‡‰ç‚ºç©ºï¼Œè·³éè§£æ", file=sys.stderr)
            return []
        
        try:
            # å˜—è©¦æå– JSON
            json_match = re.search(r'\{[\s\S]*\}', response)
            if json_match:
                data = json.loads(json_match.group())
                items = data.get('items', [])
                if items:
                    print(f"[RAG] âœ“ JSON è§£ææˆåŠŸï¼Œç²å– {len(items)} æ¢çŸ¥è­˜", file=sys.stderr)
                    return items
        except Exception as json_err:
            print(f"[RAG] JSON è§£æå¤±æ•—: {json_err}", file=sys.stderr)
        
        # é™ç´šï¼šæŒ‰è¡Œè§£æ
        items = []
        try:
            lines = response.strip().split('\n')
            current_q = None
            
            for line in lines:
                line = line.strip()
                if line.startswith('Q:') or line.startswith('å•:'):
                    current_q = line[2:].strip()
                elif line.startswith('A:') or line.startswith('ç­”:'):
                    if current_q:
                        items.append({
                            'question': current_q,
                            'answer': line[2:].strip()
                        })
                        current_q = None
            
            if items:
                print(f"[RAG] âœ“ è¡Œè§£ææˆåŠŸï¼Œç²å– {len(items)} æ¢çŸ¥è­˜", file=sys.stderr)
        except Exception as line_err:
            print(f"[RAG] è¡Œè§£æå¤±æ•—: {line_err}", file=sys.stderr)
        
        # ğŸ”§ P0 ä¿®å¾©ï¼šæœ€çµ‚å®¹éŒ¯ - å°‡æ•´å€‹å›æ‡‰ä½œç‚ºä¸€æ¢çŸ¥è­˜
        if not items and response.strip():
            print(f"[RAG] ä½¿ç”¨å®¹éŒ¯æ¨¡å¼ï¼Œå°‡å›æ‡‰ä½œç‚ºå–®æ¢çŸ¥è­˜", file=sys.stderr)
            # å˜—è©¦æå–ç¬¬ä¸€è¡Œä½œç‚ºå•é¡Œï¼Œå…¶é¤˜ä½œç‚ºç­”æ¡ˆ
            lines = response.strip().split('\n')
            if len(lines) >= 2:
                items.append({
                    'question': lines[0][:100],  # å–å‰100å­—ä½œç‚ºå•é¡Œ
                    'answer': '\n'.join(lines[1:])[:500]  # å–å¾ŒçºŒå…§å®¹ä½œç‚ºç­”æ¡ˆ
                })
            else:
                items.append({
                    'question': 'æ¥­å‹™çŸ¥è­˜',
                    'answer': response.strip()[:500]
                })
        
        return items
    
    def _parse_document_to_knowledge(self, document: str) -> list:
        """
        ğŸ†• P1-1: ç›´æ¥è§£ææ–‡æª”å…§å®¹ç‚ºçµæ§‹åŒ–çŸ¥è­˜ï¼ˆğŸ†• P0-3: æ™ºèƒ½åˆ†é¡ï¼‰
        
        æ”¯æŒè§£ææ ¼å¼ï¼š
        - ã€æ¨™é¡Œã€‘ï¼šå…§å®¹
        - æ¨™é¡Œï¼šå…§å®¹
        - æ•¸å­—. å…§å®¹
        - å•ç­”æ ¼å¼
        
        è‡ªå‹•åˆ†é¡ï¼š
        - product: ç”¢å“ç›¸é—œ
        - price: åƒ¹æ ¼/è²»ç‡ç›¸é—œ
        - process: æµç¨‹/æ“ä½œç›¸é—œ
        - faq: å¸¸è¦‹å•ç­”
        - resource: è³‡æºé€£çµ
        """
        import re
        
        if not document or len(document.strip()) < 10:
            return []
        
        items = []
        lines = document.strip().split('\n')
        
        # ğŸ†• P0-3: åˆ†é¡é—œéµè©æ˜ å°„
        category_keywords = {
            'price': ['åƒ¹æ ¼', 'è²»ç‡', 'è²»ç”¨', 'é‡‘é¡', 'æˆæœ¬', 'æ”¶è²»', 'çµç®—', 'æ‰‹çºŒè²»', 'ä½£é‡‘', 'è¿”é»', 'D0', 'D1', 'T+'],
            'product': ['ç”¢å“', 'é€šé“', 'åŠŸèƒ½', 'æœå‹™', 'æ”¯ä»˜', 'æ”¶æ¬¾', 'ä»£ä»˜', 'H5', 'å¾®ä¿¡', 'æ”¯ä»˜å¯¶', 'USDT'],
            'process': ['æµç¨‹', 'æ­¥é©Ÿ', 'å¦‚ä½•', 'æ€éº¼', 'å°æ¥', 'æ¥å…¥', 'ä½¿ç”¨', 'æ“ä½œ', 'é–‹æˆ¶', 'ç”³è«‹'],
            'faq': ['å•', 'ç­”', 'Q:', 'A:', 'æ˜¯å¦', 'å¯ä»¥', 'æ”¯æŒ', 'èƒ½ä¸èƒ½'],
            'resource': ['ç¾¤çµ„', 'é »é“', 'å®˜ç¶²', 'ç¶²å€', 'http', 't.me', 'è¦–é »', 'æ•™ç¨‹', 'é€£çµ', 'éˆæ¥']
        }
        
        def classify_content(title: str, content: str) -> str:
            """æ ¹æ“šå…§å®¹è‡ªå‹•åˆ†é¡"""
            combined = (title + ' ' + content).lower()
            
            # æŒ‰å„ªå…ˆç´šåŒ¹é…
            for category, keywords in category_keywords.items():
                for kw in keywords:
                    if kw.lower() in combined:
                        return category
            
            return 'product'  # é»˜èªç‚ºç”¢å“çŸ¥è­˜
        
        # æ¨¡å¼1: è§£æã€ã€‘æ ¼å¼çš„çµæ§‹åŒ–å…§å®¹
        bracket_pattern = re.compile(r'ã€(.+?)ã€‘[ï¼š:]\s*(.+)')
        
        # æ¨¡å¼2: è§£æã€Œæ¨™é¡Œï¼šå…§å®¹ã€æ ¼å¼
        colon_pattern = re.compile(r'^([^ï¼š:]{2,15})[ï¼š:]\s*(.+)$')
        
        # æ¨¡å¼3: è§£æã€Œæ•¸å­—. å…§å®¹ã€æ ¼å¼
        number_pattern = re.compile(r'^\d+[\.ã€]\s*(.+)$')
        
        current_section = None
        section_content = []
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            # å˜—è©¦åŒ¹é…ã€ã€‘æ ¼å¼
            bracket_match = bracket_pattern.match(line)
            if bracket_match:
                # ä¿å­˜ä¹‹å‰çš„ section
                if current_section and section_content:
                    answer = '\n'.join(section_content)
                    items.append({
                        'question': f"{current_section}æ˜¯ä»€éº¼ï¼Ÿ",
                        'answer': answer,
                        'context': document[:200],
                        'category': classify_content(current_section, answer)  # ğŸ†• è‡ªå‹•åˆ†é¡
                    })
                
                title = bracket_match.group(1).strip()
                content = bracket_match.group(2).strip()
                
                # ç›´æ¥ä½œç‚ºçŸ¥è­˜é»
                if len(content) > 5:
                    items.append({
                        'question': f"{title}æ˜¯å¤šå°‘ï¼Ÿ" if any(c.isdigit() for c in content) else f"{title}æ˜¯ä»€éº¼ï¼Ÿ",
                        'answer': content,
                        'context': document[:200],
                        'category': classify_content(title, content)  # ğŸ†• è‡ªå‹•åˆ†é¡
                    })
                
                current_section = title
                section_content = [content] if content else []
                continue
            
            # å˜—è©¦åŒ¹é…ã€Œæ¨™é¡Œï¼šå…§å®¹ã€æ ¼å¼
            colon_match = colon_pattern.match(line)
            if colon_match:
                title = colon_match.group(1).strip()
                content = colon_match.group(2).strip()
                
                # éæ¿¾å¸¸è¦‹çš„éçŸ¥è­˜æ¨™é¡Œ
                skip_titles = ['ç¾¤çµ„', 'é »é“', 'å®˜ç¶²', 'è¦–é »', 'ç¶²å€', 'http']
                if not any(skip in title for skip in skip_titles) and len(content) > 3:
                    # åˆ¤æ–·å•é¡Œé¡å‹
                    if any(c.isdigit() for c in content):
                        question = f"{title}æ˜¯å¤šå°‘ï¼Ÿ"
                    elif '~' in content or '-' in content or 'åˆ°' in content:
                        question = f"{title}ç¯„åœæ˜¯å¤šå°‘ï¼Ÿ"
                    else:
                        question = f"{title}æ˜¯ä»€éº¼ï¼Ÿ"
                    
                    items.append({
                        'question': question,
                        'answer': content,
                        'context': document[:200],
                        'category': classify_content(title, content)  # ğŸ†• è‡ªå‹•åˆ†é¡
                    })
                continue
            
            # æ”¶é›†ç•¶å‰ section çš„å…§å®¹
            if current_section:
                section_content.append(line)
        
        # è™•ç†æœ€å¾Œä¸€å€‹ section
        if current_section and section_content:
            answer = '\n'.join(section_content)
            items.append({
                'question': f"{current_section}æ˜¯ä»€éº¼ï¼Ÿ",
                'answer': answer,
                'context': document[:200],
                'category': classify_content(current_section, answer)  # ğŸ†• è‡ªå‹•åˆ†é¡
            })
        
        # ğŸ”§ é¡å¤–ï¼šæå– URL ä½œç‚ºè³‡æºçŸ¥è­˜
        url_pattern = re.compile(r'(https?://[^\s]+)')
        urls = url_pattern.findall(document)
        if urls:
            items.append({
                'question': 'æœ‰å“ªäº›ç›¸é—œé€£çµå’Œè³‡æºï¼Ÿ',
                'answer': '\n'.join(urls),
                'context': 'ç›¸é—œè³‡æºé€£çµ',
                'category': 'resource'  # ğŸ†• è³‡æºåˆ†é¡
            })
        
        # ğŸ†• P0-3: æ‰“å°åˆ†é¡çµ±è¨ˆ
        category_stats = {}
        for item in items:
            cat = item.get('category', 'unknown')
            category_stats[cat] = category_stats.get(cat, 0) + 1
        
        print(f"[RAG] ğŸ“„ æ–‡æª”è§£æå®Œæˆ: {len(items)} æ¢çŸ¥è­˜", file=sys.stderr)
        print(f"[RAG] ğŸ“Š åˆ†é¡çµ±è¨ˆ: {category_stats}", file=sys.stderr)
        return items
    
    # ==================== ğŸ†• P1-2: å°å…¥é è¦½ç¢ºèªæµç¨‹ ====================
    
    # è‡¨æ™‚å­˜å„²é è¦½çš„çŸ¥è­˜ï¼ˆç”¨æ–¼ç¢ºèªå°å…¥ï¼‰
    _pending_import_items: Dict[str, list] = {}
    
    async def handle_rag_preview_import(self, payload: Dict[str, Any]):
        """
        ğŸ†• P1-2: é è¦½å°å…¥ - è§£ææ–‡æª”ä½†ä¸å…¥åº«ï¼Œè¿”å›é è¦½çµæœ
        
        è¿”å›çµæ§‹åŒ–çš„çŸ¥è­˜åˆ—è¡¨ï¼Œè®“ç”¨æˆ¶å¯ä»¥ç·¨è¼¯/åˆªé™¤/ç¢ºèª
        """
        import sys
        import uuid
        
        print(f"[Backend] ğŸ§  RAG Preview Import", file=sys.stderr)
        
        try:
            document = payload.get('document', '')
            
            if not document or len(document.strip()) < 10:
                self.send_event("rag-preview-result", {
                    "success": False,
                    "error": "æ–‡æª”å…§å®¹éçŸ­",
                    "items": []
                })
                return
            
            # è§£ææ–‡æª”
            items = self._parse_document_to_knowledge(document)
            
            if not items:
                self.send_event("rag-preview-result", {
                    "success": False,
                    "error": "æœªèƒ½å¾æ–‡æª”ä¸­è§£æå‡ºæœ‰æ•ˆçŸ¥è­˜",
                    "items": []
                })
                return
            
            # ç”Ÿæˆé è¦½ IDï¼ˆç”¨æ–¼å¾ŒçºŒç¢ºèªï¼‰
            preview_id = str(uuid.uuid4())[:8]
            
            # ç‚ºæ¯å€‹é …ç›®æ·»åŠ è‡¨æ™‚ ID
            for i, item in enumerate(items):
                item['temp_id'] = f"{preview_id}_{i}"
                item['selected'] = True  # é»˜èªé¸ä¸­
            
            # å­˜å„²åˆ°è‡¨æ™‚ç·©å­˜
            self._pending_import_items[preview_id] = items
            
            # åˆ†é¡çµ±è¨ˆ
            category_stats = {}
            for item in items:
                cat = item.get('category', 'unknown')
                category_stats[cat] = category_stats.get(cat, 0) + 1
            
            self.send_event("rag-preview-result", {
                "success": True,
                "previewId": preview_id,
                "items": items,
                "totalCount": len(items),
                "categoryStats": category_stats
            })
            
            print(f"[RAG] âœ“ é è¦½ç”ŸæˆæˆåŠŸ: {len(items)} æ¢, ID={preview_id}", file=sys.stderr)
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("rag-preview-result", {
                "success": False,
                "error": str(e),
                "items": []
            })
    
    async def handle_rag_confirm_import(self, payload: Dict[str, Any]):
        """
        ğŸ†• P1-2: ç¢ºèªå°å…¥ - å°‡é¸ä¸­çš„çŸ¥è­˜é …å…¥åº«
        
        ç”¨æˆ¶å¯ä»¥ç·¨è¼¯/åˆªé™¤/èª¿æ•´åˆ†é¡å¾Œç¢ºèªå°å…¥
        """
        import sys
        
        print(f"[Backend] ğŸ§  RAG Confirm Import", file=sys.stderr)
        
        try:
            from telegram_rag_system import telegram_rag, KnowledgeType
            
            preview_id = payload.get('previewId', '')
            selected_items = payload.get('items', [])
            
            if not selected_items:
                # å˜—è©¦å¾ç·©å­˜ç²å–
                cached_items = self._pending_import_items.get(preview_id, [])
                selected_items = [item for item in cached_items if item.get('selected', True)]
            
            if not selected_items:
                self.send_event("rag-import-result", {
                    "success": False,
                    "error": "æ²’æœ‰é¸ä¸­çš„çŸ¥è­˜é …",
                    "importedCount": 0
                })
                return
            
            # åˆ†é¡æ˜ å°„
            category_to_type = {
                'product': KnowledgeType.PRODUCT,
                'price': KnowledgeType.PRODUCT,
                'process': KnowledgeType.SCRIPT,
                'faq': KnowledgeType.FAQ,
                'resource': KnowledgeType.PRODUCT
            }
            
            imported_count = 0
            failed_count = 0
            
            for item in selected_items:
                try:
                    category = item.get('category', 'product')
                    knowledge_type = category_to_type.get(category, KnowledgeType.PRODUCT)
                    
                    result = await telegram_rag.add_manual_knowledge(
                        knowledge_type=knowledge_type,
                        question=item.get('question', ''),
                        answer=item.get('answer', ''),
                        context=item.get('context', '')
                    )
                    
                    if result:
                        imported_count += 1
                    else:
                        failed_count += 1
                        
                except Exception as item_err:
                    print(f"[RAG] å°å…¥é …ç›®å¤±æ•—: {item_err}", file=sys.stderr)
                    failed_count += 1
            
            # æ¸…ç†ç·©å­˜
            if preview_id in self._pending_import_items:
                del self._pending_import_items[preview_id]
            
            self.send_event("rag-import-result", {
                "success": True,
                "importedCount": imported_count,
                "failedCount": failed_count
            })
            
            self.send_log(f"ğŸ§  çŸ¥è­˜å°å…¥å®Œæˆ: æˆåŠŸ {imported_count} æ¢, å¤±æ•— {failed_count} æ¢", "success")
            
            print(f"[RAG] âœ“ ç¢ºèªå°å…¥å®Œæˆ: æˆåŠŸ {imported_count}, å¤±æ•— {failed_count}", file=sys.stderr)
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("rag-import-result", {
                "success": False,
                "error": str(e),
                "importedCount": 0
            })
    
    async def handle_rag_import_url(self, payload: Dict[str, Any]):
        """ğŸŒ å¾ URL å°å…¥çŸ¥è­˜"""
        import sys
        print(f"[Backend] ğŸ§  RAG Import URL: {payload}", file=sys.stderr)
        
        try:
            from telegram_rag_system import telegram_rag, KnowledgeType
            import aiohttp
            import re
            
            url = payload.get('url', '')
            
            if not url:
                self.send_event("rag-url-imported", {
                    "success": False,
                    "error": "URL ä¸èƒ½ç‚ºç©º"
                })
                return
            
            # ğŸ”§ Phase 5: æª¢æŸ¥ AI API Key æ˜¯å¦é…ç½®
            if not ai_auto_chat:
                self.send_event("rag-url-imported", {
                    "success": False,
                    "error": "AI æœå‹™æœªåˆå§‹åŒ–ï¼Œè«‹å…ˆé…ç½® AI æ¨¡å‹",
                    "needsApiKey": True
                })
                return
            
            api_key = getattr(ai_auto_chat, 'api_key', '')
            if not api_key:
                self.send_event("rag-url-imported", {
                    "success": False,
                    "error": "å°šæœªé…ç½® AI API Keyã€‚è«‹å‰å¾€ã€ŒAI ä¸­å¿ƒã€->ã€Œæ¨¡å‹è¨­å®šã€é…ç½® Gemini æˆ– OpenAI API Key",
                    "needsApiKey": True
                })
                return
            
            print(f"[Backend] âœ“ AI API Key å·²é…ç½®ï¼Œé–‹å§‹æŠ“å–ç¶²é : {url}", file=sys.stderr)
            
            # æŠ“å–ç¶²é å…§å®¹
            async with aiohttp.ClientSession() as session:
                async with session.get(url, timeout=30) as response:
                    if response.status != 200:
                        raise Exception(f"HTTP {response.status}")
                    
                    html = await response.text()
            
            print(f"[Backend] âœ“ ç¶²é æŠ“å–æˆåŠŸï¼Œå…§å®¹é•·åº¦: {len(html)}", file=sys.stderr)
            
            # ç°¡å–®çš„ HTML è§£æï¼ˆæå–æ–‡æœ¬ï¼‰
            # ç§»é™¤ script å’Œ style
            html = re.sub(r'<script[^>]*>[\s\S]*?</script>', '', html, flags=re.IGNORECASE)
            html = re.sub(r'<style[^>]*>[\s\S]*?</style>', '', html, flags=re.IGNORECASE)
            # ç§»é™¤ HTML æ¨™ç±¤
            text = re.sub(r'<[^>]+>', '\n', html)
            # æ¸…ç†ç©ºç™½
            text = re.sub(r'\s+', ' ', text).strip()
            
            # æå–æ¨™é¡Œ
            title_match = re.search(r'<title[^>]*>([^<]+)</title>', html, re.IGNORECASE)
            title = title_match.group(1).strip() if title_match else url
            
            print(f"[Backend] âœ“ ç¶²é è§£æå®Œæˆï¼Œæ¨™é¡Œ: {title}, æ–‡å­—é•·åº¦: {len(text)}", file=sys.stderr)
            
            # ä½¿ç”¨ AI æå–çŸ¥è­˜
            items_count = 0
            
            if ai_auto_chat and hasattr(ai_auto_chat, '_generate_response_with_prompt'):
                extract_prompt = f"""å¾ä»¥ä¸‹ç¶²é å…§å®¹ä¸­æå–å¯ç”¨æ–¼å®¢æœå’ŒéŠ·å”®çš„çŸ¥è­˜ï¼Œç”Ÿæˆ JSON æ ¼å¼:

ç¶²é æ¨™é¡Œ: {title}
ç¶²é å…§å®¹ï¼ˆå‰2000å­—ï¼‰: {text[:2000]}

è«‹æå–é—œéµçš„ç”¢å“ä¿¡æ¯ã€å¸¸è¦‹å•é¡Œã€æœå‹™èªªæ˜ç­‰ï¼Œè¿”å› JSON æ ¼å¼:
{{"items": [
  {{"type": "product/faq/script", "question": "å•é¡Œæˆ–ä¸»é¡Œ", "answer": "å…§å®¹"}},
  ...
]}}"""
                
                extract_response = await ai_auto_chat._generate_response_with_prompt(
                    user_id="system",
                    user_message=extract_prompt,
                    custom_prompt="ä½ æ˜¯å°ˆæ¥­çš„çŸ¥è­˜æå–åŠ©æ‰‹ï¼Œæ“…é•·å¾ç¶²é å…§å®¹ä¸­æå–çµæ§‹åŒ–çŸ¥è­˜ã€‚è«‹ç”¨ç¹é«”ä¸­æ–‡å›ç­”ã€‚",
                    usage_type="knowledge"
                )
                
                items = self._parse_rag_knowledge_response(extract_response)
                
                type_map = {
                    'product': KnowledgeType.PRODUCT,
                    'faq': KnowledgeType.FAQ,
                    'script': KnowledgeType.SCRIPT,
                    'qa': KnowledgeType.QA
                }
                
                for item in items:
                    kt = type_map.get(item.get('type', 'qa'), KnowledgeType.QA)
                    await telegram_rag.add_manual_knowledge(
                        knowledge_type=kt,
                        question=item.get('question', ''),
                        answer=item.get('answer', ''),
                        context=f"ä¾†æº: {url}"
                    )
                    items_count += 1
            
            self.send_event("rag-url-imported", {
                "success": True,
                "url": url,
                "title": title,
                "itemsCount": items_count
            })
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("rag-url-imported", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_rag_import_document(self, payload: Dict[str, Any]):
        """ğŸ“„ å¾æ–‡æª”å°å…¥çŸ¥è­˜"""
        import sys
        import os
        print(f"[Backend] ğŸ§  RAG Import Document: {payload}", file=sys.stderr)
        
        try:
            from telegram_rag_system import telegram_rag, KnowledgeType
            
            file_path = payload.get('filePath', '')
            file_type = payload.get('fileType', '').lower()
            
            if not os.path.exists(file_path):
                self.send_event("rag-document-imported", {
                    "success": False,
                    "error": "æ–‡ä»¶ä¸å­˜åœ¨"
                })
                return
            
            text = ""
            
            # è®€å–æ–‡æª”å…§å®¹
            if file_type in ['txt', 'text']:
                with open(file_path, 'r', encoding='utf-8') as f:
                    text = f.read()
            elif file_type in ['pdf']:
                # å˜—è©¦ä½¿ç”¨ PyPDF2
                try:
                    import PyPDF2
                    with open(file_path, 'rb') as f:
                        reader = PyPDF2.PdfReader(f)
                        text = '\n'.join(page.extract_text() for page in reader.pages)
                except ImportError:
                    self.send_event("rag-document-imported", {
                        "success": False,
                        "error": "éœ€è¦å®‰è£ PyPDF2 æ‰èƒ½è®€å– PDF"
                    })
                    return
            elif file_type in ['docx', 'doc']:
                # å˜—è©¦ä½¿ç”¨ python-docx
                try:
                    from docx import Document
                    doc = Document(file_path)
                    text = '\n'.join(para.text for para in doc.paragraphs)
                except ImportError:
                    self.send_event("rag-document-imported", {
                        "success": False,
                        "error": "éœ€è¦å®‰è£ python-docx æ‰èƒ½è®€å– Word æ–‡æª”"
                    })
                    return
            else:
                # å˜—è©¦ä½œç‚ºç´”æ–‡æœ¬è®€å–
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    text = f.read()
            
            if not text.strip():
                self.send_event("rag-document-imported", {
                    "success": False,
                    "error": "æ–‡æª”å…§å®¹ç‚ºç©º"
                })
                return
            
            # ä½¿ç”¨ AI æå–çŸ¥è­˜
            items_count = 0
            
            if ai_auto_chat and hasattr(ai_auto_chat, '_generate_response_with_prompt'):
                extract_prompt = f"""å¾ä»¥ä¸‹æ–‡æª”å…§å®¹ä¸­æå–å¯ç”¨æ–¼å®¢æœå’ŒéŠ·å”®çš„çŸ¥è­˜ï¼Œç”Ÿæˆ JSON æ ¼å¼:

æ–‡æª”å…§å®¹ï¼ˆå‰3000å­—ï¼‰: {text[:3000]}

è«‹æå–é—œéµä¿¡æ¯ï¼Œè¿”å› JSON æ ¼å¼:
{{"items": [
  {{"type": "product/faq/script", "question": "å•é¡Œæˆ–ä¸»é¡Œ", "answer": "å…§å®¹"}},
  ...
]}}"""
                
                extract_response = await ai_auto_chat._generate_response_with_prompt(
                    user_id="system",
                    user_message=extract_prompt,
                    custom_prompt="ä½ æ˜¯å°ˆæ¥­çš„çŸ¥è­˜æå–åŠ©æ‰‹ã€‚è«‹ç”¨ç¹é«”ä¸­æ–‡å›ç­”ã€‚",
                    usage_type="knowledge"
                )
                
                items = self._parse_rag_knowledge_response(extract_response)
                
                type_map = {
                    'product': KnowledgeType.PRODUCT,
                    'faq': KnowledgeType.FAQ,
                    'script': KnowledgeType.SCRIPT,
                    'qa': KnowledgeType.QA
                }
                
                for item in items:
                    kt = type_map.get(item.get('type', 'qa'), KnowledgeType.QA)
                    await telegram_rag.add_manual_knowledge(
                        knowledge_type=kt,
                        question=item.get('question', ''),
                        answer=item.get('answer', ''),
                        context=f"ä¾†æº: {os.path.basename(file_path)}"
                    )
                    items_count += 1
            
            self.send_event("rag-document-imported", {
                "success": True,
                "fileName": os.path.basename(file_path),
                "itemsCount": items_count
            })
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("rag-document-imported", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_rag_cleanup(self, payload: Dict[str, Any]):
        """æ¸…ç†ä½è³ªé‡çŸ¥è­˜"""
        import sys
        print(f"[Backend] ğŸ§  RAG Cleanup", file=sys.stderr)
        
        try:
            from telegram_rag_system import telegram_rag
            
            min_score = payload.get('minScore', 0.2)
            min_uses = payload.get('minUses', 0)
            days_old = payload.get('daysOld', 30)
            
            deleted = await telegram_rag.cleanup_low_quality_knowledge(
                min_score=min_score,
                min_uses=min_uses,
                days_old=days_old
            )
            
            self.send_event("rag-cleanup-complete", {
                "success": True,
                "deletedCount": deleted
            })
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("rag-cleanup-complete", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_rag_merge_similar(self, payload: Dict[str, Any]):
        """åˆä½µç›¸ä¼¼çŸ¥è­˜"""
        import sys
        print(f"[Backend] ğŸ§  RAG Merge Similar", file=sys.stderr)
        
        try:
            from telegram_rag_system import telegram_rag
            
            threshold = payload.get('similarityThreshold', 0.9)
            
            merged = await telegram_rag.merge_similar_knowledge(
                similarity_threshold=threshold
            )
            
            self.send_event("rag-merge-complete", {
                "success": True,
                "mergedCount": merged
            })
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("rag-merge-complete", {
                "success": False,
                "error": str(e)
            })
    
    # ==================== ğŸ†• çŸ¥è­˜ç¼ºå£å’Œå¥åº·åº¦ ====================
    
    async def handle_rag_get_gaps(self, payload: Dict[str, Any]):
        """ç²å–çŸ¥è­˜ç¼ºå£åˆ—è¡¨ï¼ˆğŸ†• P0: éæ¿¾ + è‡ªå‹•ç”Ÿæˆ AI å»ºè­°ç­”æ¡ˆï¼‰"""
        import sys
        print(f"[Backend] ğŸ§  RAG Get Gaps", file=sys.stderr)
        
        try:
            from telegram_rag_system import telegram_rag
            
            status = payload.get('status', 'pending')
            limit = payload.get('limit', 20)
            min_hits = payload.get('minHits', 1)  # ğŸ†• P0-2: é™ä½é–€æª»
            auto_suggest = payload.get('autoSuggest', True)  # ğŸ†• é»˜èªè‡ªå‹•ç”Ÿæˆå»ºè­°
            
            gaps = await telegram_rag.get_knowledge_gaps(
                status=status,
                limit=limit,
                min_hits=min_hits
            )
            
            # ğŸ†• P0-3: éæ¿¾ç³»çµ± promptï¼ˆéçœŸå¯¦ç”¨æˆ¶å•é¡Œï¼‰
            system_keywords = [
                'æ ¹æ“šä»¥ä¸‹', 'ç”Ÿæˆ 5 æ¢', 'æ¥­å‹™æè¿°:', 'JSON æ ¼å¼',
                'æ ¹æ“šä»¥ä¸‹æ¥­å‹™æè¿°', 'ç”Ÿæˆ5æ¢', 'ï¼ˆJSON', 'æ¡äº§å“çŸ¥è¯†',
                'æ¢ç”¢å“çŸ¥è­˜', 'æ¡é”€å”®è¯æœ¯', 'æ¢éŠ·å”®è©±è¡“'
            ]
            
            filtered_gaps = []
            for gap in gaps:
                query = gap.get('query', '')
                # è·³éç³»çµ± prompt
                is_system_prompt = any(kw in query for kw in system_keywords)
                if is_system_prompt:
                    print(f"[RAG] éæ¿¾ç³»çµ± prompt: {query[:50]}...", file=sys.stderr)
                    continue
                # è·³ééé•·çš„å…§å®¹ï¼ˆè¶…é 500 å­—çš„å¯èƒ½æ˜¯æ–‡æª”è€Œéå•é¡Œï¼‰
                if len(query) > 500:
                    print(f"[RAG] éæ¿¾éé•·å…§å®¹: {len(query)} å­—", file=sys.stderr)
                    continue
                filtered_gaps.append(gap)
            
            gaps = filtered_gaps
            print(f"[RAG] éæ¿¾å¾Œå‰©é¤˜ {len(gaps)} æ¢ç¼ºå£", file=sys.stderr)
            
            # ğŸ†• P0: ç‚ºæ¯å€‹ç¼ºå£è‡ªå‹•ç”Ÿæˆ AI å»ºè­°ç­”æ¡ˆ
            if auto_suggest and gaps and ai_auto_chat:
                print(f"[RAG] ğŸ¤– ç‚º {len(gaps)} å€‹çŸ¥è­˜ç¼ºå£ç”Ÿæˆ AI å»ºè­°...", file=sys.stderr)
                
                for gap in gaps:
                    # è·³éå·²æœ‰å»ºè­°çš„
                    if gap.get('suggested_answer'):
                        continue
                    
                    query = gap.get('query', '')
                    if not query:
                        continue
                    
                    try:
                        # ä½¿ç”¨ AI ç”Ÿæˆå»ºè­°ç­”æ¡ˆ
                        prompt = f"""æ ¹æ“šä»¥ä¸‹å®¢æˆ¶å•é¡Œï¼Œç”Ÿæˆä¸€å€‹å°ˆæ¥­ã€å‹å¥½çš„å›ç­”ï¼š

å•é¡Œï¼š{query}

è¦æ±‚ï¼š
1. å›ç­”è¦ç°¡æ½”å¯¦ç”¨ï¼ˆ50-150å­—ï¼‰
2. èªæ°£å‹å¥½å°ˆæ¥­
3. å¦‚æœæ˜¯è©¢å•åƒ¹æ ¼/è²»ç‡ï¼Œå¯ä»¥èªªã€Œç§èŠè©³è«‡ã€æˆ–ã€Œçœ‹é‡å„ªæƒ ã€
4. å¦‚æœä¸ç¢ºå®šï¼Œçµ¦å‡ºé€šç”¨ä½†æœ‰åƒ¹å€¼çš„å›ç­”"""

                        suggested = await ai_auto_chat._generate_response_with_prompt(
                            user_id="system",
                            user_message=prompt,
                            custom_prompt="ä½ æ˜¯å°ˆæ¥­çš„å®¢æœè©±è¡“å°ˆå®¶ã€‚è«‹ç”¨ç¹é«”ä¸­æ–‡å›ç­”ã€‚",
                            usage_type="knowledge"
                        )
                        
                        if suggested:
                            gap['suggested_answer'] = suggested
                            gap['ai_generated'] = True
                            print(f"[RAG] âœ“ å·²ç‚ºã€Œ{query[:20]}...ã€ç”Ÿæˆå»ºè­°", file=sys.stderr)
                        else:
                            # æä¾›å‚™ç”¨ç­”æ¡ˆ
                            gap['suggested_answer'] = f"æ„Ÿè¬æ‚¨çš„è©¢å•ï¼é—œæ–¼ã€Œ{query[:30]}ã€ï¼Œè«‹ç§èŠæˆ‘è©³ç´°äº†è§£ï¼Œæˆ‘å€‘æœƒç‚ºæ‚¨æä¾›å°ˆæ¥­çš„è§£ç­”å’Œæ–¹æ¡ˆã€‚"
                            gap['ai_generated'] = False
                            
                    except Exception as gen_err:
                        print(f"[RAG] âš ï¸ ç”Ÿæˆå»ºè­°å¤±æ•—: {gen_err}", file=sys.stderr)
                        gap['suggested_answer'] = f"æ„Ÿè¬æ‚¨çš„è©¢å•ï¼é—œæ–¼ã€Œ{query[:30]}ã€ï¼Œæˆ‘å€‘ç¨å¾Œç‚ºæ‚¨è§£ç­”ã€‚"
                        gap['ai_generated'] = False
            
            self.send_event("rag-gaps-list", {
                "success": True,
                "gaps": gaps,
                "count": len(gaps)
            })
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("rag-gaps-list", {
                "success": False,
                "error": str(e),
                "gaps": []
            })
    
    async def handle_rag_resolve_gap(self, payload: Dict[str, Any]):
        """è§£æ±ºçŸ¥è­˜ç¼ºå£"""
        import sys
        print(f"[Backend] ğŸ§  RAG Resolve Gap: {payload}", file=sys.stderr)
        
        try:
            from telegram_rag_system import telegram_rag
            
            gap_id = payload.get('gapId')
            knowledge_type = payload.get('knowledgeType', 'faq')
            question = payload.get('question', '')
            answer = payload.get('answer', '')
            
            knowledge_id = await telegram_rag.resolve_gap(
                gap_id=gap_id,
                knowledge_type=knowledge_type,
                question=question,
                answer=answer
            )
            
            self.send_event("rag-gap-resolved", {
                "success": knowledge_id is not None,
                "gapId": gap_id,
                "knowledgeId": knowledge_id
            })
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("rag-gap-resolved", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_rag_ignore_gap(self, payload: Dict[str, Any]):
        """å¿½ç•¥çŸ¥è­˜ç¼ºå£"""
        import sys
        print(f"[Backend] ğŸ§  RAG Ignore Gap", file=sys.stderr)
        
        try:
            from telegram_rag_system import telegram_rag
            
            gap_id = payload.get('gapId')
            success = await telegram_rag.ignore_gap(gap_id)
            
            self.send_event("rag-gap-ignored", {
                "success": success,
                "gapId": gap_id
            })
            
        except Exception as e:
            self.send_event("rag-gap-ignored", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_rag_delete_gap(self, payload: Dict[str, Any]):
        """ğŸ†• P0: åˆªé™¤å–®æ¢çŸ¥è­˜ç¼ºå£ï¼ˆç„¡éœ€ç¢ºèªï¼‰"""
        import sys
        print(f"[Backend] ğŸ§  RAG Delete Gap: {payload}", file=sys.stderr)
        
        try:
            gap_id = payload.get('gapId')
            
            if not gap_id:
                self.send_event("rag-gap-deleted", {
                    "success": False,
                    "error": "ç¼ºå°‘ gapId"
                })
                return
            
            # ç›´æ¥å¾æ•¸æ“šåº«åˆªé™¤
            await db._connection.execute(
                "DELETE FROM rag_knowledge_gaps WHERE id = ?",
                (gap_id,)
            )
            await db._connection.commit()
            
            self.send_event("rag-gap-deleted", {
                "success": True,
                "gapId": gap_id
            })
            
            print(f"[RAG] âœ“ å·²åˆªé™¤ç¼ºå£ ID={gap_id}", file=sys.stderr)
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("rag-gap-deleted", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_rag_delete_gaps_batch(self, payload: Dict[str, Any]):
        """ğŸ†• P0: æ‰¹é‡åˆªé™¤çŸ¥è­˜ç¼ºå£"""
        import sys
        print(f"[Backend] ğŸ§  RAG Delete Gaps Batch", file=sys.stderr)
        
        try:
            gap_ids = payload.get('gapIds', [])
            
            if not gap_ids:
                self.send_event("rag-gaps-deleted", {
                    "success": False,
                    "error": "æ²’æœ‰è¦åˆªé™¤çš„ç¼ºå£",
                    "deletedCount": 0
                })
                return
            
            # æ‰¹é‡åˆªé™¤
            placeholders = ','.join(['?' for _ in gap_ids])
            await db._connection.execute(
                f"DELETE FROM rag_knowledge_gaps WHERE id IN ({placeholders})",
                gap_ids
            )
            await db._connection.commit()
            
            self.send_event("rag-gaps-deleted", {
                "success": True,
                "deletedCount": len(gap_ids)
            })
            
            print(f"[RAG] âœ“ æ‰¹é‡åˆªé™¤ {len(gap_ids)} æ¢ç¼ºå£", file=sys.stderr)
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("rag-gaps-deleted", {
                "success": False,
                "error": str(e),
                "deletedCount": 0
            })
    
    async def handle_rag_cleanup_duplicate_gaps(self, payload: Dict[str, Any]):
        """ğŸ†• P0: æ·±åº¦æ¸…ç†çŸ¥è­˜ç¼ºå£ï¼ˆé‡è¤‡ + ç³»çµ± prompt + åƒåœ¾æ•¸æ“šï¼‰"""
        import sys
        print(f"[Backend] ğŸ§  RAG Cleanup Duplicate Gaps", file=sys.stderr)
        
        try:
            total_deleted = 0
            stats = {'duplicates': 0, 'system_prompts': 0, 'too_long': 0, 'too_short': 0}
            
            # 1. æ¸…ç†é‡è¤‡æ•¸æ“š
            cursor = await db._connection.execute("""
                SELECT query_hash, COUNT(*) as cnt 
                FROM rag_knowledge_gaps 
                GROUP BY query_hash 
                HAVING cnt > 1
            """)
            duplicates = await cursor.fetchall()
            
            for row in duplicates:
                query_hash = row['query_hash']
                
                # ä¿ç•™ hit_count æœ€é«˜çš„é‚£æ¢ï¼Œåˆªé™¤å…¶ä»–
                await db._connection.execute("""
                    DELETE FROM rag_knowledge_gaps 
                    WHERE query_hash = ? 
                    AND id NOT IN (
                        SELECT id FROM rag_knowledge_gaps 
                        WHERE query_hash = ? 
                        ORDER BY hit_count DESC 
                        LIMIT 1
                    )
                """, (query_hash, query_hash))
                
                deleted = row['cnt'] - 1
                total_deleted += deleted
                stats['duplicates'] += deleted
            
            await db._connection.commit()
            
            # 2. ğŸ†• P0: åˆªé™¤ç³»çµ± promptï¼ˆæ›´å…¨é¢çš„åŒ¹é…ï¼‰
            system_patterns = [
                # ğŸ†• æœ€å¸¸è¦‹çš„ç³»çµ± prompt æ¨¡å¼ï¼ˆç²¾ç¢ºåŒ¹é…ï¼‰
                'æ ¹æ“šä»¥ä¸‹å®¢æˆ¶å•é¡Œï¼Œç”Ÿæˆä¸€å€‹å°ˆæ¥­%',
                'æ ¹æ®ä»¥ä¸‹å®¢æˆ·é—®é¢˜ï¼Œç”Ÿæˆä¸€ä¸ªä¸“ä¸š%',
                'æ ¹æ“šä»¥ä¸‹å®¢æˆ¶å•é¡Œ%ç”Ÿæˆ%',
                'æ ¹æ®ä»¥ä¸‹å®¢æˆ·é—®é¢˜%ç”Ÿæˆ%',
                # AI ç”Ÿæˆ prompt
                'æ ¹æ“šä»¥ä¸‹æ¥­å‹™æè¿°%',
                'æ ¹æ®ä»¥ä¸‹ä¸šåŠ¡æè¿°%',
                'æ ¹æ“šä»¥ä¸‹%ç”Ÿæˆ%',
                'æ ¹æ®ä»¥ä¸‹%ç”Ÿæˆ%',
                '%ç”Ÿæˆ 5 æ¢%',
                '%ç”Ÿæˆ5æ¢%',
                '%ç”Ÿæˆ 5 æ¡%',
                '%ç”Ÿæˆ5æ¡%',
                'æ¥­å‹™æè¿°:%',
                'æ¥­å‹™æè¿°ï¼š%',
                'ä¸šåŠ¡æè¿°:%',
                'ä¸šåŠ¡æè¿°ï¼š%',
                'JSON æ ¼å¼%',
                'ï¼ˆJSON æ ¼å¼ï¼‰%',
                '(JSON æ ¼å¼)%',
                '%æ¢ç”¢å“çŸ¥è­˜%',
                '%æ¡äº§å“çŸ¥è¯†%',
                '%æ¢éŠ·å”®è©±è¡“%',
                '%æ¡é”€å”®è¯æœ¯%',
                '%æ¢å¸¸è¦‹å•ç­”%',
                '%æ¡å¸¸è§é—®ç­”%',
                # AI å›è¦†æ ¼å¼
                '%è¦æ±‚ï¼š%å›ç­”è¦ç°¡æ½”%',
                '%è¦æ±‚:%å›ç­”è¦ç®€æ´%',
                '%èªæ°£å‹å¥½å°ˆæ¥­%',
                '%è¯­æ°”å‹å¥½ä¸“ä¸š%',
                '%ç§èŠè©³è«‡%',
                # ç³»çµ±æŒ‡ä»¤
                'ä½ æ˜¯å°ˆæ¥­çš„%',
                'ä½ æ˜¯ä¸“ä¸šçš„%',
                '%è«‹ç”¨ç¹é«”ä¸­æ–‡%',
                '%è¯·ç”¨ç®€ä½“ä¸­æ–‡%',
                '%è«‹ç”¨ç¹é«”%',
                '%è¯·ç”¨ç®€ä½“%',
                # ğŸ†• æ›´å¤š AI æŒ‡ä»¤é—œéµè©
                '%ç‚ºä»¥ä¸‹å®¢æˆ¶å•é¡Œç”Ÿæˆ%',
                '%ä¸ºä»¥ä¸‹å®¢æˆ·é—®é¢˜ç”Ÿæˆ%',
                'ç‚ºä»¥ä¸‹%ç”Ÿæˆ%',
                'ä¸ºä»¥ä¸‹%ç”Ÿæˆ%',
                '%å°ˆæ¥­ã€å‹å¥½çš„å›ç­”%',
                '%ä¸“ä¸šã€å‹å¥½çš„å›ç­”%',
                '%é©åˆå®¢æœä½¿ç”¨%',
                '%é€‚åˆå®¢æœä½¿ç”¨%',
            ]
            
            for pattern in system_patterns:
                cursor = await db._connection.execute(
                    "DELETE FROM rag_knowledge_gaps WHERE query LIKE ?",
                    (pattern,)
                )
                deleted = cursor.rowcount
                total_deleted += deleted
                stats['system_prompts'] += deleted
            
            await db._connection.commit()
            
            # 3. ğŸ†• P0: åˆªé™¤éé•·å…§å®¹ï¼ˆè¶…é 300 å­—ï¼‰
            cursor = await db._connection.execute(
                "DELETE FROM rag_knowledge_gaps WHERE LENGTH(query) > 300"
            )
            deleted = cursor.rowcount
            total_deleted += deleted
            stats['too_long'] = deleted
            
            # 4. ğŸ†• P0: åˆªé™¤éçŸ­å…§å®¹ï¼ˆå°‘æ–¼ 3 å­—ï¼‰
            cursor = await db._connection.execute(
                "DELETE FROM rag_knowledge_gaps WHERE LENGTH(query) < 3"
            )
            deleted = cursor.rowcount
            total_deleted += deleted
            stats['too_short'] = deleted
            
            await db._connection.commit()
            
            # 5. ç™¼é€çµæœ
            self.send_event("rag-duplicates-cleaned", {
                "success": True,
                "deletedCount": total_deleted,
                "stats": stats
            })
            
            print(f"[RAG] ğŸ§¹ æ¸…ç†å®Œæˆ: é‡è¤‡={stats['duplicates']}, ç³»çµ±prompt={stats['system_prompts']}, éé•·={stats['too_long']}, éçŸ­={stats['too_short']}", file=sys.stderr)
            self.send_log(f"ğŸ§¹ æ¸…ç†å®Œæˆ: åˆªé™¤ {total_deleted} æ¢ç„¡æ•ˆç¼ºå£", "success")
            print(f"[RAG] âœ“ æ¸…ç†é‡è¤‡ç¼ºå£å®Œæˆ: åˆªé™¤ {total_deleted} æ¢", file=sys.stderr)
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("rag-duplicates-cleaned", {
                "success": False,
                "error": str(e),
                "deletedCount": 0
            })
    
    async def handle_rag_suggest_gap_answer(self, payload: Dict[str, Any]):
        """ç‚ºçŸ¥è­˜ç¼ºå£ç”Ÿæˆ AI å»ºè­°ç­”æ¡ˆ"""
        import sys
        print(f"[Backend] ğŸ§  RAG Suggest Gap Answer: {payload}", file=sys.stderr)
        
        try:
            gap_id = payload.get('gapId')
            query = payload.get('query', '')
            
            # ä½¿ç”¨ AI ç”Ÿæˆå»ºè­°
            suggested_answer = ""
            if ai_auto_chat and hasattr(ai_auto_chat, '_generate_response_with_prompt'):
                prompt = f"""ç‚ºä»¥ä¸‹å®¢æˆ¶å•é¡Œç”Ÿæˆä¸€å€‹å°ˆæ¥­ã€å‹å¥½çš„å›ç­”ï¼š

å•é¡Œï¼š{query}

è«‹æä¾›ä¸€å€‹ç°¡æ½”ä½†å®Œæ•´çš„å›ç­”ï¼Œé©åˆå®¢æœä½¿ç”¨ã€‚"""
                
                suggested_answer = await ai_auto_chat._generate_response_with_prompt(
                    user_id="system",
                    user_message=prompt,
                    custom_prompt="ä½ æ˜¯å°ˆæ¥­çš„å®¢æœè©±è¡“å°ˆå®¶ï¼Œè«‹ç”¨ç¹é«”ä¸­æ–‡å›ç­”ã€‚",
                    usage_type="knowledge"
                )
            else:
                suggested_answer = f"æ„Ÿè¬æ‚¨çš„è©¢å•ã€‚é—œæ–¼ã€Œ{query[:30]}...ã€ï¼Œæˆ‘å€‘çš„å›ç­”æ˜¯..."
            
            self.send_event("rag-gap-suggestion", {
                "success": True,
                "gapId": gap_id,
                "suggestedAnswer": suggested_answer
            })
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("rag-gap-suggestion", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_rag_get_health_report(self, payload: Dict[str, Any]):
        """ç²å–çŸ¥è­˜åº«å¥åº·åº¦å ±å‘Š"""
        import sys
        print(f"[Backend] ğŸ§  RAG Get Health Report", file=sys.stderr)
        
        try:
            from telegram_rag_system import telegram_rag
            
            report = await telegram_rag.get_health_report()
            
            self.send_event("rag-health-report", {
                "success": True,
                "report": report
            })
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("rag-health-report", {
                "success": False,
                "error": str(e)
            })
    
    # ==================== ğŸ†• çŸ¥è­˜ç®¡ç† API ====================
    
    async def handle_rag_get_all_knowledge(self, payload: Dict[str, Any]):
        """ğŸ†• ç²å–æ‰€æœ‰çŸ¥è­˜åˆ—è¡¨"""
        import sys
        print(f"[Backend] ğŸ§  RAG Get All Knowledge", file=sys.stderr)
        
        try:
            cursor = await db._connection.execute("""
                SELECT id, knowledge_type, question, answer, context, 
                       success_score, use_count, feedback_positive, feedback_negative,
                       is_active, created_at, updated_at
                FROM rag_knowledge
                WHERE is_active = 1
                ORDER BY created_at DESC
                LIMIT 500
            """)
            rows = await cursor.fetchall()
            
            knowledge = []
            for row in rows:
                knowledge.append({
                    'id': row['id'],
                    'type': row['knowledge_type'],
                    'question': row['question'],
                    'answer': row['answer'],
                    'context': row['context'],
                    'successScore': row['success_score'],
                    'useCount': row['use_count'],
                    'feedbackPositive': row['feedback_positive'],
                    'feedbackNegative': row['feedback_negative'],
                    'isActive': row['is_active'],
                    'createdAt': row['created_at'],
                    'updatedAt': row['updated_at']
                })
            
            self.send_event("rag-all-knowledge", {
                "success": True,
                "knowledge": knowledge,
                "count": len(knowledge)
            })
            
            print(f"[RAG] âœ“ ç²å–çŸ¥è­˜åˆ—è¡¨: {len(knowledge)} æ¢", file=sys.stderr)
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("rag-all-knowledge", {
                "success": False,
                "error": str(e),
                "knowledge": []
            })
    
    async def handle_rag_add_knowledge(self, payload: Dict[str, Any]):
        """ğŸ†• æ‰‹å‹•æ·»åŠ çŸ¥è­˜"""
        import sys
        print(f"[Backend] ğŸ§  RAG Add Knowledge: {payload}", file=sys.stderr)
        
        try:
            from telegram_rag_system import telegram_rag, KnowledgeType
            
            knowledge_type = payload.get('type', 'qa')
            question = payload.get('question', '')
            answer = payload.get('answer', '')
            
            if not question or not answer:
                raise ValueError("å•é¡Œå’Œç­”æ¡ˆä¸èƒ½ç‚ºç©º")
            
            # ä½¿ç”¨ RAG ç³»çµ±æ·»åŠ çŸ¥è­˜
            knowledge_id = await telegram_rag.add_manual_knowledge(
                knowledge_type=KnowledgeType(knowledge_type),
                question=question,
                answer=answer
            )
            
            self.send_event("rag-knowledge-added", {
                "success": True,
                "id": knowledge_id
            })
            
            self.send_log(f"âœ… æ·»åŠ çŸ¥è­˜æˆåŠŸ", "success")
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("rag-knowledge-added", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_rag_update_knowledge(self, payload: Dict[str, Any]):
        """ğŸ†• æ›´æ–°çŸ¥è­˜"""
        import sys
        print(f"[Backend] ğŸ§  RAG Update Knowledge: {payload}", file=sys.stderr)
        
        try:
            knowledge_id = payload.get('id')
            answer = payload.get('answer')
            
            if not knowledge_id or not answer:
                raise ValueError("ID å’Œç­”æ¡ˆä¸èƒ½ç‚ºç©º")
            
            await db._connection.execute("""
                UPDATE rag_knowledge
                SET answer = ?, updated_at = CURRENT_TIMESTAMP
                WHERE id = ?
            """, (answer, knowledge_id))
            await db._connection.commit()
            
            self.send_event("rag-knowledge-updated", {
                "success": True,
                "id": knowledge_id
            })
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("rag-knowledge-updated", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_rag_delete_knowledge(self, payload: Dict[str, Any]):
        """ğŸ†• åˆªé™¤å–®æ¢çŸ¥è­˜"""
        import sys
        print(f"[Backend] ğŸ§  RAG Delete Knowledge: {payload}", file=sys.stderr)
        
        try:
            knowledge_id = payload.get('id')
            
            if not knowledge_id:
                raise ValueError("ID ä¸èƒ½ç‚ºç©º")
            
            # è»Ÿåˆªé™¤
            await db._connection.execute("""
                UPDATE rag_knowledge SET is_active = 0 WHERE id = ?
            """, (knowledge_id,))
            await db._connection.commit()
            
            self.send_event("rag-knowledge-deleted", {
                "success": True,
                "id": knowledge_id
            })
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("rag-knowledge-deleted", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_rag_delete_knowledge_batch(self, payload: Dict[str, Any]):
        """ğŸ†• æ‰¹é‡åˆªé™¤çŸ¥è­˜"""
        import sys
        print(f"[Backend] ğŸ§  RAG Delete Knowledge Batch: {payload}", file=sys.stderr)
        
        try:
            ids = payload.get('ids', [])
            
            if not ids:
                raise ValueError("IDs ä¸èƒ½ç‚ºç©º")
            
            # è»Ÿåˆªé™¤
            placeholders = ','.join(['?' for _ in ids])
            await db._connection.execute(
                f"UPDATE rag_knowledge SET is_active = 0 WHERE id IN ({placeholders})",
                ids
            )
            await db._connection.commit()
            
            self.send_event("rag-knowledge-batch-deleted", {
                "success": True,
                "deletedCount": len(ids)
            })
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("rag-knowledge-batch-deleted", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_rag_start_guided_build(self, payload: Dict[str, Any]):
        """ğŸ†• é–‹å§‹å¼•å°å¼å¤šè¼ªæ§‹å»º"""
        import sys
        print(f"[Backend] ğŸ§  RAG Start Guided Build: {payload}", file=sys.stderr)
        
        try:
            step = payload.get('step', 1)
            answers = payload.get('answers', {})
            industry = payload.get('industry', '')
            
            # æ ¹æ“šæ­¥é©Ÿè¿”å›ä¸åŒå•é¡Œ
            questions_by_step = {
                1: {
                    'step': 1,
                    'totalSteps': 5,
                    'title': 'æ¥­å‹™é¡å‹',
                    'question': 'æ‚¨çš„ä¸»è¦æ¥­å‹™æ˜¯ï¼Ÿ',
                    'type': 'select',
                    'options': [
                        {'id': 'payment', 'label': 'ğŸ’³ è·¨å¢ƒæ”¯ä»˜/å…Œæ›'},
                        {'id': 'ecommerce', 'label': 'ğŸ›’ é›»å•†é›¶å”®'},
                        {'id': 'education', 'label': 'ğŸ“– åœ¨ç·šæ•™è‚²'},
                        {'id': 'finance', 'label': 'ğŸ’° é‡‘èç†è²¡'},
                        {'id': 'service', 'label': 'ğŸ”§ æœå‹™è«®è©¢'},
                        {'id': 'other', 'label': 'ğŸ”¹ å…¶ä»–'}
                    ]
                },
                2: {
                    'step': 2,
                    'totalSteps': 5,
                    'title': 'æ ¸å¿ƒå„ªå‹¢',
                    'question': 'æ‚¨çš„ä¸»è¦ç«¶çˆ­å„ªå‹¢æ˜¯ï¼Ÿ(å¯å¤šé¸)',
                    'type': 'multiselect',
                    'options': self._get_advantages_by_industry(answers.get('step1', 'other'))
                },
                3: {
                    'step': 3,
                    'totalSteps': 5,
                    'title': 'ç”¢å“/æœå‹™',
                    'question': 'è«‹æè¿°æ‚¨çš„ä¸»è¦ç”¢å“æˆ–æœå‹™ï¼š',
                    'type': 'textarea',
                    'placeholder': 'ä¾‹å¦‚ï¼šUSDT å…Œæ›äººæ°‘å¹£ï¼Œæ”¯æŒå¾®ä¿¡ã€æ”¯ä»˜å¯¶æ”¶æ¬¾...'
                },
                4: {
                    'step': 4,
                    'totalSteps': 5,
                    'title': 'å¸¸è¦‹å•é¡Œ',
                    'question': 'å®¢æˆ¶æœ€å¸¸å•çš„å•é¡Œæœ‰å“ªäº›ï¼Ÿ(æ¯è¡Œä¸€å€‹)',
                    'type': 'textarea',
                    'placeholder': 'å¤šä¹…åˆ°è³¬ï¼Ÿ\næ‰‹çºŒè²»å¤šå°‘ï¼Ÿ\nå®‰å…¨å—ï¼Ÿ',
                    'suggestions': self._get_faq_suggestions(answers.get('step1', 'other'))
                },
                5: {
                    'step': 5,
                    'totalSteps': 5,
                    'title': 'å°è©±é¢¨æ ¼',
                    'question': 'æ‚¨å¸Œæœ› AI çš„å°è©±é¢¨æ ¼æ˜¯ï¼Ÿ',
                    'type': 'select',
                    'options': [
                        {'id': 'professional', 'label': 'ğŸ‘” å°ˆæ¥­æ­£å¼'},
                        {'id': 'friendly', 'label': 'ğŸ˜Š è¦ªåˆ‡å‹å¥½'},
                        {'id': 'efficient', 'label': 'âš¡ ç°¡æ½”é«˜æ•ˆ'},
                        {'id': 'enthusiastic', 'label': 'ğŸ‰ ç†±æƒ…ç©æ¥µ'}
                    ]
                }
            }
            
            if step <= 5:
                # è¿”å›ç•¶å‰æ­¥é©Ÿçš„å•é¡Œ
                self.send_event("rag-guided-question", {
                    "success": True,
                    **questions_by_step.get(step, questions_by_step[1])
                })
            else:
                # æ‰€æœ‰å•é¡Œå›ç­”å®Œç•¢ï¼Œé–‹å§‹ç”Ÿæˆ
                await self._generate_knowledge_from_guided_answers(answers)
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("rag-guided-question", {
                "success": False,
                "error": str(e)
            })
    
    def _get_advantages_by_industry(self, industry: str) -> list:
        """æ ¹æ“šè¡Œæ¥­è¿”å›å„ªå‹¢é¸é …"""
        common = [
            {'id': 'fast', 'label': 'âš¡ é€Ÿåº¦å¿«'},
            {'id': 'cheap', 'label': 'ğŸ’° åƒ¹æ ¼ä½'},
            {'id': 'safe', 'label': 'ğŸ”’ å®‰å…¨å¯é '},
            {'id': '24h', 'label': 'ğŸ• 24å°æ™‚æœå‹™'}
        ]
        
        industry_specific = {
            'payment': [
                {'id': 'high_rate', 'label': 'ğŸ“ˆ åŒ¯ç‡é«˜'},
                {'id': 'multi_channel', 'label': 'ğŸ’³ å¤šç¨®æ”¶ä»˜æ–¹å¼'}
            ],
            'ecommerce': [
                {'id': 'quality', 'label': 'âœ¨ å“è³ªä¿è­‰'},
                {'id': 'return', 'label': 'ğŸ”„ ä¸ƒå¤©é€€æ›'}
            ],
            'education': [
                {'id': 'expert', 'label': 'ğŸ‘¨â€ğŸ« å°ˆå®¶æˆèª²'},
                {'id': 'lifetime', 'label': 'â™¾ï¸ æ°¸ä¹…æœ‰æ•ˆ'}
            ]
        }
        
        return common + industry_specific.get(industry, [])
    
    def _get_faq_suggestions(self, industry: str) -> list:
        """æ ¹æ“šè¡Œæ¥­è¿”å›å¸¸è¦‹å•é¡Œå»ºè­°"""
        suggestions = {
            'payment': ['å¤šä¹…åˆ°è³¬ï¼Ÿ', 'åŒ¯ç‡æ€éº¼ç®—ï¼Ÿ', 'æ‰‹çºŒè²»å¤šå°‘ï¼Ÿ', 'æœ€ä½é‡‘é¡æ˜¯å¤šå°‘ï¼Ÿ', 'å®‰å…¨å—ï¼Ÿ'],
            'ecommerce': ['æ€éº¼ä¸‹å–®ï¼Ÿ', 'å¤šä¹…ç™¼è²¨ï¼Ÿ', 'å¯ä»¥é€€æ›å—ï¼Ÿ', 'æœ‰ç™¼ç¥¨å—ï¼Ÿ'],
            'education': ['èª²ç¨‹å¤šä¹…ï¼Ÿ', 'å¯ä»¥è©¦è½å—ï¼Ÿ', 'æœ‰è­‰æ›¸å—ï¼Ÿ', 'å¯ä»¥é€€æ¬¾å—ï¼Ÿ'],
            'finance': ['æ”¶ç›Šç‡å¤šå°‘ï¼Ÿ', 'é¢¨éšªå¤§å—ï¼Ÿ', 'éš¨æ™‚å¯å–å—ï¼Ÿ'],
            'service': ['æ€éº¼æ”¶è²»ï¼Ÿ', 'æœå‹™ç¯„åœæ˜¯ï¼Ÿ', 'æœ‰ä¿éšœå—ï¼Ÿ']
        }
        return suggestions.get(industry, ['æ€éº¼è³¼è²·ï¼Ÿ', 'åƒ¹æ ¼æ˜¯å¤šå°‘ï¼Ÿ', 'æœ‰å”®å¾Œå—ï¼Ÿ'])
    
    async def _generate_knowledge_from_guided_answers(self, answers: dict):
        """æ ¹æ“šå¼•å°å¼å•ç­”çš„ç­”æ¡ˆç”ŸæˆçŸ¥è­˜"""
        import sys
        from telegram_rag_system import telegram_rag, KnowledgeType
        
        try:
            industry = answers.get('step1', 'other')
            advantages = answers.get('step2', [])
            products = answers.get('step3', '')
            faqs = answers.get('step4', '')
            style = answers.get('step5', 'friendly')
            
            total_items = 0
            
            # ç™¼é€é€²åº¦
            self.send_event("rag-build-progress", {
                "progress": {"step": 1, "totalSteps": 4, "currentAction": "åˆ†ææ¥­å‹™ä¿¡æ¯...", "itemsGenerated": 0}
            })
            
            # 1. ä½¿ç”¨ AI ç”Ÿæˆç”¢å“çŸ¥è­˜
            if products and ai_auto_chat:
                prompt = f"""æ ¹æ“šä»¥ä¸‹æ¥­å‹™æè¿°ï¼Œç”Ÿæˆ 5 æ¢ç”¢å“çŸ¥è­˜ï¼ˆJSON æ ¼å¼ï¼‰:

æ¥­å‹™é¡å‹: {industry}
ç”¢å“æè¿°: {products}
å„ªå‹¢: {', '.join(advantages) if isinstance(advantages, list) else advantages}

è«‹è¿”å› JSON: {{"items": [{{"type": "product", "question": "...", "answer": "..."}}]}}"""
                
                response = await ai_auto_chat._generate_response_with_prompt(
                    user_id="system",
                    user_message=prompt,
                    custom_prompt=f"ä½ æ˜¯å°ˆæ¥­çš„çŸ¥è­˜åº«ç”ŸæˆåŠ©æ‰‹ã€‚è«‹ç”¨ç¹é«”ä¸­æ–‡ï¼Œé¢¨æ ¼: {style}",
                    usage_type="knowledge"
                )
                
                items = self._parse_rag_knowledge_response(response)
                for item in items:
                    await telegram_rag.add_manual_knowledge(
                        knowledge_type=KnowledgeType.PRODUCT,
                        question=item.get('question', ''),
                        answer=item.get('answer', '')
                    )
                    total_items += 1
            
            self.send_event("rag-build-progress", {
                "progress": {"step": 2, "totalSteps": 4, "currentAction": "ç”Ÿæˆå¸¸è¦‹å•ç­”...", "itemsGenerated": total_items}
            })
            
            # 2. æ ¹æ“šç”¨æˆ¶æä¾›çš„ FAQ ç”Ÿæˆç­”æ¡ˆ
            if faqs:
                faq_list = [q.strip() for q in faqs.split('\n') if q.strip()]
                for faq in faq_list[:10]:
                    if ai_auto_chat:
                        answer = await ai_auto_chat._generate_response_with_prompt(
                            user_id="system",
                            user_message=f"æ¥­å‹™ï¼š{products[:200]}\n\nå•é¡Œï¼š{faq}\n\nè«‹çµ¦å‡ºå°ˆæ¥­å›ç­”ã€‚",
                            custom_prompt=f"ä½ æ˜¯å°ˆæ¥­å®¢æœï¼Œé¢¨æ ¼: {style}ã€‚è«‹ç”¨ç¹é«”ä¸­æ–‡ç°¡æ½”å›ç­”ã€‚",
                            usage_type="knowledge"
                        )
                    else:
                        answer = f"é—œæ–¼æ‚¨è©¢å•çš„ã€Œ{faq}ã€ï¼Œæˆ‘å€‘çš„å›ç­”æ˜¯..."
                    
                    await telegram_rag.add_manual_knowledge(
                        knowledge_type=KnowledgeType.FAQ,
                        question=faq,
                        answer=answer
                    )
                    total_items += 1
            
            self.send_event("rag-build-progress", {
                "progress": {"step": 3, "totalSteps": 4, "currentAction": "ç”ŸæˆéŠ·å”®è©±è¡“...", "itemsGenerated": total_items}
            })
            
            # 3. ç”ŸæˆéŠ·å”®è©±è¡“
            if ai_auto_chat:
                script_prompt = f"""æ ¹æ“šä»¥ä¸‹ä¿¡æ¯ï¼Œç”Ÿæˆ 5 æ¢éŠ·å”®è©±è¡“:

æ¥­å‹™: {products[:200]}
å„ªå‹¢: {', '.join(advantages) if isinstance(advantages, list) else advantages}

è«‹è¿”å› JSON: {{"items": [{{"type": "script", "question": "å ´æ™¯", "answer": "è©±è¡“"}}]}}"""
                
                script_response = await ai_auto_chat._generate_response_with_prompt(
                    user_id="system",
                    user_message=script_prompt,
                    custom_prompt=f"ä½ æ˜¯éŠ·å”®è©±è¡“å°ˆå®¶ã€‚é¢¨æ ¼: {style}",
                    usage_type="knowledge"
                )
                
                script_items = self._parse_rag_knowledge_response(script_response)
                for item in script_items:
                    await telegram_rag.add_manual_knowledge(
                        knowledge_type=KnowledgeType.SCRIPT,
                        question=item.get('question', ''),
                        answer=item.get('answer', '')
                    )
                    total_items += 1
            
            self.send_event("rag-build-progress", {
                "progress": {"step": 4, "totalSteps": 4, "currentAction": "å®Œæˆï¼", "itemsGenerated": total_items}
            })
            
            # å®Œæˆ
            self.send_event("rag-build-complete", {
                "success": True,
                "totalItems": total_items,
                "industry": industry
            })
            self.send_log(f"ğŸ§  å¼•å°å¼æ§‹å»ºå®Œæˆï¼Œå…± {total_items} æ¢çŸ¥è­˜", "success")
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("rag-build-complete", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_documents(self, payload: Dict[str, Any]):
        """Get all documents"""
        try:
            category = payload.get('category')
            documents = await document_manager.get_all_documents(category)
            
            self.send_event("documents-list", {
                "success": True,
                "documents": documents
            })
        except Exception as e:
            self.send_event("documents-list", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_delete_document(self, payload: Dict[str, Any]):
        """Delete a document"""
        try:
            doc_id = payload.get('id')
            await document_manager.delete_document(doc_id)
            
            self.send_event("document-deleted", {"success": True, "id": doc_id})
            self.send_log("æ–‡æª”å·²åˆªé™¤", "success")
        except Exception as e:
            self.send_event("document-deleted", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_add_media(self, payload: Dict[str, Any]):
        """Add image or video to media library"""
        try:
            media_type = payload.get('mediaType', 'image')
            file_path = payload.get('filePath')
            base64_data = payload.get('base64Data')
            name = payload.get('name')
            category = payload.get('category', 'general')
            tags = payload.get('tags', [])
            description = payload.get('description')
            
            if media_type == 'image':
                result = await media_manager.add_image(
                    file_path=file_path,
                    base64_data=base64_data,
                    name=name,
                    category=category,
                    tags=tags,
                    description=description
                )
            else:
                result = await media_manager.add_video(
                    file_path=file_path,
                    base64_data=base64_data,
                    name=name,
                    category=category,
                    tags=tags,
                    description=description
                )
            
            self.send_event("media-added", result)
            if result.get('success'):
                self.send_log(f"åª’é«”å·²æ·»åŠ : {result.get('name')}", "success")
        except Exception as e:
            self.send_event("media-added", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_media(self, payload: Dict[str, Any]):
        """Get media resources"""
        try:
            media_type = payload.get('mediaType')
            category = payload.get('category')
            
            media = await media_manager.get_all_media(media_type, category)
            
            self.send_event("media-list", {
                "success": True,
                "media": media
            })
        except Exception as e:
            self.send_event("media-list", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_delete_media(self, payload: Dict[str, Any]):
        """Delete a media resource"""
        try:
            media_id = payload.get('id')
            await media_manager.delete_media(media_id)
            
            self.send_event("media-deleted", {"success": True, "id": media_id})
            self.send_log("åª’é«”å·²åˆªé™¤", "success")
        except Exception as e:
            self.send_event("media-deleted", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_search_knowledge(self, payload: Dict[str, Any]):
        """Search knowledge base"""
        try:
            query = payload.get('query', '')
            include_docs = payload.get('includeDocs', True)
            include_images = payload.get('includeImages', True)
            include_videos = payload.get('includeVideos', True)
            limit = payload.get('limit', 10)
            
            results = await search_engine.search(
                query=query,
                include_docs=include_docs,
                include_images=include_images,
                include_videos=include_videos,
                limit=limit
            )
            
            self.send_event("knowledge-search-results", {
                "success": True,
                "query": query,
                "results": results
            })
        except Exception as e:
            self.send_event("knowledge-search-results", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_add_qa_pair(self, payload: Dict[str, Any]):
        """Add a QA pair"""
        try:
            question = payload.get('question')
            answer = payload.get('answer')
            category = payload.get('category', 'general')
            keywords = payload.get('keywords', [])
            media_ids = payload.get('mediaIds', [])
            
            if not question or not answer:
                self.send_event("qa-pair-added", {"success": False, "error": "Question and answer required"})
                return
            
            qa_id = await search_engine.add_qa_pair(
                question=question,
                answer=answer,
                category=category,
                keywords=keywords,
                media_ids=media_ids
            )
            
            self.send_event("qa-pair-added", {
                "success": True,
                "id": qa_id
            })
            self.send_log("å•ç­”å°å·²æ·»åŠ ", "success")
        except Exception as e:
            self.send_event("qa-pair-added", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_qa_pairs(self, payload: Dict[str, Any]):
        """Get all QA pairs"""
        try:
            category = payload.get('category')
            qa_pairs = await search_engine.get_all_qa_pairs(category)
            
            self.send_event("qa-pairs-list", {
                "success": True,
                "qaPairs": qa_pairs
            })
        except Exception as e:
            self.send_event("qa-pairs-list", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_import_qa(self, payload: Dict[str, Any]):
        """Import QA pairs from file"""
        try:
            file_path = payload.get('filePath')
            file_type = payload.get('fileType', 'csv')
            
            if file_type == 'csv':
                result = await search_engine.import_qa_from_csv(file_path)
            else:
                result = await search_engine.import_qa_from_json(file_path)
            
            self.send_event("qa-imported", result)
            if result.get('success'):
                self.send_log(f"å°å…¥äº† {result.get('imported', 0)} æ¢å•ç­”å°", "success")
        except Exception as e:
            self.send_event("qa-imported", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_rag_context(self, payload: Dict[str, Any]):
        """Get RAG context for AI prompt"""
        try:
            query = payload.get('query', '')
            max_chunks = payload.get('maxChunks', 3)
            max_tokens = payload.get('maxTokens', 2000)
            
            context = await search_engine.build_rag_context(
                query=query,
                max_chunks=max_chunks,
                max_tokens=max_tokens
            )
            
            # Also get relevant media
            media = await search_engine.find_relevant_media(query, limit=3)
            
            self.send_event("rag-context", {
                "success": True,
                "context": context,
                "relevantMedia": media
            })
        except Exception as e:
            self.send_event("rag-context", {
                "success": False,
                "error": str(e)
            })
    
    # ==================== Auto Funnel Handlers ====================
    
    async def handle_get_funnel_overview(self):
        """ç²å–æ¼æ–—ç¸½è¦½"""
        try:
            overview = await auto_funnel.get_funnel_overview()
            self.send_event("funnel-overview", {
                "success": True,
                **overview
            })
        except Exception as e:
            self.send_event("funnel-overview", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_analyze_user_message(self, payload: Dict[str, Any]):
        """åˆ†æç”¨æˆ¶æ¶ˆæ¯ä¸¦ç¢ºå®šæ¼æ–—éšæ®µ"""
        try:
            user_id = payload.get('userId', '')
            message = payload.get('message', '')
            is_from_user = payload.get('isFromUser', True)
            
            result = await auto_funnel.analyze_message(user_id, message, is_from_user)
            
            self.send_event("message-analyzed", {
                "success": True,
                **result
            })
        except Exception as e:
            self.send_event("message-analyzed", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_transition_funnel_stage(self, payload: Dict[str, Any]):
        """æ‰‹å‹•è½‰æ›æ¼æ–—éšæ®µ"""
        try:
            user_id = payload.get('userId', '')
            new_stage = payload.get('stage', '')
            reason = payload.get('reason', 'æ‰‹å‹•è¨­ç½®')
            
            result = await auto_funnel.transition_stage(user_id, new_stage, reason)
            
            self.send_event("stage-transitioned", result)
        except Exception as e:
            self.send_event("stage-transitioned", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_user_journey(self, payload: Dict[str, Any]):
        """ç²å–ç”¨æˆ¶æ¼æ–—æ—…ç¨‹"""
        try:
            user_id = payload.get('userId', '')
            journey = await auto_funnel.get_user_journey(user_id)
            
            self.send_event("user-journey", {
                "success": True,
                "userId": user_id,
                "journey": journey
            })
        except Exception as e:
            self.send_event("user-journey", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_batch_update_stages(self, payload: Dict[str, Any]):
        """æ‰¹é‡æ›´æ–°ç”¨æˆ¶éšæ®µ"""
        try:
            user_ids = payload.get('userIds', [])
            new_stage = payload.get('stage', '')
            reason = payload.get('reason', 'æ‰¹é‡æ›´æ–°')
            
            result = await auto_funnel.batch_update_stages(user_ids, new_stage, reason)
            
            self.send_event("batch-stages-updated", {
                "success": True,
                **result
            })
        except Exception as e:
            self.send_event("batch-stages-updated", {
                "success": False,
                "error": str(e)
            })
    
    # ==================== Vector Memory Handlers ====================
    
    async def handle_add_vector_memory(self, payload: Dict[str, Any]):
        """æ·»åŠ å‘é‡è¨˜æ†¶"""
        try:
            user_id = payload.get('userId', '')
            content = payload.get('content', '')
            memory_type = payload.get('type', 'conversation')
            importance = payload.get('importance', 0.5)
            
            memory_id = await vector_memory.add_memory(
                user_id=user_id,
                content=content,
                memory_type=memory_type,
                importance=importance
            )
            
            self.send_event("memory-added", {
                "success": True,
                "memoryId": memory_id
            })
        except Exception as e:
            self.send_event("memory-added", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_search_vector_memories(self, payload: Dict[str, Any]):
        """æœç´¢å‘é‡è¨˜æ†¶"""
        try:
            user_id = payload.get('userId', '')
            query = payload.get('query', '')
            limit = payload.get('limit', 5)
            memory_type = payload.get('type')
            
            memories = await vector_memory.search_memories(
                user_id=user_id,
                query=query,
                limit=limit,
                memory_type=memory_type
            )
            
            self.send_event("memories-searched", {
                "success": True,
                "memories": memories
            })
        except Exception as e:
            self.send_event("memories-searched", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_memory_context(self, payload: Dict[str, Any]):
        """ç²å–è¨˜æ†¶ä¸Šä¸‹æ–‡"""
        try:
            user_id = payload.get('userId', '')
            message = payload.get('message', '')
            max_tokens = payload.get('maxTokens', 1500)
            
            context = await vector_memory.build_context_from_memory(
                user_id=user_id,
                current_message=message,
                max_tokens=max_tokens
            )
            
            self.send_event("memory-context", {
                "success": True,
                "context": context
            })
        except Exception as e:
            self.send_event("memory-context", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_summarize_conversation(self, payload: Dict[str, Any]):
        """ç”Ÿæˆå°è©±æ‘˜è¦"""
        try:
            user_id = payload.get('userId', '')
            max_messages = payload.get('maxMessages', 50)
            
            result = await vector_memory.summarize_conversation(
                user_id=user_id,
                max_messages=max_messages
            )
            
            self.send_event("conversation-summarized", result)
        except Exception as e:
            self.send_event("conversation-summarized", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_memory_stats(self, payload: Dict[str, Any]):
        """ç²å–è¨˜æ†¶çµ±è¨ˆ"""
        try:
            user_id = payload.get('userId', '')
            stats = await vector_memory.get_user_memory_stats(user_id)
            
            self.send_event("memory-stats", {
                "success": True,
                "userId": user_id,
                **stats
            })
        except Exception as e:
            self.send_event("memory-stats", {
                "success": False,
                "error": str(e)
            })
    
    # ==================== Telegram RAG Handlers ====================
    
    async def handle_init_rag_system(self):
        """åˆå§‹åŒ– Telegram RAG ç³»çµ±"""
        try:
            from telegram_rag_system import telegram_rag
            from chat_history_indexer import chat_indexer
            
            # åˆå§‹åŒ– RAG ç³»çµ± - ğŸ”§ Phase 1 å„ªåŒ–ï¼šé»˜èªç¦ç”¨ç¥ç¶“ç¶²çµ¡åµŒå…¥
            await telegram_rag.initialize(use_chromadb=True, use_neural=False)
            
            # åˆå§‹åŒ–ç´¢å¼•æœå‹™
            await chat_indexer.initialize()
            
            # å•Ÿå‹•å¾Œå°ç´¢å¼•
            await chat_indexer.start_background_indexing()
            
            self.send_log("âœ“ Telegram RAG ç³»çµ±åˆå§‹åŒ–å®Œæˆ", "success")
            self.send_event("rag-initialized", {"success": True})
            
        except Exception as e:
            self.send_log(f"RAG ç³»çµ±åˆå§‹åŒ–å¤±æ•—: {e}", "error")
            self.send_event("rag-initialized", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_rag_stats(self):
        """ç²å– RAG ç³»çµ±çµ±è¨ˆ"""
        try:
            from telegram_rag_system import telegram_rag
            from chat_history_indexer import chat_indexer
            
            rag_stats = await telegram_rag.get_statistics()
            indexer_stats = await chat_indexer.get_indexing_statistics()
            
            self.send_event("rag-stats", {
                "success": True,
                "rag": rag_stats,
                "indexer": indexer_stats
            })
            
        except Exception as e:
            self.send_event("rag-stats", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_search_rag(self, payload: Dict[str, Any]):
        """æœç´¢ RAG çŸ¥è­˜åº«"""
        try:
            from telegram_rag_system import telegram_rag, KnowledgeType
            
            query = payload.get('query', '')
            limit = payload.get('limit', 5)
            knowledge_type = payload.get('knowledgeType')
            
            # è½‰æ›çŸ¥è­˜é¡å‹
            kt = None
            if knowledge_type:
                try:
                    kt = KnowledgeType(knowledge_type)
                except:
                    pass
            
            results = await telegram_rag.search(query, limit=limit, knowledge_type=kt)
            
            # æ ¼å¼åŒ–çµæœ
            formatted_results = []
            for r in results:
                formatted_results.append({
                    'id': r.item.id,
                    'type': r.item.knowledge_type.value,
                    'question': r.item.question,
                    'answer': r.item.answer,
                    'successScore': r.item.success_score,
                    'useCount': r.item.use_count,
                    'similarity': r.similarity,
                    'source': r.source
                })
            
            self.send_event("rag-search-result", {
                "success": True,
                "query": query,
                "results": formatted_results
            })
            
        except Exception as e:
            self.send_event("rag-search-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_trigger_rag_learning(self, payload: Dict[str, Any]):
        """è§¸ç™¼ RAG å­¸ç¿’"""
        try:
            from telegram_rag_system import telegram_rag, ConversationOutcome
            from chat_history_indexer import chat_indexer
            
            user_id = payload.get('userId')
            account_phone = payload.get('accountPhone', '')
            outcome = payload.get('outcome', 'unknown')
            
            if user_id:
                # å­¸ç¿’ç‰¹å®šç”¨æˆ¶çš„å°è©±
                await chat_indexer.on_conversation_ended(
                    user_id=user_id,
                    account_phone=account_phone,
                    outcome=outcome
                )
                
                self.send_event("rag-learning-triggered", {
                    "success": True,
                    "userId": user_id
                })
            else:
                # æ‰¹é‡è™•ç†å¾…ç´¢å¼•çš„å°è©±
                result = await chat_indexer.index_pending_conversations()
                
                self.send_event("rag-learning-triggered", {
                    "success": True,
                    "conversationsProcessed": result.get('conversations_processed', 0),
                    "knowledgeExtracted": result.get('knowledge_extracted', 0)
                })
            
        except Exception as e:
            self.send_event("rag-learning-triggered", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_add_rag_knowledge(self, payload: Dict[str, Any]):
        """æ‰‹å‹•æ·»åŠ  RAG çŸ¥è­˜"""
        try:
            from telegram_rag_system import telegram_rag, KnowledgeType
            
            knowledge_type = payload.get('type', 'qa')
            question = payload.get('question', '')
            answer = payload.get('answer', '')
            context = payload.get('context', '')
            
            # è½‰æ›é¡å‹
            try:
                kt = KnowledgeType(knowledge_type)
            except:
                kt = KnowledgeType.QA
            
            knowledge_id = await telegram_rag.add_manual_knowledge(
                knowledge_type=kt,
                question=question,
                answer=answer,
                context=context
            )
            
            self.send_event("rag-knowledge-added", {
                "success": True,
                "knowledgeId": knowledge_id
            })
            
        except Exception as e:
            self.send_event("rag-knowledge-added", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_rag_feedback(self, payload: Dict[str, Any]):
        """è¨˜éŒ„ RAG çŸ¥è­˜åé¥‹"""
        try:
            from telegram_rag_system import telegram_rag
            
            knowledge_id = payload.get('knowledgeId')
            is_positive = payload.get('isPositive', True)
            feedback_text = payload.get('feedbackText', '')
            
            await telegram_rag.record_feedback(
                knowledge_id=knowledge_id,
                is_positive=is_positive,
                feedback_text=feedback_text
            )
            
            self.send_event("rag-feedback-recorded", {
                "success": True,
                "knowledgeId": knowledge_id
            })
            
        except Exception as e:
            self.send_event("rag-feedback-recorded", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_reindex_conversations(self, payload: Dict[str, Any]):
        """é‡æ–°ç´¢å¼•å°è©±"""
        try:
            from chat_history_indexer import chat_indexer
            
            high_value_only = payload.get('highValueOnly', False)
            days = payload.get('days', 30)
            
            if high_value_only:
                result = await chat_indexer.reindex_high_value_conversations(days=days)
            else:
                result = await chat_indexer.index_pending_conversations()
            
            self.send_log(f"é‡æ–°ç´¢å¼•å®Œæˆ: è™•ç† {result.get('conversations_processed', 0)} å€‹å°è©±", "success")
            
            self.send_event("rag-reindex-complete", {
                "success": True,
                **result
            })
            
        except Exception as e:
            self.send_event("rag-reindex-complete", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_cleanup_rag_knowledge(self, payload: Dict[str, Any]):
        """æ¸…ç† RAG çŸ¥è­˜åº«"""
        try:
            from telegram_rag_system import telegram_rag
            
            min_score = payload.get('minScore', 0.2)
            days_old = payload.get('daysOld', 30)
            merge_similar = payload.get('mergeSimilar', True)
            
            result = {
                'deleted': 0,
                'merged': 0
            }
            
            # æ¸…ç†ä½è³ªé‡çŸ¥è­˜
            result['deleted'] = await telegram_rag.cleanup_low_quality_knowledge(
                min_score=min_score,
                days_old=days_old
            )
            
            # åˆä½µç›¸ä¼¼çŸ¥è­˜
            if merge_similar:
                result['merged'] = await telegram_rag.merge_similar_knowledge()
            
            self.send_log(f"RAG çŸ¥è­˜åº«æ¸…ç†å®Œæˆ: åˆªé™¤ {result['deleted']} æ¢, åˆä½µ {result['merged']} æ¢", "success")
            
            self.send_event("rag-cleanup-complete", {
                "success": True,
                **result
            })
            
        except Exception as e:
            self.send_event("rag-cleanup-complete", {
                "success": False,
                "error": str(e)
            })
    
    # ==================== Scheduler Handlers ====================
    
    async def handle_schedule_follow_up(self, payload: Dict[str, Any]):
        """æ’ç¨‹è·Ÿé€²ä»»å‹™"""
        try:
            user_id = payload.get('userId', '')
            scheduled_at_str = payload.get('scheduledAt', '')
            message_template = payload.get('messageTemplate')
            task_type = payload.get('taskType', 'reminder')
            
            # Parse datetime
            scheduled_at = datetime.fromisoformat(scheduled_at_str.replace('Z', '+00:00'))
            
            task_id = await scheduler.schedule_follow_up(
                user_id=user_id,
                scheduled_at=scheduled_at,
                message_template=message_template,
                task_type=task_type
            )
            
            self.send_event("follow-up-scheduled", {
                "success": True,
                "taskId": task_id
            })
        except Exception as e:
            self.send_event("follow-up-scheduled", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_pending_tasks(self, payload: Dict[str, Any]):
        """ç²å–å¾…åŸ·è¡Œä»»å‹™"""
        try:
            limit = payload.get('limit', 50)
            tasks = await scheduler.get_pending_tasks(limit=limit)
            
            self.send_event("pending-tasks", {
                "success": True,
                "tasks": tasks
            })
        except Exception as e:
            self.send_event("pending-tasks", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_cancel_scheduled_task(self, payload: Dict[str, Any]):
        """å–æ¶ˆæ’ç¨‹ä»»å‹™"""
        try:
            task_id = payload.get('taskId')
            await scheduler.cancel_task(task_id)
            
            self.send_event("task-cancelled", {
                "success": True,
                "taskId": task_id
            })
        except Exception as e:
            self.send_event("task-cancelled", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_scheduler_stats(self):
        """ç²å–èª¿åº¦å™¨çµ±è¨ˆ"""
        try:
            stats = await scheduler.get_scheduler_stats()
            
            self.send_event("scheduler-stats", {
                "success": True,
                **stats
            })
        except Exception as e:
            self.send_event("scheduler-stats", {
                "success": False,
                "error": str(e)
            })
    
    # ==================== User CRM Handlers ====================
    
    async def handle_get_user_profile_full(self, payload: Dict[str, Any]):
        """ç²å–å®Œæ•´ç”¨æˆ¶è³‡æ–™"""
        try:
            user_id = payload.get('userId', '')
            
            # Get user profile
            profile = await db.get_user_profile(user_id)
            
            # Get user CRM data
            cursor = await db._connection.execute(
                "SELECT * FROM user_crm WHERE user_id = ?", (user_id,)
            )
            crm_row = await cursor.fetchone()
            crm_data = dict(crm_row) if crm_row else {}
            
            # Get user tags
            cursor = await db._connection.execute(
                "SELECT tag, tag_type, confidence FROM user_tags WHERE user_id = ?",
                (user_id,)
            )
            tags = await cursor.fetchall()
            tags_list = [dict(t) for t in tags]
            
            # Get funnel history
            history = await db.get_funnel_history(user_id, limit=10)
            
            # Get memory stats
            stats = await vector_memory.get_user_memory_stats(user_id)
            
            self.send_event("user-profile-full", {
                "success": True,
                "userId": user_id,
                "profile": profile,
                "crm": crm_data,
                "tags": tags_list,
                "funnelHistory": history,
                "memoryStats": stats
            })
        except Exception as e:
            self.send_event("user-profile-full", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_update_user_crm(self, payload: Dict[str, Any]):
        """æ›´æ–°ç”¨æˆ¶ CRM è³‡æ–™"""
        try:
            user_id = payload.get('userId', '')
            data = payload.get('data', {})
            
            # Build update query
            fields = ['company', 'industry', 'job_title', 'phone', 'email', 
                      'website', 'location', 'budget_range', 'pain_points', 'goals']
            
            updates = []
            values = []
            
            for field in fields:
                if field in data:
                    updates.append(f"{field} = ?")
                    values.append(data[field])
            
            if updates:
                values.append(user_id)
                
                # Check if record exists
                cursor = await db._connection.execute(
                    "SELECT 1 FROM user_crm WHERE user_id = ?", (user_id,)
                )
                exists = await cursor.fetchone()
                
                if exists:
                    await db._connection.execute(f"""
                        UPDATE user_crm SET {', '.join(updates)}, updated_at = CURRENT_TIMESTAMP
                        WHERE user_id = ?
                    """, values)
                else:
                    # Insert new record
                    insert_fields = [f for f in fields if f in data]
                    insert_values = [data[f] for f in insert_fields]
                    placeholders = ', '.join(['?' for _ in insert_fields])
                    
                    await db._connection.execute(f"""
                        INSERT INTO user_crm (user_id, {', '.join(insert_fields)})
                        VALUES (?, {placeholders})
                    """, [user_id] + insert_values)
                
                await db._connection.commit()
            
            self.send_event("crm-updated", {
                "success": True,
                "userId": user_id
            })
        except Exception as e:
            self.send_event("crm-updated", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_add_user_tag(self, payload: Dict[str, Any]):
        """æ·»åŠ ç”¨æˆ¶æ¨™ç±¤"""
        try:
            user_id = payload.get('userId', '')
            tag = payload.get('tag', '')
            tag_type = payload.get('tagType', 'custom')
            
            await db._connection.execute("""
                INSERT OR IGNORE INTO user_tags (user_id, tag, tag_type)
                VALUES (?, ?, ?)
            """, (user_id, tag, tag_type))
            await db._connection.commit()
            
            self.send_event("tag-added", {
                "success": True,
                "userId": user_id,
                "tag": tag
            })
        except Exception as e:
            self.send_event("tag-added", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_remove_user_tag(self, payload: Dict[str, Any]):
        """ç§»é™¤ç”¨æˆ¶æ¨™ç±¤"""
        try:
            user_id = payload.get('userId', '')
            tag = payload.get('tag', '')
            
            await db._connection.execute("""
                DELETE FROM user_tags WHERE user_id = ? AND tag = ?
            """, (user_id, tag))
            await db._connection.commit()
            
            self.send_event("tag-removed", {
                "success": True,
                "userId": user_id,
                "tag": tag
            })
        except Exception as e:
            self.send_event("tag-removed", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_user_tags(self, payload: Dict[str, Any]):
        """ç²å–ç”¨æˆ¶æ¨™ç±¤"""
        try:
            user_id = payload.get('userId', '')
            
            cursor = await db._connection.execute("""
                SELECT ut.tag, ut.tag_type, ut.confidence, ut.auto_assigned, ut.created_at,
                       td.color, td.description
                FROM user_tags ut
                LEFT JOIN tag_definitions td ON ut.tag = td.tag
                WHERE ut.user_id = ?
            """, (user_id,))
            
            rows = await cursor.fetchall()
            tags = [dict(row) for row in rows]
            
            self.send_event("user-tags", {
                "success": True,
                "userId": user_id,
                "tags": tags
            })
        except Exception as e:
            self.send_event("user-tags", {
                "success": False,
                "error": str(e)
            })
    
    # ==================== Full-Text Search Handlers ====================
    
    async def handle_search_chat_history(self, payload: Dict[str, Any]):
        """å…¨æ–‡æœç´¢èŠå¤©è¨˜éŒ„"""
        try:
            from fulltext_search import get_search_engine
            from datetime import datetime as dt
            
            query = payload.get('query', '')
            if not query:
                self.send_event("search-chat-history", {
                    "success": False,
                    "error": "æœç´¢æŸ¥è©¢ä¸èƒ½ç‚ºç©º"
                })
                return
            
            user_id = payload.get('userId')
            account_phone = payload.get('accountPhone')
            role = payload.get('role')
            limit = payload.get('limit', 50)
            offset = payload.get('offset', 0)
            
            # è§£ææ—¥æœŸç¯„åœ
            date_from = None
            date_to = None
            if payload.get('dateFrom'):
                try:
                    date_from = dt.fromisoformat(payload['dateFrom'])
                except:
                    pass
            if payload.get('dateTo'):
                try:
                    date_to = dt.fromisoformat(payload['dateTo'])
                except:
                    pass
            
            search_engine = get_search_engine()
            results = await search_engine.search_chat_history(
                query=query,
                user_id=user_id,
                account_phone=account_phone,
                role=role,
                date_from=date_from,
                date_to=date_to,
                limit=limit,
                offset=offset
            )
            
            self.send_event("search-chat-history", {
                "success": True,
                "query": query,
                "results": results,
                "count": len(results),
                "hasMore": len(results) == limit
            })
        except Exception as e:
            self.send_event("search-chat-history", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_search_leads(self, payload: Dict[str, Any]):
        """å…¨æ–‡æœç´¢ Lead"""
        try:
            from fulltext_search import get_search_engine
            from datetime import datetime as dt
            
            query = payload.get('query', '')
            if not query:
                self.send_event("search-leads", {
                    "success": False,
                    "error": "æœç´¢æŸ¥è©¢ä¸èƒ½ç‚ºç©º"
                })
                return
            
            status = payload.get('status')
            limit = payload.get('limit', 50)
            offset = payload.get('offset', 0)
            
            # è§£ææ—¥æœŸç¯„åœ
            date_from = None
            date_to = None
            if payload.get('dateFrom'):
                try:
                    date_from = dt.fromisoformat(payload['dateFrom'])
                except:
                    pass
            if payload.get('dateTo'):
                try:
                    date_to = dt.fromisoformat(payload['dateTo'])
                except:
                    pass
            
            search_engine = get_search_engine()
            results = await search_engine.search_leads(
                query=query,
                status=status,
                date_from=date_from,
                date_to=date_to,
                limit=limit,
                offset=offset
            )
            
            self.send_event("search-leads", {
                "success": True,
                "query": query,
                "results": results,
                "count": len(results),
                "hasMore": len(results) == limit
            })
        except Exception as e:
            self.send_event("search-leads", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_rebuild_search_index(self):
        """é‡å»ºæœç´¢ç´¢å¼•"""
        try:
            from fulltext_search import get_search_engine
            
            search_engine = get_search_engine()
            await search_engine.rebuild_index()
            
            self.send_log("æœç´¢ç´¢å¼•é‡å»ºå®Œæˆ", "success")
            self.send_event("search-index-rebuilt", {
                "success": True,
                "message": "æœç´¢ç´¢å¼•é‡å»ºå®Œæˆ"
            })
        except Exception as e:
            self.send_log(f"é‡å»ºæœç´¢ç´¢å¼•å¤±æ•—: {str(e)}", "error")
            self.send_event("search-index-rebuilt", {
                "success": False,
                "error": str(e)
            })
    
    # ==================== Analytics Handlers ====================
    
    async def handle_analyze_funnel(self, payload: Dict[str, Any]):
        """åˆ†æè½‰åŒ–æ¼æ–—"""
        try:
            from analytics_engine import AnalyticsEngine
            
            days = payload.get('days', 30)
            start_date = payload.get('startDate')
            end_date = payload.get('endDate')
            
            # è½‰æ›æ—¥æœŸ
            start_dt = None
            end_dt = None
            if start_date:
                try:
                    start_dt = datetime.fromisoformat(start_date.replace('Z', '+00:00'))
                except:
                    pass
            if end_date:
                try:
                    end_dt = datetime.fromisoformat(end_date.replace('Z', '+00:00'))
                except:
                    pass
            
            engine = AnalyticsEngine(db)
            result = await engine.analyze_funnel(
                days=days,
                start_date=start_dt,
                end_date=end_dt
            )
            
            self.send_event("funnel-analysis", {
                "success": True,
                **result
            })
        except Exception as e:
            self.send_event("funnel-analysis", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_analyze_user_journey(self, payload: Dict[str, Any]):
        """åˆ†æç”¨æˆ¶æ—…ç¨‹"""
        try:
            from analytics_engine import AnalyticsEngine
            
            user_id = payload.get('userId', '')
            if not user_id:
                self.send_event("user-journey-analysis", {
                    "success": False,
                    "error": "ç”¨æˆ¶IDä¸èƒ½ç‚ºç©º"
                })
                return
            
            engine = AnalyticsEngine(db)
            result = await engine.analyze_user_journey(user_id)
            
            self.send_event("user-journey-analysis", {
                "success": True,
                **result
            })
        except Exception as e:
            self.send_event("user-journey-analysis", {
                "success": False,
                "error": str(e)
            })
    
    # ==================== Monitoring Status Handlers ====================
    
    async def handle_get_monitoring_status(self):
        """ç²å–ç›£æ§ç‹€æ…‹è©³æƒ…"""
        try:
            accounts = await db.get_all_accounts()
            listener_accounts = [a for a in accounts if a.get('role') == 'Listener']
            sender_accounts = [a for a in accounts if a.get('role') == 'Sender']
            
            # æª¢æŸ¥ç›£æ§å¸³è™Ÿç‹€æ…‹
            monitoring_status = []
            for account in listener_accounts:
                phone = account.get('phone')
                status = account.get('status', 'Offline')
                
                # æª¢æŸ¥æ˜¯å¦æœ‰è¨»å†Šè™•ç†å™¨
                has_handler = phone in self.telegram_manager.message_handlers if hasattr(self.telegram_manager, 'message_handlers') else False
                
                # æª¢æŸ¥ç›£æ§ä¿¡æ¯
                monitoring_info = None
                if hasattr(self.telegram_manager, 'monitoring_info') and phone in self.telegram_manager.monitoring_info:
                    info = self.telegram_manager.monitoring_info[phone]
                    monitoring_info = {
                        'chatIds': list(info.get('chat_ids', [])),
                        'groupUrls': info.get('group_urls', []),
                        'keywordSetCount': len(info.get('keyword_sets', []))
                    }
                
                monitoring_status.append({
                    'phone': phone,
                    'status': status,
                    'hasHandler': has_handler,
                    'monitoringInfo': monitoring_info
                })
            
            # æª¢æŸ¥ç™¼é€å¸³è™Ÿç‹€æ…‹
            sender_status = []
            for account in sender_accounts:
                phone = account.get('phone')
                status = account.get('status', 'Offline')
                
                # æª¢æŸ¥æ˜¯å¦æœ‰ç§ä¿¡è™•ç†å™¨
                has_private_handler = False
                if hasattr(private_message_handler, 'private_handlers'):
                    has_private_handler = phone in private_message_handler.private_handlers
                
                sender_status.append({
                    'phone': phone,
                    'status': status,
                    'hasPrivateHandler': has_private_handler
                })
            
            # ç²å–ç›£æ§é…ç½®
            monitored_groups = await db.get_all_monitored_groups()
            keyword_sets = await db.get_all_keyword_sets()
            campaigns = await db.get_all_campaigns()
            active_campaigns = [c for c in campaigns if c.get('isActive') or c.get('is_active')]
            
            self.send_event("monitoring-status", {
                "success": True,
                "isMonitoring": self.is_monitoring,
                "listenerAccounts": monitoring_status,
                "senderAccounts": sender_status,
                "monitoredGroups": len(monitored_groups),
                "keywordSets": len(keyword_sets),
                "activeCampaigns": len(active_campaigns),
                "totalCampaigns": len(campaigns)
            })
        except Exception as e:
            self.send_event("monitoring-status", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_check_monitoring_health(self):
        """æª¢æŸ¥ç›£æ§å¥åº·ç‹€æ…‹"""
        try:
            issues = []
            warnings = []
            
            # æª¢æŸ¥ç›£æ§å¸³è™Ÿ
            accounts = await db.get_all_accounts()
            listener_accounts = [a for a in accounts if a.get('role') == 'Listener']
            online_listeners = [a for a in listener_accounts if a.get('status') == 'Online']
            
            if not listener_accounts:
                issues.append("æ²’æœ‰é…ç½®ç›£æ§å¸³è™Ÿï¼ˆListener è§’è‰²ï¼‰")
            elif not online_listeners:
                issues.append(f"æœ‰ {len(listener_accounts)} å€‹ç›£æ§å¸³è™Ÿï¼Œä½†æ²’æœ‰åœ¨ç·šçš„")
            
            # æª¢æŸ¥ç™¼é€å¸³è™Ÿ
            sender_accounts = [a for a in accounts if a.get('role') == 'Sender']
            online_senders = [a for a in sender_accounts if a.get('status') == 'Online']
            
            if not sender_accounts:
                warnings.append("æ²’æœ‰é…ç½®ç™¼é€å¸³è™Ÿï¼ˆSender è§’è‰²ï¼‰")
            elif not online_senders:
                warnings.append(f"æœ‰ {len(sender_accounts)} å€‹ç™¼é€å¸³è™Ÿï¼Œä½†æ²’æœ‰åœ¨ç·šçš„")
            
            # æª¢æŸ¥ç›£æ§é…ç½®
            monitored_groups = await db.get_all_monitored_groups()
            if not monitored_groups:
                issues.append("æ²’æœ‰é…ç½®ç›£æ§ç¾¤çµ„")
            
            keyword_sets = await db.get_all_keyword_sets()
            if not keyword_sets:
                issues.append("æ²’æœ‰é…ç½®é—œéµè©é›†")
            else:
                # æª¢æŸ¥é—œéµè©é›†æ˜¯å¦ç‚ºç©º
                empty_sets = [ks for ks in keyword_sets if not ks.get('keywords')]
                if empty_sets:
                    warnings.append(f"æœ‰ {len(empty_sets)} å€‹é—œéµè©é›†ç‚ºç©º")
            
            # æª¢æŸ¥æ´»å‹•é…ç½®
            campaigns = await db.get_all_campaigns()
            active_campaigns = [c for c in campaigns if c.get('isActive') or c.get('is_active')]
            if not active_campaigns:
                warnings.append("æ²’æœ‰å•Ÿç”¨çš„æ´»å‹•ï¼ˆå³ä½¿æ•ç²åˆ° Lead ä¹Ÿä¸æœƒè‡ªå‹•ç™¼é€ï¼‰")
            
            # æª¢æŸ¥è™•ç†å™¨è¨»å†Š
            handler_issues = []
            for account in online_listeners:
                phone = account.get('phone')
                if hasattr(self.telegram_manager, 'message_handlers'):
                    if phone not in self.telegram_manager.message_handlers:
                        handler_issues.append(f"ç›£æ§å¸³è™Ÿ {phone} æœªè¨»å†Šç¾¤çµ„æ¶ˆæ¯è™•ç†å™¨")
            
            for account in online_senders:
                phone = account.get('phone')
                if hasattr(private_message_handler, 'private_handlers'):
                    if phone not in private_message_handler.private_handlers:
                        handler_issues.append(f"ç™¼é€å¸³è™Ÿ {phone} æœªè¨»å†Šç§ä¿¡è™•ç†å™¨")
            
            if handler_issues:
                issues.extend(handler_issues)
            
            self.send_event("monitoring-health", {
                "success": True,
                "isHealthy": len(issues) == 0,
                "issues": issues,
                "warnings": warnings,
                "summary": {
                    "listenerAccounts": len(listener_accounts),
                    "onlineListeners": len(online_listeners),
                    "senderAccounts": len(sender_accounts),
                    "onlineSenders": len(online_senders),
                    "monitoredGroups": len(monitored_groups),
                    "keywordSets": len(keyword_sets),
                    "activeCampaigns": len(active_campaigns)
                }
            })
        except Exception as e:
            self.send_event("monitoring-health", {
                "success": False,
                "error": str(e)
            })
    
    # ==================== Database Management ====================
    
    async def handle_rebuild_database(self):
        """é‡å»ºæ•¸æ“šåº«ï¼ˆæœƒåˆªé™¤æ‰€æœ‰æ•¸æ“šï¼‰"""
        import shutil
        from pathlib import Path
        
        try:
            db_path = Path(config.DATABASE_URL)
            db_dir = db_path.parent
            
            self.send_log("é–‹å§‹é‡å»ºæ•¸æ“šåº«...", "info")
            
            # æ­¥é©Ÿ 1: å‚™ä»½ç¾æœ‰æ•¸æ“šåº«
            if db_path.exists():
                backup_path = db_dir / f"tgmatrix_backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.db"
                try:
                    shutil.copy2(db_path, backup_path)
                    self.send_log(f"æ•¸æ“šåº«å·²å‚™ä»½åˆ°: {backup_path.name}", "success")
                except Exception as e:
                    self.send_log(f"å‚™ä»½å¤±æ•—: {str(e)}", "warning")
            
            # æ­¥é©Ÿ 2: é—œé–‰ç•¶å‰æ•¸æ“šåº«é€£æ¥
            try:
                await db.close()
            except:
                pass
            
            # æ­¥é©Ÿ 3: åˆªé™¤èˆŠæ•¸æ“šåº«æ–‡ä»¶
            try:
                if db_path.exists():
                    db_path.unlink()
                # åˆªé™¤ WAL å’Œ SHM æ–‡ä»¶
                wal_path = Path(str(db_path) + "-wal")
                shm_path = Path(str(db_path) + "-shm")
                if wal_path.exists():
                    wal_path.unlink()
                if shm_path.exists():
                    shm_path.unlink()
                self.send_log("èˆŠæ•¸æ“šåº«æ–‡ä»¶å·²åˆªé™¤", "info")
            except Exception as e:
                self.send_log(f"åˆªé™¤èˆŠæ•¸æ“šåº«å¤±æ•—: {str(e)}", "error")
                self.send_event("database-rebuild-result", {
                    "success": False,
                    "error": f"åˆªé™¤èˆŠæ•¸æ“šåº«å¤±æ•—: {str(e)}"
                })
                return
            
            # æ­¥é©Ÿ 4: é‡æ–°åˆå§‹åŒ–æ•¸æ“šåº«
            try:
                await db.initialize()
                await db.connect()
                
                # é©—è­‰æ•¸æ“šåº«å®Œæ•´æ€§
                cursor = await db._connection.execute("PRAGMA integrity_check")
                result = await cursor.fetchone()
                if result and result[0] == 'ok':
                    self.send_log("æ•¸æ“šåº«é‡å»ºæˆåŠŸï¼Œå®Œæ•´æ€§æª¢æŸ¥é€šé", "success")
                else:
                    self.send_log(f"æ•¸æ“šåº«é‡å»ºå®Œæˆï¼Œä½†å®Œæ•´æ€§æª¢æŸ¥è­¦å‘Š: {result[0] if result else 'Unknown'}", "warning")
                
                # é‡æ–°åˆå§‹åŒ–å…¨æ–‡æœç´¢ç´¢å¼•
                try:
                    from config import DATABASE_PATH
                    search_engine = await get_init_search_engine()(str(DATABASE_PATH))
                    self.send_log("å…¨æ–‡æœç´¢ç´¢å¼•å·²é‡å»º", "success")
                except Exception as e:
                    self.send_log(f"å…¨æ–‡æœç´¢ç´¢å¼•é‡å»ºå¤±æ•—ï¼ˆå¯é¸ï¼‰: {str(e)}", "warning")
                
                self.send_event("database-rebuild-result", {
                    "success": True,
                    "message": "æ•¸æ“šåº«é‡å»ºæˆåŠŸ"
                })
                
                # ç™¼é€åˆå§‹ç‹€æ…‹äº‹ä»¶ï¼Œè®“å‰ç«¯åˆ·æ–°
                await self.handle_get_initial_state()
                
            except Exception as e:
                import traceback
                error_details = traceback.format_exc()
                print(f"[Backend] Database rebuild error: {error_details}", file=sys.stderr)
                self.send_log(f"æ•¸æ“šåº«é‡å»ºå¤±æ•—: {str(e)}", "error")
                self.send_event("database-rebuild-result", {
                    "success": False,
                    "error": str(e)
                })
                
        except Exception as e:
            import traceback
            error_details = traceback.format_exc()
            print(f"[Backend] Database rebuild error: {error_details}", file=sys.stderr)
            self.send_event("database-rebuild-result", {
                "success": False,
                "error": str(e)
            })
    
    # ==================== Chat History Handlers ====================
    
    async def handle_get_chat_history_full(self, payload: Dict[str, Any]):
        """ç²å–å®Œæ•´èŠå¤©è¨˜éŒ„ï¼ˆæ”¯æŒåˆ†é å’Œç·©å­˜ï¼‰"""
        try:
            import sys
            user_id = payload.get('userId', '')
            limit = payload.get('limit', 50)
            offset = payload.get('offset', 0)
            
            print(f"[Backend] Getting chat history for user {user_id}, limit={limit}, offset={offset}", file=sys.stderr)
            
            # å„ªåŒ–ï¼šåªæŸ¥è©¢ä¸€æ¬¡ï¼Œç²å– limit+1 æ¢ä¾†åˆ¤æ–·æ˜¯å¦æœ‰æ›´å¤š
            history = await db.get_chat_history_paginated(
                user_id=user_id,
                limit=limit + 1,  # å¤šå–ä¸€æ¢ä¾†åˆ¤æ–·æ˜¯å¦æœ‰æ›´å¤š
                offset=offset
            )
            
            # åˆ¤æ–·æ˜¯å¦æœ‰æ›´å¤šæ¶ˆæ¯
            has_more = len(history) > limit
            # åªè¿”å› limit æ¢
            if has_more:
                history = history[:limit]
            
            # ç²å–ç¸½æ•¸ï¼ˆä½¿ç”¨æ›´å¿«çš„æŸ¥è©¢ï¼Œåªåœ¨éœ€è¦æ™‚åŸ·è¡Œï¼‰
            # å¦‚æœ offset=0 ä¸”æ²’æœ‰æ›´å¤šæ¶ˆæ¯ï¼Œç¸½æ•¸å°±æ˜¯ç•¶å‰æ•¸é‡
            if offset == 0 and not has_more:
                total_count = len(history)
            else:
                # éœ€è¦æŸ¥è©¢ç¸½æ•¸
                try:
                    cursor = await db._connection.execute("""
                        SELECT COUNT(*) as total FROM chat_history WHERE user_id = ?
                    """, (user_id,))
                    total_row = await cursor.fetchone()
                    total_count = total_row['total'] if total_row else len(history)
                except Exception as count_err:
                    print(f"[Backend] Error getting total count: {count_err}", file=sys.stderr)
                    total_count = len(history)  # é™ç´šï¼šä½¿ç”¨ç•¶å‰æ•¸é‡
            
            # ç²å–ç”¨æˆ¶è³‡æ–™
            profile = await db.get_user_profile(user_id)
            
            # ç²å–ç”¨æˆ¶æ¨™ç±¤
            cursor = await db._connection.execute("""
                SELECT tag, tag_type, confidence FROM user_tags WHERE user_id = ?
            """, (user_id,))
            tags = [dict(row) for row in await cursor.fetchall()]
            
            # æ ¼å¼åŒ–æ¶ˆæ¯ï¼ˆåè½‰é †åºï¼Œå¾èˆŠåˆ°æ–°ï¼‰
            formatted_messages = []
            for msg in reversed(history):  # åè½‰ç‚ºå¾èˆŠåˆ°æ–°
                formatted_messages.append({
                    "id": msg.get('id'),
                    "role": msg.get('role'),
                    "content": msg.get('content'),
                    "timestamp": msg.get('timestamp'),
                    "accountPhone": msg.get('account_phone'),
                    "sourceGroup": msg.get('source_group'),
                })
            
            print(f"[Backend] Sending chat history: {len(formatted_messages)} messages, hasMore={has_more}, total={total_count}", file=sys.stderr)
            
            self.send_event("chat-history-full", {
                "success": True,
                "userId": user_id,
                "messages": formatted_messages,
                "profile": profile,
                "tags": tags,
                "total": total_count,
                "hasMore": has_more  # æ·»åŠ  hasMore å­—æ®µ
            })
        except Exception as e:
            import traceback
            import sys
            error_details = traceback.format_exc()
            print(f"[Backend] Error getting chat history: {error_details}", file=sys.stderr)
            self.send_event("chat-history-full", {
                "success": False,
                "error": str(e),
                "userId": payload.get('userId', '')
            })
    
    async def handle_get_chat_list(self, payload: Dict[str, Any]):
        """ç²å–èŠå¤©åˆ—è¡¨ï¼ˆæ‰€æœ‰æœ‰å°è©±çš„ç”¨æˆ¶ï¼‰"""
        try:
            limit = payload.get('limit', 50)
            offset = payload.get('offset', 0)
            search_query = payload.get('search', '')
            funnel_stage = payload.get('funnelStage')
            
            # æ§‹å»ºæŸ¥è©¢
            query = """
                SELECT DISTINCT 
                    ch.user_id,
                    up.username,
                    up.first_name,
                    up.last_name,
                    up.funnel_stage,
                    up.interest_level,
                    up.last_interaction,
                    (SELECT content FROM chat_history ch2 
                     WHERE ch2.user_id = ch.user_id 
                     ORDER BY ch2.timestamp DESC LIMIT 1) as last_message,
                    (SELECT timestamp FROM chat_history ch2 
                     WHERE ch2.user_id = ch.user_id 
                     ORDER BY ch2.timestamp DESC LIMIT 1) as last_message_time,
                    (SELECT COUNT(*) FROM chat_history ch3 
                     WHERE ch3.user_id = ch.user_id AND ch3.role = 'user') as unread_count
                FROM chat_history ch
                LEFT JOIN user_profiles up ON ch.user_id = up.user_id
                WHERE 1=1
            """
            params = []
            
            if search_query:
                query += " AND (up.username LIKE ? OR up.first_name LIKE ? OR ch.content LIKE ?)"
                search_pattern = f"%{search_query}%"
                params.extend([search_pattern, search_pattern, search_pattern])
            
            if funnel_stage:
                query += " AND up.funnel_stage = ?"
                params.append(funnel_stage)
            
            query += " ORDER BY last_message_time DESC LIMIT ? OFFSET ?"
            params.extend([limit, offset])
            
            cursor = await db._connection.execute(query, params)
            rows = await cursor.fetchall()
            
            chats = []
            for row in rows:
                chats.append({
                    "userId": row['user_id'],
                    "username": row['username'],
                    "firstName": row['first_name'],
                    "lastName": row['last_name'],
                    "funnelStage": row['funnel_stage'] or 'new',
                    "interestLevel": row['interest_level'] or 1,
                    "lastInteraction": row['last_interaction'],
                    "lastMessage": row['last_message'],
                    "lastMessageTime": row['last_message_time'],
                    "unreadCount": row['unread_count'] or 0,
                })
            
            # ç²å–ç¸½æ•¸
            count_query = """
                SELECT COUNT(DISTINCT ch.user_id) as total
                FROM chat_history ch
                LEFT JOIN user_profiles up ON ch.user_id = up.user_id
                WHERE 1=1
            """
            count_params = []
            
            if search_query:
                count_query += " AND (up.username LIKE ? OR up.first_name LIKE ? OR ch.content LIKE ?)"
                search_pattern = f"%{search_query}%"
                count_params.extend([search_pattern, search_pattern, search_pattern])
            
            if funnel_stage:
                count_query += " AND up.funnel_stage = ?"
                count_params.append(funnel_stage)
            
            count_cursor = await db._connection.execute(count_query, count_params)
            count_row = await count_cursor.fetchone()
            total = count_row['total'] if count_row else 0
            
            self.send_event("chat-list", {
                "success": True,
                "chats": chats,
                "total": total,
                "limit": limit,
                "offset": offset
            })
        except Exception as e:
            self.send_event("chat-list", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_send_ai_response(self, payload: Dict[str, Any]):
        """ç™¼é€ AI ç”Ÿæˆçš„å›å¾©ï¼ˆç”¨æ–¼åŠè‡ªå‹•æ¨¡å¼ï¼‰"""
        try:
            user_id = payload.get('userId', '')
            message = payload.get('message', '')
            account_phone = payload.get('accountPhone')
            source_group = payload.get('sourceGroup')
            username = payload.get('username', '')
            
            if not account_phone:
                # è‡ªå‹•é¸æ“‡ç™¼é€å¸³è™Ÿ
                accounts = await db.get_all_accounts()
                sender_accounts = [a for a in accounts if a.get('role') == 'Sender' and a.get('status') == 'Online']
                if sender_accounts:
                    import random
                    account_phone = random.choice(sender_accounts).get('phone')
                else:
                    raise ValueError("æ²’æœ‰å¯ç”¨çš„ç™¼é€å¸³è™Ÿ")
            
            # æª¢æŸ¥ç”¨æˆ¶æ˜¯å¦å·²äº’å‹•ï¼ˆæ±ºå®šæ˜¯å¦è¨ˆå…¥é™é¡ï¼‰
            has_interacted = await self._user_has_interacted(user_id)
            
            # æª¢æŸ¥å¸³è™Ÿé™é¡ï¼ˆæœªäº’å‹•ç”¨æˆ¶ï¼‰
            if not has_interacted:
                account = await db.get_account_by_phone(account_phone)
                if account:
                    if account.get('dailySendCount', 0) >= account.get('dailySendLimit', 50):
                        raise ValueError(f"å¸³è™Ÿ {account_phone} å·²é”æ¯æ—¥ç™¼é€é™é¡")
            
            # ç™¼é€æ¶ˆæ¯
            result = await self.telegram_manager.send_message(
                phone=account_phone,
                user_id=user_id,
                text=message,
                source_group=source_group
            )
            
            if result.get('success'):
                # ä¿å­˜ AI å›å¾©åˆ°èŠå¤©æ­·å²
                await db.add_chat_message(
                    user_id=user_id,
                    role='assistant',
                    content=message,
                    account_phone=account_phone,
                    source_group=source_group
                )
                
                # æ›´æ–°æ¯æ—¥è¨ˆæ•¸ï¼ˆåƒ…æœªäº’å‹•ç”¨æˆ¶ï¼‰
                if not has_interacted:
                    account = await db.get_account_by_phone(account_phone)
                    if account:
                        await db.update_account(account.get('id'), {
                            'dailySendCount': account.get('dailySendCount', 0) + 1
                        })
                
                # è¨˜éŒ„äº’å‹•
                await db._connection.execute("""
                    INSERT INTO user_interactions 
                    (user_id, interaction_type, direction, content, account_phone, platform)
                    VALUES (?, 'message', 'outbound', ?, ?, 'telegram')
                """, (user_id, message, account_phone))
                await db._connection.commit()
                
                self.send_event("ai-response-sent", {
                    "success": True,
                    "userId": user_id,
                    "message": message,
                    "accountPhone": account_phone
                })
            else:
                raise Exception(result.get('error', 'ç™¼é€å¤±æ•—'))
                
        except Exception as e:
            self.send_event("ai-response-sent", {
                "success": False,
                "error": str(e)
            })

    # ==================== User Management Handlers ====================
    
    async def handle_get_users_with_profiles(self, payload: Dict[str, Any]):
        """ç²å–ç”¨æˆ¶åˆ—è¡¨ï¼ˆå«ç•«åƒï¼‰ï¼Œæ”¯æŒç¯©é¸"""
        try:
            result = await db.get_users_with_profiles(
                stage=payload.get('stage'),
                tags=payload.get('tags'),
                interest_min=payload.get('interestMin'),
                interest_max=payload.get('interestMax'),
                search=payload.get('search'),
                limit=payload.get('limit', 50),
                offset=payload.get('offset', 0)
            )
            
            self.send_event("users-with-profiles", result)
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("users-with-profiles", {
                "users": [],
                "total": 0,
                "error": str(e)
            })
    
    async def handle_get_funnel_stats(self, payload: Dict[str, Any] = None):
        """ç²å–æ¼æ–—çµ±è¨ˆ"""
        try:
            stats = await db.get_detailed_funnel_stats()
            self.send_event("funnel-stats", stats)
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("funnel-stats", {
                "stages": {},
                "tags": [],
                "interest_distribution": {},
                "error": str(e)
            })
    
    async def handle_bulk_update_user_tags(self, payload: Dict[str, Any]):
        """æ‰¹é‡æ›´æ–°ç”¨æˆ¶æ¨™ç±¤"""
        try:
            user_ids = payload.get('userIds', [])
            tags = payload.get('tags', '')
            action = payload.get('action', 'add')  # add, remove, set
            
            if not user_ids:
                raise ValueError("è«‹é¸æ“‡è¦æ›´æ–°çš„ç”¨æˆ¶")
            
            await db.bulk_update_user_tags(user_ids, tags, action)
            
            self.send_log(f"å·²æ›´æ–° {len(user_ids)} å€‹ç”¨æˆ¶çš„æ¨™ç±¤", "success")
            self.send_event("bulk-update-complete", {
                "success": True,
                "type": "tags",
                "count": len(user_ids)
            })
            
        except Exception as e:
            self.send_log(f"æ‰¹é‡æ›´æ–°æ¨™ç±¤å¤±æ•—: {str(e)}", "error")
            self.send_event("bulk-update-complete", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_bulk_update_user_stage(self, payload: Dict[str, Any]):
        """æ‰¹é‡æ›´æ–°ç”¨æˆ¶éšæ®µ"""
        try:
            user_ids = payload.get('userIds', [])
            stage = payload.get('stage', '')
            
            if not user_ids:
                raise ValueError("è«‹é¸æ“‡è¦æ›´æ–°çš„ç”¨æˆ¶")
            if not stage:
                raise ValueError("è«‹é¸æ“‡ç›®æ¨™éšæ®µ")
            
            await db.bulk_update_user_stage(user_ids, stage)
            
            self.send_log(f"å·²å°‡ {len(user_ids)} å€‹ç”¨æˆ¶æ›´æ–°ç‚º {stage} éšæ®µ", "success")
            self.send_event("bulk-update-complete", {
                "success": True,
                "type": "stage",
                "count": len(user_ids)
            })
            
        except Exception as e:
            self.send_log(f"æ‰¹é‡æ›´æ–°éšæ®µå¤±æ•—: {str(e)}", "error")
            self.send_event("bulk-update-complete", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_update_user_profile(self, payload: Dict[str, Any]):
        """æ›´æ–°å–®å€‹ç”¨æˆ¶ç•«åƒ"""
        try:
            user_id = payload.get('userId')
            data = payload.get('data', {})
            
            if not user_id:
                raise ValueError("ç”¨æˆ¶ ID ä¸èƒ½ç‚ºç©º")
            
            await db.update_user_profile(user_id, data)
            
            # å¦‚æœæœ‰éšæ®µæ›´æ–°ï¼Œä½¿ç”¨å°ˆé–€çš„æ–¹æ³•
            if 'funnel_stage' in data:
                await db.set_user_funnel_stage(user_id, data['funnel_stage'])
            
            self.send_log(f"å·²æ›´æ–°ç”¨æˆ¶ {user_id} çš„ç•«åƒ", "success")
            self.send_event("user-profile-updated", {
                "success": True,
                "userId": user_id
            })
            
        except Exception as e:
            self.send_log(f"æ›´æ–°ç”¨æˆ¶ç•«åƒå¤±æ•—: {str(e)}", "error")
            self.send_event("user-profile-updated", {
                "success": False,
                "error": str(e)
            })
    
    # ==================== Batch Operations Handlers ====================
    
    async def handle_batch_update_lead_status(self, payload: Dict[str, Any]):
        """æ‰¹é‡æ›´æ–° Lead ç‹€æ…‹"""
        try:
            lead_ids = payload.get('leadIds', [])
            new_status = payload.get('newStatus')
            
            if not lead_ids:
                self.send_event("batch-operation-result", {
                    "success": False,
                    "error": "æœªé¸æ“‡ä»»ä½• Lead"
                })
                return
            
            if not new_status:
                self.send_event("batch-operation-result", {
                    "success": False,
                    "error": "æœªæŒ‡å®šæ–°ç‹€æ…‹"
                })
                return
            
            batch_ops = get_batch_ops()
            if not batch_ops:
                self.send_event("batch-operation-result", {
                    "success": False,
                    "error": "æ‰¹é‡æ“ä½œç³»çµ±æœªåˆå§‹åŒ–"
                })
                return
            
            result = await batch_ops.batch_update_lead_status(lead_ids, new_status)
            
            if result.get('success'):
                self.send_log(f"æ‰¹é‡æ›´æ–°ç‹€æ…‹å®Œæˆ: {result.get('successCount')}/{len(lead_ids)} æˆåŠŸ", "success")
            else:
                self.send_log(f"æ‰¹é‡æ›´æ–°ç‹€æ…‹å¤±æ•—: {result.get('error')}", "error")
            
            self.send_event("batch-operation-result", result)
            
        except Exception as e:
            self.send_log(f"æ‰¹é‡æ›´æ–°ç‹€æ…‹å¤±æ•—: {str(e)}", "error")
            self.send_event("batch-operation-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_batch_add_tag(self, payload: Dict[str, Any]):
        """æ‰¹é‡æ·»åŠ æ¨™ç±¤"""
        try:
            lead_ids = payload.get('leadIds', [])
            tag = payload.get('tag')
            
            if not lead_ids:
                self.send_event("batch-operation-result", {
                    "success": False,
                    "error": "æœªé¸æ“‡ä»»ä½• Lead"
                })
                return
            
            if not tag:
                self.send_event("batch-operation-result", {
                    "success": False,
                    "error": "æœªæŒ‡å®šæ¨™ç±¤"
                })
                return
            
            batch_ops = get_batch_ops()
            if not batch_ops:
                self.send_event("batch-operation-result", {
                    "success": False,
                    "error": "æ‰¹é‡æ“ä½œç³»çµ±æœªåˆå§‹åŒ–"
                })
                return
            
            result = await batch_ops.batch_add_tag(lead_ids, tag)
            
            if result.get('success'):
                self.send_log(f"æ‰¹é‡æ·»åŠ æ¨™ç±¤å®Œæˆ: {result.get('successCount')}/{len(lead_ids)} æˆåŠŸ", "success")
            else:
                self.send_log(f"æ‰¹é‡æ·»åŠ æ¨™ç±¤å¤±æ•—: {result.get('error')}", "error")
            
            self.send_event("batch-operation-result", result)
            
        except Exception as e:
            self.send_log(f"æ‰¹é‡æ·»åŠ æ¨™ç±¤å¤±æ•—: {str(e)}", "error")
            self.send_event("batch-operation-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_batch_remove_tag(self, payload: Dict[str, Any]):
        """æ‰¹é‡ç§»é™¤æ¨™ç±¤"""
        try:
            lead_ids = payload.get('leadIds', [])
            tag = payload.get('tag')
            
            if not lead_ids:
                self.send_event("batch-operation-result", {
                    "success": False,
                    "error": "æœªé¸æ“‡ä»»ä½• Lead"
                })
                return
            
            if not tag:
                self.send_event("batch-operation-result", {
                    "success": False,
                    "error": "æœªæŒ‡å®šæ¨™ç±¤"
                })
                return
            
            batch_ops = get_batch_ops()
            if not batch_ops:
                self.send_event("batch-operation-result", {
                    "success": False,
                    "error": "æ‰¹é‡æ“ä½œç³»çµ±æœªåˆå§‹åŒ–"
                })
                return
            
            result = await batch_ops.batch_remove_tag(lead_ids, tag)
            
            if result.get('success'):
                self.send_log(f"æ‰¹é‡ç§»é™¤æ¨™ç±¤å®Œæˆ: {result.get('successCount')}/{len(lead_ids)} æˆåŠŸ", "success")
            else:
                self.send_log(f"æ‰¹é‡ç§»é™¤æ¨™ç±¤å¤±æ•—: {result.get('error')}", "error")
            
            self.send_event("batch-operation-result", result)
            
        except Exception as e:
            self.send_log(f"æ‰¹é‡ç§»é™¤æ¨™ç±¤å¤±æ•—: {str(e)}", "error")
            self.send_event("batch-operation-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_batch_add_to_dnc(self, payload: Dict[str, Any]):
        """æ‰¹é‡æ·»åŠ åˆ° DNC åˆ—è¡¨"""
        try:
            lead_ids = payload.get('leadIds', [])
            
            if not lead_ids:
                self.send_event("batch-operation-result", {
                    "success": False,
                    "error": "æœªé¸æ“‡ä»»ä½• Lead"
                })
                return
            
            batch_ops = get_batch_ops()
            if not batch_ops:
                self.send_event("batch-operation-result", {
                    "success": False,
                    "error": "æ‰¹é‡æ“ä½œç³»çµ±æœªåˆå§‹åŒ–"
                })
                return
            
            result = await batch_ops.batch_add_to_dnc(lead_ids)
            
            if result.get('success'):
                self.send_log(f"æ‰¹é‡æ·»åŠ åˆ° DNC å®Œæˆ: {result.get('successCount')}/{len(lead_ids)} æˆåŠŸ", "success")
            else:
                self.send_log(f"æ‰¹é‡æ·»åŠ åˆ° DNC å¤±æ•—: {result.get('error')}", "error")
            
            self.send_event("batch-operation-result", result)
            
        except Exception as e:
            self.send_log(f"æ‰¹é‡æ·»åŠ åˆ° DNC å¤±æ•—: {str(e)}", "error")
            self.send_event("batch-operation-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_batch_remove_from_dnc(self, payload: Dict[str, Any]):
        """æ‰¹é‡å¾ DNC åˆ—è¡¨ç§»é™¤"""
        try:
            lead_ids = payload.get('leadIds', [])
            
            if not lead_ids:
                self.send_event("batch-operation-result", {
                    "success": False,
                    "error": "æœªé¸æ“‡ä»»ä½• Lead"
                })
                return
            
            batch_ops = get_batch_ops()
            if not batch_ops:
                self.send_event("batch-operation-result", {
                    "success": False,
                    "error": "æ‰¹é‡æ“ä½œç³»çµ±æœªåˆå§‹åŒ–"
                })
                return
            
            result = await batch_ops.batch_remove_from_dnc(lead_ids)
            
            if result.get('success'):
                self.send_log(f"æ‰¹é‡å¾ DNC ç§»é™¤å®Œæˆ: {result.get('successCount')}/{len(lead_ids)} æˆåŠŸ", "success")
            else:
                self.send_log(f"æ‰¹é‡å¾ DNC ç§»é™¤å¤±æ•—: {result.get('error')}", "error")
            
            self.send_event("batch-operation-result", result)
            
        except Exception as e:
            self.send_log(f"æ‰¹é‡å¾ DNC ç§»é™¤å¤±æ•—: {str(e)}", "error")
            self.send_event("batch-operation-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_batch_update_funnel_stage(self, payload: Dict[str, Any]):
        """æ‰¹é‡æ›´æ–°æ¼æ–—éšæ®µ"""
        try:
            lead_ids = payload.get('leadIds', [])
            new_stage = payload.get('newStage')
            
            if not lead_ids:
                self.send_event("batch-operation-result", {
                    "success": False,
                    "error": "æœªé¸æ“‡ä»»ä½• Lead"
                })
                return
            
            if not new_stage:
                self.send_event("batch-operation-result", {
                    "success": False,
                    "error": "æœªæŒ‡å®šæ–°éšæ®µ"
                })
                return
            
            batch_ops = get_batch_ops()
            if not batch_ops:
                self.send_event("batch-operation-result", {
                    "success": False,
                    "error": "æ‰¹é‡æ“ä½œç³»çµ±æœªåˆå§‹åŒ–"
                })
                return
            
            result = await batch_ops.batch_update_funnel_stage(lead_ids, new_stage)
            
            if result.get('success'):
                self.send_log(f"æ‰¹é‡æ›´æ–°æ¼æ–—éšæ®µå®Œæˆ: {result.get('successCount')}/{len(lead_ids)} æˆåŠŸ", "success")
            else:
                self.send_log(f"æ‰¹é‡æ›´æ–°æ¼æ–—éšæ®µå¤±æ•—: {result.get('error')}", "error")
            
            self.send_event("batch-operation-result", result)
            
        except Exception as e:
            self.send_log(f"æ‰¹é‡æ›´æ–°æ¼æ–—éšæ®µå¤±æ•—: {str(e)}", "error")
            self.send_event("batch-operation-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_batch_delete_leads(self, payload: Dict[str, Any]):
        """æ‰¹é‡åˆªé™¤ Lead"""
        try:
            lead_ids = payload.get('leadIds', [])
            
            self.send_log(f"æ”¶åˆ°æ‰¹é‡åˆªé™¤è«‹æ±‚: {len(lead_ids)} å€‹ Lead, IDs: {lead_ids[:10]}{'...' if len(lead_ids) > 10 else ''}", "info")
            
            if not lead_ids:
                self.send_event("batch-operation-result", {
                    "success": False,
                    "error": "æœªé¸æ“‡ä»»ä½• Lead"
                })
                return
            
            # ä½¿ç”¨ database çš„ batch_delete_leads æ–¹æ³•
            result = await db.batch_delete_leads(lead_ids)
            
            success_count = result.get('deleted', 0)
            failed = result.get('failed', [])
            
            self.send_log(f"æ‰¹é‡åˆªé™¤å®Œæˆ: {success_count}/{len(lead_ids)} æˆåŠŸ", "success" if success_count > 0 else "warning")
            
            if failed:
                self.send_log(f"åˆªé™¤å¤±æ•—çš„ ID: {failed}", "warning")
            
            # åˆ·æ–° leads åˆ—è¡¨ï¼ˆåŒ…å«ç¸½æ•¸ï¼‰
            data = await db.get_leads_with_total()
            self.send_log(f"åˆ·æ–°å¾Œå‰©é¤˜ {data['total']} å€‹ Leadï¼ˆé¡¯ç¤º {len(data['leads'])} å€‹ï¼‰", "info")
            self.send_event("leads-updated", {"leads": data['leads'], "total": data['total']})
            
            self.send_event("batch-operation-result", {
                "success": success_count > 0,
                "successCount": success_count,
                "failureCount": len(lead_ids) - success_count
            })
            
        except Exception as e:
            self.send_log(f"æ‰¹é‡åˆªé™¤å¤±æ•—: {str(e)}", "error")
            import traceback
            traceback.print_exc()
            self.send_event("batch-operation-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_delete_lead(self, payload: Dict[str, Any]):
        """åˆªé™¤å–®å€‹ Lead"""
        try:
            lead_id = payload.get('leadId')
            
            self.send_log(f"æ”¶åˆ°åˆªé™¤è«‹æ±‚: Lead ID = {lead_id}", "info")
            
            if not lead_id:
                self.send_event("lead-deleted", {
                    "success": False,
                    "error": "æœªæä¾› Lead ID"
                })
                return
            
            result = await db.delete_lead(lead_id)
            
            if result:
                self.send_log(f"âœ“ å·²åˆªé™¤ Lead: {lead_id}", "success")
                # åˆ·æ–° leads åˆ—è¡¨ï¼ˆåŒ…å«ç¸½æ•¸ï¼‰
                data = await db.get_leads_with_total()
                self.send_log(f"åˆ·æ–°å¾Œå‰©é¤˜ {data['total']} å€‹ Leadï¼ˆé¡¯ç¤º {len(data['leads'])} å€‹ï¼‰", "info")
                self.send_event("leads-updated", {"leads": data['leads'], "total": data['total']})
                self.send_event("lead-deleted", {"success": True, "leadId": lead_id})
            else:
                self.send_log(f"âœ— åˆªé™¤ Lead {lead_id} å¤±æ•— (è¨˜éŒ„å¯èƒ½ä¸å­˜åœ¨)", "warning")
                self.send_event("lead-deleted", {"success": False, "error": "åˆªé™¤å¤±æ•— - è¨˜éŒ„å¯èƒ½ä¸å­˜åœ¨"})
                
        except Exception as e:
            self.send_log(f"åˆªé™¤ Lead å¤±æ•—: {str(e)}", "error")
            import traceback
            traceback.print_exc()
            self.send_event("lead-deleted", {"success": False, "error": str(e)})
    
    async def handle_invite_lead_to_collab_group(self, payload: Dict[str, Any]):
        """é‚€è«‹ Lead é€²å…¥å”ä½œç¾¤çµ„"""
        try:
            lead_id = payload.get('leadId')
            user_id = payload.get('userId')
            username = payload.get('username')
            group_id = payload.get('groupId')
            
            if not user_id or not group_id:
                self.send_event("invite-result", {
                    "success": False,
                    "error": "ç¼ºå°‘ç”¨æˆ¶ ID æˆ–ç¾¤çµ„ ID"
                })
                return
            
            self.send_log(f"ğŸ”— æ­£åœ¨é‚€è«‹ @{username or user_id} é€²å…¥å”ä½œç¾¤çµ„ {group_id}", "info")
            
            # ç²å–å”ä½œç¾¤çµ„ä¿¡æ¯
            collab_group = await db.fetch_one(
                'SELECT * FROM collab_groups WHERE id = ?',
                (group_id,)
            )
            
            if not collab_group:
                self.send_event("invite-result", {
                    "success": False,
                    "error": "å”ä½œç¾¤çµ„ä¸å­˜åœ¨"
                })
                return
            
            # ç²å–ç™¼é€å¸³è™Ÿï¼ˆç”¨æ–¼é‚€è«‹ï¼‰
            sender_accounts = [a for a in self.telegram_manager.active_clients.keys()]
            if not sender_accounts:
                self.send_event("invite-result", {
                    "success": False,
                    "error": "æ²’æœ‰å¯ç”¨çš„ç™¼é€å¸³è™Ÿ"
                })
                return
            
            # ä½¿ç”¨ç¬¬ä¸€å€‹å¯ç”¨çš„å¸³è™Ÿç™¼é€é‚€è«‹
            sender_phone = sender_accounts[0]
            client = self.telegram_manager.get_client(sender_phone)
            
            if client and client.is_connected():
                try:
                    # å˜—è©¦é‚€è«‹ç”¨æˆ¶
                    from telethon.tl.functions.channels import InviteToChannelRequest
                    from telethon.tl.functions.messages import AddChatUserRequest
                    
                    # ç²å–ç›®æ¨™ç”¨æˆ¶å¯¦é«”
                    target_user = await client.get_entity(int(user_id))
                    
                    # ç²å–ç¾¤çµ„å¯¦é«”
                    group_chat_id = collab_group.get('chat_id')
                    if group_chat_id:
                        group_entity = await client.get_entity(int(group_chat_id))
                        
                        # é‚€è«‹ç”¨æˆ¶
                        await client(InviteToChannelRequest(
                            channel=group_entity,
                            users=[target_user]
                        ))
                        
                        self.send_log(f"âœ“ å·²æˆåŠŸé‚€è«‹ @{username or user_id} é€²å…¥ç¾¤çµ„", "success")
                        self.send_event("invite-result", {
                            "success": True,
                            "userId": user_id,
                            "groupId": group_id
                        })
                        
                        # æ›´æ–° lead ç‹€æ…‹
                        await db.execute(
                            'UPDATE extracted_members SET invited = 1, invited_at = CURRENT_TIMESTAMP WHERE user_id = ?',
                            (str(user_id),)
                        )
                    else:
                        self.send_event("invite-result", {
                            "success": False,
                            "error": "å”ä½œç¾¤çµ„æœªå‰µå»º Telegram ç¾¤"
                        })
                        
                except Exception as e:
                    self.send_log(f"é‚€è«‹å¤±æ•—: {str(e)}", "error")
                    self.send_event("invite-result", {
                        "success": False,
                        "error": str(e)
                    })
            else:
                self.send_event("invite-result", {
                    "success": False,
                    "error": "ç™¼é€å¸³è™Ÿæœªé€£æ¥"
                })
                
        except Exception as e:
            self.send_log(f"é‚€è«‹ Lead é€²ç¾¤å¤±æ•—: {str(e)}", "error")
            import traceback
            traceback.print_exc()
            self.send_event("invite-result", {"success": False, "error": str(e)})
    
    async def handle_create_collab_group_for_lead(self, payload: Dict[str, Any]):
        """ç‚ºé«˜æ„å‘å®¢æˆ¶è‡ªå‹•å‰µå»ºå”ä½œç¾¤çµ„"""
        try:
            lead_id = payload.get('leadId')
            user_id = payload.get('userId')
            username = payload.get('username')
            script_id = payload.get('scriptId')  # ä½¿ç”¨çš„åŠ‡æœ¬ ID
            
            if not user_id:
                self.send_event("create-collab-group-result", {
                    "success": False,
                    "error": "ç¼ºå°‘ç”¨æˆ¶ ID"
                })
                return
            
            self.send_log(f"ğŸ­ æ­£åœ¨ç‚º @{username or user_id} å‰µå»ºå¤šè§’è‰²å”ä½œç¾¤çµ„", "info")
            
            # å‰µå»ºå”ä½œç¾¤çµ„è¨˜éŒ„
            group_name = f"VIP-{username or user_id[:8]}"
            
            await db.execute('''
                INSERT INTO collab_groups (name, target_user_id, script_id, status, created_at)
                VALUES (?, ?, ?, 'pending', CURRENT_TIMESTAMP)
            ''', (group_name, str(user_id), script_id))
            
            # ç²å–å‰µå»ºçš„ç¾¤çµ„ ID
            result = await db.fetch_one(
                'SELECT id FROM collab_groups WHERE target_user_id = ? ORDER BY created_at DESC LIMIT 1',
                (str(user_id),)
            )
            
            if result:
                self.send_log(f"âœ“ å”ä½œç¾¤çµ„ '{group_name}' å‰µå»ºæˆåŠŸ", "success")
                self.send_event("create-collab-group-result", {
                    "success": True,
                    "groupId": result['id'],
                    "groupName": group_name
                })
                
                # æ›´æ–° lead ç‹€æ…‹
                await db.execute(
                    'UPDATE extracted_members SET notes = notes || ? WHERE user_id = ?',
                    (f'\nğŸ­ å·²å‰µå»ºå”ä½œç¾¤çµ„: {group_name}', str(user_id))
                )
            else:
                self.send_event("create-collab-group-result", {
                    "success": False,
                    "error": "å‰µå»ºç¾¤çµ„è¨˜éŒ„å¤±æ•—"
                })
                
        except Exception as e:
            self.send_log(f"å‰µå»ºå”ä½œç¾¤çµ„å¤±æ•—: {str(e)}", "error")
            import traceback
            traceback.print_exc()
            self.send_event("create-collab-group-result", {"success": False, "error": str(e)})

    async def handle_undo_batch_operation(self, payload: Dict[str, Any]):
        """æ’¤éŠ·æ‰¹é‡æ“ä½œ"""
        try:
            operation_id = payload.get('operationId')
            
            if not operation_id:
                self.send_event("batch-undo-result", {
                    "success": False,
                    "error": "æœªæŒ‡å®šæ“ä½œ ID"
                })
                return
            
            batch_ops = get_batch_ops()
            if not batch_ops:
                self.send_event("batch-undo-result", {
                    "success": False,
                    "error": "æ‰¹é‡æ“ä½œç³»çµ±æœªåˆå§‹åŒ–"
                })
                return
            
            result = await batch_ops.undo_operation(operation_id)
            
            if result.get('success'):
                self.send_log(f"æ’¤éŠ·æ“ä½œæˆåŠŸ: {operation_id}", "success")
            else:
                self.send_log(f"æ’¤éŠ·æ“ä½œå¤±æ•—: {result.get('error')}", "error")
            
            self.send_event("batch-undo-result", result)
            
        except Exception as e:
            self.send_log(f"æ’¤éŠ·æ“ä½œå¤±æ•—: {str(e)}", "error")
            self.send_event("batch-undo-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_batch_operation_history(self, payload: Dict[str, Any]):
        """ç²å–æ‰¹é‡æ“ä½œæ­·å²"""
        try:
            limit = payload.get('limit', 50)
            offset = payload.get('offset', 0)
            operation_type = payload.get('operationType')
            
            batch_ops = get_batch_ops()
            if not batch_ops:
                self.send_event("batch-operation-history", {
                    "success": False,
                    "error": "æ‰¹é‡æ“ä½œç³»çµ±æœªåˆå§‹åŒ–"
                })
                return
            
            result = await batch_ops.get_operation_history(limit, offset, operation_type)
            
            self.send_event("batch-operation-history", result)
            
        except Exception as e:
            self.send_log(f"ç²å–æ“ä½œæ­·å²å¤±æ•—: {str(e)}", "error")
            self.send_event("batch-operation-history", {
                "success": False,
                "error": str(e)
            })
    
    # ==================== Search History Handlers ====================
    
    async def handle_get_search_history(self, payload: Dict[str, Any]):
        """ç²å–æœç´¢æ­·å²è¨˜éŒ„"""
        try:
            from search_history_service import get_search_history_service
            search_history = get_search_history_service()
            
            keyword = payload.get('keyword')
            limit = payload.get('limit', 50)
            offset = payload.get('offset', 0)
            
            results = search_history.get_search_history(keyword, limit, offset)
            
            self.send_event("search-history-result", {
                "success": True,
                "history": results,
                "total": len(results)
            })
            
        except Exception as e:
            self.send_log(f"ç²å–æœç´¢æ­·å²å¤±æ•—: {str(e)}", "error")
            self.send_event("search-history-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_search_results_by_id(self, payload: Dict[str, Any]):
        """ç²å–æŸæ¬¡æœç´¢çš„çµæœ"""
        try:
            from search_history_service import get_search_history_service
            search_history = get_search_history_service()
            
            search_id = payload.get('searchId')
            if not search_id:
                self.send_event("search-results-by-id", {
                    "success": False,
                    "error": "ç¼ºå°‘ searchId åƒæ•¸"
                })
                return
            
            results = search_history.get_search_results(search_id)
            
            self.send_event("search-results-by-id", {
                "success": True,
                "results": results,
                "total": len(results)
            })
            
        except Exception as e:
            self.send_log(f"ç²å–æœç´¢çµæœå¤±æ•—: {str(e)}", "error")
            self.send_event("search-results-by-id", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_search_statistics(self, payload: Dict[str, Any]):
        """ç²å–æœç´¢çµ±è¨ˆä¿¡æ¯"""
        try:
            from search_history_service import get_search_history_service
            search_history = get_search_history_service()
            
            stats = search_history.get_statistics()
            
            self.send_event("search-statistics-result", {
                "success": True,
                **stats
            })
            
        except Exception as e:
            self.send_log(f"ç²å–æœç´¢çµ±è¨ˆå¤±æ•—: {str(e)}", "error")
            self.send_event("search-statistics-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_resource_history(self, payload: Dict[str, Any]):
        """ç²å–è³‡æºçš„æ­·å²è¨˜éŒ„"""
        try:
            from search_history_service import get_search_history_service
            search_history = get_search_history_service()
            
            resource_id = payload.get('resourceId')
            username = payload.get('username')
            telegram_id = payload.get('telegramId')
            
            result = search_history.get_resource_history(
                resource_id=resource_id,
                username=username,
                telegram_id=telegram_id
            )
            
            if result:
                self.send_event("resource-history-result", {
                    "success": True,
                    **result
                })
            else:
                self.send_event("resource-history-result", {
                    "success": False,
                    "error": "è³‡æºä¸å­˜åœ¨"
                })
            
        except Exception as e:
            self.send_log(f"ç²å–è³‡æºæ­·å²å¤±æ•—: {str(e)}", "error")
            self.send_event("resource-history-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_cleanup_search_history(self, payload: Dict[str, Any]):
        """æ¸…ç†èˆŠçš„æœç´¢è¨˜éŒ„"""
        try:
            from search_history_service import get_search_history_service
            search_history = get_search_history_service()
            
            days = payload.get('days', 30)
            deleted = search_history.cleanup_old_records(days)
            
            self.send_log(f"å·²æ¸…ç† {deleted} æ¢èˆŠæœç´¢è¨˜éŒ„", "success")
            self.send_event("cleanup-search-history-result", {
                "success": True,
                "deleted": deleted
            })
            
        except Exception as e:
            self.send_log(f"æ¸…ç†æœç´¢æ­·å²å¤±æ•—: {str(e)}", "error")
            self.send_event("cleanup-search-history-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_all_tags(self):
        """ç²å–æ‰€æœ‰æ¨™ç±¤"""
        try:
            batch_ops = get_batch_ops()
            if not batch_ops:
                self.send_event("all-tags", {
                    "success": False,
                    "error": "æ‰¹é‡æ“ä½œç³»çµ±æœªåˆå§‹åŒ–"
                })
                return
            
            result = await batch_ops.get_all_tags()
            
            self.send_event("all-tags", result)
            
        except Exception as e:
            self.send_log(f"ç²å–æ¨™ç±¤åˆ—è¡¨å¤±æ•—: {str(e)}", "error")
            self.send_event("all-tags", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_create_tag(self, payload: Dict[str, Any]):
        """å‰µå»ºæ–°æ¨™ç±¤"""
        try:
            name = payload.get('name')
            color = payload.get('color', '#3B82F6')
            
            if not name:
                self.send_event("tag-created", {
                    "success": False,
                    "error": "æ¨™ç±¤åç¨±ä¸èƒ½ç‚ºç©º"
                })
                return
            
            batch_ops = get_batch_ops()
            if not batch_ops:
                self.send_event("tag-created", {
                    "success": False,
                    "error": "æ‰¹é‡æ“ä½œç³»çµ±æœªåˆå§‹åŒ–"
                })
                return
            
            result = await batch_ops.create_tag(name, color)
            
            if result.get('success'):
                self.send_log(f"å‰µå»ºæ¨™ç±¤æˆåŠŸ: {name}", "success")
            else:
                self.send_log(f"å‰µå»ºæ¨™ç±¤å¤±æ•—: {result.get('error')}", "error")
            
            self.send_event("tag-created", result)
            
        except Exception as e:
            self.send_log(f"å‰µå»ºæ¨™ç±¤å¤±æ•—: {str(e)}", "error")
            self.send_event("tag-created", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_delete_tag(self, payload: Dict[str, Any]):
        """åˆªé™¤æ¨™ç±¤"""
        try:
            name = payload.get('name')
            
            if not name:
                self.send_event("tag-deleted", {
                    "success": False,
                    "error": "æ¨™ç±¤åç¨±ä¸èƒ½ç‚ºç©º"
                })
                return
            
            batch_ops = get_batch_ops()
            if not batch_ops:
                self.send_event("tag-deleted", {
                    "success": False,
                    "error": "æ‰¹é‡æ“ä½œç³»çµ±æœªåˆå§‹åŒ–"
                })
                return
            
            result = await batch_ops.delete_tag(name)
            
            if result.get('success'):
                self.send_log(f"åˆªé™¤æ¨™ç±¤æˆåŠŸ: {name}", "success")
            else:
                self.send_log(f"åˆªé™¤æ¨™ç±¤å¤±æ•—: {result.get('error')}", "error")
            
            self.send_event("tag-deleted", result)
            
        except Exception as e:
            self.send_log(f"åˆªé™¤æ¨™ç±¤å¤±æ•—: {str(e)}", "error")
            self.send_event("tag-deleted", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_lead_tags(self, payload: Dict[str, Any]):
        """ç²å– Lead çš„æ¨™ç±¤"""
        try:
            lead_id = payload.get('leadId')
            
            if not lead_id:
                self.send_event("lead-tags", {
                    "success": False,
                    "error": "Lead ID ä¸èƒ½ç‚ºç©º"
                })
                return
            
            batch_ops = get_batch_ops()
            if not batch_ops:
                self.send_event("lead-tags", {
                    "success": False,
                    "error": "æ‰¹é‡æ“ä½œç³»çµ±æœªåˆå§‹åŒ–"
                })
                return
            
            result = await batch_ops.get_lead_tags(lead_id)
            result['leadId'] = lead_id
            
            self.send_event("lead-tags", result)
            
        except Exception as e:
            self.send_log(f"ç²å– Lead æ¨™ç±¤å¤±æ•—: {str(e)}", "error")
            self.send_event("lead-tags", {
                "success": False,
                "error": str(e)
            })
    
    # ==================== Ad System Handlers (å»£å‘Šç™¼é€ç³»çµ±) ====================
    
    async def handle_create_ad_template(self, payload: Dict[str, Any]):
        """å‰µå»ºå»£å‘Šæ¨¡æ¿"""
        try:
            template_manager = get_ad_template_manager()
            if not template_manager:
                self.send_event("ad-template-created", {"success": False, "error": "å»£å‘Šç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            result = await template_manager.create_template(
                name=payload.get('name', ''),
                content=payload.get('content', ''),
                media_type=payload.get('mediaType', 'text'),
                media_file_id=payload.get('mediaFileId'),
                media_path=payload.get('mediaPath')
            )
            
            if result.get('success'):
                self.send_log(f"å»£å‘Šæ¨¡æ¿å·²å‰µå»º: {result.get('name')}", "success")
            
            self.send_event("ad-template-created", result)
            
        except Exception as e:
            self.send_event("ad-template-created", {"success": False, "error": str(e)})
    
    async def handle_update_ad_template(self, payload: Dict[str, Any]):
        """æ›´æ–°å»£å‘Šæ¨¡æ¿"""
        try:
            template_manager = get_ad_template_manager()
            if not template_manager:
                self.send_event("ad-template-updated", {"success": False, "error": "å»£å‘Šç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            template_id = payload.get('templateId')
            updates = payload.get('updates', {})
            
            result = await template_manager.update_template(template_id, updates)
            
            self.send_event("ad-template-updated", result)
            
        except Exception as e:
            self.send_event("ad-template-updated", {"success": False, "error": str(e)})
    
    async def handle_delete_ad_template(self, payload: Dict[str, Any]):
        """åˆªé™¤å»£å‘Šæ¨¡æ¿"""
        try:
            template_manager = get_ad_template_manager()
            if not template_manager:
                self.send_event("ad-template-deleted", {"success": False, "error": "å»£å‘Šç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            template_id = payload.get('templateId')
            result = await template_manager.delete_template(template_id)
            
            if result.get('success'):
                self.send_log(f"å»£å‘Šæ¨¡æ¿å·²åˆªé™¤: ID {template_id}", "info")
            
            self.send_event("ad-template-deleted", result)
            
        except Exception as e:
            self.send_event("ad-template-deleted", {"success": False, "error": str(e)})
    
    async def handle_get_ad_templates(self, payload: Dict[str, Any]):
        """ç²å–å»£å‘Šæ¨¡æ¿åˆ—è¡¨"""
        try:
            template_manager = get_ad_template_manager()
            if not template_manager:
                self.send_event("ad-templates", {"success": False, "error": "å»£å‘Šç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            active_only = payload.get('activeOnly', False)
            templates = await template_manager.get_all_templates(active_only)
            
            self.send_event("ad-templates", {
                "success": True,
                "templates": [t.to_dict() for t in templates]
            })
            
        except Exception as e:
            self.send_event("ad-templates", {"success": False, "error": str(e)})
    
    async def handle_toggle_ad_template_status(self, payload: Dict[str, Any]):
        """åˆ‡æ›å»£å‘Šæ¨¡æ¿ç‹€æ…‹"""
        try:
            template_manager = get_ad_template_manager()
            if not template_manager:
                self.send_event("ad-template-toggled", {"success": False, "error": "å»£å‘Šç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            template_id = payload.get('templateId')
            result = await template_manager.toggle_template_status(template_id)
            
            self.send_event("ad-template-toggled", result)
            
        except Exception as e:
            self.send_event("ad-template-toggled", {"success": False, "error": str(e)})
    
    async def handle_preview_ad_template(self, payload: Dict[str, Any]):
        """é è¦½å»£å‘Šæ¨¡æ¿è®Šé«”"""
        try:
            template_manager = get_ad_template_manager()
            if not template_manager:
                self.send_event("ad-template-preview", {"success": False, "error": "å»£å‘Šç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            template_id = payload.get('templateId')
            count = payload.get('count', 5)
            
            result = await template_manager.preview_template(template_id, count)
            
            self.send_event("ad-template-preview", result)
            
        except Exception as e:
            self.send_event("ad-template-preview", {"success": False, "error": str(e)})
    
    async def handle_validate_spintax(self, payload: Dict[str, Any]):
        """é©—è­‰ Spintax èªæ³•"""
        try:
            content = payload.get('content', '')
            result = SpintaxGenerator.preview_variants(content, 5)
            result['success'] = result.get('valid', False)
            
            self.send_event("spintax-validated", result)
            
        except Exception as e:
            self.send_event("spintax-validated", {"success": False, "error": str(e)})
    
    async def handle_create_ad_schedule(self, payload: Dict[str, Any]):
        """å‰µå»ºå»£å‘Šè¨ˆåŠƒ"""
        try:
            ad_manager = get_ad_manager()
            if not ad_manager:
                self.send_event("ad-schedule-created", {"success": False, "error": "å»£å‘Šç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            result = await ad_manager.create_schedule(
                template_id=payload.get('templateId'),
                name=payload.get('name', ''),
                target_groups=payload.get('targetGroups', []),
                send_mode=payload.get('sendMode', 'scheduled'),
                schedule_type=payload.get('scheduleType', 'once'),
                assigned_accounts=payload.get('assignedAccounts', []),
                schedule_time=payload.get('scheduleTime'),
                interval_minutes=payload.get('intervalMinutes', 60),
                trigger_keywords=payload.get('triggerKeywords', []),
                account_strategy=payload.get('accountStrategy', 'single')
            )
            
            if result.get('success'):
                self.send_log(f"å»£å‘Šè¨ˆåŠƒå·²å‰µå»º: {result.get('name')}", "success")
                # Reload triggers if needed
                scheduler = get_ad_scheduler()
                if scheduler:
                    await scheduler.reload_triggers()
            
            self.send_event("ad-schedule-created", result)
            
        except Exception as e:
            self.send_event("ad-schedule-created", {"success": False, "error": str(e)})
    
    async def handle_update_ad_schedule(self, payload: Dict[str, Any]):
        """æ›´æ–°å»£å‘Šè¨ˆåŠƒ"""
        try:
            ad_manager = get_ad_manager()
            if not ad_manager:
                self.send_event("ad-schedule-updated", {"success": False, "error": "å»£å‘Šç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            schedule_id = payload.get('scheduleId')
            updates = payload.get('updates', {})
            
            result = await ad_manager.update_schedule(schedule_id, updates)
            
            if result.get('success'):
                scheduler = get_ad_scheduler()
                if scheduler:
                    await scheduler.reload_triggers()
            
            self.send_event("ad-schedule-updated", result)
            
        except Exception as e:
            self.send_event("ad-schedule-updated", {"success": False, "error": str(e)})
    
    async def handle_delete_ad_schedule(self, payload: Dict[str, Any]):
        """åˆªé™¤å»£å‘Šè¨ˆåŠƒ"""
        try:
            ad_manager = get_ad_manager()
            if not ad_manager:
                self.send_event("ad-schedule-deleted", {"success": False, "error": "å»£å‘Šç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            schedule_id = payload.get('scheduleId')
            result = await ad_manager.delete_schedule(schedule_id)
            
            if result.get('success'):
                self.send_log(f"å»£å‘Šè¨ˆåŠƒå·²åˆªé™¤: ID {schedule_id}", "info")
                scheduler = get_ad_scheduler()
                if scheduler:
                    await scheduler.reload_triggers()
            
            self.send_event("ad-schedule-deleted", result)
            
        except Exception as e:
            self.send_event("ad-schedule-deleted", {"success": False, "error": str(e)})
    
    async def handle_get_ad_schedules(self, payload: Dict[str, Any]):
        """ç²å–å»£å‘Šè¨ˆåŠƒåˆ—è¡¨"""
        try:
            ad_manager = get_ad_manager()
            if not ad_manager:
                self.send_event("ad-schedules", {"success": False, "error": "å»£å‘Šç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            active_only = payload.get('activeOnly', False)
            schedules = await ad_manager.get_all_schedules(active_only)
            
            self.send_event("ad-schedules", {
                "success": True,
                "schedules": [s.to_dict() for s in schedules]
            })
            
        except Exception as e:
            self.send_event("ad-schedules", {"success": False, "error": str(e)})
    
    async def handle_toggle_ad_schedule_status(self, payload: Dict[str, Any]):
        """åˆ‡æ›å»£å‘Šè¨ˆåŠƒç‹€æ…‹"""
        try:
            ad_manager = get_ad_manager()
            if not ad_manager:
                self.send_event("ad-schedule-toggled", {"success": False, "error": "å»£å‘Šç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            schedule_id = payload.get('scheduleId')
            result = await ad_manager.toggle_schedule_status(schedule_id)
            
            if result.get('success'):
                scheduler = get_ad_scheduler()
                if scheduler:
                    await scheduler.reload_triggers()
            
            self.send_event("ad-schedule-toggled", result)
            
        except Exception as e:
            self.send_event("ad-schedule-toggled", {"success": False, "error": str(e)})
    
    async def handle_run_ad_schedule_now(self, payload: Dict[str, Any]):
        """ç«‹å³åŸ·è¡Œå»£å‘Šè¨ˆåŠƒ"""
        try:
            scheduler = get_ad_scheduler()
            if not scheduler:
                self.send_event("ad-schedule-run-result", {"success": False, "error": "å»£å‘Šæ’ç¨‹å™¨æœªåˆå§‹åŒ–"})
                return
            
            schedule_id = payload.get('scheduleId')
            result = await scheduler.run_schedule_now(schedule_id)
            
            self.send_event("ad-schedule-run-result", result)
            
        except Exception as e:
            self.send_event("ad-schedule-run-result", {"success": False, "error": str(e)})
    
    async def handle_send_ad_now(self, payload: Dict[str, Any]):
        """ç«‹å³ç™¼é€å»£å‘Š"""
        try:
            broadcaster = get_ad_broadcaster()
            if not broadcaster:
                self.send_event("ad-send-result", {"success": False, "error": "å»£å‘Šç™¼é€å™¨æœªåˆå§‹åŒ–"})
                return
            
            result = await broadcaster.send_now(
                template_id=payload.get('templateId'),
                target_groups=payload.get('targetGroups', []),
                account_phones=payload.get('accountPhones', []),
                account_strategy=payload.get('accountStrategy', 'rotate')
            )
            
            self.send_event("ad-send-result", result)
            
        except Exception as e:
            self.send_event("ad-send-result", {"success": False, "error": str(e)})
    
    async def handle_get_ad_send_logs(self, payload: Dict[str, Any]):
        """ç²å–å»£å‘Šç™¼é€è¨˜éŒ„"""
        try:
            ad_manager = get_ad_manager()
            if not ad_manager:
                self.send_event("ad-send-logs", {"success": False, "error": "å»£å‘Šç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            result = await ad_manager.get_send_logs(
                limit=payload.get('limit', 100),
                offset=payload.get('offset', 0),
                template_id=payload.get('templateId'),
                schedule_id=payload.get('scheduleId'),
                status=payload.get('status')
            )
            
            self.send_event("ad-send-logs", result)
            
        except Exception as e:
            self.send_event("ad-send-logs", {"success": False, "error": str(e)})
    
    async def handle_get_ad_overview_stats(self, payload: Dict[str, Any]):
        """ç²å–å»£å‘Šç¸½è¦½çµ±è¨ˆ"""
        try:
            analytics = get_ad_analytics()
            if not analytics:
                self.send_event("ad-overview-stats", {"success": False, "error": "å»£å‘Šåˆ†ææœªåˆå§‹åŒ–"})
                return
            
            days = payload.get('days', 7)
            result = await analytics.get_overview_stats(days)
            
            self.send_event("ad-overview-stats", result)
            
        except Exception as e:
            self.send_event("ad-overview-stats", {"success": False, "error": str(e)})
    
    async def handle_get_ad_template_stats(self, payload: Dict[str, Any]):
        """ç²å–æ¨¡æ¿çµ±è¨ˆ"""
        try:
            analytics = get_ad_analytics()
            if not analytics:
                self.send_event("ad-template-stats", {"success": False, "error": "å»£å‘Šåˆ†ææœªåˆå§‹åŒ–"})
                return
            
            template_id = payload.get('templateId')
            result = await analytics.get_template_stats(template_id)
            
            self.send_event("ad-template-stats", result)
            
        except Exception as e:
            self.send_event("ad-template-stats", {"success": False, "error": str(e)})
    
    async def handle_get_ad_schedule_stats(self, payload: Dict[str, Any]):
        """ç²å–è¨ˆåŠƒçµ±è¨ˆ"""
        try:
            analytics = get_ad_analytics()
            if not analytics:
                self.send_event("ad-schedule-stats", {"success": False, "error": "å»£å‘Šåˆ†ææœªåˆå§‹åŒ–"})
                return
            
            schedule_id = payload.get('scheduleId')
            result = await analytics.get_schedule_stats(schedule_id)
            
            self.send_event("ad-schedule-stats", result)
            
        except Exception as e:
            self.send_event("ad-schedule-stats", {"success": False, "error": str(e)})
    
    async def handle_get_ad_account_stats(self, payload: Dict[str, Any]):
        """ç²å–å¸³è™Ÿçµ±è¨ˆ"""
        try:
            analytics = get_ad_analytics()
            if not analytics:
                self.send_event("ad-account-stats", {"success": False, "error": "å»£å‘Šåˆ†ææœªåˆå§‹åŒ–"})
                return
            
            days = payload.get('days', 7)
            result = await analytics.get_account_stats(days)
            
            self.send_event("ad-account-stats", result)
            
        except Exception as e:
            self.send_event("ad-account-stats", {"success": False, "error": str(e)})
    
    async def handle_get_ad_group_stats(self, payload: Dict[str, Any]):
        """ç²å–ç¾¤çµ„çµ±è¨ˆ"""
        try:
            analytics = get_ad_analytics()
            if not analytics:
                self.send_event("ad-group-stats", {"success": False, "error": "å»£å‘Šåˆ†ææœªåˆå§‹åŒ–"})
                return
            
            days = payload.get('days', 7)
            result = await analytics.get_group_stats(days)
            
            self.send_event("ad-group-stats", result)
            
        except Exception as e:
            self.send_event("ad-group-stats", {"success": False, "error": str(e)})
    
    async def handle_get_ad_daily_stats(self, payload: Dict[str, Any]):
        """ç²å–æ¯æ—¥çµ±è¨ˆ"""
        try:
            analytics = get_ad_analytics()
            if not analytics:
                self.send_event("ad-daily-stats", {"success": False, "error": "å»£å‘Šåˆ†ææœªåˆå§‹åŒ–"})
                return
            
            days = payload.get('days', 30)
            result = await analytics.get_daily_stats(days)
            
            self.send_event("ad-daily-stats", result)
            
        except Exception as e:
            self.send_event("ad-daily-stats", {"success": False, "error": str(e)})
    
    # ==================== User Tracking Handlers (ç”¨æˆ¶è¿½è¹¤ç³»çµ±) ====================
    
    async def handle_add_user_to_track(self, payload: Dict[str, Any]):
        """æ·»åŠ ç”¨æˆ¶åˆ°è¿½è¹¤åˆ—è¡¨"""
        try:
            tracker = get_user_tracker()
            if not tracker:
                self.send_event("user-added-to-track", {"success": False, "error": "ç”¨æˆ¶è¿½è¹¤ç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            result = await tracker.add_user_to_track(
                user_id=payload.get('userId'),
                username=payload.get('username'),
                first_name=payload.get('firstName'),
                last_name=payload.get('lastName'),
                source=payload.get('source', 'manual'),
                source_group_id=payload.get('sourceGroupId'),
                notes=payload.get('notes')
            )
            
            if result.get('success'):
                self.send_log(f"ç”¨æˆ¶å·²æ·»åŠ åˆ°è¿½è¹¤åˆ—è¡¨", "success")
            
            self.send_event("user-added-to-track", result)
            
        except Exception as e:
            self.send_event("user-added-to-track", {"success": False, "error": str(e)})
    
    async def handle_add_user_from_lead(self, payload: Dict[str, Any]):
        """å¾ Lead æ·»åŠ ç”¨æˆ¶åˆ°è¿½è¹¤"""
        try:
            tracker = get_user_tracker()
            if not tracker:
                self.send_event("user-added-from-lead", {"success": False, "error": "ç”¨æˆ¶è¿½è¹¤ç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            lead_id = payload.get('leadId')
            result = await tracker.add_user_from_lead(lead_id)
            
            self.send_event("user-added-from-lead", result)
            
        except Exception as e:
            self.send_event("user-added-from-lead", {"success": False, "error": str(e)})
    
    async def handle_remove_tracked_user(self, payload: Dict[str, Any]):
        """ç§»é™¤è¿½è¹¤ç”¨æˆ¶"""
        try:
            tracker = get_user_tracker()
            if not tracker:
                self.send_event("user-removed", {"success": False, "error": "ç”¨æˆ¶è¿½è¹¤ç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            user_id = payload.get('userId')
            result = await tracker.remove_user(user_id)
            
            if result.get('success'):
                self.send_log(f"ç”¨æˆ¶å·²å¾è¿½è¹¤åˆ—è¡¨ç§»é™¤", "info")
            
            self.send_event("user-removed", result)
            
        except Exception as e:
            self.send_event("user-removed", {"success": False, "error": str(e)})
    
    async def handle_get_tracked_users(self, payload: Dict[str, Any]):
        """ç²å–è¿½è¹¤ç”¨æˆ¶åˆ—è¡¨"""
        try:
            tracker = get_user_tracker()
            if not tracker:
                self.send_event("tracked-users", {"success": False, "error": "ç”¨æˆ¶è¿½è¹¤ç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            result = await tracker.get_all_tracked_users(
                value_level=payload.get('valueLevel'),
                status=payload.get('status'),
                limit=payload.get('limit', 100),
                offset=payload.get('offset', 0)
            )
            
            self.send_event("tracked-users", result)
            
        except Exception as e:
            self.send_event("tracked-users", {"success": False, "error": str(e)})
    
    async def handle_update_user_value_level(self, payload: Dict[str, Any]):
        """æ›´æ–°ç”¨æˆ¶åƒ¹å€¼ç­‰ç´š"""
        try:
            tracker = get_user_tracker()
            if not tracker:
                self.send_event("user-value-updated", {"success": False, "error": "ç”¨æˆ¶è¿½è¹¤ç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            result = await tracker.update_user_value_level(
                user_id=payload.get('userId'),
                value_level=payload.get('valueLevel')
            )
            
            self.send_event("user-value-updated", result)
            
        except Exception as e:
            self.send_event("user-value-updated", {"success": False, "error": str(e)})
    
    async def handle_track_user_groups(self, payload: Dict[str, Any]):
        """è¿½è¹¤ç”¨æˆ¶ç¾¤çµ„"""
        try:
            tracker = get_user_tracker()
            if not tracker:
                self.send_event("user-tracking-completed", {"success": False, "error": "ç”¨æˆ¶è¿½è¹¤ç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            result = await tracker.track_user_groups(
                user_id=payload.get('userId'),
                account_phone=payload.get('accountPhone')
            )
            
            # Event is sent by tracker
            
        except Exception as e:
            self.send_event("user-tracking-failed", {"success": False, "error": str(e)})
    
    async def handle_batch_track_users(self, payload: Dict[str, Any]):
        """æ‰¹é‡è¿½è¹¤ç”¨æˆ¶"""
        try:
            tracker = get_user_tracker()
            if not tracker:
                self.send_event("batch-tracking-completed", {"success": False, "error": "ç”¨æˆ¶è¿½è¹¤ç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            result = await tracker.batch_track_users(
                user_ids=payload.get('userIds', []),
                account_phone=payload.get('accountPhone')
            )
            
            # Event is sent by tracker
            
        except Exception as e:
            self.send_event("batch-tracking-completed", {"success": False, "error": str(e)})
    
    async def handle_get_user_groups(self, payload: Dict[str, Any]):
        """ç²å–ç”¨æˆ¶ç¾¤çµ„"""
        try:
            tracker = get_user_tracker()
            if not tracker:
                self.send_event("user-groups", {"success": False, "error": "ç”¨æˆ¶è¿½è¹¤ç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            result = await tracker.get_user_groups(payload.get('userId'))
            
            self.send_event("user-groups", result)
            
        except Exception as e:
            self.send_event("user-groups", {"success": False, "error": str(e)})
    
    async def handle_get_high_value_groups(self, payload: Dict[str, Any]):
        """ç²å–é«˜åƒ¹å€¼ç¾¤çµ„"""
        try:
            tracker = get_user_tracker()
            if not tracker:
                self.send_event("high-value-groups", {"success": False, "error": "ç”¨æˆ¶è¿½è¹¤ç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            result = await tracker.get_high_value_groups(
                limit=payload.get('limit', 50)
            )
            
            self.send_event("high-value-groups", result)
            
        except Exception as e:
            self.send_event("high-value-groups", {"success": False, "error": str(e)})
    
    async def handle_get_tracking_stats(self, payload: Dict[str, Any]):
        """ç²å–è¿½è¹¤çµ±è¨ˆ"""
        try:
            tracker = get_user_tracker()
            if not tracker:
                self.send_event("tracking-stats", {"success": False, "error": "ç”¨æˆ¶è¿½è¹¤ç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            result = await tracker.get_tracking_stats()
            
            self.send_event("tracking-stats", result)
            
        except Exception as e:
            self.send_event("tracking-stats", {"success": False, "error": str(e)})
    
    async def handle_get_tracking_logs(self, payload: Dict[str, Any]):
        """ç²å–è¿½è¹¤æ—¥èªŒ"""
        try:
            tracker = get_user_tracker()
            if not tracker:
                self.send_event("tracking-logs", {"success": False, "error": "ç”¨æˆ¶è¿½è¹¤ç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            result = await tracker.get_tracking_logs(
                user_id=payload.get('userId'),
                limit=payload.get('limit', 50),
                offset=payload.get('offset', 0)
            )
            
            self.send_event("tracking-logs", result)
            
        except Exception as e:
            self.send_event("tracking-logs", {"success": False, "error": str(e)})
    
    async def handle_get_user_value_distribution(self, payload: Dict[str, Any]):
        """ç²å–ç”¨æˆ¶åƒ¹å€¼åˆ†ä½ˆ"""
        try:
            analytics = get_user_analytics()
            if not analytics:
                self.send_event("user-value-distribution", {"success": False, "error": "ç”¨æˆ¶åˆ†ææœªåˆå§‹åŒ–"})
                return
            
            result = await analytics.get_user_value_distribution()
            
            self.send_event("user-value-distribution", result)
            
        except Exception as e:
            self.send_event("user-value-distribution", {"success": False, "error": str(e)})
    
    async def handle_get_group_overlap_analysis(self, payload: Dict[str, Any]):
        """ç²å–ç¾¤çµ„é‡ç–Šåˆ†æ"""
        try:
            analytics = get_user_analytics()
            if not analytics:
                self.send_event("group-overlap-analysis", {"success": False, "error": "ç”¨æˆ¶åˆ†ææœªåˆå§‹åŒ–"})
                return
            
            result = await analytics.get_group_overlap_analysis(
                min_overlap=payload.get('minOverlap', 2)
            )
            
            self.send_event("group-overlap-analysis", result)
            
        except Exception as e:
            self.send_event("group-overlap-analysis", {"success": False, "error": str(e)})
    
    async def handle_get_tracking_effectiveness(self, payload: Dict[str, Any]):
        """ç²å–è¿½è¹¤æ•ˆç‡"""
        try:
            analytics = get_user_analytics()
            if not analytics:
                self.send_event("tracking-effectiveness", {"success": False, "error": "ç”¨æˆ¶åˆ†ææœªåˆå§‹åŒ–"})
                return
            
            result = await analytics.get_tracking_effectiveness()
            
            self.send_event("tracking-effectiveness", result)
            
        except Exception as e:
            self.send_event("tracking-effectiveness", {"success": False, "error": str(e)})
    
    # ==================== Campaign Handlers (ç‡ŸéŠ·æ´»å‹•å”èª¿å™¨) ====================
    
    async def handle_create_campaign(self, payload: Dict[str, Any]):
        """å‰µå»ºç‡ŸéŠ·æ´»å‹•"""
        try:
            orchestrator = get_campaign_orchestrator()
            if not orchestrator:
                self.send_event("campaign-created", {"success": False, "error": "ç‡ŸéŠ·æ´»å‹•ç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            result = await orchestrator.create_campaign(
                name=payload.get('name', ''),
                description=payload.get('description', ''),
                phases=payload.get('phases'),
                target_groups=payload.get('targetGroups', []),
                assigned_accounts=payload.get('assignedAccounts', []),
                keywords=payload.get('keywords', []),
                ad_template_id=payload.get('adTemplateId'),
                settings=payload.get('settings', {})
            )
            
            if result.get('success'):
                self.send_log(f"ç‡ŸéŠ·æ´»å‹•å·²å‰µå»º: {result.get('name')}", "success")
            
            self.send_event("campaign-created", result)
            
        except Exception as e:
            self.send_event("campaign-created", {"success": False, "error": str(e)})
    
    async def handle_update_campaign(self, payload: Dict[str, Any]):
        """æ›´æ–°ç‡ŸéŠ·æ´»å‹•"""
        try:
            orchestrator = get_campaign_orchestrator()
            if not orchestrator:
                self.send_event("campaign-updated", {"success": False, "error": "ç‡ŸéŠ·æ´»å‹•ç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            result = await orchestrator.update_campaign(
                campaign_id=payload.get('campaignId'),
                updates=payload.get('updates', {})
            )
            
            self.send_event("campaign-updated", result)
            
        except Exception as e:
            self.send_event("campaign-updated", {"success": False, "error": str(e)})
    
    async def handle_delete_campaign(self, payload: Dict[str, Any]):
        """åˆªé™¤ç‡ŸéŠ·æ´»å‹•"""
        try:
            orchestrator = get_campaign_orchestrator()
            if not orchestrator:
                self.send_event("campaign-deleted", {"success": False, "error": "ç‡ŸéŠ·æ´»å‹•ç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            result = await orchestrator.delete_campaign(payload.get('campaignId'))
            
            if result.get('success'):
                self.send_log("ç‡ŸéŠ·æ´»å‹•å·²åˆªé™¤", "info")
            
            self.send_event("campaign-deleted", result)
            
        except Exception as e:
            self.send_event("campaign-deleted", {"success": False, "error": str(e)})
    
    async def handle_get_campaigns(self, payload: Dict[str, Any]):
        """ç²å–ç‡ŸéŠ·æ´»å‹•åˆ—è¡¨"""
        try:
            orchestrator = get_campaign_orchestrator()
            if not orchestrator:
                self.send_event("campaigns", {"success": False, "error": "ç‡ŸéŠ·æ´»å‹•ç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            result = await orchestrator.get_all_campaigns(
                status=payload.get('status'),
                limit=payload.get('limit', 50),
                offset=payload.get('offset', 0)
            )
            
            self.send_event("campaigns", result)
            
        except Exception as e:
            self.send_event("campaigns", {"success": False, "error": str(e)})
    
    async def handle_get_campaign(self, payload: Dict[str, Any]):
        """ç²å–å–®å€‹ç‡ŸéŠ·æ´»å‹•"""
        try:
            orchestrator = get_campaign_orchestrator()
            if not orchestrator:
                self.send_event("campaign", {"success": False, "error": "ç‡ŸéŠ·æ´»å‹•ç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            campaign = await orchestrator.get_campaign(payload.get('campaignId'))
            
            if campaign:
                self.send_event("campaign", {"success": True, "campaign": campaign.to_dict()})
            else:
                self.send_event("campaign", {"success": False, "error": "æ´»å‹•ä¸å­˜åœ¨"})
            
        except Exception as e:
            self.send_event("campaign", {"success": False, "error": str(e)})
    
    async def handle_start_campaign(self, payload: Dict[str, Any]):
        """å•Ÿå‹•ç‡ŸéŠ·æ´»å‹•"""
        try:
            orchestrator = get_campaign_orchestrator()
            if not orchestrator:
                self.send_event("campaign-started", {"success": False, "error": "ç‡ŸéŠ·æ´»å‹•ç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            result = await orchestrator.start_campaign(payload.get('campaignId'))
            
            # Event is sent by orchestrator
            
        except Exception as e:
            self.send_event("campaign-started", {"success": False, "error": str(e)})
    
    async def handle_pause_campaign(self, payload: Dict[str, Any]):
        """æš«åœç‡ŸéŠ·æ´»å‹•"""
        try:
            orchestrator = get_campaign_orchestrator()
            if not orchestrator:
                self.send_event("campaign-paused", {"success": False, "error": "ç‡ŸéŠ·æ´»å‹•ç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            result = await orchestrator.pause_campaign(payload.get('campaignId'))
            
            self.send_event("campaign-paused", result)
            
        except Exception as e:
            self.send_event("campaign-paused", {"success": False, "error": str(e)})
    
    async def handle_resume_campaign(self, payload: Dict[str, Any]):
        """æ¢å¾©ç‡ŸéŠ·æ´»å‹•"""
        try:
            orchestrator = get_campaign_orchestrator()
            if not orchestrator:
                self.send_event("campaign-resumed", {"success": False, "error": "ç‡ŸéŠ·æ´»å‹•ç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            result = await orchestrator.resume_campaign(payload.get('campaignId'))
            
            # Event is sent by start_campaign
            
        except Exception as e:
            self.send_event("campaign-resumed", {"success": False, "error": str(e)})
    
    async def handle_stop_campaign(self, payload: Dict[str, Any]):
        """åœæ­¢ç‡ŸéŠ·æ´»å‹•"""
        try:
            orchestrator = get_campaign_orchestrator()
            if not orchestrator:
                self.send_event("campaign-stopped", {"success": False, "error": "ç‡ŸéŠ·æ´»å‹•ç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            result = await orchestrator.stop_campaign(payload.get('campaignId'))
            
            # Event is sent by orchestrator
            
        except Exception as e:
            self.send_event("campaign-stopped", {"success": False, "error": str(e)})
    
    async def handle_get_campaign_logs(self, payload: Dict[str, Any]):
        """ç²å–ç‡ŸéŠ·æ´»å‹•æ—¥èªŒ"""
        try:
            orchestrator = get_campaign_orchestrator()
            if not orchestrator:
                self.send_event("campaign-logs", {"success": False, "error": "ç‡ŸéŠ·æ´»å‹•ç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            result = await orchestrator.get_campaign_logs(
                campaign_id=payload.get('campaignId'),
                limit=payload.get('limit', 50)
            )
            
            self.send_event("campaign-logs", result)
            
        except Exception as e:
            self.send_event("campaign-logs", {"success": False, "error": str(e)})
    
    async def handle_get_unified_overview(self, payload: Dict[str, Any]):
        """ç²å–çµ±ä¸€æ¦‚è¦½"""
        try:
            stats = get_multi_channel_stats()
            if not stats:
                self.send_event("unified-overview", {"success": False, "error": "çµ±è¨ˆç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            result = await stats.get_unified_overview(
                days=payload.get('days', 7)
            )
            
            self.send_event("unified-overview", result)
            
        except Exception as e:
            self.send_event("unified-overview", {"success": False, "error": str(e)})
    
    async def handle_get_daily_trends(self, payload: Dict[str, Any]):
        """ç²å–æ¯æ—¥è¶¨å‹¢"""
        try:
            stats = get_multi_channel_stats()
            if not stats:
                self.send_event("daily-trends", {"success": False, "error": "çµ±è¨ˆç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            result = await stats.get_daily_trends(
                days=payload.get('days', 30)
            )
            
            self.send_event("daily-trends", result)
            
        except Exception as e:
            self.send_event("daily-trends", {"success": False, "error": str(e)})
    
    async def handle_get_channel_performance(self, payload: Dict[str, Any]):
        """ç²å–æ¸ é“æ•ˆèƒ½"""
        try:
            stats = get_multi_channel_stats()
            if not stats:
                self.send_event("channel-performance", {"success": False, "error": "çµ±è¨ˆç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            result = await stats.get_channel_performance()
            
            self.send_event("channel-performance", result)
            
        except Exception as e:
            self.send_event("channel-performance", {"success": False, "error": str(e)})
    
    async def handle_get_funnel_analysis(self, payload: Dict[str, Any]):
        """ç²å–æ¼æ–—åˆ†æ"""
        try:
            stats = get_multi_channel_stats()
            if not stats:
                self.send_event("funnel-analysis", {"success": False, "error": "çµ±è¨ˆç³»çµ±æœªåˆå§‹åŒ–"})
                return
            
            result = await stats.get_funnel_analysis()
            
            self.send_event("funnel-analysis", result)
            
        except Exception as e:
            self.send_event("funnel-analysis", {"success": False, "error": str(e)})
    
    # ==================== Multi-Role Handlers (å¤šè§’è‰²å”ä½œ) ====================
    
    async def handle_get_role_templates(self, payload: Dict[str, Any]):
        """ç²å–è§’è‰²æ¨¡æ¿"""
        try:
            role_manager = get_multi_role_manager()
            if not role_manager:
                self.send_event("role-templates", {"success": False, "error": "è§’è‰²ç®¡ç†å™¨æœªåˆå§‹åŒ–"})
                return
            
            templates = role_manager.get_role_templates()
            self.send_event("role-templates", {"success": True, "templates": templates})
            
        except Exception as e:
            self.send_event("role-templates", {"success": False, "error": str(e)})
    
    async def handle_assign_role(self, payload: Dict[str, Any]):
        """åˆ†é…è§’è‰²"""
        try:
            role_manager = get_multi_role_manager()
            if not role_manager:
                self.send_event("role-assigned", {"success": False, "error": "è§’è‰²ç®¡ç†å™¨æœªåˆå§‹åŒ–"})
                return
            
            result = await role_manager.assign_role(
                account_phone=payload.get('accountPhone'),
                role_type=payload.get('roleType'),
                role_name=payload.get('roleName', ''),
                personality=payload.get('personality'),
                speaking_style=payload.get('speakingStyle'),
                emoji_frequency=payload.get('emojiFrequency'),
                response_speed=payload.get('responseSpeed'),
                custom_prompt=payload.get('customPrompt'),
                bio=payload.get('bio')
            )
            
            if result.get('success'):
                self.send_log(f"å·²åˆ†é…è§’è‰²: {payload.get('roleType')}", "success")
            
            self.send_event("role-assigned", result)
            
        except Exception as e:
            self.send_event("role-assigned", {"success": False, "error": str(e)})
    
    async def handle_update_role(self, payload: Dict[str, Any]):
        """æ›´æ–°è§’è‰²"""
        try:
            role_manager = get_multi_role_manager()
            if not role_manager:
                self.send_event("role-updated", {"success": False, "error": "è§’è‰²ç®¡ç†å™¨æœªåˆå§‹åŒ–"})
                return
            
            result = await role_manager.update_role(
                role_id=payload.get('roleId'),
                updates=payload.get('updates', {})
            )
            
            self.send_event("role-updated", result)
            
        except Exception as e:
            self.send_event("role-updated", {"success": False, "error": str(e)})
    
    async def handle_remove_role(self, payload: Dict[str, Any]):
        """ç§»é™¤è§’è‰²"""
        try:
            role_manager = get_multi_role_manager()
            if not role_manager:
                self.send_event("role-removed", {"success": False, "error": "è§’è‰²ç®¡ç†å™¨æœªåˆå§‹åŒ–"})
                return
            
            result = await role_manager.remove_role(payload.get('roleId'))
            
            self.send_event("role-removed", result)
            
        except Exception as e:
            self.send_event("role-removed", {"success": False, "error": str(e)})
    
    async def handle_get_account_roles(self, payload: Dict[str, Any]):
        """ç²å–å¸³è™Ÿè§’è‰²"""
        try:
            role_manager = get_multi_role_manager()
            if not role_manager:
                self.send_event("account-roles", {"success": False, "error": "è§’è‰²ç®¡ç†å™¨æœªåˆå§‹åŒ–"})
                return
            
            roles = await role_manager.get_account_roles(payload.get('accountPhone'))
            self.send_event("account-roles", {
                "success": True,
                "roles": [r.to_dict() for r in roles]
            })
            
        except Exception as e:
            self.send_event("account-roles", {"success": False, "error": str(e)})
    
    async def handle_get_all_roles(self, payload: Dict[str, Any]):
        """ç²å–æ‰€æœ‰è§’è‰²"""
        try:
            role_manager = get_multi_role_manager()
            if not role_manager:
                self.send_event("all-roles", {"success": False, "error": "è§’è‰²ç®¡ç†å™¨æœªåˆå§‹åŒ–"})
                return
            
            result = await role_manager.get_all_roles(
                role_type=payload.get('roleType'),
                active_only=payload.get('activeOnly', True)
            )
            
            self.send_event("all-roles", result)
            
        except Exception as e:
            self.send_event("all-roles", {"success": False, "error": str(e)})
    
    async def handle_get_role_stats(self, payload: Dict[str, Any]):
        """ç²å–è§’è‰²çµ±è¨ˆ"""
        try:
            role_manager = get_multi_role_manager()
            if not role_manager:
                self.send_event("role-stats", {"success": False, "error": "è§’è‰²ç®¡ç†å™¨æœªåˆå§‹åŒ–"})
                return
            
            result = await role_manager.get_role_stats()
            self.send_event("role-stats", result)
            
        except Exception as e:
            self.send_event("role-stats", {"success": False, "error": str(e)})
    
    async def handle_get_script_templates(self, payload: Dict[str, Any]):
        """ç²å–åŠ‡æœ¬æ¨¡æ¿"""
        try:
            script_engine = get_script_engine()
            if not script_engine:
                self.send_event("script-templates", {"success": False, "error": "åŠ‡æœ¬å¼•æ“æœªåˆå§‹åŒ–"})
                return
            
            result = await script_engine.get_all_templates(
                scenario=payload.get('scenario'),
                active_only=payload.get('activeOnly', True)
            )
            
            self.send_event("script-templates", result)
            
        except Exception as e:
            self.send_event("script-templates", {"success": False, "error": str(e)})
    
    async def handle_create_script_template(self, payload: Dict[str, Any]):
        """å‰µå»ºåŠ‡æœ¬æ¨¡æ¿"""
        try:
            script_engine = get_script_engine()
            if not script_engine:
                self.send_event("script-template-created", {"success": False, "error": "åŠ‡æœ¬å¼•æ“æœªåˆå§‹åŒ–"})
                return
            
            result = await script_engine.create_template(
                name=payload.get('name'),
                description=payload.get('description', ''),
                scenario=payload.get('scenario', 'custom'),
                stages=payload.get('stages', []),
                required_roles=payload.get('requiredRoles', []),
                min_roles=payload.get('minRoles', 2),
                duration_minutes=payload.get('durationMinutes', 10)
            )
            
            self.send_event("script-template-created", result)
            
        except Exception as e:
            self.send_event("script-template-created", {"success": False, "error": str(e)})
    
    async def handle_delete_script_template(self, payload: Dict[str, Any]):
        """åˆªé™¤åŠ‡æœ¬æ¨¡æ¿"""
        try:
            script_engine = get_script_engine()
            if not script_engine:
                self.send_event("script-template-deleted", {"success": False, "error": "åŠ‡æœ¬å¼•æ“æœªåˆå§‹åŒ–"})
                return
            
            result = await script_engine.delete_template(payload.get('templateId'))
            self.send_event("script-template-deleted", result)
            
        except Exception as e:
            self.send_event("script-template-deleted", {"success": False, "error": str(e)})
    
    async def handle_start_script_execution(self, payload: Dict[str, Any]):
        """å•Ÿå‹•åŠ‡æœ¬åŸ·è¡Œ"""
        try:
            script_engine = get_script_engine()
            if not script_engine:
                self.send_event("script-execution-created", {"success": False, "error": "åŠ‡æœ¬å¼•æ“æœªåˆå§‹åŒ–"})
                return
            
            result = await script_engine.start_execution(
                template_id=payload.get('templateId'),
                group_id=payload.get('groupId'),
                target_user_id=payload.get('targetUserId'),
                target_username=payload.get('targetUsername'),
                assigned_roles=payload.get('assignedRoles', {})
            )
            
            self.send_event("script-execution-created", result)
            
        except Exception as e:
            self.send_event("script-execution-created", {"success": False, "error": str(e)})
    
    async def handle_run_script_execution(self, payload: Dict[str, Any]):
        """é‹è¡ŒåŠ‡æœ¬åŸ·è¡Œ"""
        try:
            script_engine = get_script_engine()
            if not script_engine:
                self.send_event("script-execution-started", {"success": False, "error": "åŠ‡æœ¬å¼•æ“æœªåˆå§‹åŒ–"})
                return
            
            result = await script_engine.run_execution(payload.get('executionId'))
            # Event sent by engine
            
        except Exception as e:
            self.send_event("script-execution-started", {"success": False, "error": str(e)})
    
    async def handle_stop_script_execution(self, payload: Dict[str, Any]):
        """åœæ­¢åŠ‡æœ¬åŸ·è¡Œ"""
        try:
            script_engine = get_script_engine()
            if not script_engine:
                self.send_event("script-execution-stopped", {"success": False, "error": "åŠ‡æœ¬å¼•æ“æœªåˆå§‹åŒ–"})
                return
            
            result = await script_engine.stop_execution(
                execution_id=payload.get('executionId'),
                outcome=payload.get('outcome', 'stopped')
            )
            
        except Exception as e:
            self.send_event("script-execution-stopped", {"success": False, "error": str(e)})
    
    async def handle_get_active_executions(self, payload: Dict[str, Any]):
        """ç²å–æ´»èºåŸ·è¡Œ"""
        try:
            script_engine = get_script_engine()
            if not script_engine:
                self.send_event("active-executions", {"success": False, "error": "åŠ‡æœ¬å¼•æ“æœªåˆå§‹åŒ–"})
                return
            
            result = await script_engine.get_active_executions()
            self.send_event("active-executions", result)
            
        except Exception as e:
            self.send_event("active-executions", {"success": False, "error": str(e)})
    
    async def handle_get_execution_stats(self, payload: Dict[str, Any]):
        """ç²å–åŸ·è¡Œçµ±è¨ˆ"""
        try:
            script_engine = get_script_engine()
            if not script_engine:
                self.send_event("execution-stats", {"success": False, "error": "åŠ‡æœ¬å¼•æ“æœªåˆå§‹åŒ–"})
                return
            
            result = await script_engine.get_execution_stats()
            self.send_event("execution-stats", result)
            
        except Exception as e:
            self.send_event("execution-stats", {"success": False, "error": str(e)})
    
    async def handle_create_collab_group(self, payload: Dict[str, Any]):
        """å‰µå»ºå”ä½œç¾¤çµ„"""
        try:
            coordinator = get_collaboration_coordinator()
            if not coordinator:
                self.send_event("collab-group-created", {"success": False, "error": "å”ä½œå”èª¿å™¨æœªåˆå§‹åŒ–"})
                return
            
            result = await coordinator.create_collab_group(
                group_title=payload.get('groupTitle'),
                creator_phone=payload.get('creatorPhone'),
                purpose=payload.get('purpose', 'conversion'),
                target_user_id=payload.get('targetUserId'),
                target_username=payload.get('targetUsername')
            )
            
        except Exception as e:
            self.send_event("collab-group-created", {"success": False, "error": str(e)})
    
    async def handle_add_collab_member(self, payload: Dict[str, Any]):
        """æ·»åŠ å”ä½œæˆå“¡"""
        try:
            coordinator = get_collaboration_coordinator()
            if not coordinator:
                self.send_event("collab-member-added", {"success": False, "error": "å”ä½œå”èª¿å™¨æœªåˆå§‹åŒ–"})
                return
            
            result = await coordinator.add_member(
                collab_id=payload.get('collabId'),
                account_phone=payload.get('accountPhone'),
                role_type=payload.get('roleType')
            )
            
        except Exception as e:
            self.send_event("collab-member-added", {"success": False, "error": str(e)})
    
    async def handle_get_collab_groups(self, payload: Dict[str, Any]):
        """ç²å–å”ä½œç¾¤çµ„"""
        try:
            coordinator = get_collaboration_coordinator()
            if not coordinator:
                self.send_event("collab-groups", {"success": False, "error": "å”ä½œå”èª¿å™¨æœªåˆå§‹åŒ–"})
                return
            
            result = await coordinator.get_all_collab_groups(
                status=payload.get('status'),
                purpose=payload.get('purpose'),
                limit=payload.get('limit', 50)
            )
            
            self.send_event("collab-groups", result)
            
        except Exception as e:
            self.send_event("collab-groups", {"success": False, "error": str(e)})
    
    async def handle_update_collab_status(self, payload: Dict[str, Any]):
        """æ›´æ–°å”ä½œç‹€æ…‹"""
        try:
            coordinator = get_collaboration_coordinator()
            if not coordinator:
                self.send_event("collab-group-updated", {"success": False, "error": "å”ä½œå”èª¿å™¨æœªåˆå§‹åŒ–"})
                return
            
            result = await coordinator.update_group_status(
                collab_id=payload.get('collabId'),
                status=payload.get('status'),
                outcome=payload.get('outcome')
            )
            
        except Exception as e:
            self.send_event("collab-group-updated", {"success": False, "error": str(e)})
    
    async def handle_get_collab_stats(self, payload: Dict[str, Any]):
        """ç²å–å”ä½œçµ±è¨ˆ"""
        try:
            coordinator = get_collaboration_coordinator()
            if not coordinator:
                self.send_event("collab-stats", {"success": False, "error": "å”ä½œå”èª¿å™¨æœªåˆå§‹åŒ–"})
                return
            
            result = await coordinator.get_collab_stats()
            self.send_event("collab-stats", result)
            
        except Exception as e:
            self.send_event("collab-stats", {"success": False, "error": str(e)})

    # ==================== ğŸ†• P1-1: Marketing Task Handlers ====================
    
    async def handle_get_marketing_tasks(self, payload: Dict[str, Any]):
        """ç²å–ç‡ŸéŠ·ä»»å‹™åˆ—è¡¨"""
        try:
            service = get_marketing_task_service()
            if not service:
                self.send_event("marketing-tasks-loaded", {"success": False, "error": "ç‡ŸéŠ·ä»»å‹™æœå‹™æœªåˆå§‹åŒ–"})
                return
            
            result = await service.get_all_tasks(
                status=payload.get('status'),
                goal_type=payload.get('goalType'),
                limit=payload.get('limit', 100)
            )
            self.send_event("marketing-tasks-loaded", result)
            
        except Exception as e:
            self.send_event("marketing-tasks-loaded", {"success": False, "error": str(e)})
    
    async def handle_create_marketing_task(self, payload: Dict[str, Any]):
        """å‰µå»ºç‡ŸéŠ·ä»»å‹™"""
        try:
            service = get_marketing_task_service()
            if not service:
                self.send_event("marketing-task-created", {"success": False, "error": "ç‡ŸéŠ·ä»»å‹™æœå‹™æœªåˆå§‹åŒ–"})
                return
            
            result = await service.create_task(
                name=payload.get('name'),
                goal_type=payload.get('goalType', 'conversion'),
                execution_mode=payload.get('executionMode', 'hybrid'),
                description=payload.get('description'),
                target_criteria=payload.get('targetCriteria'),
                role_config=payload.get('roleConfig'),
                schedule_config=payload.get('scheduleConfig'),
                created_by=payload.get('createdBy')
            )
            # Event is sent by the service
            
        except Exception as e:
            self.send_event("marketing-task-created", {"success": False, "error": str(e)})
    
    async def handle_update_marketing_task(self, payload: Dict[str, Any]):
        """æ›´æ–°ç‡ŸéŠ·ä»»å‹™"""
        try:
            service = get_marketing_task_service()
            if not service:
                self.send_event("marketing-task-updated", {"success": False, "error": "ç‡ŸéŠ·ä»»å‹™æœå‹™æœªåˆå§‹åŒ–"})
                return
            
            task_id = payload.get('id')
            if not task_id:
                self.send_event("marketing-task-updated", {"success": False, "error": "ç¼ºå°‘ä»»å‹™ID"})
                return
            
            # Remove 'id' from updates
            updates = {k: v for k, v in payload.items() if k != 'id'}
            result = await service.update_task(int(task_id), updates)
            # Event is sent by the service
            
        except Exception as e:
            self.send_event("marketing-task-updated", {"success": False, "error": str(e)})
    
    async def handle_delete_marketing_task(self, payload: Dict[str, Any]):
        """åˆªé™¤ç‡ŸéŠ·ä»»å‹™"""
        try:
            service = get_marketing_task_service()
            if not service:
                self.send_event("marketing-task-deleted", {"success": False, "error": "ç‡ŸéŠ·ä»»å‹™æœå‹™æœªåˆå§‹åŒ–"})
                return
            
            task_id = payload.get('id')
            if not task_id:
                self.send_event("marketing-task-deleted", {"success": False, "error": "ç¼ºå°‘ä»»å‹™ID"})
                return
            
            result = await service.delete_task(int(task_id))
            # Event is sent by the service
            
        except Exception as e:
            self.send_event("marketing-task-deleted", {"success": False, "error": str(e)})
    
    async def handle_start_marketing_task(self, payload: Dict[str, Any]):
        """å•Ÿå‹•ç‡ŸéŠ·ä»»å‹™"""
        try:
            service = get_marketing_task_service()
            if not service:
                self.send_event("marketing-task-started", {"success": False, "error": "ç‡ŸéŠ·ä»»å‹™æœå‹™æœªåˆå§‹åŒ–"})
                return
            
            task_id = payload.get('id')
            if not task_id:
                self.send_event("marketing-task-started", {"success": False, "error": "ç¼ºå°‘ä»»å‹™ID"})
                return
            
            result = await service.start_task(int(task_id))
            self.send_event("marketing-task-started", result)
            
        except Exception as e:
            self.send_event("marketing-task-started", {"success": False, "error": str(e)})
    
    async def handle_pause_marketing_task(self, payload: Dict[str, Any]):
        """æš«åœç‡ŸéŠ·ä»»å‹™"""
        try:
            service = get_marketing_task_service()
            if not service:
                self.send_event("marketing-task-paused", {"success": False, "error": "ç‡ŸéŠ·ä»»å‹™æœå‹™æœªåˆå§‹åŒ–"})
                return
            
            task_id = payload.get('id')
            if not task_id:
                self.send_event("marketing-task-paused", {"success": False, "error": "ç¼ºå°‘ä»»å‹™ID"})
                return
            
            result = await service.pause_task(int(task_id))
            self.send_event("marketing-task-paused", result)
            
        except Exception as e:
            self.send_event("marketing-task-paused", {"success": False, "error": str(e)})
    
    async def handle_resume_marketing_task(self, payload: Dict[str, Any]):
        """æ¢å¾©ç‡ŸéŠ·ä»»å‹™"""
        try:
            service = get_marketing_task_service()
            if not service:
                self.send_event("marketing-task-resumed", {"success": False, "error": "ç‡ŸéŠ·ä»»å‹™æœå‹™æœªåˆå§‹åŒ–"})
                return
            
            task_id = payload.get('id')
            if not task_id:
                self.send_event("marketing-task-resumed", {"success": False, "error": "ç¼ºå°‘ä»»å‹™ID"})
                return
            
            result = await service.resume_task(int(task_id))
            self.send_event("marketing-task-resumed", result)
            
        except Exception as e:
            self.send_event("marketing-task-resumed", {"success": False, "error": str(e)})
    
    async def handle_complete_marketing_task(self, payload: Dict[str, Any]):
        """å®Œæˆç‡ŸéŠ·ä»»å‹™"""
        try:
            service = get_marketing_task_service()
            if not service:
                self.send_event("marketing-task-completed", {"success": False, "error": "ç‡ŸéŠ·ä»»å‹™æœå‹™æœªåˆå§‹åŒ–"})
                return
            
            task_id = payload.get('id')
            if not task_id:
                self.send_event("marketing-task-completed", {"success": False, "error": "ç¼ºå°‘ä»»å‹™ID"})
                return
            
            result = await service.complete_task(int(task_id))
            self.send_event("marketing-task-completed", result)
            
        except Exception as e:
            self.send_event("marketing-task-completed", {"success": False, "error": str(e)})
    
    async def handle_add_marketing_task_targets(self, payload: Dict[str, Any]):
        """æ·»åŠ ä»»å‹™ç›®æ¨™ç”¨æˆ¶"""
        try:
            service = get_marketing_task_service()
            if not service:
                self.send_event("marketing-task-targets-added", {"success": False, "error": "ç‡ŸéŠ·ä»»å‹™æœå‹™æœªåˆå§‹åŒ–"})
                return
            
            task_id = payload.get('taskId')
            targets = payload.get('targets', [])
            if not task_id:
                self.send_event("marketing-task-targets-added", {"success": False, "error": "ç¼ºå°‘ä»»å‹™ID"})
                return
            
            result = await service.add_targets(int(task_id), targets)
            # Event is sent by the service
            
        except Exception as e:
            self.send_event("marketing-task-targets-added", {"success": False, "error": str(e)})
    
    async def handle_get_marketing_task_targets(self, payload: Dict[str, Any]):
        """ç²å–ä»»å‹™ç›®æ¨™ç”¨æˆ¶"""
        try:
            service = get_marketing_task_service()
            if not service:
                self.send_event("marketing-task-targets-loaded", {"success": False, "error": "ç‡ŸéŠ·ä»»å‹™æœå‹™æœªåˆå§‹åŒ–"})
                return
            
            task_id = payload.get('taskId')
            if not task_id:
                self.send_event("marketing-task-targets-loaded", {"success": False, "error": "ç¼ºå°‘ä»»å‹™ID"})
                return
            
            result = await service.get_task_targets(
                int(task_id),
                status=payload.get('status'),
                limit=payload.get('limit', 100)
            )
            self.send_event("marketing-task-targets-loaded", result)
            
        except Exception as e:
            self.send_event("marketing-task-targets-loaded", {"success": False, "error": str(e)})
    
    async def handle_update_marketing_task_target(self, payload: Dict[str, Any]):
        """æ›´æ–°ç›®æ¨™ç‹€æ…‹"""
        try:
            service = get_marketing_task_service()
            if not service:
                self.send_event("marketing-task-target-updated", {"success": False, "error": "ç‡ŸéŠ·ä»»å‹™æœå‹™æœªåˆå§‹åŒ–"})
                return
            
            task_id = payload.get('taskId')
            target_id = payload.get('targetId')
            status = payload.get('status')
            
            if not task_id or not target_id:
                self.send_event("marketing-task-target-updated", {"success": False, "error": "ç¼ºå°‘åƒæ•¸"})
                return
            
            result = await service.update_target_status(
                int(task_id), 
                int(target_id), 
                status,
                outcome=payload.get('outcome')
            )
            self.send_event("marketing-task-target-updated", result)
            
        except Exception as e:
            self.send_event("marketing-task-target-updated", {"success": False, "error": str(e)})
    
    async def handle_assign_marketing_task_role(self, payload: Dict[str, Any]):
        """åˆ†é…ä»»å‹™è§’è‰²"""
        try:
            service = get_marketing_task_service()
            if not service:
                self.send_event("marketing-task-role-assigned", {"success": False, "error": "ç‡ŸéŠ·ä»»å‹™æœå‹™æœªåˆå§‹åŒ–"})
                return
            
            task_id = payload.get('taskId')
            if not task_id:
                self.send_event("marketing-task-role-assigned", {"success": False, "error": "ç¼ºå°‘ä»»å‹™ID"})
                return
            
            result = await service.assign_role(
                int(task_id),
                role_type=payload.get('roleType'),
                role_name=payload.get('roleName'),
                account_id=payload.get('accountId'),
                account_phone=payload.get('accountPhone'),
                persona_prompt=payload.get('personaPrompt')
            )
            self.send_event("marketing-task-role-assigned", result)
            
        except Exception as e:
            self.send_event("marketing-task-role-assigned", {"success": False, "error": str(e)})
    
    async def handle_auto_assign_marketing_task_roles(self, payload: Dict[str, Any]):
        """è‡ªå‹•åˆ†é…ä»»å‹™è§’è‰²"""
        try:
            service = get_marketing_task_service()
            if not service:
                self.send_event("marketing-task-roles-assigned", {"success": False, "error": "ç‡ŸéŠ·ä»»å‹™æœå‹™æœªåˆå§‹åŒ–"})
                return
            
            task_id = payload.get('taskId')
            if not task_id:
                self.send_event("marketing-task-roles-assigned", {"success": False, "error": "ç¼ºå°‘ä»»å‹™ID"})
                return
            
            # TODO: Implement auto-assign logic
            self.send_event("marketing-task-roles-assigned", {"success": True, "assignedCount": 0})
            
        except Exception as e:
            self.send_event("marketing-task-roles-assigned", {"success": False, "error": str(e)})
    
    async def handle_get_marketing_task_stats(self, payload: Dict[str, Any]):
        """ç²å–ä»»å‹™çµ±è¨ˆ"""
        try:
            service = get_marketing_task_service()
            if not service:
                self.send_event("marketing-task-stats-loaded", {"success": False, "error": "ç‡ŸéŠ·ä»»å‹™æœå‹™æœªåˆå§‹åŒ–"})
                return
            
            task_id = payload.get('taskId')
            if task_id:
                result = await service.get_task_stats(int(task_id))
            else:
                result = await service.get_overall_stats()
            
            self.send_event("marketing-task-stats-loaded", result)
            
        except Exception as e:
            self.send_event("marketing-task-stats-loaded", {"success": False, "error": str(e)})

    # ==================== API Credential Pool Handlers ====================
    
    async def handle_get_api_credentials(self, payload: Dict[str, Any]):
        """ç²å– API æ†‘æ“šæ± ä¿¡æ¯"""
        import sys
        print("[Backend] handle_get_api_credentials called", file=sys.stderr)
        try:
            from api_credential_pool import get_api_credential_pool
            data_dir = str(Path(config.DATA_PATH))
            print(f"[Backend] API pool data_dir: {data_dir}", file=sys.stderr)
            pool = get_api_credential_pool(data_dir)
            print(f"[Backend] API pool loaded, credentials count: {len(pool.credentials)}", file=sys.stderr)

            # æ¯æ¬¡ç²å–æ™‚åŒæ­¥ä½¿ç”¨è¨ˆæ•¸ï¼Œç¢ºä¿æº–ç¢ºæ€§
            accounts = await db.get_all_accounts()
            print(f"[Backend] Got {len(accounts)} accounts for API sync", file=sys.stderr)
            pool.sync_usage_counts(accounts)

            statistics = pool.get_statistics()
            print(f"[Backend] API statistics: {statistics}", file=sys.stderr)
            # å‚³éå¸³è™Ÿæ•¸æ“šä»¥ç²å–æ­£ç¢ºçš„ç¶å®šå¸³è™Ÿåˆ—è¡¨
            credentials = pool.list_credentials(include_hash=True, accounts=accounts)
            print(f"[Backend] Sending {len(credentials)} API credentials to frontend", file=sys.stderr)

            response = {
                "success": True,
                "statistics": statistics,
                "credentials": credentials
            }
            self.send_event("api-credentials-updated", response)
            print("[Backend] api-credentials-updated event sent", file=sys.stderr)
            return response
            
        except Exception as e:
            print(f"[Backend] Error getting API credentials: {e}", file=sys.stderr)
            response = {
                "success": False,
                "error": str(e),
                "statistics": None,
                "credentials": []
            }
            self.send_event("api-credentials-updated", response)
            return response
    
    async def handle_add_api_credential(self, payload: Dict[str, Any]):
        """æ·»åŠ  API æ†‘æ“š"""
        try:
            from api_credential_pool import get_api_credential_pool
            data_dir = str(Path(config.DATA_PATH))
            pool = get_api_credential_pool(data_dir)
            
            api_id = payload.get("api_id", "").strip()
            api_hash = payload.get("api_hash", "").strip()
            name = payload.get("name", "").strip()
            source = payload.get("source", "").strip()
            max_accounts = payload.get("max_accounts", 5)
            
            if not api_id or not api_hash:
                self.send_event("api-credential-added", {
                    "success": False,
                    "error": "API ID å’Œ API Hash ç‚ºå¿…å¡«é …"
                })
                return
            
            # é©—è­‰æ ¼å¼
            if not api_id.isdigit():
                self.send_event("api-credential-added", {
                    "success": False,
                    "error": "API ID å¿…é ˆæ˜¯ç´”æ•¸å­—"
                })
                return
            
            import re
            if not re.match(r'^[a-f0-9]{32}$', api_hash, re.IGNORECASE):
                self.send_event("api-credential-added", {
                    "success": False,
                    "error": "API Hash æ ¼å¼ä¸æ­£ç¢ºï¼ˆæ‡‰ç‚º32ä½åå…­é€²åˆ¶å­—ç¬¦ä¸²ï¼‰"
                })
                return
            
            success = pool.add_credential(
                api_id=api_id,
                api_hash=api_hash,
                name=name or f"API_{api_id[-4:]}",
                source=source,
                max_accounts=max_accounts
            )
            
            if success:
                self.send_event("api-credential-added", {"success": True})
                self.send_log(f"âœ… å·²æ·»åŠ  API æ†‘æ“šï¼š{api_id}", "success")
                # åˆ·æ–°åˆ—è¡¨
                await self.handle_get_api_credentials({})
            else:
                self.send_event("api-credential-added", {
                    "success": False,
                    "error": "æ·»åŠ å¤±æ•—ï¼Œå¯èƒ½è©² API ID å·²å­˜åœ¨"
                })
            
        except Exception as e:
            print(f"[Backend] Error adding API credential: {e}", file=sys.stderr)
            self.send_event("api-credential-added", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_remove_api_credential(self, payload: Dict[str, Any]):
        """ç§»é™¤ API æ†‘æ“š"""
        try:
            from api_credential_pool import get_api_credential_pool
            data_dir = str(Path(config.DATA_PATH))
            pool = get_api_credential_pool(data_dir)
            
            api_id = payload.get("api_id", "").strip()
            
            if not api_id:
                self.send_event("api-credential-removed", {
                    "success": False,
                    "error": "è«‹æŒ‡å®šè¦åˆªé™¤çš„ API ID"
                })
                return
            
            success = pool.remove_credential(api_id)
            
            if success:
                self.send_event("api-credential-removed", {"success": True})
                self.send_log(f"ğŸ—‘ï¸ å·²åˆªé™¤ API æ†‘æ“šï¼š{api_id}", "info")
                # åˆ·æ–°åˆ—è¡¨
                await self.handle_get_api_credentials({})
            else:
                self.send_event("api-credential-removed", {
                    "success": False,
                    "error": "åˆªé™¤å¤±æ•—ï¼Œæœªæ‰¾åˆ°è©² API ID"
                })
            
        except Exception as e:
            print(f"[Backend] Error removing API credential: {e}", file=sys.stderr)
            self.send_event("api-credential-removed", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_toggle_api_credential(self, payload: Dict[str, Any]):
        """åˆ‡æ› API æ†‘æ“šå•Ÿç”¨ç‹€æ…‹"""
        try:
            from api_credential_pool import get_api_credential_pool
            data_dir = str(Path(config.DATA_PATH))
            pool = get_api_credential_pool(data_dir)
            
            api_id = payload.get("api_id", "").strip()
            is_active = payload.get("is_active", True)
            
            cred = pool.get_credential(api_id)
            if cred:
                cred.is_active = is_active
                pool.save()
                self.send_event("api-credential-toggled", {"success": True})
                self.send_log(f"{'â–¶ï¸ å·²å•Ÿç”¨' if is_active else 'â¸ï¸ å·²åœç”¨'} API æ†‘æ“šï¼š{api_id}", "info")
                # åˆ·æ–°åˆ—è¡¨
                await self.handle_get_api_credentials({})
            else:
                self.send_event("api-credential-toggled", {
                    "success": False,
                    "error": "æœªæ‰¾åˆ°è©² API ID"
                })
            
        except Exception as e:
            print(f"[Backend] Error toggling API credential: {e}", file=sys.stderr)
            self.send_event("api-credential-toggled", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_bulk_import_api_credentials(self, payload: Dict[str, Any]):
        """æ‰¹é‡å°å…¥ API æ†‘æ“š"""
        try:
            from api_credential_pool import get_api_credential_pool
            data_dir = str(Path(config.DATA_PATH))
            pool = get_api_credential_pool(data_dir)
            
            credentials = payload.get("credentials", [])
            
            if not credentials:
                self.send_event("api-credentials-imported", {
                    "success": False,
                    "error": "æ²’æœ‰æä¾›æ†‘æ“š"
                })
                return
            
            success_count = 0
            fail_count = 0
            
            for cred in credentials:
                api_id = cred.get("api_id", "").strip()
                api_hash = cred.get("api_hash", "").strip()
                name = cred.get("name", "").strip()
                
                if api_id and api_hash:
                    if pool.add_credential(api_id, api_hash, name):
                        success_count += 1
                    else:
                        fail_count += 1
                else:
                    fail_count += 1
            
            self.send_event("api-credentials-imported", {
                "success": True,
                "success_count": success_count,
                "fail_count": fail_count
            })
            self.send_log(f"ğŸ“¥ æ‰¹é‡å°å…¥å®Œæˆï¼šæˆåŠŸ {success_count} å€‹ï¼Œå¤±æ•— {fail_count} å€‹", "info")
            
            # åˆ·æ–°åˆ—è¡¨
            await self.handle_get_api_credentials({})
            
        except Exception as e:
            print(f"[Backend] Error bulk importing API credentials: {e}", file=sys.stderr)
            self.send_event("api-credentials-imported", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_api_recommendation(self, payload: Dict[str, Any]):
        """ç²å– API æ†‘æ“šå»ºè­°"""
        try:
            from api_credential_pool import get_api_credential_pool
            data_dir = str(Path(config.DATA_PATH))
            pool = get_api_credential_pool(data_dir)
            
            account_count = payload.get("account_count", 50)
            recommendation = pool.get_recommendation(account_count)
            
            self.send_event("api-recommendation", {
                "success": True,
                **recommendation
            })
            
        except Exception as e:
            print(f"[Backend] Error getting API recommendation: {e}", file=sys.stderr)
            self.send_event("api-recommendation", {
                "success": False,
                "error": str(e)
            })

    # ==================== Platform API Pool Handlers ====================
    
    async def handle_get_platform_api_usage(self, payload: Dict[str, Any]):
        """ç²å–ç”¨æˆ¶çš„å¹³å° API ä½¿ç”¨æƒ…æ³"""
        try:
            from platform_api_pool import get_platform_api_pool
            
            user_id = payload.get("userId", "default_user")
            membership_level = payload.get("membershipLevel", "bronze")

            data_dir = str(Path(config.DATA_PATH))
            pool = get_platform_api_pool(data_dir)
            quota_info = pool.check_user_quota(user_id, membership_level)
            
            self.send_event("platform-api-usage", quota_info)
            
        except Exception as e:
            print(f"[Backend] Error getting platform API usage: {e}", file=sys.stderr)
            self.send_event("platform-api-usage", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_allocate_platform_api(self, payload: Dict[str, Any]):
        """ç‚ºç”¨æˆ¶åˆ†é…å¹³å° API"""
        try:
            from platform_api_pool import get_platform_api_pool
            
            user_id = payload.get("userId", "default_user")
            phone = payload.get("phone", "")
            membership_level = payload.get("membershipLevel", "bronze")
            
            if not phone:
                self.send_event("platform-api-allocated", {
                    "success": False,
                    "error": "è«‹æä¾›æ‰‹æ©Ÿè™Ÿ"
                })
                return
            
            data_dir = str(Path(config.DATA_PATH))
            pool = get_platform_api_pool(data_dir)
            result = pool.allocate_api_for_user(user_id, phone, membership_level)
            
            self.send_event("platform-api-allocated", result)
            
            if result.get("success"):
                self.send_log(f"âœ… å·²ç‚º {phone} åˆ†é…å¹³å° API", "info")
            
        except Exception as e:
            print(f"[Backend] Error allocating platform API: {e}", file=sys.stderr)
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("platform-api-allocated", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_release_platform_api(self, payload: Dict[str, Any]):
        """é‡‹æ”¾ç”¨æˆ¶çš„å¹³å° API åˆ†é…"""
        try:
            from platform_api_pool import get_platform_api_pool
            
            phone = payload.get("phone", "")
            
            if not phone:
                self.send_event("platform-api-released", {
                    "success": False,
                    "error": "è«‹æä¾›æ‰‹æ©Ÿè™Ÿ"
                })
                return
            
            data_dir = str(Path(config.DATA_PATH))
            pool = get_platform_api_pool(data_dir)
            success, message = pool.release_allocation(phone)
            
            self.send_event("platform-api-released", {
                "success": success,
                "message": message
            })
            
        except Exception as e:
            print(f"[Backend] Error releasing platform API: {e}", file=sys.stderr)
            self.send_event("platform-api-released", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_admin_add_platform_api(self, payload: Dict[str, Any]):
        """ç®¡ç†å“¡æ·»åŠ å¹³å° API"""
        try:
            from platform_api_pool import get_platform_api_pool
            
            api_id = payload.get("apiId", "")
            api_hash = payload.get("apiHash", "")
            name = payload.get("name", "")
            max_accounts = payload.get("maxAccounts", 3)
            
            if not api_id or not api_hash:
                self.send_event("admin-platform-api-added", {
                    "success": False,
                    "error": "è«‹æä¾›å®Œæ•´çš„ API æ†‘æ“š"
                })
                return
            
            data_dir = str(Path(config.DATA_PATH))
            pool = get_platform_api_pool(data_dir)
            success, message = pool.add_platform_api(api_id, api_hash, name, max_accounts)
            
            self.send_event("admin-platform-api-added", {
                "success": success,
                "message": message
            })
            
            if success:
                self.send_log(f"âœ… ç®¡ç†å“¡æ·»åŠ å¹³å° API: {name}", "info")
            
        except Exception as e:
            print(f"[Backend] Error adding platform API: {e}", file=sys.stderr)
            self.send_event("admin-platform-api-added", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_admin_list_platform_apis(self, payload: Dict[str, Any]):
        """ç®¡ç†å“¡åˆ—å‡ºæ‰€æœ‰å¹³å° API"""
        try:
            from platform_api_pool import get_platform_api_pool
            
            data_dir = str(Path(config.DATA_PATH))
            pool = get_platform_api_pool(data_dir)
            apis = pool.list_platform_apis()
            stats = pool.get_pool_statistics()
            
            self.send_event("admin-platform-apis-list", {
                "success": True,
                "apis": apis,
                "statistics": stats
            })
            
        except Exception as e:
            print(f"[Backend] Error listing platform APIs: {e}", file=sys.stderr)
            self.send_event("admin-platform-apis-list", {
                "success": False,
                "error": str(e)
            })

    # ==================== TData Import Handlers ====================
    
    async def handle_select_tdata_folder(self, payload: Dict[str, Any]):
        """è™•ç†é¸æ“‡ TData æ–‡ä»¶å¤¾è«‹æ±‚"""
        try:
            # é€™å€‹éœ€è¦ç”±å‰ç«¯çš„ Electron è™•ç†æ–‡ä»¶å°è©±æ¡†
            # é€™è£¡åªæ˜¯ç™¼é€ä¸€å€‹äº‹ä»¶è®“å‰ç«¯æ‰“é–‹å°è©±æ¡†
            self.send_event("open-folder-dialog", {
                "purpose": "tdata",
                "title": "é¸æ“‡ TData æ–‡ä»¶å¤¾"
            })
        except Exception as e:
            print(f"[Backend] Error in select-tdata-folder: {e}", file=sys.stderr)
    
    async def handle_parse_tdata(self, payload: Dict[str, Any]):
        """è§£æ TData æ–‡ä»¶å¤¾"""
        try:
            from tdata_importer import get_tdata_importer
            
            tdata_path = payload.get("path", "")
            
            if not tdata_path:
                self.send_event("tdata-parsed", {
                    "success": False,
                    "error": "è«‹æŒ‡å®š TData è·¯å¾‘"
                })
                return
            
            importer = get_tdata_importer(str(self.sessions_dir))
            accounts = importer.find_tdata_accounts(tdata_path)
            
            self.send_event("tdata-parsed", {
                "success": True,
                "accounts": accounts,
                "count": len(accounts)
            })
            
            self.send_log(f"ğŸ“‚ å·²è§£æ TDataï¼Œæ‰¾åˆ° {len(accounts)} å€‹å¸³æˆ¶", "info")
            
        except Exception as e:
            print(f"[Backend] Error parsing TData: {e}", file=sys.stderr)
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("tdata-parsed", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_import_tdata(self, payload: Dict[str, Any]):
        """å°å…¥ TData å¸³æˆ¶"""
        try:
            from tdata_importer import get_tdata_importer
            from database import db
            
            tdata_path = payload.get("path", "")
            accounts = payload.get("accounts", [])
            
            if not tdata_path or not accounts:
                self.send_event("tdata-imported", {
                    "success": False,
                    "error": "è«‹æŒ‡å®š TData è·¯å¾‘å’Œè¦å°å…¥çš„å¸³æˆ¶"
                })
                return
            
            importer = get_tdata_importer(str(self.sessions_dir))
            result = importer.import_batch(tdata_path, accounts)
            
            # ç‚ºæˆåŠŸå°å…¥çš„å¸³æˆ¶æ·»åŠ åˆ°æ•¸æ“šåº«
            for detail in result.get("details", []):
                if detail.get("success"):
                    phone = detail.get("phone")
                    try:
                        # æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
                        existing = await db.get_account_by_phone(phone)
                        if not existing:
                            # æ·»åŠ æ–°å¸³æˆ¶
                            from device_fingerprint import DeviceFingerprintGenerator
                            fingerprint = DeviceFingerprintGenerator.generate_for_phone(phone)
                            
                            await db.add_account({
                                "phone": phone,
                                "status": "Offline",
                                "deviceModel": fingerprint.get("device_model", "Unknown"),
                                "systemVersion": fingerprint.get("system_version", "Unknown"),
                                "appVersion": fingerprint.get("app_version", "Unknown"),
                                "langCode": fingerprint.get("lang_code", "en"),
                                "platform": fingerprint.get("platform", "android"),
                                "healthScore": 100,
                                "dailySendLimit": 50
                            })
                    except Exception as e:
                        print(f"[Backend] Error adding imported account {phone}: {e}", file=sys.stderr)
            
            self.send_event("tdata-imported", {
                "success": True,
                **result
            })
            
            self.send_log(f"ğŸ“¥ TData å°å…¥å®Œæˆï¼šæˆåŠŸ {result['success_count']} å€‹ï¼Œå¤±æ•— {result['fail_count']} å€‹", "info")
            
            # åˆ·æ–°å¸³æˆ¶åˆ—è¡¨
            all_accounts = await db.get_all_accounts()
            self.send_event("accounts-updated", all_accounts)
            
        except Exception as e:
            print(f"[Backend] Error importing TData: {e}", file=sys.stderr)
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("tdata-imported", {
                "success": False,
                "error": str(e)
            })

    # ==================== æ™ºèƒ½æ¨¡çµ„ Handlers (Phase B) ====================
    
    async def handle_get_intent_score(self, payload: Dict[str, Any]):
        """ç²å–æ¶ˆæ¯çš„æ„åœ–è©•åˆ†"""
        try:
            from intent_scorer import score_lead_intent
            
            message = payload.get("message", "")
            context = payload.get("context", [])
            
            result = await score_lead_intent(message, context)
            
            self.send_event("intent-score-result", {
                "success": True,
                **result
            })
        except Exception as e:
            print(f"[Backend] Error scoring intent: {e}", file=sys.stderr)
            self.send_event("intent-score-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_smart_replies(self, payload: Dict[str, Any]):
        """ç²å–æ™ºèƒ½å›è¦†å»ºè­°"""
        try:
            from smart_reply import generate_smart_replies
            
            message = payload.get("message", "")
            context = payload.get("context", [])
            intent_type = payload.get("intentType", "general")
            intent_score = payload.get("intentScore", 50)
            max_suggestions = payload.get("maxSuggestions", 3)
            
            result = await generate_smart_replies(
                message=message,
                context=context,
                intent_type=intent_type,
                intent_score=intent_score,
                max_suggestions=max_suggestions
            )
            
            self.send_event("smart-replies-result", {
                "success": True,
                **result
            })
        except Exception as e:
            print(f"[Backend] Error generating smart replies: {e}", file=sys.stderr)
            self.send_event("smart-replies-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_auto_tags(self, payload: Dict[str, Any]):
        """ç²å–è‡ªå‹•æ¨™ç±¤"""
        try:
            from auto_tagger import auto_tag_lead
            
            message = payload.get("message", "")
            intent_score = payload.get("intentScore", 0)
            source_url = payload.get("sourceUrl", "")
            has_replied = payload.get("hasReplied", False)
            inquiry_count = payload.get("inquiryCount", 0)
            
            result = await auto_tag_lead(
                message=message,
                intent_score=intent_score,
                source_url=source_url,
                has_replied=has_replied,
                inquiry_count=inquiry_count
            )
            
            self.send_event("auto-tags-result", {
                "success": True,
                **result
            })
        except Exception as e:
            print(f"[Backend] Error auto-tagging: {e}", file=sys.stderr)
            self.send_event("auto-tags-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_predict_send_time(self, payload: Dict[str, Any]):
        """é æ¸¬æœ€ä½³ç™¼é€æ™‚é–“"""
        try:
            from send_time_predictor import predict_best_send_time
            
            user_id = payload.get("userId")
            urgency = payload.get("urgency", "normal")
            
            result = await predict_best_send_time(
                user_id=user_id,
                urgency=urgency
            )
            
            self.send_event("send-time-prediction", {
                "success": True,
                **result
            })
        except Exception as e:
            print(f"[Backend] Error predicting send time: {e}", file=sys.stderr)
            self.send_event("send-time-prediction", {
                "success": False,
                "error": str(e)
            })

    # ==================== æµç¨‹è‡ªå‹•åŒ– Handlers (Phase C) ====================
    
    async def handle_get_automation_rules(self, payload: Dict[str, Any]):
        """ç²å–è‡ªå‹•åŒ–è¦å‰‡"""
        try:
            from automation_rules import get_automation_engine
            
            engine = get_automation_engine()
            rules_data = engine.to_dict()
            
            self.send_event("automation-rules", {
                "success": True,
                **rules_data
            })
        except Exception as e:
            print(f"[Backend] Error getting automation rules: {e}", file=sys.stderr)
            self.send_event("automation-rules", {"success": False, "error": str(e)})
    
    async def handle_add_automation_rule(self, payload: Dict[str, Any]):
        """æ·»åŠ è‡ªå‹•åŒ–è¦å‰‡"""
        try:
            from automation_rules import get_automation_engine, AutomationRule, Trigger, Action, TriggerType, ActionType, Condition, ConditionOperator
            
            engine = get_automation_engine()
            
            # æ§‹å»ºè¦å‰‡
            triggers = []
            for t in payload.get("triggers", []):
                conditions = [
                    Condition(c["field"], ConditionOperator(c["operator"]), c["value"])
                    for c in t.get("conditions", [])
                ]
                triggers.append(Trigger(TriggerType(t["type"]), conditions, t.get("params", {})))
            
            actions = [
                Action(ActionType(a["type"]), a.get("params", {}), a.get("delay_seconds", 0))
                for a in payload.get("actions", [])
            ]
            
            rule = AutomationRule(
                id=payload.get("id", f"rule_{len(engine.rules)}"),
                name=payload.get("name", "æ–°è¦å‰‡"),
                description=payload.get("description", ""),
                triggers=triggers,
                actions=actions,
                enabled=payload.get("enabled", True),
                priority=payload.get("priority", 0)
            )
            
            engine.add_rule(rule)
            
            self.send_event("automation-rule-added", {"success": True, "ruleId": rule.id})
        except Exception as e:
            print(f"[Backend] Error adding automation rule: {e}", file=sys.stderr)
            self.send_event("automation-rule-added", {"success": False, "error": str(e)})
    
    async def handle_update_automation_rule(self, payload: Dict[str, Any]):
        """æ›´æ–°è‡ªå‹•åŒ–è¦å‰‡"""
        try:
            from automation_rules import get_automation_engine
            
            engine = get_automation_engine()
            rule_id = payload.get("ruleId")
            updates = payload.get("updates", {})
            
            engine.update_rule(rule_id, updates)
            
            self.send_event("automation-rule-updated", {"success": True, "ruleId": rule_id})
        except Exception as e:
            print(f"[Backend] Error updating automation rule: {e}", file=sys.stderr)
            self.send_event("automation-rule-updated", {"success": False, "error": str(e)})
    
    async def handle_delete_automation_rule(self, payload: Dict[str, Any]):
        """åˆªé™¤è‡ªå‹•åŒ–è¦å‰‡"""
        try:
            from automation_rules import get_automation_engine
            
            engine = get_automation_engine()
            rule_id = payload.get("ruleId")
            
            engine.remove_rule(rule_id)
            
            self.send_event("automation-rule-deleted", {"success": True, "ruleId": rule_id})
        except Exception as e:
            print(f"[Backend] Error deleting automation rule: {e}", file=sys.stderr)
            self.send_event("automation-rule-deleted", {"success": False, "error": str(e)})
    
    async def handle_get_reminders(self, payload: Dict[str, Any]):
        """ç²å–æé†’åˆ—è¡¨"""
        try:
            from follow_up_reminder import get_reminder_system
            
            system = get_reminder_system()
            reminders = system.get_all_reminders()
            stats = system.get_stats()
            
            self.send_event("reminders", {
                "success": True,
                "reminders": [
                    {
                        "id": r.id,
                        "leadId": r.lead_id,
                        "leadName": r.lead_name,
                        "type": r.type.value,
                        "priority": r.priority.value,
                        "message": r.message,
                        "dueAt": r.due_at.isoformat(),
                        "isDue": r.is_due(),
                        "snoozeCount": r.snooze_count
                    }
                    for r in reminders
                ],
                "stats": stats
            })
        except Exception as e:
            print(f"[Backend] Error getting reminders: {e}", file=sys.stderr)
            self.send_event("reminders", {"success": False, "error": str(e)})
    
    async def handle_create_reminder(self, payload: Dict[str, Any]):
        """å‰µå»ºæé†’"""
        try:
            from follow_up_reminder import create_follow_up_reminder
            
            result = await create_follow_up_reminder(
                lead_id=payload.get("leadId"),
                lead_name=payload.get("leadName", ""),
                message=payload.get("message", ""),
                priority=payload.get("priority", "medium"),
                due_in_minutes=payload.get("dueInMinutes", 0)
            )
            
            self.send_event("reminder-created", {"success": True, **result})
        except Exception as e:
            print(f"[Backend] Error creating reminder: {e}", file=sys.stderr)
            self.send_event("reminder-created", {"success": False, "error": str(e)})
    
    async def handle_snooze_reminder(self, payload: Dict[str, Any]):
        """å»¶å¾Œæé†’"""
        try:
            from follow_up_reminder import get_reminder_system
            
            system = get_reminder_system()
            system.snooze_reminder(
                payload.get("reminderId"),
                payload.get("minutes", 30)
            )
            
            self.send_event("reminder-snoozed", {"success": True})
        except Exception as e:
            print(f"[Backend] Error snoozing reminder: {e}", file=sys.stderr)
            self.send_event("reminder-snoozed", {"success": False, "error": str(e)})
    
    async def handle_complete_reminder(self, payload: Dict[str, Any]):
        """å®Œæˆæé†’"""
        try:
            from follow_up_reminder import get_reminder_system
            
            system = get_reminder_system()
            system.complete_reminder(payload.get("reminderId"))
            
            self.send_event("reminder-completed", {"success": True})
        except Exception as e:
            print(f"[Backend] Error completing reminder: {e}", file=sys.stderr)
            self.send_event("reminder-completed", {"success": False, "error": str(e)})
    
    async def handle_process_stage_event(self, payload: Dict[str, Any]):
        """è™•ç†éšæ®µæµè½‰äº‹ä»¶"""
        try:
            from stage_flow import process_stage_event
            
            result = await process_stage_event(
                lead_id=payload.get("leadId"),
                current_stage=payload.get("currentStage"),
                trigger=payload.get("trigger"),
                event_data=payload.get("eventData", {})
            )
            
            self.send_event("stage-event-processed", {
                "success": True,
                "transition": result
            })
        except Exception as e:
            print(f"[Backend] Error processing stage event: {e}", file=sys.stderr)
            self.send_event("stage-event-processed", {"success": False, "error": str(e)})
    
    async def handle_get_stage_flow(self, payload: Dict[str, Any]):
        """ç²å–éšæ®µæµè½‰é…ç½®"""
        try:
            from stage_flow import get_stage_flow_manager
            
            manager = get_stage_flow_manager()
            visualization = manager.get_flow_visualization()
            
            self.send_event("stage-flow", {"success": True, **visualization})
        except Exception as e:
            print(f"[Backend] Error getting stage flow: {e}", file=sys.stderr)
            self.send_event("stage-flow", {"success": False, "error": str(e)})
    
    async def handle_create_ab_test(self, payload: Dict[str, Any]):
        """å‰µå»º A/B æ¸¬è©¦"""
        try:
            from experiments.ab_testing import create_ab_test
            
            result = await create_ab_test(
                name=payload.get("name", "æ–°æ¸¬è©¦"),
                variants=payload.get("variants", []),
                description=payload.get("description", ""),
                primary_metric=payload.get("primaryMetric", "response_rate")
            )
            
            self.send_event("ab-test-created", {"success": True, **result})
        except Exception as e:
            print(f"[Backend] Error creating A/B test: {e}", file=sys.stderr)
            self.send_event("ab-test-created", {"success": False, "error": str(e)})
    
    async def handle_start_ab_test(self, payload: Dict[str, Any]):
        """é–‹å§‹ A/B æ¸¬è©¦"""
        try:
            from experiments.ab_testing import get_ab_testing_manager
            
            manager = get_ab_testing_manager()
            success = manager.start_experiment(payload.get("testId"))
            
            self.send_event("ab-test-started", {"success": success})
        except Exception as e:
            print(f"[Backend] Error starting A/B test: {e}", file=sys.stderr)
            self.send_event("ab-test-started", {"success": False, "error": str(e)})
    
    async def handle_get_ab_test_results(self, payload: Dict[str, Any]):
        """ç²å– A/B æ¸¬è©¦çµæœ"""
        try:
            from experiments.ab_testing import get_ab_testing_manager
            
            manager = get_ab_testing_manager()
            result = manager.analyze_experiment(payload.get("testId"))
            results = {
                "winner": result.winner if result else None,
                "significance": result.statistical_significance if result else 0,
                "recommendations": result.recommendations if result else []
            } if result else None
            
            self.send_event("ab-test-results", {
                "success": True,
                "results": results
            })
        except Exception as e:
            print(f"[Backend] Error getting A/B test results: {e}", file=sys.stderr)
            self.send_event("ab-test-results", {"success": False, "error": str(e)})

    # ==================== æ•¸æ“šé©…å‹• Handlers (Phase D) ====================
    
    async def handle_analyze_attribution(self, payload: Dict[str, Any]):
        """åˆ†æè½‰åŒ–æ­¸å› """
        try:
            from conversion_attribution import analyze_attribution
            
            result = await analyze_attribution(
                model=payload.get("model", "linear"),
                days=payload.get("days", 30)
            )
            
            self.send_event("attribution-analysis", {
                "success": True,
                **result
            })
        except Exception as e:
            print(f"[Backend] Error analyzing attribution: {e}", file=sys.stderr)
            self.send_event("attribution-analysis", {"success": False, "error": str(e)})
    
    async def handle_analyze_account_roi(self, payload: Dict[str, Any]):
        """åˆ†æå¸³è™Ÿ ROI"""
        try:
            from account_roi import analyze_account_roi
            
            result = await analyze_account_roi(
                rank_by=payload.get("rankBy", "efficiency")
            )
            
            self.send_event("account-roi-analysis", {
                "success": True,
                **result
            })
        except Exception as e:
            print(f"[Backend] Error analyzing account ROI: {e}", file=sys.stderr)
            self.send_event("account-roi-analysis", {"success": False, "error": str(e)})
    
    async def handle_analyze_time_effectiveness(self, payload: Dict[str, Any]):
        """åˆ†ææ™‚æ®µæ•ˆæœ"""
        try:
            from time_analysis import analyze_time_effectiveness
            
            result = await analyze_time_effectiveness()
            
            self.send_event("time-analysis", {
                "success": True,
                **result
            })
        except Exception as e:
            print(f"[Backend] Error analyzing time effectiveness: {e}", file=sys.stderr)
            self.send_event("time-analysis", {"success": False, "error": str(e)})
    
    async def handle_predict_lead_conversion(self, payload: Dict[str, Any]):
        """é æ¸¬ Lead è½‰åŒ–"""
        try:
            from predictive_analytics import predict_lead_conversion
            
            result = await predict_lead_conversion(
                lead_id=payload.get("leadId", 0),
                intent_score=payload.get("intentScore", 0),
                interaction_count=payload.get("interactionCount", 0),
                days_since_first_contact=payload.get("daysSinceFirstContact", 0),
                days_since_last_contact=payload.get("daysSinceLastContact", 0),
                replied=payload.get("replied", False),
                reply_speed_minutes=payload.get("replySpeedMinutes", 0),
                source_type=payload.get("sourceType", "unknown")
            )
            
            self.send_event("lead-prediction", {
                "success": True,
                **result
            })
        except Exception as e:
            print(f"[Backend] Error predicting lead conversion: {e}", file=sys.stderr)
            self.send_event("lead-prediction", {"success": False, "error": str(e)})

    # ==================== Resource Discovery Handlers ====================
    
    async def handle_init_resource_discovery(self):
        """åˆå§‹åŒ–è³‡æºç™¼ç¾ç³»çµ±"""
        try:
            self.send_log("ğŸš€ é–‹å§‹åˆå§‹åŒ–è³‡æºç™¼ç¾ç³»çµ±...", "info")
            
            # è¨­ç½®æœç´¢æœå‹™ï¼ˆä¸éœ€è¦é¡å¤–åˆå§‹åŒ–æ•¸æ“šåº«ï¼Œå…±ç”¨ä¸»æ•¸æ“šåº«ï¼‰
            group_search_service.set_clients(self.telegram_manager.clients)
            group_search_service.set_event_callback(self.send_event)
            resource_discovery.set_event_callback(self.send_event)
            resource_discovery._initialized = True  # æ¨™è¨˜ç‚ºå·²åˆå§‹åŒ–
            
            # çµ±è¨ˆå·²é€£æ¥çš„å¸³è™Ÿ
            connected_clients = {phone: client for phone, client in self.telegram_manager.clients.items() if client.is_connected}
            self.send_log(f"ğŸ“± æ‰¾åˆ° {len(connected_clients)} å€‹å·²é€£æ¥çš„å¸³è™Ÿ", "info")

            # è¼‰å…¥è‡ªå®šç¾©æœç´¢æ¸ é“
            await self._refresh_custom_bots()

            self.send_log("âœ… è³‡æºç™¼ç¾ç³»çµ±åˆå§‹åŒ–å®Œæˆ", "success")
            self.send_event("resource-discovery-initialized", {"success": True})
            
        except Exception as e:
            import traceback
            self.send_log(f"âŒ è³‡æºç™¼ç¾ç³»çµ±åˆå§‹åŒ–å¤±æ•—: {e}", "error")
            traceback.print_exc()
            self.send_event("resource-discovery-initialized", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_search_resources(self, payload: Dict[str, Any]):
        """æœç´¢ç¾¤çµ„/é »é“è³‡æº"""
        try:
            query = payload.get('query', '')
            phone = payload.get('phone')
            limit = payload.get('limit', 50)
            keywords = payload.get('keywords', [])
            search_type = payload.get('searchType', 'all')  # all, group, channel, supergroup
            min_members = payload.get('minMembers', 0)
            language = payload.get('language')
            # ğŸ†• Dæ–¹æ¡ˆï¼šæœç´¢æœƒè©± ID
            search_session_id = payload.get('searchSessionId', '')
            search_keyword = payload.get('searchKeyword', query)
            
            if not query:
                self.send_event("search-resources-complete", {
                    "success": False,
                    "error": "æœç´¢é—œéµè©ä¸èƒ½ç‚ºç©º"
                })
                return
            
            self.send_log(f"ğŸ” é–‹å§‹æœç´¢: '{query}'", "info")
            
            # æª¢æŸ¥æ˜¯å¦æœ‰å·²é€£æ¥çš„å®¢æˆ¶ç«¯
            connected_clients = {p: c for p, c in self.telegram_manager.clients.items() if c.is_connected}
            if not connected_clients:
                self.send_log("âš ï¸ æ²’æœ‰å·²é€£æ¥çš„å¸³è™Ÿï¼Œç„¡æ³•æœç´¢", "warning")
                self.send_event("search-resources-complete", {
                    "success": False,
                    "error": "æ²’æœ‰å·²é€£æ¥çš„å¸³è™Ÿï¼Œè«‹å…ˆç™»éŒ„å¸³è™Ÿ"
                })
                return
            
            self.send_log(f"ğŸ“± ä½¿ç”¨ {len(connected_clients)} å€‹å¸³è™Ÿé€²è¡Œæœç´¢", "info")
            
            # ç¢ºä¿å®¢æˆ¶ç«¯å·²è¨­ç½®
            group_search_service.set_clients(self.telegram_manager.clients)
            group_search_service.set_event_callback(self.send_event)
            
            # ç™¼é€æœç´¢é–‹å§‹äº‹ä»¶
            self.send_event("search-progress", {
                "query": query,
                "status": "searching",
                "message": f"æ­£åœ¨æœç´¢ '{query}'..."
            })
            
            # ğŸ†• Cæ–¹æ¡ˆï¼šåªæœç´¢ï¼Œä¸ä¿å­˜åˆ°æ•¸æ“šåº«
            # ç›´æ¥ä½¿ç”¨ search_groups è¿”å›çµæœï¼Œç”¨æˆ¶é»æ“Šæ”¶è—æ™‚æ‰ä¿å­˜
            try:
                search_results = await asyncio.wait_for(
                    group_search_service.search_groups(
                        query=query,
                        phone=phone,
                        limit=limit,
                        search_type=search_type,
                        min_members=min_members,
                        language=language
                    ),
                    timeout=60.0  # 60ç§’è¶…æ™‚
                )
            except asyncio.TimeoutError:
                self.send_log("â±ï¸ æœç´¢è¶…æ™‚ï¼ˆ60ç§’ï¼‰", "warning")
                self.send_event("search-results-direct", {
                    "success": False,
                    "query": query,
                    "error": "æœç´¢è¶…æ™‚ï¼Œè«‹ç¨å¾Œå†è©¦"
                })
                self.send_event("search-resources-complete", {
                    "success": False,
                    "error": "æœç´¢è¶…æ™‚ï¼Œè«‹ç¨å¾Œå†è©¦"
                })
                return
            
            self.send_log(f"ğŸ” æœç´¢å®Œæˆ: æ‰¾åˆ° {len(search_results)} å€‹çµæœ", "success")
            
            # è½‰æ›ç‚ºå‰ç«¯å¯ç”¨çš„æ ¼å¼
            results_for_frontend = []
            for result in search_results:
                # è¨ˆç®—ç›¸é—œåº¦è©•åˆ†
                relevance_score = resource_discovery.calculate_relevance_score(
                    result.title, result.description, [query]
                )
                
                results_for_frontend.append({
                    'id': None,  # æœªä¿å­˜åˆ°æ•¸æ“šåº«ï¼Œæ²’æœ‰ ID
                    'telegram_id': result.telegram_id,
                    'username': result.username,
                    'title': result.title,
                    'description': result.description,
                    'member_count': result.member_count,
                    'resource_type': result.chat_type,
                    'overall_score': relevance_score,
                    'relevance_score': relevance_score,
                    'is_public': result.is_public,
                    'status': 'discovered',
                    'discovery_source': 'search',
                    'discovery_keyword': query,
                    'is_saved': False  # ğŸ†• æ¨™è¨˜ï¼šå°šæœªä¿å­˜åˆ°æ•¸æ“šåº«
                })
            
            # ç™¼é€ç›´æ¥çµæœçµ¦å‰ç«¯
            self.send_event("search-results-direct", {
                "success": True,
                "query": query,
                "results": results_for_frontend,
                "total": len(results_for_frontend)
            })
            
            # åŒæ™‚ç™¼é€èˆŠæ ¼å¼äº‹ä»¶ï¼ˆå…¼å®¹ï¼‰
            self.send_event("search-resources-complete", {
                "success": True,
                "query": query,
                "found": len(results_for_frontend),
                "new": 0,
                "updated": 0
            })
            
        except Exception as e:
            self.send_log(f"âŒ æœç´¢è³‡æºå¤±æ•—: {e}", "error")
            import traceback
            traceback.print_exc()
            self.send_event("search-results-direct", {
                "success": False,
                "query": query,
                "error": str(e)
            })
            self.send_event("search-resources-complete", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_search_jiso(self, payload: Dict[str, Any]):
        """ææœ Bot æœç´¢"""
        try:
            keyword = payload.get('keyword', '').strip()
            phone = payload.get('phone')
            limit = payload.get('limit', 50)
            
            if not keyword:
                self.send_event("search-jiso-complete", {
                    "success": False,
                    "error": "æœç´¢å…³é”®è¯ä¸èƒ½ä¸ºç©º"
                })
                return
            
            self.send_log(f"ğŸ” å¼€å§‹ææœæœç´¢: '{keyword}'", "info")
            
            # ç¡®ä¿å®¢æˆ·ç«¯å·²è®¾ç½®
            jiso_search_service.set_clients(self.telegram_manager.clients)
            jiso_search_service.set_event_callback(self.send_event)
            
            # æ‰§è¡Œæœç´¢
            result = await jiso_search_service.search(
                keyword=keyword,
                phone=phone,
                limit=limit
            )
            
            if result["success"]:
                self.send_log(f"ğŸ” ææœå®Œæˆ: æ‰¾åˆ° {len(result['results'])} ä¸ªç»“æœ", "success")
                
                # ä¿å­˜ç»“æœåˆ°èµ„æºå‘ç°æ•°æ®åº“
                saved_count = 0
                import hashlib as _hashlib
                
                for item in result["results"]:
                    try:
                        # ä¼˜å…ˆä½¿ç”¨ usernameï¼Œå¦åˆ™ä½¿ç”¨ title ç”Ÿæˆå”¯ä¸€æ ‡è¯†
                        username = item.get("username")
                        title = item.get("title", "")

                        # å¦‚æœæ²¡æœ‰ usernameï¼Œå°è¯•ä» title ä¸­æå–æˆ–ç”Ÿæˆ
                        if not username and title:
                            # å°è¯•ä» title ä¸­æå– @username
                            import re
                            at_match = re.search(r'@([a-zA-Z][a-zA-Z0-9_]{3,})', title)
                            if at_match:
                                username = at_match.group(1)
                            else:
                                # ä½¿ç”¨ title çš„å“ˆå¸Œä½œä¸ºå”¯ä¸€æ ‡è¯†
                                title_hash = _hashlib.md5(title.encode()).hexdigest()[:12]
                                username = f"jiso_{title_hash}"

                        if username or title:
                            # è¨ˆç®—ç›¸é—œåº¦è©•åˆ†
                            description = item.get("description", "")
                            relevance_score = resource_discovery.calculate_relevance_score(
                                title, description, [keyword]
                            )
                            
                            # åˆ¤æ–·æ˜¯å¦æœ‰çœŸå¯¦éˆæ¥ï¼ˆç”¨æ–¼å¯é”æ€§è©•åˆ†ï¼‰
                            has_real_link = bool(item.get("link") or (username and not username.startswith("jiso_")))
                            
                            # åˆ›å»º DiscoveredResource å¯¹è±¡
                            resource = DiscoveredResource(
                                telegram_id=username or f"jiso_{saved_count}",
                                username=username if not username.startswith("jiso_") else "",  # jiso_ é–‹é ­ä¸æ˜¯çœŸå¯¦ username
                                title=title,
                                description=description,
                                member_count=item.get("member_count", 0),
                                resource_type=item.get("chat_type", "supergroup"),
                                discovery_source="jiso",
                                discovery_keyword=keyword,
                                status="discovered",
                                relevance_score=relevance_score,
                                invite_link=item.get("link", "")
                            )
                            resource_id = await resource_discovery.add_resource(resource)
                            if saved_count < 3:  # åªæ˜¾ç¤ºå‰3ä¸ª
                                self.send_log(f"  ğŸ’¾ ä¿å­˜: {title[:30]}... (ID:{resource_id})", "info")
                            saved_count += 1
                    except Exception as e:
                        self.send_log(f"ä¿å­˜èµ„æºå¤±è´¥: {e}", "warning")
                        import traceback
                        traceback.print_exc()

                self.send_log(f"ğŸ’¾ æ€»å…±ä¿å­˜äº† {saved_count}/{len(result['results'])} ä¸ªèµ„æº", "info")
            
            self.send_event("search-jiso-complete", result)
            
        except Exception as e:
            self.send_log(f"âŒ ææœå¤±è´¥: {e}", "error")
            import traceback
            traceback.print_exc()
            self.send_event("search-jiso-complete", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_check_jiso_availability(self, payload: Dict[str, Any]):
        """æ£€æŸ¥ææœå¯ç”¨æ€§"""
        try:
            phone = payload.get('phone')
            
            # ç¡®ä¿å®¢æˆ·ç«¯å·²è®¾ç½®
            jiso_search_service.set_clients(self.telegram_manager.clients)
            
            result = await jiso_search_service.check_availability(phone)
            
            self.send_event("jiso-availability", result)
            
        except Exception as e:
            self.send_event("jiso-availability", {
                "available": False,
                "reason": str(e)
            })
    
    async def handle_clear_resources(self, payload: Dict[str, Any]):
        """ğŸ†• æ¸…ç†è³‡æºæ•¸æ“š"""
        try:
            clear_type = payload.get('type', 'all')  # all, search_history, old_data
            days_to_keep = payload.get('daysToKeep', 0)  # ä¿ç•™æœ€è¿‘ N å¤©çš„æ•¸æ“š
            
            self.send_log(f"ğŸ§¹ é–‹å§‹æ¸…ç†è³‡æºæ•¸æ“š (é¡å‹: {clear_type})...", "info")
            
            deleted_count = 0
            
            if clear_type == 'all':
                # æ¸…ç†æ‰€æœ‰ discovered_resources
                result = await db.execute_async(
                    "DELETE FROM discovered_resources"
                )
                deleted_count = result.rowcount if hasattr(result, 'rowcount') else 0
                
            elif clear_type == 'old_data':
                # æ¸…ç†èˆŠæ•¸æ“šï¼ˆä¿ç•™æœ€è¿‘ N å¤©ï¼‰
                if days_to_keep > 0:
                    cutoff_date = datetime.now() - timedelta(days=days_to_keep)
                    result = await db.execute_async(
                        "DELETE FROM discovered_resources WHERE discovered_at < ?",
                        (cutoff_date.isoformat(),)
                    )
                    deleted_count = result.rowcount if hasattr(result, 'rowcount') else 0
                else:
                    result = await db.execute_async(
                        "DELETE FROM discovered_resources"
                    )
                    deleted_count = result.rowcount if hasattr(result, 'rowcount') else 0
            
            elif clear_type == 'search_history':
                # åªæ¸…ç†æœç´¢æ­·å²ï¼ˆä¿ç•™å·²æ”¶è—çš„ï¼‰
                result = await db.execute_async(
                    "DELETE FROM discovered_resources WHERE is_saved = 0 OR is_saved IS NULL"
                )
                deleted_count = result.rowcount if hasattr(result, 'rowcount') else 0
            
            self.send_log(f"âœ… æ¸…ç†å®Œæˆï¼Œå·²åˆªé™¤ {deleted_count} æ¢è¨˜éŒ„", "success")
            
            # ç™¼é€æ›´æ–°äº‹ä»¶
            self.send_event("clear-resources-complete", {
                "success": True,
                "deleted_count": deleted_count,
                "type": clear_type
            })
            
            # é‡æ–°ç²å–è³‡æºçµ±è¨ˆ
            await self.handle_get_resource_stats({})
            
        except Exception as e:
            self.send_log(f"âŒ æ¸…ç†å¤±æ•—: {e}", "error")
            import traceback
            traceback.print_exc()
            self.send_event("clear-resources-complete", {
                "success": False,
                "error": str(e)
            })

    # ==================== è‡ªå®šç¾©æœç´¢æ¸ é“ç®¡ç† ====================

    async def handle_get_search_channels(self, payload: Dict[str, Any]):
        """ç²å–æœç´¢æ¸ é“åˆ—è¡¨"""
        try:
            enabled_only = payload.get('enabledOnly', False)
            
            # ç²å–è‡ªå®šç¾©æ¸ é“
            custom_channels = await db.get_custom_search_channels(enabled_only)
            
            # ç³»çµ±æ¸ é“å·²å…§å»ºåœ¨å¾Œç«¯ï¼Œä¸åœ¨å‰ç«¯é¡¯ç¤º
            # å‰ç«¯åªç®¡ç†ç”¨æˆ¶è‡ªå®šç¾©æ¸ é“
            system_channels = []
            
            # æ¨™è¨˜è‡ªå®šç¾©æ¸ é“
            for ch in custom_channels:
                ch['is_system'] = False
            
            self.send_event("search-channels-list", {
                "success": True,
                "system_channels": system_channels,
                "custom_channels": custom_channels
            })
            
        except Exception as e:
            self.send_log(f"ç²å–æœç´¢æ¸ é“å¤±æ•—: {e}", "error")
            self.send_event("search-channels-list", {
                "success": False,
                "error": str(e)
            })

    async def handle_add_search_channel(self, payload: Dict[str, Any]):
        """æ·»åŠ è‡ªå®šç¾©æœç´¢æ¸ é“"""
        try:
            bot_username = payload.get('botUsername', '').strip().lstrip('@')
            display_name = payload.get('displayName', '').strip()
            query_format = payload.get('queryFormat', '{keyword}')
            priority = payload.get('priority', 'backup')
            notes = payload.get('notes', '')
            
            if not bot_username:
                self.send_event("search-channel-added", {
                    "success": False,
                    "error": "Bot ç”¨æˆ¶åä¸èƒ½ç‚ºç©º"
                })
                return
            
            # æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
            existing = await db.get_custom_search_channels()
            for ch in existing:
                if ch['bot_username'] == bot_username:
                    self.send_event("search-channel-added", {
                        "success": False,
                        "error": f"@{bot_username} å·²å­˜åœ¨"
                    })
                    return
            
            channel_id = await db.add_custom_search_channel(
                bot_username=bot_username,
                display_name=display_name or bot_username,
                query_format=query_format,
                priority=priority,
                notes=notes
            )
            
            if channel_id:
                self.send_log(f"â• æ·»åŠ æœç´¢æ¸ é“: @{bot_username}", "success")
                self.send_event("search-channel-added", {
                    "success": True,
                    "channelId": channel_id,
                    "botUsername": bot_username
                })
                
                # æ›´æ–° jiso_search_service çš„è‡ªå®šç¾© Bot åˆ—è¡¨
                await self._refresh_custom_bots()
            else:
                self.send_event("search-channel-added", {
                    "success": False,
                    "error": "æ·»åŠ å¤±æ•—"
                })
                
        except Exception as e:
            self.send_log(f"æ·»åŠ æœç´¢æ¸ é“å¤±æ•—: {e}", "error")
            self.send_event("search-channel-added", {
                "success": False,
                "error": str(e)
            })

    async def handle_update_search_channel(self, payload: Dict[str, Any]):
        """æ›´æ–°æœç´¢æ¸ é“"""
        try:
            channel_id = payload.get('channelId')
            
            if not channel_id or channel_id < 0:
                self.send_event("search-channel-updated", {
                    "success": False,
                    "error": "ç„¡æ³•ä¿®æ”¹ç³»çµ±æ¸ é“"
                })
                return
            
            updates = {}
            if 'displayName' in payload:
                updates['display_name'] = payload['displayName']
            if 'queryFormat' in payload:
                updates['query_format'] = payload['queryFormat']
            if 'priority' in payload:
                updates['priority'] = payload['priority']
            if 'enabled' in payload:
                updates['enabled'] = 1 if payload['enabled'] else 0
            if 'notes' in payload:
                updates['notes'] = payload['notes']
            
            success = await db.update_custom_search_channel(channel_id, **updates)
            
            if success:
                self.send_log(f"âœï¸ æ›´æ–°æœç´¢æ¸ é“ ID:{channel_id}", "success")
                await self._refresh_custom_bots()
            
            self.send_event("search-channel-updated", {
                "success": success,
                "channelId": channel_id
            })
            
        except Exception as e:
            self.send_log(f"æ›´æ–°æœç´¢æ¸ é“å¤±æ•—: {e}", "error")
            self.send_event("search-channel-updated", {
                "success": False,
                "error": str(e)
            })

    async def handle_delete_search_channel(self, payload: Dict[str, Any]):
        """åˆªé™¤æœç´¢æ¸ é“"""
        try:
            channel_id = payload.get('channelId')
            
            if not channel_id or channel_id < 0:
                self.send_event("search-channel-deleted", {
                    "success": False,
                    "error": "ç„¡æ³•åˆªé™¤ç³»çµ±æ¸ é“"
                })
                return
            
            success = await db.delete_custom_search_channel(channel_id)
            
            if success:
                self.send_log(f"ğŸ—‘ï¸ åˆªé™¤æœç´¢æ¸ é“ ID:{channel_id}", "success")
                await self._refresh_custom_bots()
            
            self.send_event("search-channel-deleted", {
                "success": success,
                "channelId": channel_id
            })
            
        except Exception as e:
            self.send_log(f"åˆªé™¤æœç´¢æ¸ é“å¤±æ•—: {e}", "error")
            self.send_event("search-channel-deleted", {
                "success": False,
                "error": str(e)
            })

    async def handle_test_search_channel(self, payload: Dict[str, Any]):
        """æ¸¬è©¦æœç´¢æ¸ é“"""
        try:
            bot_username = payload.get('botUsername', '').lstrip('@')
            
            if not bot_username:
                self.send_event("search-channel-tested", {
                    "success": False,
                    "error": "Bot ç”¨æˆ¶åä¸èƒ½ç‚ºç©º"
                })
                return
            
            self.send_log(f"ğŸ” æ¸¬è©¦æ¸ é“: @{bot_username}...", "info")
            
            # ä½¿ç”¨ jiso_search_service æ¸¬è©¦ Bot
            import time
            start_time = time.time()
            
            jiso_search_service.set_clients(self.telegram_manager.clients)
            
            # å˜—è©¦è§£æ Bot
            available_clients = {p: c for p, c in self.telegram_manager.clients.items() if c.is_connected}
            if not available_clients:
                self.send_event("search-channel-tested", {
                    "success": False,
                    "botUsername": bot_username,
                    "status": "offline",
                    "error": "æ²’æœ‰å¯ç”¨çš„å¸³è™Ÿ"
                })
                return
            
            client = list(available_clients.values())[0]
            peer = await jiso_search_service._resolve_bot(client, bot_username)
            
            response_time = time.time() - start_time
            
            if peer:
                # æ›´æ–°æ•¸æ“šåº«
                await db.update_channel_test_result(bot_username, True, response_time)
                
                self.send_log(f"âœ… @{bot_username} å¯ç”¨ ({response_time:.1f}s)", "success")
                self.send_event("search-channel-tested", {
                    "success": True,
                    "botUsername": bot_username,
                    "status": "online",
                    "responseTime": response_time
                })
            else:
                await db.update_channel_test_result(bot_username, False)
                
                self.send_log(f"âŒ @{bot_username} ä¸å¯ç”¨", "warning")
                self.send_event("search-channel-tested", {
                    "success": False,
                    "botUsername": bot_username,
                    "status": "offline",
                    "error": "Bot ä¸å­˜åœ¨æˆ–ä¸å¯è¨ªå•"
                })
                
        except Exception as e:
            self.send_log(f"æ¸¬è©¦æ¸ é“å¤±æ•—: {e}", "error")
            self.send_event("search-channel-tested", {
                "success": False,
                "error": str(e)
            })

    async def _refresh_custom_bots(self):
        """åˆ·æ–°è‡ªå®šç¾© Bot åˆ—è¡¨åˆ° jiso_search_service"""
        try:
            channels = await db.get_custom_search_channels(enabled_only=True)
            custom_bots = [ch['bot_username'] for ch in channels]
            jiso_search_service.config.custom_bots = custom_bots
            self.send_log(f"ğŸ”„ å·²åˆ·æ–°è‡ªå®šç¾© Bot åˆ—è¡¨: {len(custom_bots)} å€‹", "info")
        except Exception as e:
            self.send_log(f"åˆ·æ–°è‡ªå®šç¾© Bot åˆ—è¡¨å¤±æ•—: {e}", "warning")

    async def handle_get_resources(self, payload: Dict[str, Any]):
        """ç²å–è³‡æºåˆ—è¡¨"""
        print(f"[Backend] handle_get_resources called with payload: {payload}", file=sys.stderr)
        try:
            status = payload.get('status')
            resource_type = payload.get('type')
            limit = payload.get('limit', 50)
            offset = payload.get('offset', 0)
            # ğŸ†• å„ªåŒ–æ’åºï¼šæŒ‰ç›¸é—œæ€§è©•åˆ†é™åº + æ›´æ–°æ™‚é–“é™åº
            order_by = payload.get('orderBy', 'overall_score DESC, updated_at DESC')
            # ğŸ†• æ”¯æŒæŒ‰æœç´¢æœƒè©±éæ¿¾
            search_session_id = payload.get('searchSessionId')
            search_keyword = payload.get('searchKeyword')
            
            print(f"[Backend] Fetching resources with limit={limit}, session={search_session_id}...", file=sys.stderr)
            resources = await resource_discovery.list_resources(
                status=status,
                resource_type=resource_type,
                limit=limit,
                offset=offset,
                order_by=order_by,
                search_session_id=search_session_id,
                search_keyword=search_keyword
            )
            
            total = await resource_discovery.count_resources(
                status=status, 
                resource_type=resource_type,
                search_session_id=search_session_id,
                search_keyword=search_keyword
            )
            print(f"[Backend] Found {len(resources)} resources (total: {total})", file=sys.stderr)
            
            self.send_event("resources-list", {
                "success": True,
                "resources": resources,
                "total": total,
                "limit": limit,
                "offset": offset,
                "searchSessionId": search_session_id  # ğŸ†• è¿”å›æœƒè©± ID
            })
            print(f"[Backend] Sent resources-list event", file=sys.stderr)
            
            # ğŸ”§ å¾Œå°è‡ªå‹•é©—è­‰æœªé©—è­‰é¡å‹çš„è³‡æºï¼ˆç•°æ­¥åŸ·è¡Œï¼Œä¸é˜»å¡ï¼‰
            asyncio.create_task(self._auto_verify_resource_types(resources))
            
        except Exception as e:
            self.send_log(f"âŒ ç²å–è³‡æºåˆ—è¡¨å¤±æ•—: {e}", "error")
            self.send_event("resources-list", {
                "success": False,
                "error": str(e)
            })
    
    async def _auto_verify_resource_types(self, resources: list):
        """å¾Œå°è‡ªå‹•é©—è­‰è³‡æºé¡å‹"""
        import sys
        import asyncio
        
        try:
            # æ‰¾å‡ºæœªé©—è­‰çš„è³‡æºï¼ˆtype_verified = 0 æˆ–ä¸å­˜åœ¨ï¼‰
            unverified = [r for r in resources if not r.get('type_verified')]
            
            if not unverified:
                return
            
            # ç²å–åœ¨ç·šå¸³è™Ÿ
            accounts = await db.get_all_accounts()
            online_phone = None
            for acc in accounts:
                if acc.get('status') == 'Online':
                    phone = acc.get('phone')
                    if phone in self.telegram_manager.clients:
                        online_phone = phone
                        break
            
            if not online_phone:
                return  # æ²’æœ‰å¯ç”¨å¸³è™Ÿï¼Œè·³éé©—è­‰
            
            client = self.telegram_manager.clients[online_phone]
            
            # æ‰¹é‡é©—è­‰ï¼ˆæ¯æ¬¡æœ€å¤š 5 å€‹ï¼Œä½¿ç”¨æ™ºèƒ½ FloodWait è™•ç†ï¼‰
            verified_count = 0
            for resource in unverified[:5]:
                try:
                    username = resource.get('username', '')
                    invite_link = resource.get('invite_link', '')
                    chat_target = username or invite_link
                    
                    if not chat_target:
                        continue
                    
                    # ğŸ†• ä½¿ç”¨æ™ºèƒ½ FloodWait è™•ç†
                    await flood_handler.wait_before_operation(online_phone, 'get_chat')
                    
                    chat_info = await client.get_chat(chat_target)
                    
                    if chat_info:
                        from pyrogram.enums import ChatType
                        if chat_info.type == ChatType.CHANNEL:
                            new_type = "channel"
                        elif chat_info.type == ChatType.SUPERGROUP:
                            new_type = "supergroup"
                        elif chat_info.type == ChatType.GROUP:
                            new_type = "group"
                        else:
                            new_type = resource.get('resource_type', 'unknown')
                        
                        old_type = resource.get('resource_type', 'unknown')
                        resource_id = resource.get('id')
                        
                        # æ›´æ–°æ•¸æ“šåº«
                        await db.execute(
                            "UPDATE discovered_resources SET resource_type = ?, type_verified = 1 WHERE id = ?",
                            (new_type, resource_id)
                        )
                        await db._connection.commit()
                        
                        verified_count += 1
                        
                        if new_type != old_type:
                            # ç™¼é€æ›´æ–°äº‹ä»¶åˆ°å‰ç«¯
                            self.send_event("resource-type-verified", {
                                "success": True,
                                "resourceId": resource_id,
                                "oldType": old_type,
                                "newType": new_type,
                                "title": resource.get('title', '')
                            })
                            
                except Exception as e:
                    error_str = str(e).lower()
                    resource_id = resource.get('id')
                    username = resource.get('username', 'unknown')
                    
                    # éŒ¯èª¤åˆ†é¡å’Œè™•ç†
                    if 'username not found' in error_str or 'not found' in error_str:
                        # ç”¨æˆ¶åä¸å­˜åœ¨ï¼šæ¨™è¨˜ç‚ºç„¡æ•ˆ
                        await db.execute(
                            "UPDATE discovered_resources SET status = 'invalid', type_verified = 1, notes = ? WHERE id = ?",
                            (f"ç”¨æˆ¶åä¸å­˜åœ¨: {username}", resource_id)
                        )
                        await db._connection.commit()
                        # åªåœ¨èª¿è©¦æ™‚è¼¸å‡ºï¼ˆé¿å…æ—¥èªŒéå¤šï¼‰
                        print(f"[Backend] Resource {resource_id}: Username not found ({username})", file=sys.stderr)
                    elif 'floodwait' in error_str:
                        # FloodWaitï¼šè·³éï¼Œç¨å¾Œé‡è©¦
                        print(f"[Backend] FloodWait during verification, skipping remaining", file=sys.stderr)
                        break  # åœæ­¢æœ¬æ¬¡é©—è­‰ï¼Œé¿å…è§¸ç™¼æ›´å¤šé™åˆ¶
                    elif 'peer_flood' in error_str or 'flood' in error_str:
                        # è§¸ç™¼ Flood é™åˆ¶ï¼Œåœæ­¢é©—è­‰
                        print(f"[Backend] Flood limit hit, stopping verification", file=sys.stderr)
                        break
                    elif 'forbidden' in error_str or 'access' in error_str:
                        # æ¬Šé™å•é¡Œï¼šæ¨™è¨˜éœ€è¦æ‰‹å‹•é©—è­‰
                        await db.execute(
                            "UPDATE discovered_resources SET notes = ? WHERE id = ?",
                            (f"éœ€è¦æ‰‹å‹•é©—è­‰: æ¬Šé™ä¸è¶³", resource_id)
                        )
                        await db._connection.commit()
                    else:
                        # å…¶ä»–éŒ¯èª¤ï¼šåªè¨˜éŒ„æ—¥èªŒ
                        print(f"[Backend] Auto-verify error for resource {resource_id}: {e}", file=sys.stderr)
                    continue
            
            if verified_count > 0:
                print(f"[Backend] Auto-verified {verified_count} resource types", file=sys.stderr)
                
        except Exception as e:
            print(f"[Backend] Error in auto-verify task: {e}", file=sys.stderr)
    
    async def handle_get_resource_stats(self, payload: Dict[str, Any] = None):
        """ç²å–è³‡æºçµ±è¨ˆ"""
        try:
            stats = await resource_discovery.get_statistics()
            
            self.send_event("resource-stats", {
                "success": True,
                **stats
            })
            
        except Exception as e:
            self.send_log(f"âŒ ç²å–è³‡æºçµ±è¨ˆå¤±æ•—: {e}", "error")
            self.send_event("resource-stats", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_add_resource_manually(self, payload: Dict[str, Any]):
        """æ‰‹å‹•æ·»åŠ è³‡æº"""
        try:
            resource = DiscoveredResource(
                resource_type=payload.get('type', 'group'),
                telegram_id=payload.get('telegramId', ''),
                username=payload.get('username', ''),
                title=payload.get('title', ''),
                description=payload.get('description', ''),
                member_count=payload.get('memberCount', 0),
                invite_link=payload.get('inviteLink', ''),
                discovery_source='manual',
                tags=payload.get('tags', []),
                notes=payload.get('notes', '')
            )
            
            # å¦‚æœæœ‰ username æˆ–é‚€è«‹éˆæ¥ï¼Œå˜—è©¦ç²å–è©³ç´°ä¿¡æ¯ä¸¦è‡ªå‹•è­˜åˆ¥é¡å‹
            if resource.username or resource.invite_link:
                group_search_service.set_clients(self.telegram_manager.clients)
                chat_id = resource.username or resource.invite_link
                info = await group_search_service.get_chat_info(chat_id)
                if info and 'error' not in info:
                    resource.telegram_id = info.get('telegram_id', resource.telegram_id)
                    resource.title = info.get('title', resource.title)
                    resource.description = info.get('description', resource.description)
                    resource.member_count = info.get('member_count', resource.member_count)
                    resource.is_public = info.get('is_public', True)
                    resource.has_discussion = info.get('has_discussion', False)
                    # ğŸ”§ è‡ªå‹•è­˜åˆ¥è³‡æºé¡å‹ï¼ˆé »é“/ç¾¤çµ„ï¼‰
                    chat_type = info.get('type', '')
                    if chat_type:
                        resource.resource_type = chat_type
                        self.send_log(f"ğŸ“‹ è‡ªå‹•è­˜åˆ¥é¡å‹: {chat_type}", "info")
            
            resource_id = await resource_discovery.add_resource(resource)
            
            self.send_log(f"â• æ‰‹å‹•æ·»åŠ è³‡æº: {resource.title or resource.username}", "success")
            self.send_event("resource-added", {
                "success": True,
                "resourceId": resource_id
            })
            
        except Exception as e:
            self.send_log(f"âŒ æ·»åŠ è³‡æºå¤±æ•—: {e}", "error")
            self.send_event("resource-added", {
                "success": False,
                "error": str(e)
            })
    
    # ğŸ†• Cæ–¹æ¡ˆï¼šæ”¶è—è³‡æºï¼ˆä¿å­˜åˆ°æ•¸æ“šåº«ï¼‰
    async def handle_save_resource(self, payload: Dict[str, Any]):
        """æ”¶è—è³‡æº - å°‡æœç´¢çµæœä¿å­˜åˆ°æ•¸æ“šåº«"""
        try:
            telegram_id = payload.get('telegram_id')
            if not telegram_id:
                raise ValueError("ç¼ºå°‘ telegram_id")
            
            # æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
            existing = await resource_discovery.get_resource_by_telegram_id(telegram_id)
            if existing:
                self.send_log(f"â­ è³‡æºå·²å­˜åœ¨: {payload.get('title')}", "info")
                self.send_event("resource-saved", {
                    "success": True,
                    "telegram_id": telegram_id,
                    "resource_id": existing['id'],
                    "already_exists": True
                })
                return
            
            # å‰µå»ºæ–°è³‡æº
            from resource_discovery import DiscoveredResource
            resource = DiscoveredResource(
                resource_type=payload.get('resource_type', 'group'),
                telegram_id=telegram_id,
                username=payload.get('username', ''),
                title=payload.get('title', ''),
                description=payload.get('description', ''),
                member_count=payload.get('member_count', 0),
                activity_score=0.5,
                relevance_score=payload.get('overall_score', 0.5),
                discovery_source='search',
                discovery_keyword=payload.get('discovery_keyword', ''),
                discovered_by_phone='',
                status='discovered'
            )
            
            resource_id = await resource_discovery.add_resource(resource)
            
            self.send_log(f"â­ å·²æ”¶è—: {payload.get('title')}", "success")
            self.send_event("resource-saved", {
                "success": True,
                "telegram_id": telegram_id,
                "resource_id": resource_id,
                "already_exists": False
            })
            
        except Exception as e:
            self.send_log(f"âŒ æ”¶è—å¤±æ•—: {e}", "error")
            self.send_event("resource-saved", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_unsave_resource(self, payload: Dict[str, Any]):
        """å–æ¶ˆæ”¶è— - å¾æ•¸æ“šåº«åˆªé™¤è³‡æº"""
        try:
            telegram_id = payload.get('telegram_id')
            if not telegram_id:
                raise ValueError("ç¼ºå°‘ telegram_id")
            
            # æŸ¥æ‰¾è³‡æº
            existing = await resource_discovery.get_resource_by_telegram_id(telegram_id)
            if not existing:
                self.send_log(f"è³‡æºä¸å­˜åœ¨ï¼Œç„¡éœ€åˆªé™¤", "info")
                self.send_event("resource-unsaved", {
                    "success": True,
                    "telegram_id": telegram_id
                })
                return
            
            # åˆªé™¤è³‡æº
            await resource_discovery.delete_resource(existing['id'])
            
            self.send_log(f"ğŸ—‘ï¸ å·²å–æ¶ˆæ”¶è—", "success")
            self.send_event("resource-unsaved", {
                "success": True,
                "telegram_id": telegram_id
            })
            
        except Exception as e:
            self.send_log(f"âŒ å–æ¶ˆæ”¶è—å¤±æ•—: {e}", "error")
            self.send_event("resource-unsaved", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_delete_resource(self, payload: Dict[str, Any]):
        """åˆªé™¤è³‡æº"""
        try:
            resource_id = payload.get('resourceId')
            if not resource_id:
                raise ValueError("è³‡æº ID ä¸èƒ½ç‚ºç©º")
            
            await resource_discovery.delete_resource(resource_id)
            
            self.send_log(f"ğŸ—‘ï¸ å·²åˆªé™¤è³‡æº ID: {resource_id}", "success")
            self.send_event("resource-deleted", {
                "success": True,
                "resourceId": resource_id
            })
            
        except Exception as e:
            self.send_log(f"âŒ åˆªé™¤è³‡æºå¤±æ•—: {e}", "error")
            self.send_event("resource-deleted", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_delete_resources_batch(self, payload: Dict[str, Any]):
        """æ‰¹é‡åˆªé™¤è³‡æº"""
        try:
            resource_ids = payload.get('resourceIds', [])
            if not resource_ids:
                raise ValueError("è³‡æº ID åˆ—è¡¨ä¸èƒ½ç‚ºç©º")
            
            deleted_count = 0
            for rid in resource_ids:
                try:
                    await resource_discovery.delete_resource(rid)
                    deleted_count += 1
                except Exception as e:
                    self.send_log(f"åˆªé™¤è³‡æº {rid} å¤±æ•—: {e}", "warning")
            
            self.send_log(f"ğŸ—‘ï¸ å·²æ‰¹é‡åˆªé™¤ {deleted_count}/{len(resource_ids)} å€‹è³‡æº", "success")
            self.send_event("resources-batch-deleted", {
                "success": True,
                "deletedCount": deleted_count,
                "totalRequested": len(resource_ids)
            })
            
        except Exception as e:
            self.send_log(f"âŒ æ‰¹é‡åˆªé™¤è³‡æºå¤±æ•—: {e}", "error")
            self.send_event("resources-batch-deleted", {
                "success": False,
                "error": str(e)
            })

    async def handle_verify_resource_type(self, payload: Dict[str, Any]):
        """é©—è­‰ä¸¦æ›´æ–°è³‡æºçš„çœŸå¯¦é¡å‹"""
        try:
            import sys
            resource_id = payload.get('resourceId')
            
            if not resource_id:
                raise ValueError("è³‡æº ID ä¸èƒ½ç‚ºç©º")
            
            # ç²å–è³‡æºè©³æƒ…
            from database import db
            await db.connect()
            
            resources = await db.fetch_all(
                "SELECT * FROM discovered_resources WHERE id = ?",
                (resource_id,)
            )
            
            if not resources:
                raise ValueError(f"æ‰¾ä¸åˆ°è³‡æº ID: {resource_id}")
            
            resource = resources[0]
            username = resource.get('username', '')
            invite_link = resource.get('invite_link', '')
            title = resource.get('title', '')
            old_type = resource.get('resource_type', 'unknown')
            
            self.send_log(f"ğŸ” æ­£åœ¨é©—è­‰è³‡æºé¡å‹: {title}", "info")
            
            # ç²å–åœ¨ç·šå¸³è™Ÿ
            accounts = await db.get_all_accounts()
            online_phone = None
            for acc in accounts:
                if acc.get('status') == 'Online':
                    phone = acc.get('phone')
                    if phone in self.telegram_manager.clients:
                        online_phone = phone
                        break
            
            if not online_phone:
                raise ValueError("æ²’æœ‰å¯ç”¨çš„åœ¨ç·šå¸³è™Ÿï¼Œè«‹å…ˆç™»éŒ„")
            
            client = self.telegram_manager.clients[online_phone]
            
            # ä½¿ç”¨ Telegram API ç²å–çœŸå¯¦é¡å‹
            chat_target = username or invite_link
            if not chat_target:
                raise ValueError("æ²’æœ‰å¯ç”¨çš„ username æˆ– invite_link")
            
            chat_info = await client.get_chat(chat_target)
            
            verified_type = old_type
            if chat_info:
                from pyrogram.enums import ChatType
                if chat_info.type == ChatType.CHANNEL:
                    verified_type = "channel"
                elif chat_info.type == ChatType.SUPERGROUP:
                    verified_type = "supergroup"
                elif chat_info.type == ChatType.GROUP:
                    verified_type = "group"
                elif chat_info.type == ChatType.BOT:
                    verified_type = "bot"
            
            # æ›´æ–°æ•¸æ“šåº«
            if verified_type != old_type:
                await db.execute(
                    "UPDATE discovered_resources SET resource_type = ? WHERE id = ?",
                    (verified_type, resource_id)
                )
                await db._connection.commit()
                self.send_log(f"âœ… é¡å‹å·²æ›´æ–°: {old_type} â†’ {verified_type}", "success")
            else:
                self.send_log(f"âœ… é¡å‹ç¢ºèª: {verified_type}", "info")
            
            self.send_event("resource-type-verified", {
                "success": True,
                "resourceId": resource_id,
                "oldType": old_type,
                "newType": verified_type,
                "title": title
            })
            
        except Exception as e:
            import sys
            print(f"[Backend] Error verifying resource type: {e}", file=sys.stderr)
            self.send_log(f"âŒ é©—è­‰é¡å‹å¤±æ•—: {e}", "error")
            self.send_event("resource-type-verified", {
                "success": False,
                "resourceId": payload.get('resourceId'),
                "error": str(e)
            })

    async def handle_batch_verify_resource_types(self, payload: Dict[str, Any]):
        """æ‰¹é‡é©—è­‰è³‡æºé¡å‹ï¼ˆåœ¨å¾Œå°éœé»˜è™•ç†ï¼Œé¿å… FloodWaitï¼‰"""
        try:
            import sys
            import asyncio
            resource_ids = payload.get('resourceIds', [])
            
            if not resource_ids:
                return
            
            print(f"[Backend] Batch verifying {len(resource_ids)} resources", file=sys.stderr)
            
            # ç²å–åœ¨ç·šå¸³è™Ÿ
            from database import db
            await db.connect()
            accounts = await db.get_all_accounts()
            online_phone = None
            for acc in accounts:
                if acc.get('status') == 'Online':
                    phone = acc.get('phone')
                    if phone in self.telegram_manager.clients:
                        online_phone = phone
                        break
            
            if not online_phone:
                print("[Backend] No online account for batch verification", file=sys.stderr)
                return
            
            client = self.telegram_manager.clients[online_phone]
            verified_count = 0
            
            for resource_id in resource_ids:
                try:
                    resources = await db.fetch_all(
                        "SELECT * FROM discovered_resources WHERE id = ?",
                        (resource_id,)
                    )
                    
                    if not resources:
                        continue
                    
                    resource = resources[0]
                    username = resource.get('username', '')
                    old_type = resource.get('resource_type', 'unknown')
                    
                    if not username:
                        continue
                    
                    chat_info = await client.get_chat(username)
                    
                    if chat_info:
                        from pyrogram.enums import ChatType
                        if chat_info.type == ChatType.CHANNEL:
                            new_type = "channel"
                        elif chat_info.type == ChatType.SUPERGROUP:
                            new_type = "supergroup"
                        elif chat_info.type == ChatType.GROUP:
                            new_type = "group"
                        else:
                            new_type = old_type
                        
                        if new_type != old_type:
                            await db.execute(
                                "UPDATE discovered_resources SET resource_type = ?, type_verified = 1 WHERE id = ?",
                                (new_type, resource_id)
                            )
                            await db._connection.commit()
                            verified_count += 1
                            print(f"[Backend] Type updated: {resource.get('title')} {old_type} -> {new_type}", file=sys.stderr)
                        else:
                            # æ¨™è¨˜ç‚ºå·²é©—è­‰
                            await db.execute(
                                "UPDATE discovered_resources SET type_verified = 1 WHERE id = ?",
                                (resource_id,)
                            )
                            await db._connection.commit()
                    
                    # ç­‰å¾… 1-2 ç§’é¿å… FloodWait
                    await asyncio.sleep(1.5)
                    
                except Exception as e:
                    print(f"[Backend] Error verifying resource {resource_id}: {e}", file=sys.stderr)
                    continue
            
            if verified_count > 0:
                self.send_log(f"âœ… è‡ªå‹•æ›´æ–°äº† {verified_count} å€‹è³‡æºé¡å‹", "info")
                # ç™¼é€æ›´æ–°äº‹ä»¶è®“å‰ç«¯åˆ·æ–°
                self.send_event("resources-types-verified", {
                    "success": True,
                    "count": verified_count
                })
                
        except Exception as e:
            import sys
            print(f"[Backend] Error in batch verify: {e}", file=sys.stderr)

    async def handle_clear_all_resources(self):
        """æ¸…ç©ºæ‰€æœ‰æœç´¢çµæœè³‡æº"""
        try:
            deleted_count = await resource_discovery.clear_all_resources()
            self.send_log(f"ğŸ—‘ï¸ å·²æ¸…ç©ºæ‰€æœ‰è³‡æºï¼Œå…± {deleted_count} æ¢", "success")
            self.send_event("resources-cleared", {
                "success": True,
                "deletedCount": deleted_count
            })
        except Exception as e:
            self.send_log(f"âŒ æ¸…ç©ºè³‡æºå¤±æ•—: {e}", "error")
            self.send_event("resources-cleared", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_add_to_join_queue(self, payload: Dict[str, Any]):
        """æ·»åŠ è³‡æºåˆ°åŠ å…¥éšŠåˆ—"""
        try:
            resource_ids = payload.get('resourceIds', [])
            priority = payload.get('priority', 5)
            
            if not resource_ids:
                raise ValueError("è³‡æº ID åˆ—è¡¨ä¸èƒ½ç‚ºç©º")
            
            added = 0
            for rid in resource_ids:
                await resource_discovery.add_to_join_queue(rid, priority)
                added += 1
            
            self.send_log(f"ğŸ“‹ å·²æ·»åŠ  {added} å€‹è³‡æºåˆ°åŠ å…¥éšŠåˆ—", "success")
            self.send_event("join-queue-updated", {
                "success": True,
                "added": added
            })
            
        except Exception as e:
            self.send_log(f"âŒ æ·»åŠ åˆ°éšŠåˆ—å¤±æ•—: {e}", "error")
            self.send_event("join-queue-updated", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_process_join_queue(self, payload: Dict[str, Any]):
        """è™•ç†åŠ å…¥éšŠåˆ—"""
        try:
            limit = payload.get('limit', 5)
            
            group_search_service.set_clients(self.telegram_manager.clients)
            stats = await group_search_service.process_join_queue(limit=limit)
            
            self.send_log(f"ğŸš€ è™•ç†éšŠåˆ—: æˆåŠŸ {stats['successCount']}, å¤±æ•— {stats['failed']}", "success")
            self.send_event("join-queue-processed", {
                "success": True,
                **stats
            })
            
        except Exception as e:
            self.send_log(f"âŒ è™•ç†éšŠåˆ—å¤±æ•—: {e}", "error")
            self.send_event("join-queue-processed", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_batch_join_resources(self, payload: Dict[str, Any]):
        """æ‰¹é‡åŠ å…¥è³‡æº"""
        try:
            resource_ids = payload.get('resourceIds', [])
            delay_min = payload.get('delayMin', 30)
            delay_max = payload.get('delayMax', 60)
            
            if not resource_ids:
                raise ValueError("è³‡æº ID åˆ—è¡¨ä¸èƒ½ç‚ºç©º")
            
            group_search_service.set_clients(self.telegram_manager.clients)
            
            # åœ¨å¾Œå°é‹è¡Œæ‰¹é‡åŠ å…¥
            async def batch_join_task():
                stats = await group_search_service.batch_join(
                    resource_ids=resource_ids,
                    delay_range=(delay_min, delay_max)
                )
                self.send_event("batch-join-complete", {
                    "success": True,
                    **stats
                })
            
            task = asyncio.create_task(batch_join_task())
            self.background_tasks.append(task)
            
            self.send_log(f"ğŸš€ é–‹å§‹æ‰¹é‡åŠ å…¥ {len(resource_ids)} å€‹è³‡æº", "info")
            self.send_event("batch-join-started", {
                "success": True,
                "count": len(resource_ids)
            })
            
        except Exception as e:
            self.send_log(f"âŒ æ‰¹é‡åŠ å…¥å¤±æ•—: {e}", "error")
            self.send_event("batch-join-started", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_join_and_monitor_resource(self, payload: Dict[str, Any]):
        """åŠ å…¥ç¾¤çµ„ä¸¦æ·»åŠ åˆ°ç›£æ§"""
        try:
            resource_id = payload.get('resourceId')
            username = payload.get('username')
            telegram_id = payload.get('telegramId')
            title = payload.get('title', '')
            phone = payload.get('phone')  # ğŸ†• å¯é¸æŒ‡å®šå¸³è™Ÿ
            
            if not username and not telegram_id:
                raise ValueError("éœ€è¦ username æˆ– telegramId")
            
            # ğŸ”§ P0: æ§‹å»ºç¾¤çµ„ URL
            if username:
                group_url = f"https://t.me/{username.lstrip('@')}"
            elif telegram_id:
                group_url = str(telegram_id)
            else:
                raise ValueError("éœ€è¦ username æˆ– telegramId")
            
            # ğŸ”§ P0: ç²å–å¯ç”¨çš„å¸³è™Ÿ phone
            if not phone:
                # è‡ªå‹•é¸æ“‡ä¸€å€‹å·²é€£æ¥çš„å¸³è™Ÿ
                connected_accounts = [
                    p for p, c in self.telegram_manager.clients.items()
                    if c and c.is_connected
                ]
                if not connected_accounts:
                    raise ValueError("æ²’æœ‰å¯ç”¨çš„å·²é€£æ¥å¸³è™Ÿï¼Œè«‹å…ˆé€£æ¥ä¸€å€‹å¸³è™Ÿ")
                phone = connected_accounts[0]
                self.send_log(f"ğŸ“± ä½¿ç”¨å¸³è™Ÿ: {phone[:4]}****", "info")
            
            # ğŸ”§ P0: ä½¿ç”¨ TelegramManager.join_group æ–¹æ³•ï¼ˆæ­£ç¢ºçš„æ–¹æ³•ï¼‰
            self.send_log(f"ğŸš€ æ­£åœ¨åŠ å…¥: {title}", "info")
            join_result = await self.telegram_manager.join_group(phone, group_url)
            
            if join_result.get('success'):
                self.send_log(f"âœ… å·²åŠ å…¥ç¾¤çµ„: {title}", "success")
                
                # æ·»åŠ åˆ°ç›£æ§
                self.send_log(f"ğŸ“Š æ­£åœ¨æ·»åŠ ç›£æ§: {title}", "info")
                
                # ç²å–ç¾¤çµ„ä¿¡æ¯æ·»åŠ åˆ°ç›£æ§
                from database import db
                await db.connect()
                
                # ğŸ”§ P0: ç²å–æˆå“¡æ•¸ - ä½¿ç”¨åŠ å…¥æ™‚ä½¿ç”¨çš„å¸³è™Ÿ
                members_count = 0
                chat_telegram_id = None
                resource_type = 'group'
                try:
                    # ğŸ”§ P0: å„ªå…ˆä½¿ç”¨åŠ å…¥æ™‚çš„ phone å°æ‡‰çš„å®¢æˆ¶ç«¯
                    client = None
                    if phone and phone in self.telegram_manager.clients:
                        client = self.telegram_manager.clients[phone]
                        if client and not client.is_connected:
                            client = None
                    
                    # å›é€€ï¼šæ‰¾ä»»æ„å¯ç”¨çš„å®¢æˆ¶ç«¯
                    if not client:
                        for c in self.telegram_manager._clients.values():
                            if c and c.is_connected:
                                client = c
                                break
                    
                    if client:
                        chat_target = username or telegram_id
                        if chat_target:
                            # ğŸ”§ P0: å˜—è©¦ç²å–èŠå¤©ä¿¡æ¯
                            try:
                                chat_info = await client.get_chat(chat_target)
                                if chat_info:
                                    members_count = getattr(chat_info, 'members_count', 0) or 0
                                    chat_telegram_id = chat_info.id
                                    from pyrogram.enums import ChatType
                                    if chat_info.type == ChatType.CHANNEL:
                                        resource_type = 'channel'
                                    elif chat_info.type == ChatType.SUPERGROUP:
                                        resource_type = 'supergroup'
                                    self.send_log(f"ğŸ“Š ç²å–æˆå“¡æ•¸: {members_count}", "info")
                            except Exception as get_chat_err:
                                import sys
                                print(f"[Backend] get_chat error: {get_chat_err}", file=sys.stderr)
                                # å˜—è©¦ä½¿ç”¨æ•¸å­— ID é‡æ–°ç²å–
                                if telegram_id and str(telegram_id).lstrip('-').isdigit():
                                    try:
                                        chat_info = await client.get_chat(int(telegram_id))
                                        if chat_info:
                                            members_count = getattr(chat_info, 'members_count', 0) or 0
                                            chat_telegram_id = chat_info.id
                                            self.send_log(f"ğŸ“Š ä½¿ç”¨ ID ç²å–æˆå“¡æ•¸: {members_count}", "info")
                                    except Exception:
                                        pass
                except Exception as chat_err:
                    import sys
                    print(f"[Backend] Error getting member count: {chat_err}", file=sys.stderr)
                
                # æª¢æŸ¥æ˜¯å¦å·²åœ¨ç›£æ§åˆ—è¡¨
                existing = await db.fetch_one(
                    "SELECT id FROM monitored_groups WHERE link LIKE ?",
                    (f"%{username}%" if username else f"%{telegram_id}%",)
                )
                
                # ğŸ†• æª¢æ¸¬æ˜¯å¦å¯ä»¥æå–æˆå“¡ï¼ˆé »é“é»˜èªä¸å¯æå–ï¼‰
                can_extract = 1 if resource_type != 'channel' else 0
                
                if not existing:
                    # ğŸ”§ P0: æ·»åŠ åˆ°ç›£æ§ç¾¤çµ„ï¼ˆåŒ…å« phoneã€æˆå“¡æ•¸ã€ç¾¤çµ„é¡å‹ï¼‰
                    await db._connection.execute("""
                        INSERT INTO monitored_groups (link, name, phone, keyword_set_ids, is_active, member_count, telegram_id, resource_type, can_extract_members, created_at)
                        VALUES (?, ?, ?, '[]', 1, ?, ?, ?, ?, datetime('now'))
                    """, (f"https://t.me/{username}" if username else telegram_id, title, phone, members_count, chat_telegram_id, resource_type, can_extract))
                    await db._connection.commit()
                    type_label = {'channel': 'é »é“', 'supergroup': 'è¶…ç´šç¾¤', 'group': 'ç¾¤çµ„'}.get(resource_type, 'ç¾¤çµ„')
                    self.send_log(f"âœ… å·²æ·»åŠ åˆ°ç›£æ§: {title} ({type_label}ï¼Œ{members_count} æˆå“¡ï¼Œå¸³è™Ÿ: {phone[:4]}****)", "success")
                else:
                    # ğŸ”§ P0: æ›´æ–°æˆå“¡æ•¸ã€phone å’Œç¾¤çµ„é¡å‹
                    await db._connection.execute("""
                        UPDATE monitored_groups 
                        SET member_count = ?, telegram_id = COALESCE(telegram_id, ?), phone = COALESCE(phone, ?),
                            resource_type = ?, can_extract_members = ?
                        WHERE link LIKE ?
                    """, (members_count, chat_telegram_id, phone, resource_type, can_extract, f"%{username}%" if username else f"%{telegram_id}%"))
                    await db._connection.commit()
                    self.send_log(f"â„¹ï¸ ç¾¤çµ„å·²åœ¨ç›£æ§åˆ—è¡¨ä¸­ï¼Œå·²æ›´æ–°", "info")
                
                # ğŸ†• åŒæ­¥æ›´æ–° discovered_resourcesï¼ˆåŒ…å« joined_by_phoneï¼‰
                if resource_id:
                    await db.execute(
                        """UPDATE discovered_resources 
                           SET status = 'joined', member_count = ?, resource_type = ?, 
                               joined_by_phone = ?, joined_at = CURRENT_TIMESTAMP,
                               telegram_id = COALESCE(telegram_id, ?)
                           WHERE id = ?""",
                        (members_count, resource_type, phone, chat_telegram_id, resource_id)
                    )
                
                # ğŸ”§ P0: è¿”å›æ›´å®Œæ•´çš„ä¿¡æ¯çµ¦å‰ç«¯
                self.send_event("join-and-monitor-complete", {
                    "success": True,
                    "resourceId": resource_id,
                    "telegramId": telegram_id,
                    "username": username,
                    "joined": True,
                    "monitored": True,
                    "memberCount": members_count,
                    "phone": phone,
                    "status": "joined"  # ğŸ†• è¿”å›æ–°ç‹€æ…‹
                })
            else:
                # ğŸ†• ç²å–æ›´å‹å¥½çš„éŒ¯èª¤ä¿¡æ¯
                raw_error = join_result.get('error', 'åŠ å…¥å¤±æ•—')
                raise Exception(raw_error)
                
        except Exception as e:
            # ğŸ†• éŒ¯èª¤ä¿¡æ¯å‹å¥½åŒ–è™•ç†
            error_str = str(e)
            friendly_error = self._get_friendly_join_error(error_str)
            
            self.send_log(f"âŒ åŠ å…¥å¤±æ•—: {friendly_error}", "error")
            self.send_event("join-and-monitor-complete", {
                "success": False,
                "error": friendly_error
            })
    
    def _get_friendly_join_error(self, error: str) -> str:
        """å°‡æŠ€è¡“éŒ¯èª¤è½‰æ›ç‚ºç”¨æˆ¶å‹å¥½çš„ä¿¡æ¯"""
        error_lower = error.lower()
        
        # å¸¸è¦‹éŒ¯èª¤æ˜ å°„
        error_mappings = {
            'flood_wait': 'æ“ä½œéæ–¼é »ç¹ï¼Œè«‹ç¨å¾Œå†è©¦',
            'floodwait': 'æ“ä½œéæ–¼é »ç¹ï¼Œè«‹ç¨å¾Œå†è©¦',
            'user_already_participant': 'æ‚¨å·²ç¶“æ˜¯è©²ç¾¤çµ„çš„æˆå“¡',
            'invite_hash_expired': 'é‚€è«‹éˆæ¥å·²å¤±æ•ˆæˆ–éæœŸ',
            'invite_hash_invalid': 'é‚€è«‹éˆæ¥ç„¡æ•ˆ',
            'user_not_participant': 'æ‚¨ä¸æ˜¯è©²ç¾¤çµ„çš„æˆå“¡',
            'chat_write_forbidden': 'æ²’æœ‰æ¬Šé™ç™¼é€æ¶ˆæ¯åˆ°è©²ç¾¤çµ„',
            'peer_id_invalid': 'ç¾¤çµ„ ID ç„¡æ•ˆï¼Œè«‹æª¢æŸ¥éˆæ¥æ˜¯å¦æ­£ç¢º',
            'username_not_occupied': 'æ‰¾ä¸åˆ°è©²ç¾¤çµ„ï¼Œç”¨æˆ¶åä¸å­˜åœ¨',
            'username_invalid': 'ç¾¤çµ„ç”¨æˆ¶åæ ¼å¼ç„¡æ•ˆ',
            'channel_private': 'é€™æ˜¯ç§æœ‰ç¾¤çµ„ï¼Œéœ€è¦é‚€è«‹éˆæ¥æ‰èƒ½åŠ å…¥',
            'channel_invalid': 'ç„¡æ•ˆçš„é »é“/ç¾¤çµ„',
            'chat_invalid': 'ç„¡æ•ˆçš„èŠå¤©',
            'no attribute': 'åŠŸèƒ½æš«æ™‚ä¸å¯ç”¨ï¼Œè«‹é‡å•Ÿæ‡‰ç”¨å¾Œé‡è©¦',
            'not connected': 'å¸³è™Ÿæœªé€£æ¥ï¼Œè«‹å…ˆç™»éŒ„å¸³è™Ÿ',
            'account not connected': 'å¸³è™Ÿæœªé€£æ¥ï¼Œè«‹å…ˆç™»éŒ„å¸³è™Ÿ',
            'æ²’æœ‰å¯ç”¨çš„å·²é€£æ¥å¸³è™Ÿ': 'è«‹å…ˆåœ¨ã€Œå¸³è™Ÿç®¡ç†ã€ä¸­ç™»éŒ„è‡³å°‘ä¸€å€‹å¸³è™Ÿ',
            'timeout': 'é€£æ¥è¶…æ™‚ï¼Œè«‹æª¢æŸ¥ç¶²çµ¡å¾Œé‡è©¦',
        }
        
        for key, friendly_msg in error_mappings.items():
            if key in error_lower:
                return friendly_msg
        
        # å¦‚æœæ²’æœ‰åŒ¹é…ï¼Œè¿”å›åŸå§‹éŒ¯èª¤ï¼ˆä½†æ¸…ç†æŠ€è¡“ç´°ç¯€ï¼‰
        if 'object has no attribute' in error_lower:
            return 'ç³»çµ±åŠŸèƒ½ç•°å¸¸ï¼Œè«‹é‡å•Ÿæ‡‰ç”¨å¾Œé‡è©¦'
        
        return error

    async def handle_join_and_monitor_with_account(self, payload: Dict[str, Any]):
        """ä½¿ç”¨æŒ‡å®šå¸³è™ŸåŠ å…¥ä¸¦ç›£æ§ç¾¤çµ„"""
        try:
            resource_id = payload.get('resourceId', 0)
            phone = payload.get('phone')
            keywords = payload.get('keywords', [])
            # ğŸ”§ FIX: è®€å–å‰ç«¯å‚³éçš„é—œéµè©é›† ID åˆ—è¡¨
            keyword_set_ids = payload.get('keywordSetIds', [])
            auto_enable = payload.get('autoEnableMonitor', True)
            # ğŸ†• æ”¯æŒå¾å‰ç«¯å‚³éè³‡æºä¿¡æ¯ï¼ˆç•¶ resourceId === 0 æ™‚ï¼‰
            resource_info = payload.get('resourceInfo', {})
            # ğŸ†• æˆå“¡æ•¸ï¼ˆåŠ å…¥å¾Œæ›´æ–°ï¼‰
            members_count = 0
            
            # ğŸ”§ FIX: è¨˜éŒ„æ¥æ”¶åˆ°çš„é—œéµè©é›† ID
            if keyword_set_ids:
                self.send_log(f"ğŸ“‹ æ¥æ”¶åˆ°é—œéµè©é›†ç¶å®š: {keyword_set_ids}", "info")
            
            if not phone:
                raise ValueError("è«‹é¸æ“‡åŠ å…¥å¸³è™Ÿ")
            
            self.send_log(f"ğŸš€ ä½¿ç”¨ {phone} åŠ å…¥ç¾¤çµ„ä¸¦è¨­ç½®ç›£æ§...", "info")
            
            # ç²å–è³‡æºè©³æƒ…
            from database import db
            await db.connect()
            
            resource = None
            title = ''
            username = ''
            invite_link = ''
            current_status = 'discovered'
            
            # ğŸ†• å¦‚æœ resourceId === 0ï¼Œå˜—è©¦ä½¿ç”¨å„ç¨®æ–¹å¼æŸ¥æ‰¾æˆ–å‰µå»ºè³‡æº
            if resource_id == 0:
                # å¾ resourceInfo ç²å–ä¿¡æ¯
                username = resource_info.get('username', '').strip()
                telegram_id = resource_info.get('telegram_id', '').strip()
                title = resource_info.get('title', '').strip()
                link = resource_info.get('link', '').strip()
                
                import re
                
                # ğŸ”‘ å¾ link ä¸­æå–æœ‰æ•ˆä¿¡æ¯
                extracted_username = ''
                extracted_invite_hash = ''
                is_message_link = False  # æ˜¯å¦ç‚ºæ¶ˆæ¯éˆæ¥ï¼ˆéç¾¤çµ„ç›´é€£ï¼‰
                
                if link:
                    # è§£æ link æ ¼å¼
                    if '/+' in link or '/joinchat/' in link:
                        # ç§æœ‰ç¾¤çµ„é‚€è«‹éˆæ¥ï¼šhttps://t.me/+hash æˆ– https://t.me/joinchat/hash
                        invite_link = link
                        self.send_log(f"ğŸ“‹ æª¢æ¸¬åˆ°é‚€è«‹éˆæ¥: {link}", "info")
                    elif 't.me/' in link:
                        # æª¢æŸ¥æ˜¯å¦ç‚ºæ¶ˆæ¯éˆæ¥æ ¼å¼ï¼šhttps://t.me/username/messageId
                        message_link_match = re.search(r't\.me/([^/?\s]+)/(\d+)', link)
                        if message_link_match:
                            # é€™æ˜¯æ¶ˆæ¯éˆæ¥ï¼Œä¸æ˜¯ç¾¤çµ„ç›´é€£
                            link_username = message_link_match.group(1)
                            message_id = message_link_match.group(2)
                            is_message_link = True
                            self.send_log(f"âš ï¸ æª¢æ¸¬åˆ°æ¶ˆæ¯éˆæ¥ï¼ˆéç¾¤çµ„ç›´é€£ï¼‰: {link}", "warning")
                            
                            # æª¢æŸ¥ username æ˜¯å¦ç‚º botï¼ˆæœç´¢æ©Ÿå™¨äººï¼‰
                            if link_username.lower().endswith('bot'):
                                self.send_log(f"âš ï¸ éˆæ¥æŒ‡å‘æœç´¢æ©Ÿå™¨äºº @{link_username}ï¼Œéœ€è¦ç²å–çœŸæ­£çš„ç¾¤çµ„éˆæ¥", "warning")
                                # æ¸…ç©º usernameï¼Œå› ç‚ºé€™æ˜¯æ©Ÿå™¨äººçš„ username
                                if username and username.lower().endswith('bot'):
                                    username = ''
                                    telegram_id = ''
                        else:
                            # æ™®é€šç¾¤çµ„éˆæ¥ï¼šhttps://t.me/username
                            match = re.search(r't\.me/([^/?\s]+)$', link)
                            if match:
                                extracted_username = match.group(1)
                                if not extracted_username.startswith('+'):
                                    # æª¢æŸ¥æ˜¯å¦ç‚º bot
                                    if not extracted_username.lower().endswith('bot'):
                                        username = extracted_username
                                        self.send_log(f"ğŸ“‹ å¾éˆæ¥æå– username: {username}", "info")
                                    else:
                                        self.send_log(f"âš ï¸ éˆæ¥æŒ‡å‘æ©Ÿå™¨äºº @{extracted_username}ï¼Œè·³é", "warning")
                                else:
                                    invite_link = link
                
                # ğŸ”‘ æª¢æŸ¥ username æ˜¯å¦ç‚ºæœç´¢æ©Ÿå™¨äººï¼ˆä»¥ 'bot' çµå°¾ï¼‰
                if username and username.lower().endswith('bot'):
                    self.send_log(f"âš ï¸ username '{username}' çœ‹èµ·ä¾†æ˜¯æ©Ÿå™¨äººï¼Œä¸æ˜¯ç¾¤çµ„", "warning")
                    # å¦‚æœæ²’æœ‰å…¶ä»–åŠ å…¥æ–¹å¼ï¼Œå ±éŒ¯
                    if not invite_link:
                        raise ValueError(f"ç„¡æ³•åŠ å…¥ï¼š'{username}' æ˜¯æœç´¢æ©Ÿå™¨äººï¼Œè«‹å¾æœç´¢çµæœä¸­é»æ“Šé€²å…¥ç¾¤çµ„ï¼Œç„¶å¾Œè¤‡è£½ç¾¤çµ„çš„é‚€è«‹éˆæ¥")
                    username = ''  # æ¸…ç©º bot username
                
                # ğŸ”‘ é©—è­‰ telegram_id æ˜¯å¦ç‚ºæœ‰æ•ˆ IDï¼ˆä¸æ˜¯ title çš„èª¤ç”¨ï¼‰
                # æœ‰æ•ˆçš„ telegram_id æ‡‰è©²æ˜¯æ•¸å­—æˆ–ç°¡çŸ­çš„æ¨™è­˜ç¬¦
                if telegram_id and (len(telegram_id) > 50 or not telegram_id.replace('-', '').replace('_', '').isalnum()):
                    self.send_log(f"âš ï¸ telegram_id æ ¼å¼ç„¡æ•ˆï¼Œå¿½ç•¥: {telegram_id[:30]}...", "warning")
                    telegram_id = ''  # é‡ç½®ç„¡æ•ˆçš„ telegram_id
                
                # å¦‚æœ telegram_id ä¹Ÿæ˜¯ bot usernameï¼Œæ¸…ç©º
                if telegram_id and telegram_id.lower().endswith('bot'):
                    telegram_id = ''
                
                # å˜—è©¦æ ¹æ“š username æŸ¥æ‰¾
                if username:
                    resources = await db.fetch_all(
                        "SELECT * FROM discovered_resources WHERE username = ?",
                        (username,)
                    )
                    if resources:
                        resource = resources[0]
                        resource_id = resource.get('id')
                        self.send_log(f"ğŸ“‹ æ ¹æ“š username æ‰¾åˆ°è³‡æº ID: {resource_id}", "info")
                
                # å˜—è©¦æ ¹æ“š invite_link æŸ¥æ‰¾
                if not resource and invite_link:
                    resources = await db.fetch_all(
                        "SELECT * FROM discovered_resources WHERE invite_link = ?",
                        (invite_link,)
                    )
                    if resources:
                        resource = resources[0]
                        resource_id = resource.get('id')
                        self.send_log(f"ğŸ“‹ æ ¹æ“š invite_link æ‰¾åˆ°è³‡æº ID: {resource_id}", "info")
                
                # å¦‚æœé‚„æ˜¯æ²’æ‰¾åˆ°ï¼Œä¸”æœ‰æœ‰æ•ˆçš„ telegram_idï¼Œå˜—è©¦ä½¿ç”¨ telegram_id æŸ¥æ‰¾
                if not resource and telegram_id:
                    resources = await db.fetch_all(
                        "SELECT * FROM discovered_resources WHERE telegram_id = ?",
                        (telegram_id,)
                    )
                    if resources:
                        resource = resources[0]
                        resource_id = resource.get('id')
                        self.send_log(f"ğŸ“‹ æ ¹æ“š telegram_id æ‰¾åˆ°è³‡æº ID: {resource_id}", "info")
                
                # ğŸ†• å¦‚æœé‚„æ˜¯æ²’æ‰¾åˆ°ï¼Œæª¢æŸ¥æ˜¯å¦æœ‰è¶³å¤ ä¿¡æ¯å‰µå»ºè³‡æº
                if not resource:
                    # å¿…é ˆæœ‰åŠ å…¥æ–¹å¼ï¼ˆusername æˆ– invite_linkï¼‰
                    if not username and not invite_link:
                        raise ValueError("ç¼ºå°‘åŠ å…¥æ–¹å¼ï¼šè«‹æä¾›ç¾¤çµ„ username æˆ–é‚€è«‹éˆæ¥")
                    
                    self.send_log(f"ğŸ“ è³‡æºä¸å­˜åœ¨ï¼Œæ­£åœ¨å‰µå»ºæ–°è³‡æº...", "info")
                    # ä½¿ç”¨ resource_discovery æ·»åŠ è³‡æº
                    from resource_discovery import ResourceDiscovery
                    resource_discovery = ResourceDiscovery()
                    
                    # ç”Ÿæˆæœ‰æ•ˆçš„ telegram_id
                    valid_telegram_id = username or f"invite_{int(time.time())}"
                    if telegram_id and len(telegram_id) <= 50:
                        valid_telegram_id = telegram_id
                    
                    new_resource = {
                        'telegram_id': valid_telegram_id,
                        'username': username,
                        'title': title or username or 'æœªå‘½åè³‡æº',
                        'description': resource_info.get('description', ''),
                        'member_count': resource_info.get('member_count', 0),
                        'resource_type': resource_info.get('resource_type', 'supergroup'),
                        'discovery_source': 'manual_join',
                        'status': 'discovered',
                        'invite_link': invite_link or (f"https://t.me/{username}" if username else '')
                    }
                    
                    resource_id = await resource_discovery.add_resource(new_resource)
                    self.send_log(f"âœ… å·²å‰µå»ºæ–°è³‡æº ID: {resource_id}", "success")
                    
                    # é‡æ–°æŸ¥è©¢ç²å–å®Œæ•´è³‡æºä¿¡æ¯
                    resources = await db.fetch_all(
                        "SELECT * FROM discovered_resources WHERE id = ?",
                        (resource_id,)
                    )
                    if resources:
                        resource = resources[0]
            
            # å¦‚æœ resourceId ä¸ç‚º 0ï¼Œæ­£å¸¸æŸ¥è©¢
            if not resource and resource_id > 0:
                resources = await db.fetch_all(
                    "SELECT * FROM discovered_resources WHERE id = ?",
                    (resource_id,)
                )
                if not resources:
                    raise ValueError(f"æ‰¾ä¸åˆ°è³‡æº ID: {resource_id}")
                resource = resources[0]
            
            if not resource:
                raise ValueError("ç„¡æ³•æ‰¾åˆ°æˆ–å‰µå»ºè³‡æº")
            
            # æ›´æ–°è³‡æºä¿¡æ¯ï¼ˆå„ªå…ˆä½¿ç”¨è³‡æºä¸­çš„å€¼ï¼Œä½†ä¿ç•™å¾ resourceInfo æå–çš„ invite_linkï¼‰
            title = resource.get('title', '') or title
            username = resource.get('username', '') or username
            # ğŸ”‘ é—œéµï¼šç¢ºä¿ invite_link è¢«æ­£ç¢ºè¨­ç½®
            invite_link = resource.get('invite_link', '') or invite_link or resource_info.get('link', '')
            current_status = resource.get('status', 'discovered')
            
            # æª¢æŸ¥å¸³è™Ÿæ˜¯å¦å­˜åœ¨ä¸”å·²é€£æ¥
            if phone not in self.telegram_manager.clients:
                raise ValueError(f"å¸³è™Ÿ {phone} æœªé€£æ¥")
            
            client = self.telegram_manager.clients[phone]
            if not client.is_connected:
                raise ValueError(f"å¸³è™Ÿ {phone} æœªé€£æ¥")
            
            # è¿½è¸ªåŠ å…¥ç‹€æ…‹
            join_status = 'joined'  # é»˜èªç‚ºå·²åŠ å…¥
            
            # å¦‚æœè³‡æºå°šæœªåŠ å…¥ï¼Œå…ˆåŠ å…¥ç¾¤çµ„
            if current_status not in ['joined', 'monitoring']:
                self.send_log(f"ğŸ“¥ æ­£åœ¨åŠ å…¥ç¾¤çµ„: {title}", "info")
                
                # å˜—è©¦åŠ å…¥ç¾¤çµ„
                join_target = username or invite_link
                
                # ğŸ†• å¦‚æœæ²’æœ‰æœ‰æ•ˆçš„åŠ å…¥æ–¹å¼ï¼Œå˜—è©¦ä½¿ç”¨ç¾¤çµ„åç¨±æœç´¢
                if not join_target and title:
                    self.send_log(f"ğŸ” æ²’æœ‰ username æˆ–é‚€è«‹éˆæ¥ï¼Œå˜—è©¦æœç´¢ç¾¤çµ„: {title}", "info")
                    try:
                        # ä½¿ç”¨ Telegram å…¨å±€æœç´¢
                        search_results = await client.search_global(title, limit=5)
                        for result in search_results:
                            if hasattr(result, 'chat') and result.chat:
                                chat = result.chat
                                chat_title = getattr(chat, 'title', '') or ''
                                chat_username = getattr(chat, 'username', '')
                                
                                # æª¢æŸ¥æ¨™é¡Œæ˜¯å¦åŒ¹é…
                                if title.lower() in chat_title.lower() or chat_title.lower() in title.lower():
                                    if chat_username:
                                        join_target = chat_username
                                        username = chat_username
                                        self.send_log(f"âœ… æ‰¾åˆ°åŒ¹é…ç¾¤çµ„: @{chat_username}", "success")
                                        break
                    except Exception as search_err:
                        self.send_log(f"æœç´¢ç¾¤çµ„å¤±æ•—: {search_err}", "warning")
                
                if not join_target:
                    # æä¾›æ›´å‹å¥½çš„éŒ¯èª¤æç¤º
                    error_msg = f"ç„¡æ³•åŠ å…¥ç¾¤çµ„ã€Œ{title}ã€ï¼š\n"
                    error_msg += "â€¢ æ­¤æœç´¢çµæœæ²’æœ‰æä¾›ç¾¤çµ„çš„ username æˆ–é‚€è«‹éˆæ¥\n"
                    error_msg += "â€¢ è«‹åœ¨ Telegram ä¸­é»æ“Šæœç´¢æ©Ÿå™¨äººçš„çµæœï¼Œæ‰‹å‹•ç²å–ç¾¤çµ„éˆæ¥å¾Œå†è©¦\n"
                    error_msg += "â€¢ æˆ–è€…ç›´æ¥åœ¨ Telegram ä¸­æœç´¢ä¸¦åŠ å…¥è©²ç¾¤çµ„"
                    raise ValueError(error_msg)
                
                try:
                    if username:
                        await client.join_chat(username)
                    elif invite_link:
                        await client.join_chat(invite_link)
                    
                    self.send_log(f"âœ… å·²åŠ å…¥ç¾¤çµ„: {title}", "success")
                    
                    # ğŸ” é—œéµï¼šç²å–çœŸå¯¦çš„èŠå¤©é¡å‹å’Œæˆå“¡æ•¸ä¸¦æ›´æ–°æ•¸æ“šåº«
                    verified_type = None
                    members_count = 0
                    telegram_id = None
                    try:
                        chat_target = username or invite_link
                        chat_info = await client.get_chat(chat_target)
                        if chat_info:
                            # å¾ Pyrogram Chat å°è±¡ç²å–çœŸå¯¦é¡å‹
                            from pyrogram.enums import ChatType
                            if chat_info.type == ChatType.CHANNEL:
                                verified_type = "channel"
                            elif chat_info.type == ChatType.SUPERGROUP:
                                verified_type = "supergroup"
                            elif chat_info.type == ChatType.GROUP:
                                verified_type = "group"
                            elif chat_info.type == ChatType.BOT:
                                verified_type = "bot"
                            
                            # ğŸ†• ç²å–æˆå“¡æ•¸
                            members_count = getattr(chat_info, 'members_count', 0) or 0
                            telegram_id = chat_info.id
                            
                            if verified_type:
                                self.send_log(f"ğŸ“‹ é¡å‹ç¢ºèª: {verified_type}, æˆå“¡æ•¸: {members_count}", "info")
                    except Exception as type_err:
                        import sys
                        print(f"[Backend] Error getting chat type: {type_err}", file=sys.stderr)
                    
                    # æ›´æ–°è³‡æºç‹€æ…‹ï¼ˆåŒ…å«é©—è­‰å¾Œçš„é¡å‹å’Œæˆå“¡æ•¸ï¼‰
                    if verified_type:
                        await db.execute(
                            """UPDATE discovered_resources 
                               SET status = ?, joined_by_phone = ?, joined_at = CURRENT_TIMESTAMP, resource_type = ?, member_count = ?, telegram_id = COALESCE(telegram_id, ?)
                               WHERE id = ?""",
                            ('joined', phone, verified_type, members_count, telegram_id, resource_id)
                        )
                    else:
                        await db.execute(
                            """UPDATE discovered_resources 
                               SET status = ?, joined_by_phone = ?, joined_at = CURRENT_TIMESTAMP, member_count = ?, telegram_id = COALESCE(telegram_id, ?)
                               WHERE id = ?""",
                            ('joined', phone, members_count, telegram_id, resource_id)
                        )
                    await db._connection.commit()
                    
                except Exception as join_error:
                    error_msg = str(join_error)
                    error_lower = error_msg.lower()
                    
                    if 'already' in error_lower or 'participant' in error_lower:
                        # å¸³è™Ÿå·²åœ¨ç¾¤çµ„ä¸­
                        self.send_log(f"â„¹ï¸ å¸³è™Ÿå·²åœ¨ç¾¤çµ„ä¸­", "info")
                        await db.execute(
                            """UPDATE discovered_resources 
                               SET status = ?, joined_by_phone = ? 
                               WHERE id = ?""",
                            ('joined', phone, resource_id)
                        )
                        await db._connection.commit()
                    elif 'invite_request_sent' in error_lower or 'request_sent' in error_lower:
                        # ğŸ†• ç¾¤çµ„éœ€è¦ç®¡ç†å“¡æ‰¹å‡†ï¼ŒåŠ å…¥è«‹æ±‚å·²ç™¼é€
                        self.send_log(f"ğŸ“¨ åŠ å…¥è«‹æ±‚å·²ç™¼é€ï¼Œç­‰å¾…ç®¡ç†å“¡æ‰¹å‡†: {title}", "info")
                        join_status = 'pending_approval'  # æ›´æ–°ç‹€æ…‹
                        await db.execute(
                            """UPDATE discovered_resources 
                               SET status = ?, joined_by_phone = ? 
                               WHERE id = ?""",
                            ('pending_approval', phone, resource_id)
                        )
                        await db._connection.commit()
                        # ä¸æ‹‹å‡ºéŒ¯èª¤ï¼Œç¹¼çºŒè¨­ç½®ç›£æ§
                    elif 'user_already_participant' in error_lower:
                        # å¸³è™Ÿå·²ç¶“æ˜¯æˆå“¡
                        self.send_log(f"â„¹ï¸ å¸³è™Ÿå·²æ˜¯ç¾¤çµ„æˆå“¡", "info")
                        await db.execute(
                            """UPDATE discovered_resources 
                               SET status = ?, joined_by_phone = ? 
                               WHERE id = ?""",
                            ('joined', phone, resource_id)
                        )
                        await db._connection.commit()
                    else:
                        raise join_error
            
            # è¨­ç½®ç›£æ§
            if auto_enable or keywords:
                new_status = 'monitoring'
                keywords_str = ','.join(keywords) if keywords else ''
                
                await db.execute(
                    """UPDATE discovered_resources 
                       SET status = ?, monitoring_keywords = ?, monitoring_enabled = 1 
                       WHERE id = ?""",
                    (new_status, keywords_str, resource_id)
                )
                await db._connection.commit()
                
                # æ·»åŠ åˆ° monitored_groups è¡¨
                existing = await db.fetch_all(
                    "SELECT id FROM monitored_groups WHERE link LIKE ? OR name = ?",
                    (f"%{username}%" if username else f"%{title}%", title)
                )
                
                # ğŸ”§ FIX: å°‡ keyword_set_ids åºåˆ—åŒ–ç‚º JSON å­—ç¬¦ä¸²
                import json
                keyword_set_ids_json = json.dumps(keyword_set_ids) if keyword_set_ids else '[]'
                
                if not existing:
                    # ğŸ†• æ’å…¥æ™‚åŒ…å«æˆå“¡æ•¸ã€telegram_id å’Œé—œéµè©é›† ID
                    await db.execute(
                        """INSERT INTO monitored_groups (name, link, phone, is_active, keywords, keyword_set_ids, member_count, telegram_id, last_active)
                           VALUES (?, ?, ?, 1, ?, ?, ?, ?, CURRENT_TIMESTAMP)""",
                        (title, f"https://t.me/{username}" if username else invite_link, phone, keywords_str, keyword_set_ids_json, members_count, telegram_id)
                    )
                    await db._connection.commit()
                    bound_msg = f", ç¶å®š {len(keyword_set_ids)} å€‹è©é›†" if keyword_set_ids else ""
                    self.send_log(f"âœ… å·²æ·»åŠ åˆ°ç›£æ§åˆ—è¡¨: {title} ({members_count} æˆå“¡{bound_msg})", "success")
                else:
                    # ğŸ†• æ›´æ–°æ™‚ä¹ŸåŒæ­¥æˆå“¡æ•¸å’Œé—œéµè©é›† ID
                    # ğŸ”§ FIX: åªæœ‰åœ¨å‚³å…¥ keyword_set_ids æ™‚æ‰æ›´æ–°
                    if keyword_set_ids:
                        await db.execute(
                            """UPDATE monitored_groups 
                               SET keywords = ?, keyword_set_ids = ?, phone = ?, is_active = 1, member_count = ?, telegram_id = COALESCE(telegram_id, ?)
                               WHERE link LIKE ? OR name = ?""",
                            (keywords_str, keyword_set_ids_json, phone, members_count, telegram_id, f"%{username}%" if username else f"%{title}%", title)
                        )
                    else:
                        await db.execute(
                            """UPDATE monitored_groups 
                               SET keywords = ?, phone = ?, is_active = 1, member_count = ?, telegram_id = COALESCE(telegram_id, ?)
                               WHERE link LIKE ? OR name = ?""",
                            (keywords_str, phone, members_count, telegram_id, f"%{username}%" if username else f"%{title}%", title)
                        )
                    await db._connection.commit()
                    bound_msg = f", ç¶å®š {len(keyword_set_ids)} å€‹è©é›†" if keyword_set_ids else ""
                    self.send_log(f"âœ… å·²æ›´æ–°ç›£æ§è¨­ç½®: {title} ({members_count} æˆå“¡{bound_msg})", "success")
                
                if keywords:
                    self.send_log(f"ğŸ” ç›£æ§é—œéµè©: {', '.join(keywords)}", "info")
            
            self.send_event("join-and-monitor-with-account-complete", {
                "success": True,
                "resourceId": resource_id,
                "phone": phone,
                "keywords": keywords,
                "keywordSetIds": keyword_set_ids,  # ğŸ”§ FIX: è¿”å›ç¶å®šçš„é—œéµè©é›† ID
                "status": join_status,  # ğŸ†• è¿”å›åŠ å…¥ç‹€æ…‹
                "memberCount": members_count,  # ğŸ†• è¿”å›æˆå“¡æ•¸
                "message": "åŠ å…¥è«‹æ±‚å·²ç™¼é€ï¼Œç­‰å¾…ç®¡ç†å“¡æ‰¹å‡†" if join_status == 'pending_approval' else "å·²æˆåŠŸåŠ å…¥ä¸¦è¨­ç½®ç›£æ§"
            })
            
        except Exception as e:
            # ğŸ†• ä½¿ç”¨å‹å¥½éŒ¯èª¤è™•ç†
            error_str = str(e)
            friendly_error = self._get_friendly_join_error(error_str)
            
            self.send_log(f"âŒ åŠ å…¥å¤±æ•—: {friendly_error}", "error")
            import traceback
            traceback.print_exc()
            self.send_event("join-and-monitor-with-account-complete", {
                "success": False,
                "error": friendly_error
            })
    
    async def handle_batch_join_and_monitor(self, payload: Dict[str, Any]):
        """æ‰¹é‡åŠ å…¥ä¸¦ç›£æ§"""
        try:
            resource_ids = payload.get('resourceIds', [])
            
            if not resource_ids:
                raise ValueError("è³‡æº ID åˆ—è¡¨ä¸èƒ½ç‚ºç©º")
            
            self.send_log(f"ğŸš€ é–‹å§‹æ‰¹é‡åŠ å…¥ä¸¦ç›£æ§ {len(resource_ids)} å€‹è³‡æº", "info")
            
            # ç²å–è³‡æºè©³æƒ…
            from database import db
            await db.connect()
            
            success_count = 0
            fail_count = 0
            
            for resource_id in resource_ids:
                try:
                    resource = await db.fetch_one(
                        "SELECT * FROM discovered_resources WHERE id = ?",
                        (resource_id,)
                    )
                    
                    if resource:
                        await self.handle_join_and_monitor_resource({
                            'resourceId': resource_id,
                            'username': resource.get('username'),
                            'telegramId': resource.get('telegram_id'),
                            'title': resource.get('title', '')
                        })
                        success_count += 1
                        
                        # å»¶é²é¿å…é »ç‡é™åˆ¶
                        import random
                        await asyncio.sleep(random.uniform(30, 60))
                        
                except Exception as e:
                    self.send_log(f"âŒ è™•ç†è³‡æº {resource_id} å¤±æ•—: {e}", "error")
                    fail_count += 1
            
            self.send_log(f"âœ… æ‰¹é‡åŠ å…¥ç›£æ§å®Œæˆ: æˆåŠŸ {success_count}, å¤±æ•— {fail_count}", "success")
            self.send_event("batch-join-and-monitor-complete", {
                "success": True,
                "total": len(resource_ids),
                "successCount": success_count,
                "failed": fail_count
            })
            
        except Exception as e:
            self.send_log(f"âŒ æ‰¹é‡åŠ å…¥ä¸¦ç›£æ§å¤±æ•—: {e}", "error")
            self.send_event("batch-join-and-monitor-complete", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_analyze_group_link(self, payload: Dict[str, Any]):
        """åˆ†æç¾¤çµ„éˆæ¥"""
        try:
            link = payload.get('link', '').strip()
            
            if not link:
                raise ValueError("éˆæ¥ä¸èƒ½ç‚ºç©º")
            
            self.send_log(f"ğŸ” æ­£åœ¨åˆ†æéˆæ¥: {link}", "info")
            
            # è§£æéˆæ¥
            import re
            username = None
            
            # åŒ¹é… t.me/username æˆ– @username
            patterns = [
                r't\.me/([a-zA-Z0-9_]+)',
                r'@([a-zA-Z0-9_]+)',
                r'^([a-zA-Z0-9_]+)$'
            ]
            
            for pattern in patterns:
                match = re.search(pattern, link)
                if match:
                    username = match.group(1)
                    break
            
            if not username:
                # å¯èƒ½æ˜¯ç§æœ‰éˆæ¥
                if 't.me/+' in link or 't.me/joinchat' in link:
                    self.send_event("link-analysis-complete", {
                        "success": True,
                        "isPrivate": True,
                        "link": link,
                        "message": "é€™æ˜¯ç§æœ‰é‚€è«‹éˆæ¥ï¼Œéœ€è¦åŠ å…¥å¾Œæ‰èƒ½åˆ†æ"
                    })
                    return
                else:
                    raise ValueError("ç„¡æ³•è§£æéˆæ¥æ ¼å¼")
            
            # ç²å–ç¾¤çµ„ä¿¡æ¯
            group_search_service.set_clients(self.telegram_manager.clients)
            phone, client = group_search_service._get_available_client()
            
            if not client:
                raise ValueError("æ²’æœ‰å¯ç”¨çš„å¸³è™Ÿ")
            
            from pyrogram.enums import ChatType
            
            chat = await client.get_chat(username)
            
            if not chat:
                raise ValueError("æ‰¾ä¸åˆ°è©²ç¾¤çµ„")
            
            # åŸºç¤ä¿¡æ¯
            analysis = {
                "success": True,
                "isPrivate": False,
                "basic": {
                    "id": str(chat.id),
                    "title": chat.title or chat.first_name or username,
                    "username": chat.username or "",
                    "type": str(chat.type.name) if chat.type else "unknown",
                    "memberCount": chat.members_count or 0,
                    "description": chat.description or "",
                    "isPublic": bool(chat.username),
                    "createdAt": chat.date.isoformat() if chat.date else None
                }
            }
            
            self.send_log(f"âœ… åˆ†æå®Œæˆ: {chat.title or username}", "success")
            self.send_event("link-analysis-complete", analysis)
            
        except Exception as e:
            self.send_log(f"âŒ åˆ†æéˆæ¥å¤±æ•—: {e}", "error")
            self.send_event("link-analysis-complete", {
                "success": False,
                "error": str(e)
            })
    
    # ==================== æˆå“¡æå–è™•ç†å™¨ ====================
    
    async def handle_batch_refresh_member_counts(self, payload: Dict[str, Any]):
        """ğŸ†• æ‰¹é‡åˆ·æ–°ç¾¤çµ„æˆå“¡æ•¸"""
        import sys
        print(f"[Backend] handle_batch_refresh_member_counts called", file=sys.stderr)
        
        groups = payload.get('groups', [])
        if not groups:
            self.send_event("batch-refresh-member-counts-complete", {
                "success": True,
                "total": 0,
                "updated": 0,
                "failed": 0
            })
            return
        
        try:
            # æ‰¾åˆ°å¯ç”¨çš„å®¢æˆ¶ç«¯
            client = None
            for c in self.telegram_manager._clients.values():
                if c and c.is_connected:
                    client = c
                    break
            
            if not client:
                self.send_event("batch-refresh-member-counts-complete", {
                    "success": False,
                    "error": "æ²’æœ‰å¯ç”¨çš„åœ¨ç·šå¸³è™Ÿ"
                })
                return
            
            updated_count = 0
            failed_count = 0
            
            for i, group in enumerate(groups):
                try:
                    group_id = group.get('id')
                    url = group.get('url', '')
                    
                    # è§£æç¾¤çµ„æ¨™è­˜
                    chat_identifier = url
                    if url.startswith('https://t.me/'):
                        chat_identifier = url.replace('https://t.me/', '')
                    if not chat_identifier.startswith('@') and not chat_identifier.startswith('+'):
                        chat_identifier = f"@{chat_identifier}"
                    
                    # ç²å–æˆå“¡æ•¸
                    chat = await client.get_chat(chat_identifier)
                    member_count = chat.members_count or 0
                    
                    # æ›´æ–°æ•¸æ“šåº«
                    if member_count > 0:
                        await db.update_group_member_count(url, member_count)
                        updated_count += 1
                    
                    # ç™¼é€é€²åº¦
                    self.send_event("batch-refresh-member-counts-progress", {
                        "current": i + 1,
                        "total": len(groups),
                        "groupId": str(group_id),
                        "memberCount": member_count
                    })
                    
                    # é¿å…è§¸ç™¼é€Ÿç‡é™åˆ¶
                    await asyncio.sleep(0.5)
                    
                except Exception as e:
                    print(f"[Backend] Error refreshing member count for group {group.get('id')}: {e}", file=sys.stderr)
                    failed_count += 1
                    
                    # ä»ç„¶ç™¼é€é€²åº¦
                    self.send_event("batch-refresh-member-counts-progress", {
                        "current": i + 1,
                        "total": len(groups),
                        "groupId": str(group.get('id')),
                        "memberCount": 0
                    })
            
            self.send_event("batch-refresh-member-counts-complete", {
                "success": True,
                "total": len(groups),
                "updated": updated_count,
                "failed": failed_count
            })
            
        except Exception as e:
            import traceback
            traceback.print_exc()
            self.send_event("batch-refresh-member-counts-complete", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_group_member_count(self, payload: Dict[str, Any]):
        """ğŸ†• ç²å–ç¾¤çµ„æˆå“¡æ•¸ï¼ˆæ”¯æŒé‡æ–°ç²å–ï¼‰"""
        import sys
        print(f"[Backend] handle_get_group_member_count called with payload: {payload}", file=sys.stderr)
        
        group_id = payload.get('groupId')
        url = payload.get('url', '')
        account_phone = payload.get('accountPhone')
        
        try:
            # æ‰¾åˆ°å¯ç”¨çš„å®¢æˆ¶ç«¯
            client = None
            phone = account_phone
            
            if account_phone:
                client = self.telegram_manager.get_client(account_phone)
            
            if not client or not client.is_connected:
                # å˜—è©¦ä½¿ç”¨ä»»æ„åœ¨ç·šå¸³è™Ÿ
                for acc_phone, c in self.telegram_manager._clients.items():
                    if c and c.is_connected:
                        client = c
                        phone = acc_phone
                        break
            
            if not client or not client.is_connected:
                self.send_event("group-member-count-result", {
                    "success": False,
                    "groupId": group_id,
                    "error": "æ²’æœ‰å¯ç”¨çš„åœ¨ç·šå¸³è™Ÿ"
                })
                return
            
            # ğŸ”§ ä¿®å¾©ï¼šè§£æç¾¤çµ„æ¨™è­˜ï¼Œæ”¯æŒå¤šç¨®æ ¼å¼
            telegram_id = payload.get('telegramId') or payload.get('telegram_id')
            chat_identifier = None
            
            # å„ªå…ˆä½¿ç”¨ telegram_idï¼ˆæ•¸å­— IDï¼‰
            if telegram_id:
                try:
                    chat_identifier = int(telegram_id)
                    print(f"[Backend] Using telegram_id: {chat_identifier}", file=sys.stderr)
                except (ValueError, TypeError):
                    chat_identifier = None
            
            # å…¶æ¬¡ä½¿ç”¨ url
            if not chat_identifier and url:
                chat_identifier = url
                if url.startswith('https://t.me/'):
                    chat_identifier = url.replace('https://t.me/', '')
                if isinstance(chat_identifier, str):
                    if chat_identifier.startswith('+'):
                        # ç§æœ‰ç¾¤çµ„é‚€è«‹éˆæ¥
                        chat_identifier = url
                    elif chat_identifier and not chat_identifier.startswith('@'):
                        chat_identifier = f"@{chat_identifier}"
            
            if not chat_identifier:
                self.send_event("group-member-count-result", {
                    "success": False,
                    "groupId": group_id,
                    "error": "ç¼ºå°‘ç¾¤çµ„æ¨™è­˜ï¼ˆURL æˆ– Telegram IDï¼‰"
                })
                return
            
            print(f"[Backend] Getting member count for: {chat_identifier}", file=sys.stderr)
            
            # ç²å–ç¾¤çµ„ä¿¡æ¯
            try:
                chat = await client.get_chat(chat_identifier)
                member_count = chat.members_count or 0
                
                print(f"[Backend] Got member count: {member_count}", file=sys.stderr)
                
                # æ›´æ–°æ•¸æ“šåº«
                if member_count > 0:
                    await db.update_group_member_count(url, member_count)
                
                self.send_event("group-member-count-result", {
                    "success": True,
                    "groupId": group_id,
                    "memberCount": member_count,
                    "chatTitle": chat.title
                })
                
            except Exception as chat_err:
                error_str = str(chat_err).lower()
                if 'not found' in error_str or 'invalid' in error_str:
                    error_msg = "ç¾¤çµ„ä¸å­˜åœ¨æˆ–ç„¡æ³•è¨ªå•"
                elif 'banned' in error_str or 'kicked' in error_str:
                    error_msg = "å¸³è™Ÿè¢«è¸¢å‡ºè©²ç¾¤çµ„"
                elif 'private' in error_str:
                    error_msg = "é€™æ˜¯ç§æœ‰ç¾¤çµ„ï¼Œéœ€è¦é‚€è«‹éˆæ¥"
                else:
                    error_msg = f"ç²å–å¤±æ•—ï¼š{str(chat_err)}"
                
                print(f"[Backend] Error getting chat: {chat_err}", file=sys.stderr)
                self.send_event("group-member-count-result", {
                    "success": False,
                    "groupId": group_id,
                    "error": error_msg
                })
                
        except Exception as e:
            import traceback
            traceback.print_exc()
            self.send_event("group-member-count-result", {
                "success": False,
                "groupId": group_id,
                "error": f"ç²å–æˆå“¡æ•¸å¤±æ•—ï¼š{str(e)}"
            })
    
    async def handle_get_group_collected_stats(self, payload: Dict[str, Any]):
        """ğŸ†• ç²å–ç¾¤çµ„å·²æ”¶é›†ç”¨æˆ¶çµ±è¨ˆ"""
        import sys
        print(f"[Backend] handle_get_group_collected_stats: {payload}", file=sys.stderr)
        
        group_id = payload.get('groupId')
        telegram_id = payload.get('telegramId')
        
        try:
            from database import db
            await db.connect()
            
            collected_users = 0
            monitored_messages = 0
            
            if telegram_id:
                telegram_id_str = str(telegram_id)
                # ğŸ”§ ä¿®å¾©ï¼šæŸ¥è©¢ discussion_messages è¡¨ï¼ˆç¾¤çµ„ç›£æ§æ¶ˆæ¯çš„æ­£ç¢ºä½ç½®ï¼‰
                try:
                    messages_result = await db.fetch_one(
                        "SELECT COUNT(*) as count FROM discussion_messages WHERE discussion_id = ?",
                        (telegram_id_str,)
                    )
                    if messages_result:
                        monitored_messages = messages_result['count'] if isinstance(messages_result, dict) else (messages_result[0] if messages_result else 0)
                    
                    users_result = await db.fetch_one(
                        "SELECT COUNT(DISTINCT user_id) as count FROM discussion_messages WHERE discussion_id = ? AND user_id IS NOT NULL AND user_id != ''",
                        (telegram_id_str,)
                    )
                    if users_result:
                        collected_users = users_result['count'] if isinstance(users_result, dict) else (users_result[0] if users_result else 0)
                    
                    print(f"[Backend] Stats from discussion_messages: messages={monitored_messages}, users={collected_users}", file=sys.stderr)
                except Exception as dm_err:
                    print(f"[Backend] discussion_messages query failed: {dm_err}, trying collected_users", file=sys.stderr)
                
                # ğŸ†• åŒæ™‚æŸ¥è©¢ collected_users è¡¨ï¼ˆå¾æ­·å²æ¶ˆæ¯æ”¶é›†çš„ç”¨æˆ¶ï¼‰
                try:
                    cu_result = await db.fetch_one(
                        "SELECT COUNT(*) as count FROM collected_users WHERE source_group = ? OR source_group = ?",
                        (telegram_id_str, f"-100{telegram_id_str.lstrip('-')}")
                    )
                    if cu_result:
                        cu_count = cu_result['count'] if isinstance(cu_result, dict) else (cu_result[0] if cu_result else 0)
                        if cu_count > collected_users:
                            collected_users = cu_count
                            print(f"[Backend] Updated collected_users from collected_users table: {collected_users}", file=sys.stderr)
                except Exception:
                    pass  # è¡¨å¯èƒ½ä¸å­˜åœ¨
            
            self.send_event("group-collected-stats", {
                "groupId": group_id,
                "collectedUsers": collected_users,
                "monitoredMessages": monitored_messages
            })
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("group-collected-stats", {
                "groupId": group_id,
                "collectedUsers": 0,
                "monitoredMessages": 0,
                "error": str(e)
            })
    
    async def handle_get_collected_users_count(self, payload: Dict[str, Any]):
        """ğŸ†• ç²å–å·²æ”¶é›†ç”¨æˆ¶æ•¸é‡"""
        import sys
        group_id = payload.get('groupId')
        source_type = payload.get('sourceType', 'monitoring')
        
        try:
            from database import db
            await db.connect()
            
            # å¾ extracted_members è¡¨æŸ¥è©¢
            result = await db.fetch_one(
                "SELECT COUNT(*) as count FROM extracted_members WHERE source_chat_id = ?",
                (str(group_id),)
            )
            count = result['count'] if result and hasattr(result, '__getitem__') else 0
            
            self.send_event("collected-users-count", {
                "groupId": group_id,
                "count": count
            })
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("collected-users-count", {
                "groupId": group_id,
                "count": 0
            })
    
    async def handle_get_history_collection_stats(self, payload: Dict[str, Any]):
        """ğŸ†• ç²å–æ­·å²æ¶ˆæ¯æ”¶é›†çµ±è¨ˆï¼ˆç”¨æ–¼æ”¶é›†å°è©±æ¡†ï¼‰"""
        import sys
        print(f"[Backend] handle_get_history_collection_stats: {payload}", file=sys.stderr)
        
        group_id = payload.get('groupId')
        telegram_id = payload.get('telegramId')
        
        try:
            from database import db
            await db.connect()
            
            chat_id = str(telegram_id) if telegram_id else str(group_id)
            
            # æŸ¥è©¢æ¶ˆæ¯ç¸½æ•¸
            total_messages = 0
            messages_result = await db.fetch_one(
                "SELECT COUNT(*) as count FROM chat_history WHERE chat_id = ?",
                (chat_id,)
            )
            if messages_result:
                total_messages = messages_result['count'] if hasattr(messages_result, '__getitem__') else 0
            
            # æŸ¥è©¢å”¯ä¸€ç™¼é€è€…æ•¸é‡
            unique_senders = 0
            senders_result = await db.fetch_one(
                "SELECT COUNT(DISTINCT sender_id) as count FROM chat_history WHERE chat_id = ? AND sender_id IS NOT NULL AND sender_id != ''",
                (chat_id,)
            )
            if senders_result:
                unique_senders = senders_result['count'] if hasattr(senders_result, '__getitem__') else 0
            
            # æŸ¥è©¢æ´»èºç”¨æˆ¶æ•¸ï¼ˆç™¼è¨€>=3æ¬¡ï¼‰
            active_users = 0
            active_result = await db.fetch_one(
                """SELECT COUNT(*) as count FROM (
                    SELECT sender_id, COUNT(*) as msg_count 
                    FROM chat_history 
                    WHERE chat_id = ? AND sender_id IS NOT NULL AND sender_id != ''
                    GROUP BY sender_id 
                    HAVING msg_count >= 3
                )""",
                (chat_id,)
            )
            if active_result:
                active_users = active_result['count'] if hasattr(active_result, '__getitem__') else 0
            
            # æŸ¥è©¢æ¶ˆæ¯æ™‚é–“ç¯„åœ
            date_range = {'first': '', 'last': ''}
            date_result = await db.fetch_one(
                "SELECT MIN(timestamp) as first_date, MAX(timestamp) as last_date FROM chat_history WHERE chat_id = ?",
                (chat_id,)
            )
            if date_result:
                date_range['first'] = str(date_result['first_date']) if date_result.get('first_date') else ''
                date_range['last'] = str(date_result['last_date']) if date_result.get('last_date') else ''
            
            # æŸ¥è©¢å·²æ”¶é›†ç”¨æˆ¶æ•¸ï¼ˆåœ¨ collected_users è¡¨ä¸­ï¼‰
            collected_users = 0
            collected_result = await db.fetch_one(
                "SELECT COUNT(*) as count FROM collected_users WHERE source_groups LIKE ?",
                (f'%{chat_id}%',)
            )
            if collected_result:
                collected_users = collected_result['count'] if hasattr(collected_result, '__getitem__') else 0
            
            self.send_event("history-collection-stats", {
                "groupId": group_id,
                "success": True,
                "stats": {
                    "totalMessages": total_messages,
                    "uniqueSenders": unique_senders,
                    "activeUsers": active_users,
                    "collectedUsers": collected_users,
                    "dateRange": date_range
                }
            })
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("history-collection-stats", {
                "groupId": group_id,
                "success": False,
                "error": str(e)
            })
    
    async def handle_collect_users_from_history_advanced(self, payload: Dict[str, Any]):
        """ğŸ†• å¾æ­·å²æ¶ˆæ¯æ”¶é›†ç”¨æˆ¶ï¼ˆé€²éšç‰ˆï¼Œæ”¯æŒæ›´å¤šé…ç½®ï¼‰"""
        import sys
        from datetime import datetime, timedelta
        print(f"[Backend] handle_collect_users_from_history_advanced: {payload}", file=sys.stderr)
        
        group_id = payload.get('groupId')
        telegram_id = payload.get('telegramId')
        config = payload.get('config', {})
        
        # è§£æé…ç½®
        limit = config.get('limit', 200)
        time_range = config.get('timeRange', '30d')
        min_messages = config.get('minMessages', 1)
        skip_duplicates = config.get('skipDuplicates', True)
        exclude_bots = config.get('excludeBots', True)
        require_username = config.get('requireUsername', False)
        auto_sync = config.get('autoSync', True)
        
        try:
            from database import db
            await db.connect()
            
            chat_id = str(telegram_id) if telegram_id else str(group_id)
            
            # æ§‹å»ºæ™‚é–“æ¢ä»¶
            time_condition = ""
            if time_range == '7d':
                cutoff = (datetime.now() - timedelta(days=7)).isoformat()
                time_condition = f"AND timestamp >= '{cutoff}'"
            elif time_range == '30d':
                cutoff = (datetime.now() - timedelta(days=30)).isoformat()
                time_condition = f"AND timestamp >= '{cutoff}'"
            elif time_range == '90d':
                cutoff = (datetime.now() - timedelta(days=90)).isoformat()
                time_condition = f"AND timestamp >= '{cutoff}'"
            
            # ç™¼é€é€²åº¦æ›´æ–°
            self.send_event("history-collection-progress", {
                "groupId": group_id,
                "current": 0,
                "total": 100,
                "status": "æ­£åœ¨æŸ¥è©¢æ­·å²æ¶ˆæ¯..."
            })
            
            # æ§‹å»ºæŸ¥è©¢
            limit_clause = f"LIMIT {limit}" if limit > 0 else ""
            
            query = f"""
                SELECT 
                    sender_id,
                    sender_name,
                    sender_username,
                    COUNT(*) as message_count,
                    MAX(timestamp) as last_message_at
                FROM chat_history 
                WHERE chat_id = ? 
                  AND sender_id IS NOT NULL 
                  AND sender_id != ''
                  {time_condition}
                GROUP BY sender_id
                HAVING message_count >= ?
                ORDER BY message_count DESC
                {limit_clause}
            """
            
            results = await db.fetch_all(query, (chat_id, min_messages))
            
            if not results:
                self.send_event("history-collection-result", {
                    "groupId": group_id,
                    "success": False,
                    "error": "æœªæ‰¾åˆ°ç¬¦åˆæ¢ä»¶çš„ç”¨æˆ¶"
                })
                return
            
            total = len(results)
            collected_count = 0
            new_count = 0
            updated_count = 0
            skipped_count = 0
            
            # è³ªé‡çµ±è¨ˆ
            high_activity = 0
            medium_activity = 0
            low_activity = 0
            
            for idx, row in enumerate(results):
                try:
                    sender_id = row['sender_id'] if hasattr(row, '__getitem__') else row[0]
                    sender_name = row['sender_name'] if hasattr(row, '__getitem__') else row[1]
                    sender_username = row['sender_username'] if hasattr(row, '__getitem__') else row[2]
                    message_count = row['message_count'] if hasattr(row, '__getitem__') else row[3]
                    last_message = row['last_message_at'] if hasattr(row, '__getitem__') else row[4]
                    
                    if not sender_id:
                        continue
                    
                    # æª¢æŸ¥æ˜¯å¦éœ€è¦ç”¨æˆ¶å
                    if require_username and not sender_username:
                        skipped_count += 1
                        continue
                    
                    # æª¢æŸ¥æ˜¯å¦æ˜¯æ©Ÿå™¨äººï¼ˆç°¡å–®åˆ¤æ–·ï¼‰
                    if exclude_bots:
                        if sender_username and sender_username.lower().endswith('bot'):
                            skipped_count += 1
                            continue
                    
                    # æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
                    if skip_duplicates:
                        existing = await db.fetch_one(
                            "SELECT id FROM collected_users WHERE telegram_id = ?",
                            (str(sender_id),)
                        )
                        if existing:
                            updated_count += 1
                            # æ›´æ–°ç¾æœ‰è¨˜éŒ„
                            await db.execute(
                                """UPDATE collected_users 
                                   SET message_count = ?, last_message_at = ?, updated_at = CURRENT_TIMESTAMP
                                   WHERE telegram_id = ?""",
                                (message_count, last_message, str(sender_id))
                            )
                            continue
                    
                    # æ’å…¥æ–°ç”¨æˆ¶
                    user_data = {
                        'telegram_id': str(sender_id),
                        'username': sender_username or '',
                        'first_name': sender_name or '',
                        'last_name': '',
                        'source_groups': [chat_id],
                        'collected_by': 'history_scan',
                        'message_count': message_count,
                        'last_message_at': last_message
                    }
                    
                    user_id = await db.upsert_collected_user(user_data)
                    collected_count += 1
                    if user_id > 0:
                        new_count += 1
                    
                    # çµ±è¨ˆè³ªé‡
                    if message_count >= 10:
                        high_activity += 1
                    elif message_count >= 3:
                        medium_activity += 1
                    else:
                        low_activity += 1
                    
                    # ç™¼é€é€²åº¦
                    if idx % 10 == 0:
                        self.send_event("history-collection-progress", {
                            "groupId": group_id,
                            "current": idx + 1,
                            "total": total,
                            "status": f"å·²è™•ç† {idx + 1}/{total} ä½ç”¨æˆ¶"
                        })
                        
                except Exception as row_err:
                    print(f"[Backend] Error processing row: {row_err}", file=sys.stderr)
                    continue
            
            self.send_log(f"âœ… æ­·å²æ¶ˆæ¯æ”¶é›†å®Œæˆ: å…± {collected_count} ä½ç”¨æˆ¶ï¼Œæ–°å¢ {new_count} ä½", "success")
            
            self.send_event("history-collection-result", {
                "groupId": group_id,
                "success": True,
                "result": {
                    "success": True,
                    "collected": collected_count,
                    "newUsers": new_count,
                    "updated": updated_count,
                    "skipped": skipped_count,
                    "quality": {
                        "highActivity": high_activity,
                        "mediumActivity": medium_activity,
                        "lowActivity": low_activity
                    }
                }
            })
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_log(f"âŒ æ”¶é›†å¤±æ•—: {str(e)}", "error")
            self.send_event("history-collection-result", {
                "groupId": group_id,
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_group_monitoring_status(self, payload: Dict[str, Any]):
        """ğŸ†• ç²å–ç¾¤çµ„ç›£æ§ç‹€æ…‹"""
        import sys
        group_id = payload.get('groupId')
        telegram_id = payload.get('telegramId')
        
        try:
            from database import db
            await db.connect()
            
            # æª¢æŸ¥ç¾¤çµ„æ˜¯å¦åœ¨ç›£æ§ä¸­
            group = await db.fetch_one(
                "SELECT id, is_active, phone FROM monitored_groups WHERE id = ? OR telegram_id = ?",
                (group_id, str(telegram_id) if telegram_id else '')
            )
            
            is_monitoring = False
            collected_users = 0
            
            if group:
                is_active = group.get('is_active', 0) if hasattr(group, 'get') else 0
                has_phone = bool(group.get('phone', '')) if hasattr(group, 'get') else False
                is_monitoring = bool(is_active) and has_phone and self.is_monitoring
                
                # æŸ¥è©¢å·²æ”¶é›†ç”¨æˆ¶æ•¸
                if telegram_id:
                    result = await db.fetch_one(
                        "SELECT COUNT(DISTINCT sender_id) as count FROM chat_history WHERE chat_id = ? AND sender_id IS NOT NULL",
                        (str(telegram_id),)
                    )
                    if result:
                        collected_users = result['count'] if hasattr(result, '__getitem__') else 0
            
            self.send_event("group-monitoring-status", {
                "groupId": group_id,
                "isMonitoring": is_monitoring,
                "collectedUsers": collected_users
            })
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("group-monitoring-status", {
                "groupId": group_id,
                "isMonitoring": False,
                "collectedUsers": 0
            })
    
    async def handle_collect_users_from_history(self, payload: Dict[str, Any]):
        """ğŸ†• å¾æ­·å²æ¶ˆæ¯ä¸­æ”¶é›†ç”¨æˆ¶ï¼ˆæ›¿ä»£æˆå“¡æå–ï¼‰"""
        import sys
        print(f"[Backend] ========== handle_collect_users_from_history CALLED ==========", file=sys.stderr)
        
        group_id = payload.get('groupId')
        telegram_id = payload.get('telegramId')
        limit = payload.get('limit', 500)
        
        try:
            from database import db
            await db.connect()
            
            self.send_log(f"ğŸ”„ æ­£åœ¨å¾æ­·å²æ¶ˆæ¯ä¸­æ”¶é›†ç”¨æˆ¶...", "info")
            
            # æŸ¥è©¢ç¾¤çµ„çš„æ­·å²æ¶ˆæ¯ä¸­çš„å”¯ä¸€ç™¼é€è€…
            chat_id = str(telegram_id) if telegram_id else str(group_id)
            
            # å¾ chat_history è¡¨ç²å–å”¯ä¸€ç™¼é€è€…
            query = """
                SELECT DISTINCT 
                    sender_id,
                    sender_name,
                    sender_username,
                    COUNT(*) as message_count,
                    MAX(timestamp) as last_message_at
                FROM chat_history 
                WHERE chat_id = ? AND sender_id IS NOT NULL AND sender_id != ''
                GROUP BY sender_id
                ORDER BY message_count DESC
                LIMIT ?
            """
            
            results = await db.fetch_all(query, (chat_id, limit))
            
            if not results:
                self.send_log(f"âš ï¸ æœªæ‰¾åˆ°æ­·å²æ¶ˆæ¯ï¼Œè«‹å…ˆé–‹å•Ÿç¾¤çµ„ç›£æ§", "warning")
                self.send_event("collect-from-history-result", {
                    "groupId": group_id,
                    "success": False,
                    "error": "æœªæ‰¾åˆ°æ­·å²æ¶ˆæ¯ï¼Œè«‹å…ˆé–‹å•Ÿç¾¤çµ„ç›£æ§ä¸€æ®µæ™‚é–“",
                    "collected": 0,
                    "total": 0
                })
                return
            
            # å°‡ç™¼é€è€…æ·»åŠ åˆ° collected_users è¡¨
            collected_count = 0
            new_count = 0
            
            for row in results:
                try:
                    sender_id = row['sender_id'] if hasattr(row, '__getitem__') else row[0]
                    sender_name = row['sender_name'] if hasattr(row, '__getitem__') else row[1]
                    sender_username = row['sender_username'] if hasattr(row, '__getitem__') else row[2]
                    message_count = row['message_count'] if hasattr(row, '__getitem__') else row[3]
                    last_message = row['last_message_at'] if hasattr(row, '__getitem__') else row[4]
                    
                    if not sender_id:
                        continue
                    
                    user_data = {
                        'telegram_id': str(sender_id),
                        'username': sender_username or '',
                        'first_name': sender_name or '',
                        'last_name': '',
                        'source_groups': [chat_id],
                        'collected_by': 'history_scan',
                        'message_count': message_count,
                        'last_message_at': last_message
                    }
                    
                    user_id = await db.upsert_collected_user(user_data)
                    collected_count += 1
                    if user_id > 0:
                        new_count += 1
                        
                except Exception as row_err:
                    print(f"[Backend] Error processing row: {row_err}", file=sys.stderr)
                    continue
            
            self.send_log(f"âœ… å¾æ­·å²æ¶ˆæ¯æ”¶é›†å®Œæˆ: å…± {collected_count} ä½ç”¨æˆ¶ï¼Œæ–°å¢ {new_count} ä½", "success")
            
            self.send_event("collect-from-history-result", {
                "groupId": group_id,
                "success": True,
                "collected": collected_count,
                "newUsers": new_count,
                "total": len(results)
            })
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_log(f"âŒ æ”¶é›†å¤±æ•—: {str(e)}", "error")
            self.send_event("collect-from-history-result", {
                "groupId": group_id,
                "success": False,
                "error": str(e),
                "collected": 0
            })
    
    async def handle_extract_members(self, payload: Dict[str, Any]):
        """æå–ç¾¤çµ„æˆå“¡"""
        import sys
        print(f"[Backend] ========== handle_extract_members CALLED ==========", file=sys.stderr)
        print(f"[Backend] Payload: {payload}", file=sys.stderr)
        self.send_log("ğŸ“¥ æ”¶åˆ°æˆå“¡æå–è«‹æ±‚", "info")
        
        try:
            # ğŸ”§ FIX: å„ªå…ˆä½¿ç”¨ telegramIdï¼ˆæ•¸å­— IDï¼‰ï¼Œæ”¯æŒç§æœ‰ç¾¤çµ„
            telegram_id = payload.get('telegramId')
            chat_id = payload.get('chatId')
            username = payload.get('username')
            phone = payload.get('phone')
            resource_id = payload.get('resourceId')
            limit = payload.get('limit', 100)
            
            # å¾ filters ç²å–éæ¿¾é¸é …
            filters = payload.get('filters', {})
            filter_bots = filters.get('bots', True) if filters else payload.get('filterBots', True)
            
            # ğŸ”§ ä¿®å¾©ï¼šå„ªå…ˆä½¿ç”¨ onlineStatus å­—ç¬¦ä¸²
            online_status = None
            if filters:
                # å„ªå…ˆä½¿ç”¨æ˜ç¢ºçš„ onlineStatus å­—ç¬¦ä¸²
                online_status = filters.get('onlineStatus')
                
                # å›é€€ï¼šä½¿ç”¨å¸ƒçˆ¾å€¼
                if not online_status:
                    if filters.get('online') == True:
                        online_status = 'online'
                    elif filters.get('offline') == True:
                        online_status = 'offline'
            
            # é»˜èªå€¼
            if not online_status:
                online_status = 'all'
            
            filter_offline = filters.get('offline', False) if filters else payload.get('filterOffline', False)
            chinese_only = filters.get('chinese', False) if filters else False
            premium_only = filters.get('isPremium', False) if filters else False
            has_username = filters.get('hasUsername', False) if filters else False
            
            print(f"[Backend] Online status filter: {online_status}", file=sys.stderr)
            
            # ğŸ”§ FIX: æ±ºå®šä½¿ç”¨å“ªå€‹ ID
            # å„ªå…ˆç´š: telegramId > æœ‰æ•ˆçš„ username > å¾æ•¸æ“šåº«æŸ¥è©¢
            effective_chat_id = None
            
            # 1. å„ªå…ˆä½¿ç”¨ telegramIdï¼ˆå°ç§æœ‰ç¾¤çµ„æœ‰æ•ˆï¼‰
            if telegram_id and str(telegram_id).lstrip('-').isdigit():
                effective_chat_id = int(telegram_id)
                print(f"[Backend] Using telegramId: {effective_chat_id}", file=sys.stderr)
            
            # 2. å¦‚æœ chatId æ˜¯æ•¸å­— IDï¼Œä½¿ç”¨å®ƒ
            elif chat_id and str(chat_id).lstrip('-').isdigit():
                effective_chat_id = int(chat_id)
                print(f"[Backend] Using numeric chatId: {effective_chat_id}", file=sys.stderr)
            
            # 3. å¦‚æœ chatId æ˜¯æœ‰æ•ˆçš„ usernameï¼ˆä¸æ˜¯é‚€è«‹éˆæ¥æ ¼å¼ï¼‰ï¼Œä½¿ç”¨å®ƒ
            elif chat_id and not str(chat_id).startswith('+'):
                effective_chat_id = chat_id
                print(f"[Backend] Using username chatId: {effective_chat_id}", file=sys.stderr)
            
            # 4. å¾æ•¸æ“šåº«æŸ¥è©¢ telegram_id
            if not effective_chat_id:
                print(f"[Backend] No valid chat_id, trying to fetch from database...", file=sys.stderr)
                if resource_id:
                    # å˜—è©¦å¾ monitored_groups è¡¨æŸ¥è©¢
                    from database import db
                    await db.connect()
                    group = await db.fetch_one(
                        "SELECT telegram_id, link FROM monitored_groups WHERE id = ?",
                        (resource_id,)
                    )
                    if group:
                        db_telegram_id = group.get('telegram_id') if hasattr(group, 'get') else (group[0] if group else None)
                        if db_telegram_id:
                            effective_chat_id = int(db_telegram_id) if str(db_telegram_id).lstrip('-').isdigit() else db_telegram_id
                            print(f"[Backend] Found telegram_id from database: {effective_chat_id}", file=sys.stderr)
            
            print(f"[Backend] extract-members: effective_chat_id={effective_chat_id}, resource_id={resource_id}, limit={limit}", file=sys.stderr)
            print(f"[Backend] Filters: bots={filter_bots}, offline={filter_offline}, chinese={chinese_only}", file=sys.stderr)
            
            if not effective_chat_id:
                raise ValueError("ç¾¤çµ„ ID ä¸èƒ½ç‚ºç©ºã€‚å°æ–¼ç§æœ‰ç¾¤çµ„ï¼Œéœ€è¦å…ˆç²å–å…¶ Telegram IDã€‚")
            
            chat_id = effective_chat_id
            
            # ğŸ”§ P0 FIX: å„ªå…ˆä½¿ç”¨å·²åŠ å…¥ç¾¤çµ„çš„å¸³è™Ÿ
            if not phone:
                from database import db
                await db.connect()
                
                # 1. å˜—è©¦å¾ discovered_resources ç²å– joined_by_phone
                # ğŸ”§ ä¿®å¾©ï¼šåŒæ™‚æ”¯æŒæŒ‰ idã€telegram_idã€username æŸ¥è©¢
                try:
                    resource = None
                    
                    # 1a. æŒ‰ resource_id æŸ¥è©¢
                    if resource_id:
                        resource = await db.fetch_one(
                            "SELECT joined_by_phone, telegram_id FROM discovered_resources WHERE id = ?",
                            (resource_id,)
                        )
                        print(f"[Backend] Query by resource_id={resource_id}: found={resource is not None}", file=sys.stderr)
                    
                    # 1b. æŒ‰ telegram_id æŸ¥è©¢
                    if not resource and telegram_id:
                        resource = await db.fetch_one(
                            "SELECT joined_by_phone, telegram_id FROM discovered_resources WHERE telegram_id = ?",
                            (str(telegram_id),)
                        )
                        print(f"[Backend] Query by telegram_id={telegram_id}: found={resource is not None}", file=sys.stderr)
                    
                    # 1c. æŒ‰ username æŸ¥è©¢
                    if not resource and username:
                        resource = await db.fetch_one(
                            "SELECT joined_by_phone, telegram_id FROM discovered_resources WHERE username = ?",
                            (username.lstrip('@'),)
                        )
                        print(f"[Backend] Query by username={username}: found={resource is not None}", file=sys.stderr)
                    
                    if resource:
                        joined_phone = resource.get('joined_by_phone') if hasattr(resource, 'get') else resource[0]
                        print(f"[Backend] Found joined_by_phone={joined_phone}", file=sys.stderr)
                        if joined_phone and joined_phone in self.telegram_manager.clients:
                            phone = joined_phone
                            print(f"[Backend] âœ“ Using joined_by_phone from discovered_resources: {phone}", file=sys.stderr)
                        elif joined_phone:
                            print(f"[Backend] âš  joined_by_phone {joined_phone} not in connected clients", file=sys.stderr)
                except Exception as e:
                    print(f"[Backend] Error fetching joined_by_phone: {e}", file=sys.stderr)
                
                # 2. å˜—è©¦å¾ monitored_groups ç²å– phone
                if not phone:
                    try:
                        # é€šé telegram_id æˆ– username æŸ¥è©¢
                        chat_id_str = str(effective_chat_id)
                        group = await db.fetch_one(
                            """SELECT phone FROM monitored_groups 
                               WHERE telegram_id = ? OR link LIKE ? OR name LIKE ?""",
                            (chat_id_str, f"%{chat_id_str}%", f"%{username}%" if username else "")
                        )
                        if group:
                            group_phone = group.get('phone') if hasattr(group, 'get') else group[0]
                            if group_phone and group_phone in self.telegram_manager.clients:
                                phone = group_phone
                                print(f"[Backend] âœ“ Using phone from monitored_groups: {phone}", file=sys.stderr)
                    except Exception as e:
                        print(f"[Backend] Error fetching phone from monitored_groups: {e}", file=sys.stderr)
                
                # 3. å›é€€ï¼šä½¿ç”¨ç¬¬ä¸€å€‹å¯ç”¨çš„å®¢æˆ¶ç«¯ï¼Œä½†ç™¼å‡ºæ˜ç¢ºè­¦å‘Š
                if not phone and self.telegram_manager.clients:
                    phone = list(self.telegram_manager.clients.keys())[0]
                    print(f"[Backend] âš  Using default phone (fallback): {phone}", file=sys.stderr)
                    self.send_log(f"âš ï¸ æœªæ‰¾åˆ°å·²åŠ å…¥ç¾¤çµ„çš„å¸³è™Ÿï¼Œå˜—è©¦ä½¿ç”¨å¸³è™Ÿ {phone[:4]}****", "warning")
                    self.send_log(f"ğŸ’¡ å¦‚æå–å¤±æ•—ï¼Œè«‹å…ˆä½¿ç”¨è©²å¸³è™ŸåŠ å…¥æ­¤ç¾¤çµ„", "info")
            
            self.send_log(f"ğŸ” é–‹å§‹æå–æˆå“¡: {chat_id} (å¸³è™Ÿ: {phone})", "info")
            
            # è¨­ç½®å®¢æˆ¶ç«¯
            member_extraction_service.set_clients(self.telegram_manager.clients)
            member_extraction_service.set_event_callback(self.send_event)
            
            # ç™¼é€é–‹å§‹äº‹ä»¶
            self.send_event("members-extraction-progress", {
                "resourceId": resource_id,
                "status": "starting",
                "extracted": 0,
                "total": 0
            })
            
            # æå–æˆå“¡ - ğŸ”§ ä¿®å¾©ï¼šå‚³é online_status åƒæ•¸
            result = await member_extraction_service.extract_members(
                chat_id=chat_id,
                phone=phone,
                limit=limit,
                filter_bots=filter_bots,
                filter_offline=filter_offline,
                online_status=online_status,  # ğŸ”§ æ·»åŠ åœ¨ç·šç‹€æ…‹éæ¿¾
                save_to_db=True
            )
            
            if result['success']:
                members = result.get('members', [])
                
                # æ‡‰ç”¨é¡å¤–çš„éæ¿¾å™¨
                filtered_members = []
                for member in members:
                    # è¯äººéæ¿¾
                    if chinese_only:
                        name = (member.get('first_name', '') or '') + (member.get('last_name', '') or '')
                        bio = member.get('bio', '') or ''
                        # æª¢æŸ¥æ˜¯å¦æœ‰ä¸­æ–‡å­—ç¬¦
                        import re
                        if not re.search(r'[\u4e00-\u9fff]', name + bio):
                            continue
                    
                    # Premium éæ¿¾
                    if premium_only and not member.get('is_premium'):
                        continue
                    
                    # ç”¨æˆ¶åéæ¿¾
                    if has_username and not member.get('username'):
                        continue
                    
                    filtered_members.append(member)
                
                result['members'] = filtered_members
                result['extracted'] = len(filtered_members)
                
                self.send_log(f"âœ… æå–å®Œæˆ: {len(filtered_members)} æˆå“¡ (ç¸½è¨ˆ: {len(members)})", "success")
                
                # ğŸ†• è‡ªå‹•åŒæ­¥åˆ°çµ±ä¸€è¯ç¹«äººè¡¨
                try:
                    from unified_contacts import get_unified_contacts_manager
                    from database import db as sync_db  # ğŸ”§ ä¿®å¾©ï¼šç¢ºä¿æ­£ç¢ºå°å…¥
                    await sync_db.connect()
                    manager = get_unified_contacts_manager(sync_db)
                    sync_stats = await manager.sync_from_sources()
                    print(f"[Backend] Auto-synced to unified_contacts: {sync_stats}", file=sys.stderr)
                    self.send_log(f"âœ… å·²åŒæ­¥åˆ°è³‡æºä¸­å¿ƒ: æ–°å¢ {sync_stats['synced']}ï¼Œæ›´æ–° {sync_stats['updated']}", "info")
                except Exception as sync_err:
                    import traceback
                    traceback.print_exc(file=sys.stderr)
                    print(f"[Backend] Auto-sync error: {sync_err}", file=sys.stderr)
            else:
                self.send_log(f"âŒ æå–å¤±æ•—: {result['error']}", "error")
            
            # ç™¼é€å®Œæˆäº‹ä»¶ - ğŸ”§ ä¿®å¾©ï¼šåŒ…å«è©³ç´°éŒ¯èª¤ä¿¡æ¯
            self.send_event("members-extracted", {
                "resourceId": resource_id,
                "success": result.get('success', False),
                "members": result.get('members', []),
                "extracted": result.get('extracted', 0),
                "total": result.get('total', 0),
                "onlineCount": result.get('online_count', 0),
                "error": result.get('error'),
                "error_code": result.get('error_code'),  # ğŸ†• éŒ¯èª¤ä»£ç¢¼
                "error_details": result.get('error_details')  # ğŸ†• è©³ç´°éŒ¯èª¤ä¿¡æ¯
            })
            
        except Exception as e:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_log(f"âŒ æå–æˆå“¡å¤±æ•—: {e}", "error")
            self.send_event("members-extracted", {
                "resourceId": payload.get('resourceId'),
                "success": False,
                "error": str(e),
                "members": [],
                "extracted": 0,
                "total": 0
            })
    
    async def handle_get_extracted_members(self, payload: Dict[str, Any]):
        """ç²å–å·²æå–çš„æˆå“¡åˆ—è¡¨"""
        import time
        start_time = time.time()
        print(f"[Backend] handle_get_extracted_members started, payload: {payload}", file=sys.stderr)
        
        try:
            online_only = payload.get('onlineOnly', False)
            min_value_level = payload.get('minValueLevel')
            source_chat_id = payload.get('sourceChatId')
            not_contacted = payload.get('notContacted', False)
            limit = payload.get('limit', 100)
            offset = payload.get('offset', 0)
            
            print(f"[Backend] Fetching members with limit={limit}, offset={offset}...", file=sys.stderr)
            members = await member_extraction_service.get_members(
                online_only=online_only,
                min_value_level=min_value_level,
                source_chat_id=source_chat_id,
                not_contacted=not_contacted,
                limit=limit,
                offset=offset
            )
            
            elapsed = time.time() - start_time
            print(f"[Backend] Fetched {len(members)} members in {elapsed:.2f}s", file=sys.stderr)
            
            self.send_event("extracted-members-list", {
                "success": True,
                "members": members,
                "count": len(members)
            })
            print(f"[Backend] Sent extracted-members-list event with {len(members)} members", file=sys.stderr)
            
        except Exception as e:
            self.send_log(f"âŒ ç²å–æˆå“¡åˆ—è¡¨å¤±æ•—: {e}", "error")
            self.send_event("extracted-members-list", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_member_stats(self, payload: Dict[str, Any]):
        """ç²å–æˆå“¡çµ±è¨ˆ"""
        try:
            source_chat_id = payload.get('sourceChatId')
            
            stats = await member_extraction_service.count_members(source_chat_id)
            
            self.send_event("member-stats", {
                "success": True,
                **stats
            })
            
        except Exception as e:
            self.send_log(f"âŒ ç²å–æˆå“¡çµ±è¨ˆå¤±æ•—: {e}", "error")
            self.send_event("member-stats", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_online_members(self, payload: Dict[str, Any]):
        """ç²å–åœ¨ç·šæˆå“¡"""
        try:
            limit = payload.get('limit', 100)
            
            members = await member_extraction_service.get_online_members(limit)
            
            self.send_event("online-members-list", {
                "success": True,
                "members": members,
                "count": len(members)
            })
            
        except Exception as e:
            self.send_log(f"âŒ ç²å–åœ¨ç·šæˆå“¡å¤±æ•—: {e}", "error")
            self.send_event("online-members-list", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_update_member(self, payload: Dict[str, Any]):
        """æ›´æ–°æˆå“¡ä¿¡æ¯"""
        try:
            user_id = payload.get('userId')
            updates = payload.get('updates', {})
            
            if not user_id:
                raise ValueError("ç”¨æˆ¶ ID ä¸èƒ½ç‚ºç©º")
            
            # æ§‹å»ºæ›´æ–°èªå¥
            set_clauses = []
            params = []
            
            allowed_fields = ['tags', 'notes', 'contacted', 'contacted_at', 'response_status', 'converted', 'value_level']
            
            for field, value in updates.items():
                if field in allowed_fields:
                    set_clauses.append(f"{field} = ?")
                    params.append(value if not isinstance(value, bool) else (1 if value else 0))
            
            if not set_clauses:
                self.send_event("member-updated", {
                    "success": True,
                    "userId": user_id,
                    "message": "ç„¡éœ€æ›´æ–°"
                })
                return
            
            # æ·»åŠ æ›´æ–°æ™‚é–“
            set_clauses.append("updated_at = ?")
            params.append(datetime.now().isoformat())
            
            # æ·»åŠ  user_id åƒæ•¸
            params.append(user_id)
            
            query = f"UPDATE extracted_members SET {', '.join(set_clauses)} WHERE user_id = ?"
            
            await db.execute(query, tuple(params))
            
            self.send_log(f"âœ… æ›´æ–°æˆå“¡ {user_id} æˆåŠŸ", "success")
            self.send_event("member-updated", {
                "success": True,
                "userId": user_id
            })
            
        except Exception as e:
            self.send_log(f"âŒ æ›´æ–°æˆå“¡å¤±æ•—: {e}", "error")
            self.send_event("member-updated", {
                "success": False,
                "error": str(e)
            })
    
    # ==================== ç‡ŸéŠ·è§¸é”è™•ç†å™¨ ====================
    
    async def handle_send_bulk_messages(self, payload: Dict[str, Any]):
        """æ‰¹é‡ç™¼é€ç§ä¿¡"""
        try:
            user_ids = payload.get('userIds', [])
            message_template = payload.get('messageTemplate', '')
            delay_min = payload.get('delayMin', 30)
            delay_max = payload.get('delayMax', 90)
            
            if not user_ids:
                raise ValueError("ç”¨æˆ¶ ID åˆ—è¡¨ä¸èƒ½ç‚ºç©º")
            if not message_template:
                raise ValueError("æ¶ˆæ¯æ¨¡æ¿ä¸èƒ½ç‚ºç©º")
            
            self.send_log(f"ğŸ“¤ é–‹å§‹æ‰¹é‡ç™¼é€: {len(user_ids)} äºº", "info")
            
            # è¨­ç½®å®¢æˆ¶ç«¯
            marketing_outreach_service.set_clients(self.telegram_manager.clients)
            marketing_outreach_service.set_event_callback(self.send_event)
            
            # åœ¨å¾Œå°åŸ·è¡Œ
            async def send_task():
                stats = await marketing_outreach_service.batch_send_messages(
                    user_ids=user_ids,
                    message_template=message_template,
                    delay_range=(delay_min, delay_max)
                )
                self.send_event("bulk-send-complete", {
                    "success": True,
                    **stats
                })
            
            asyncio.create_task(send_task())
            
            self.send_event("bulk-send-started", {
                "success": True,
                "total": len(user_ids)
            })
            
        except Exception as e:
            self.send_log(f"âŒ æ‰¹é‡ç™¼é€å¤±æ•—: {e}", "error")
            self.send_event("bulk-send-complete", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_batch_invite_to_group(self, payload: Dict[str, Any]):
        """æ‰¹é‡é‚€è«‹å…¥ç¾¤"""
        try:
            user_ids = payload.get('userIds', [])
            group_id = payload.get('groupId', '')
            delay_min = payload.get('delayMin', 30)
            delay_max = payload.get('delayMax', 90)
            
            if not user_ids:
                raise ValueError("ç”¨æˆ¶ ID åˆ—è¡¨ä¸èƒ½ç‚ºç©º")
            if not group_id:
                raise ValueError("ç›®æ¨™ç¾¤çµ„ä¸èƒ½ç‚ºç©º")
            
            self.send_log(f"ğŸ“¥ é–‹å§‹æ‰¹é‡é‚€è«‹: {len(user_ids)} äºº -> {group_id}", "info")
            
            # è¨­ç½®å®¢æˆ¶ç«¯
            marketing_outreach_service.set_clients(self.telegram_manager.clients)
            marketing_outreach_service.set_event_callback(self.send_event)
            
            # åœ¨å¾Œå°åŸ·è¡Œ
            async def invite_task():
                stats = await marketing_outreach_service.batch_invite(
                    user_ids=user_ids,
                    group_id=group_id,
                    delay_range=(delay_min, delay_max)
                )
                self.send_event("batch-invite-complete", {
                    "success": True,
                    **stats
                })
            
            asyncio.create_task(invite_task())
            
            self.send_event("batch-invite-started", {
                "success": True,
                "total": len(user_ids)
            })
            
        except Exception as e:
            self.send_log(f"âŒ æ‰¹é‡é‚€è«‹å¤±æ•—: {e}", "error")
            self.send_event("batch-invite-complete", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_create_marketing_campaign(self, payload: Dict[str, Any]):
        """å‰µå»ºç‡ŸéŠ·æ´»å‹•"""
        try:
            name = payload.get('name', '')
            campaign_type = payload.get('type', 'pm')
            target_users = payload.get('targetUsers', [])
            target_group = payload.get('targetGroup')
            message_template = payload.get('messageTemplate')
            
            if not name:
                raise ValueError("æ´»å‹•åç¨±ä¸èƒ½ç‚ºç©º")
            
            campaign_id = await marketing_outreach_service.create_campaign(
                name=name,
                campaign_type=campaign_type,
                target_users=target_users,
                target_group=target_group,
                message_template=message_template
            )
            
            self.send_log(f"ğŸ“¢ å‰µå»ºç‡ŸéŠ·æ´»å‹•æˆåŠŸ: {name} (ID: {campaign_id})", "success")
            self.send_event("campaign-created", {
                "success": True,
                "campaignId": campaign_id,
                "name": name
            })
            
        except Exception as e:
            self.send_log(f"âŒ å‰µå»ºç‡ŸéŠ·æ´»å‹•å¤±æ•—: {e}", "error")
            self.send_event("campaign-created", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_start_marketing_campaign(self, payload: Dict[str, Any]):
        """å•Ÿå‹•ç‡ŸéŠ·æ´»å‹•"""
        try:
            campaign_id = payload.get('campaignId')
            
            if not campaign_id:
                raise ValueError("æ´»å‹• ID ä¸èƒ½ç‚ºç©º")
            
            # è¨­ç½®å®¢æˆ¶ç«¯
            marketing_outreach_service.set_clients(self.telegram_manager.clients)
            marketing_outreach_service.set_event_callback(self.send_event)
            
            self.send_log(f"ğŸš€ å•Ÿå‹•ç‡ŸéŠ·æ´»å‹•: {campaign_id}", "info")
            
            # åœ¨å¾Œå°åŸ·è¡Œ
            async def campaign_task():
                result = await marketing_outreach_service.start_campaign(campaign_id)
                self.send_event("campaign-complete", {
                    "campaignId": campaign_id,
                    **result
                })
            
            asyncio.create_task(campaign_task())
            
            self.send_event("campaign-started", {
                "success": True,
                "campaignId": campaign_id
            })
            
        except Exception as e:
            self.send_log(f"âŒ å•Ÿå‹•ç‡ŸéŠ·æ´»å‹•å¤±æ•—: {e}", "error")
            self.send_event("campaign-complete", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_marketing_stats(self, payload: Dict[str, Any]):
        """ç²å–ç‡ŸéŠ·çµ±è¨ˆ"""
        try:
            campaign_id = payload.get('campaignId')
            
            stats = await marketing_outreach_service.get_campaign_stats(campaign_id)
            
            self.send_event("marketing-stats", {
                "success": True,
                "stats": stats
            })
            
        except Exception as e:
            self.send_log(f"âŒ ç²å–ç‡ŸéŠ·çµ±è¨ˆå¤±æ•—: {e}", "error")
            self.send_event("marketing-stats", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_ollama_models(self, payload: Dict[str, Any]):
        """ç²å– Ollama å¯ç”¨æ¨¡å‹åˆ—è¡¨"""
        try:
            import aiohttp
            
            endpoint = payload.get('endpoint', 'http://localhost:11434')
            
            async with aiohttp.ClientSession() as session:
                async with session.get(f"{endpoint}/api/tags", timeout=aiohttp.ClientTimeout(total=10)) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        models = [model['name'] for model in data.get('models', [])]
                        
                        self.send_log(f"ğŸ¦™ Ollama æ¨¡å‹åˆ—è¡¨: {models}", "info")
                        self.send_event("ollama-models", {
                            "success": True,
                            "models": models
                        })
                    else:
                        raise Exception(f"Ollama API è¿”å› {resp.status}")
                        
        except Exception as e:
            self.send_log(f"âŒ ç²å– Ollama æ¨¡å‹å¤±æ•—: {e}", "error")
            self.send_event("ollama-models", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_test_ollama_connection(self, payload: Dict[str, Any]):
        """æ¸¬è©¦ Ollama é€£æ¥"""
        try:
            import aiohttp
            
            endpoint = payload.get('endpoint', 'http://localhost:11434')
            
            async with aiohttp.ClientSession() as session:
                async with session.get(f"{endpoint}/api/version", timeout=aiohttp.ClientTimeout(total=5)) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        version = data.get('version', 'unknown')
                        
                        self.send_log(f"ğŸ¦™ Ollama é€£æ¥æˆåŠŸ (ç‰ˆæœ¬: {version})", "success")
                        self.send_event("local-ai-test-result", {
                            "success": True,
                            "message": f"Ollama é€£æ¥æˆåŠŸ (v{version})"
                        })
                    else:
                        raise Exception(f"é€£æ¥å¤±æ•—: HTTP {resp.status}")
                        
        except Exception as e:
            self.send_log(f"âŒ Ollama é€£æ¥å¤±æ•—: {e}", "error")
            self.send_event("local-ai-test-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_ollama_generate(self, payload: Dict[str, Any]):
        """ä½¿ç”¨ Ollama ç”Ÿæˆæ–‡æœ¬"""
        try:
            import aiohttp
            
            endpoint = payload.get('endpoint', 'http://localhost:11434')
            model = payload.get('model', 'qwen2:7b')
            prompt = payload.get('prompt', '')
            system = payload.get('system', '')
            
            if not prompt:
                raise ValueError("prompt ä¸èƒ½ç‚ºç©º")
            
            request_data = {
                "model": model,
                "prompt": prompt,
                "stream": False
            }
            
            if system:
                request_data["system"] = system
            
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    f"{endpoint}/api/generate",
                    json=request_data,
                    timeout=aiohttp.ClientTimeout(total=60)
                ) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        response = data.get('response', '')
                        
                        self.send_event("ollama-response", {
                            "success": True,
                            "response": response,
                            "model": model
                        })
                    else:
                        raise Exception(f"ç”Ÿæˆå¤±æ•—: HTTP {resp.status}")
                        
        except Exception as e:
            self.send_log(f"âŒ Ollama ç”Ÿæˆå¤±æ•—: {e}", "error")
            self.send_event("ollama-response", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_discovery_keywords(self):
        """ç²å–æœç´¢é—œéµè©åˆ—è¡¨"""
        try:
            keywords = await resource_discovery.get_search_keywords()
            
            self.send_event("discovery-keywords", {
                "success": True,
                "keywords": keywords
            })
            
        except Exception as e:
            self.send_log(f"âŒ ç²å–é—œéµè©å¤±æ•—: {e}", "error")
            self.send_event("discovery-keywords", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_add_discovery_keyword(self, payload: Dict[str, Any]):
        """æ·»åŠ æœç´¢é—œéµè©"""
        try:
            keyword = payload.get('keyword', '').strip()
            category = payload.get('category', 'general')
            priority = payload.get('priority', 5)
            
            if not keyword:
                raise ValueError("é—œéµè©ä¸èƒ½ç‚ºç©º")
            
            keyword_id = await resource_discovery.add_search_keyword(keyword, category, priority)
            
            self.send_log(f"â• æ·»åŠ æœç´¢é—œéµè©: {keyword}", "success")
            self.send_event("discovery-keyword-added", {
                "success": True,
                "keywordId": keyword_id,
                "keyword": keyword
            })
            
        except Exception as e:
            self.send_log(f"âŒ æ·»åŠ é—œéµè©å¤±æ•—: {e}", "error")
            self.send_event("discovery-keyword-added", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_discovery_logs(self, payload: Dict[str, Any]):
        """ç²å–æœç´¢æ—¥èªŒ"""
        try:
            limit = payload.get('limit', 50)
            logs = await resource_discovery.get_discovery_logs(limit=limit)
            
            self.send_event("discovery-logs", {
                "success": True,
                "logs": logs
            })
            
        except Exception as e:
            self.send_log(f"âŒ ç²å–æœç´¢æ—¥èªŒå¤±æ•—: {e}", "error")
            self.send_event("discovery-logs", {
                "success": False,
                "error": str(e)
            })
    
    # ==================== Discussion Watcher Handlers ====================
    
    async def handle_init_discussion_watcher(self):
        """åˆå§‹åŒ–è¨è«–çµ„ç›£æ§æœå‹™"""
        try:
            await discussion_watcher.initialize()
            discussion_watcher.set_clients(self.telegram_manager.clients)
            discussion_watcher.set_event_callback(self.send_event)
            
            # è¨­ç½®é—œéµè©åŒ¹é…å™¨
            from keyword_matcher import keyword_matcher
            discussion_watcher.set_keyword_matcher(keyword_matcher)
            
            self.send_log("âœ… è¨è«–çµ„ç›£æ§æœå‹™åˆå§‹åŒ–å®Œæˆ", "success")
            self.send_event("discussion-watcher-initialized", {"success": True})
            
        except Exception as e:
            self.send_log(f"âŒ è¨è«–çµ„ç›£æ§æœå‹™åˆå§‹åŒ–å¤±æ•—: {e}", "error")
            self.send_event("discussion-watcher-initialized", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_discover_discussion(self, payload: Dict[str, Any]):
        """ç™¼ç¾é »é“çš„è¨è«–çµ„"""
        try:
            channel_id = payload.get('channelId', '')
            phone = payload.get('phone')
            
            if not channel_id:
                raise ValueError("é »é“ ID ä¸èƒ½ç‚ºç©º")
            
            discussion_watcher.set_clients(self.telegram_manager.clients)
            discussion = await discussion_watcher.discover_discussion(channel_id, phone)
            
            if discussion:
                self.send_log(f"âœ… ç™¼ç¾è¨è«–çµ„: {discussion.discussion_title}", "success")
                self.send_event("discussion-discovered", {
                    "success": True,
                    "discussion": {
                        "id": discussion.id,
                        "channel_id": discussion.channel_id,
                        "channel_title": discussion.channel_title,
                        "discussion_id": discussion.discussion_id,
                        "discussion_title": discussion.discussion_title
                    }
                })
            else:
                self.send_event("discussion-discovered", {
                    "success": False,
                    "error": "æœªæ‰¾åˆ°è¨è«–çµ„æˆ–é »é“ç„¡è¨è«–å€"
                })
            
        except Exception as e:
            self.send_log(f"âŒ ç™¼ç¾è¨è«–çµ„å¤±æ•—: {e}", "error")
            self.send_event("discussion-discovered", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_discover_discussions_from_resources(self):
        """å¾å·²ç™¼ç¾çš„è³‡æºä¸­ç™¼ç¾è¨è«–çµ„"""
        try:
            discussion_watcher.set_clients(self.telegram_manager.clients)
            discussions = await discussion_watcher.discover_from_resources()
            
            self.send_log(f"âœ… å¾è³‡æºç™¼ç¾äº† {len(discussions)} å€‹è¨è«–çµ„", "success")
            self.send_event("discussions-batch-discovered", {
                "success": True,
                "count": len(discussions),
                "discussions": [
                    {
                        "id": d.id,
                        "channel_title": d.channel_title,
                        "discussion_title": d.discussion_title
                    } for d in discussions
                ]
            })
            
        except Exception as e:
            self.send_log(f"âŒ æ‰¹é‡ç™¼ç¾è¨è«–çµ„å¤±æ•—: {e}", "error")
            self.send_event("discussions-batch-discovered", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_channel_discussions(self, payload: Dict[str, Any]):
        """ç²å–é »é“-è¨è«–çµ„åˆ—è¡¨"""
        try:
            active_only = payload.get('activeOnly', True)
            discussions = await discussion_watcher.list_channel_discussions(active_only)
            
            self.send_event("channel-discussions-list", {
                "success": True,
                "discussions": discussions
            })
            
        except Exception as e:
            self.send_log(f"âŒ ç²å–è¨è«–çµ„åˆ—è¡¨å¤±æ•—: {e}", "error")
            self.send_event("channel-discussions-list", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_start_discussion_monitoring(self, payload: Dict[str, Any]):
        """é–‹å§‹ç›£æ§è¨è«–çµ„"""
        try:
            discussion_id = payload.get('discussionId', '')
            phone = payload.get('phone')
            
            if not discussion_id:
                raise ValueError("è¨è«–çµ„ ID ä¸èƒ½ç‚ºç©º")
            
            discussion_watcher.set_clients(self.telegram_manager.clients)
            success = await discussion_watcher.start_monitoring(discussion_id, phone)
            
            if success:
                self.send_log(f"ğŸŸ¢ é–‹å§‹ç›£æ§è¨è«–çµ„: {discussion_id}", "success")
            
            self.send_event("discussion-monitoring-status", {
                "success": success,
                "discussion_id": discussion_id,
                "status": "monitoring" if success else "error"
            })
            
        except Exception as e:
            self.send_log(f"âŒ å•Ÿå‹•ç›£æ§å¤±æ•—: {e}", "error")
            self.send_event("discussion-monitoring-status", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_stop_discussion_monitoring(self, payload: Dict[str, Any]):
        """åœæ­¢ç›£æ§è¨è«–çµ„"""
        try:
            discussion_id = payload.get('discussionId', '')
            
            if not discussion_id:
                raise ValueError("è¨è«–çµ„ ID ä¸èƒ½ç‚ºç©º")
            
            success = await discussion_watcher.stop_monitoring(discussion_id)
            
            if success:
                self.send_log(f"ğŸ”´ åœæ­¢ç›£æ§è¨è«–çµ„: {discussion_id}", "success")
            
            self.send_event("discussion-monitoring-status", {
                "success": success,
                "discussion_id": discussion_id,
                "status": "stopped"
            })
            
        except Exception as e:
            self.send_log(f"âŒ åœæ­¢ç›£æ§å¤±æ•—: {e}", "error")
            self.send_event("discussion-monitoring-status", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_discussion_messages(self, payload: Dict[str, Any]):
        """ç²å–è¨è«–çµ„æ¶ˆæ¯"""
        try:
            discussion_id = payload.get('discussionId', '')
            limit = payload.get('limit', 50)
            matched_only = payload.get('matchedOnly', False)
            
            if not discussion_id:
                raise ValueError("è¨è«–çµ„ ID ä¸èƒ½ç‚ºç©º")
            
            messages = await discussion_watcher.get_discussion_messages(
                discussion_id, limit, matched_only
            )
            
            self.send_event("discussion-messages", {
                "success": True,
                "discussion_id": discussion_id,
                "messages": messages
            })
            
        except Exception as e:
            self.send_log(f"âŒ ç²å–æ¶ˆæ¯å¤±æ•—: {e}", "error")
            self.send_event("discussion-messages", {
                "success": False,
                "error": str(e)
            })
    
    # ========== å¤šè§’è‰²å”ä½œè™•ç†å™¨ ==========
    
    async def handle_multi_role_add_role(self, payload: Dict[str, Any]):
        """æ·»åŠ è§’è‰²"""
        try:
            manager = get_multi_role_manager()
            result = await manager.add_role(payload)
            
            self.send_event("multi-role-role-added", result)
            
            if result.get("success"):
                self.send_log(f"ğŸ­ æ·»åŠ è§’è‰²: {payload.get('name', '')}", "success")
        except Exception as e:
            self.send_log(f"âŒ æ·»åŠ è§’è‰²å¤±æ•—: {e}", "error")
            self.send_event("multi-role-role-added", {"success": False, "error": str(e)})
    
    async def handle_multi_role_update_role(self, payload: Dict[str, Any]):
        """æ›´æ–°è§’è‰²"""
        try:
            manager = get_multi_role_manager()
            role_id = payload.get("id")
            result = await manager.update_role(role_id, payload)
            
            self.send_event("multi-role-role-updated", result)
            
            if result.get("success"):
                self.send_log(f"ğŸ­ æ›´æ–°è§’è‰²: {role_id}", "success")
        except Exception as e:
            self.send_log(f"âŒ æ›´æ–°è§’è‰²å¤±æ•—: {e}", "error")
            self.send_event("multi-role-role-updated", {"success": False, "error": str(e)})
    
    async def handle_multi_role_delete_role(self, payload: Dict[str, Any]):
        """åˆªé™¤è§’è‰²"""
        try:
            manager = get_multi_role_manager()
            role_id = payload.get("id")
            result = await manager.delete_role(role_id)
            
            self.send_event("multi-role-role-deleted", result)
            
            if result.get("success"):
                self.send_log(f"ğŸ—‘ï¸ åˆªé™¤è§’è‰²: {role_id}", "success")
        except Exception as e:
            self.send_log(f"âŒ åˆªé™¤è§’è‰²å¤±æ•—: {e}", "error")
            self.send_event("multi-role-role-deleted", {"success": False, "error": str(e)})
    
    async def handle_multi_role_get_roles(self):
        """ç²å–æ‰€æœ‰è§’è‰²"""
        try:
            manager = get_multi_role_manager()
            roles = await manager.get_all_roles()
            
            self.send_event("multi-role-roles", {"success": True, "roles": roles})
        except Exception as e:
            self.send_log(f"âŒ ç²å–è§’è‰²å¤±æ•—: {e}", "error")
            self.send_event("multi-role-roles", {"success": False, "error": str(e)})
    
    async def handle_multi_role_add_script(self, payload: Dict[str, Any]):
        """æ·»åŠ åŠ‡æœ¬"""
        try:
            manager = get_multi_role_manager()
            result = await manager.add_script(payload)
            
            self.send_event("multi-role-script-added", result)
            
            if result.get("success"):
                self.send_log(f"ğŸ“œ æ·»åŠ åŠ‡æœ¬: {payload.get('name', '')}", "success")
        except Exception as e:
            self.send_log(f"âŒ æ·»åŠ åŠ‡æœ¬å¤±æ•—: {e}", "error")
            self.send_event("multi-role-script-added", {"success": False, "error": str(e)})
    
    async def handle_multi_role_update_script(self, payload: Dict[str, Any]):
        """æ›´æ–°åŠ‡æœ¬"""
        try:
            manager = get_multi_role_manager()
            script_id = payload.get("id")
            result = await manager.update_script(script_id, payload)
            
            self.send_event("multi-role-script-updated", result)
            
            if result.get("success"):
                self.send_log(f"ğŸ“œ æ›´æ–°åŠ‡æœ¬: {script_id}", "success")
        except Exception as e:
            self.send_log(f"âŒ æ›´æ–°åŠ‡æœ¬å¤±æ•—: {e}", "error")
            self.send_event("multi-role-script-updated", {"success": False, "error": str(e)})
    
    async def handle_multi_role_delete_script(self, payload: Dict[str, Any]):
        """åˆªé™¤åŠ‡æœ¬"""
        try:
            manager = get_multi_role_manager()
            script_id = payload.get("id")
            result = await manager.delete_script(script_id)
            
            self.send_event("multi-role-script-deleted", result)
            
            if result.get("success"):
                self.send_log(f"ğŸ—‘ï¸ åˆªé™¤åŠ‡æœ¬: {script_id}", "success")
        except Exception as e:
            self.send_log(f"âŒ åˆªé™¤åŠ‡æœ¬å¤±æ•—: {e}", "error")
            self.send_event("multi-role-script-deleted", {"success": False, "error": str(e)})
    
    async def handle_multi_role_get_scripts(self):
        """ç²å–æ‰€æœ‰åŠ‡æœ¬"""
        try:
            manager = get_multi_role_manager()
            scripts = await manager.get_all_scripts()
            
            self.send_event("multi-role-scripts", {"success": True, "scripts": scripts})
        except Exception as e:
            self.send_log(f"âŒ ç²å–åŠ‡æœ¬å¤±æ•—: {e}", "error")
            self.send_event("multi-role-scripts", {"success": False, "error": str(e)})
    
    async def handle_multi_role_create_group(self, payload: Dict[str, Any]):
        """å‰µå»ºå”ä½œç¾¤çµ„"""
        try:
            manager = get_multi_role_manager()
            result = await manager.create_group(payload)
            
            self.send_event("multi-role-group-created", result)
            
            if result.get("success"):
                self.send_log(f"ğŸ‘¥ å‰µå»ºå”ä½œç¾¤çµ„: {payload.get('groupTitle', '')}", "success")
        except Exception as e:
            self.send_log(f"âŒ å‰µå»ºç¾¤çµ„å¤±æ•—: {e}", "error")
            self.send_event("multi-role-group-created", {"success": False, "error": str(e)})
    
    async def handle_multi_role_update_group(self, payload: Dict[str, Any]):
        """æ›´æ–°ç¾¤çµ„"""
        try:
            manager = get_multi_role_manager()
            group_id = payload.get("id")
            result = await manager.update_group(group_id, payload)
            
            self.send_event("multi-role-group-updated", result)
        except Exception as e:
            self.send_log(f"âŒ æ›´æ–°ç¾¤çµ„å¤±æ•—: {e}", "error")
            self.send_event("multi-role-group-updated", {"success": False, "error": str(e)})
    
    async def handle_multi_role_get_groups(self, payload: Dict[str, Any]):
        """ç²å–ç¾¤çµ„åˆ—è¡¨"""
        try:
            manager = get_multi_role_manager()
            status = payload.get("status") if payload else None
            groups = await manager.get_all_groups(status)
            
            self.send_event("multi-role-groups", {"success": True, "groups": groups})
        except Exception as e:
            self.send_log(f"âŒ ç²å–ç¾¤çµ„å¤±æ•—: {e}", "error")
            self.send_event("multi-role-groups", {"success": False, "error": str(e)})
    
    async def handle_multi_role_get_stats(self):
        """ç²å–çµ±è¨ˆæ•¸æ“š"""
        try:
            manager = get_multi_role_manager()
            stats = await manager.get_stats()
            
            self.send_event("multi-role-stats", {"success": True, "stats": stats})
        except Exception as e:
            self.send_log(f"âŒ ç²å–çµ±è¨ˆå¤±æ•—: {e}", "error")
            self.send_event("multi-role-stats", {"success": False, "error": str(e)})
    
    async def handle_multi_role_export_data(self):
        """å°å‡ºæ•¸æ“š"""
        try:
            manager = get_multi_role_manager()
            data = await manager.export_data()
            
            self.send_event("multi-role-data-exported", {"success": True, "data": data})
            self.send_log("ğŸ“¦ å¤šè§’è‰²æ•¸æ“šå°å‡ºå®Œæˆ", "success")
        except Exception as e:
            self.send_log(f"âŒ å°å‡ºæ•¸æ“šå¤±æ•—: {e}", "error")
            self.send_event("multi-role-data-exported", {"success": False, "error": str(e)})
    
    async def handle_multi_role_import_data(self, payload: Dict[str, Any]):
        """å°å…¥æ•¸æ“š"""
        try:
            manager = get_multi_role_manager()
            result = await manager.import_data(payload.get("data", {}))
            
            self.send_event("multi-role-data-imported", result)
            
            if result.get("success"):
                self.send_log(f"ğŸ“¥ å¤šè§’è‰²æ•¸æ“šå°å…¥å®Œæˆ", "success")
        except Exception as e:
            self.send_log(f"âŒ å°å…¥æ•¸æ“šå¤±æ•—: {e}", "error")
            self.send_event("multi-role-data-imported", {"success": False, "error": str(e)})
            
        except Exception as e:
            self.send_log(f"âŒ ç²å–è¨è«–çµ„æ¶ˆæ¯å¤±æ•—: {e}", "error")
            self.send_event("discussion-messages", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_reply_to_discussion(self, payload: Dict[str, Any]):
        """å›å¾©è¨è«–çµ„æ¶ˆæ¯"""
        try:
            discussion_id = payload.get('discussionId', '')
            message_id = payload.get('messageId')
            reply_text = payload.get('replyText', '')
            phone = payload.get('phone')
            
            if not discussion_id or not message_id or not reply_text:
                raise ValueError("è¨è«–çµ„ IDã€æ¶ˆæ¯ ID å’Œå›å¾©å…§å®¹ä¸èƒ½ç‚ºç©º")
            
            discussion_watcher.set_clients(self.telegram_manager.clients)
            result = await discussion_watcher.reply_to_message(
                discussion_id, message_id, reply_text, phone
            )
            
            if result['success']:
                self.send_log(f"âœ… å·²å›å¾©æ¶ˆæ¯ {message_id}", "success")
            
            self.send_event("discussion-reply-result", result)
            
        except Exception as e:
            self.send_log(f"âŒ å›å¾©å¤±æ•—: {e}", "error")
            self.send_event("discussion-reply-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_get_discussion_stats(self):
        """ç²å–è¨è«–çµ„ç›£æ§çµ±è¨ˆ"""
        try:
            stats = await discussion_watcher.get_statistics()
            
            self.send_event("discussion-stats", {
                "success": True,
                **stats
            })
            
        except Exception as e:
            self.send_log(f"âŒ ç²å–çµ±è¨ˆå¤±æ•—: {e}", "error")
            self.send_event("discussion-stats", {
                "success": False,
                "error": str(e)
            })

    # ==================== AI Team Execution Handlers ====================
    
    # AI åœ˜éšŠåŸ·è¡Œå™¨å¯¦ä¾‹
    _ai_team_executor = None
    
    def get_ai_team_executor(self):
        """ç²å–æˆ–å‰µå»º AI åœ˜éšŠåŸ·è¡Œå™¨"""
        if self._ai_team_executor is None:
            from ai_team_executor import AITeamExecutor
            self._ai_team_executor = AITeamExecutor(
                message_queue=self.message_queue,
                database=db,
                send_event=self.send_event,
                send_log=self.send_log
            )
        return self._ai_team_executor
    
    async def handle_ai_team_start_execution(self, payload: Dict[str, Any]):
        """å•Ÿå‹• AI åœ˜éšŠåŸ·è¡Œä»»å‹™"""
        import sys
        
        try:
            executor = self.get_ai_team_executor()
            success = await executor.start_execution(payload)
            
            if success:
                goal = payload.get('goal', '')
                self.send_log(f"ğŸ¤– AI åœ˜éšŠé–‹å§‹åŸ·è¡Œ: {goal[:50]}...", "info")
            
        except Exception as e:
            print(f"[AITeam] å•Ÿå‹•å¤±æ•—: {e}", file=sys.stderr)
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_log(f"âŒ AI åœ˜éšŠå•Ÿå‹•å¤±æ•—: {e}", "error")
    
    async def handle_ai_team_pause_execution(self, payload: Dict[str, Any]):
        """æš«åœ AI åœ˜éšŠåŸ·è¡Œ"""
        executor = self.get_ai_team_executor()
        execution_id = payload.get('executionId')
        executor.pause_execution(execution_id)
    
    async def handle_ai_team_resume_execution(self, payload: Dict[str, Any]):
        """æ¢å¾© AI åœ˜éšŠåŸ·è¡Œ"""
        executor = self.get_ai_team_executor()
        execution_id = payload.get('executionId')
        executor.resume_execution(execution_id)
    
    async def handle_ai_team_stop_execution(self, payload: Dict[str, Any]):
        """åœæ­¢ AI åœ˜éšŠåŸ·è¡Œ"""
        executor = self.get_ai_team_executor()
        execution_id = payload.get('executionId')
        executor.stop_execution(execution_id)
    
    async def handle_ai_team_add_targets(self, payload: Dict[str, Any]):
        """æ·»åŠ ç›®æ¨™ç”¨æˆ¶åˆ° AI åœ˜éšŠéšŠåˆ—"""
        import sys
        targets = payload.get('targets', [])
        print(f"[AITeam] æ·»åŠ  {len(targets)} å€‹ç›®æ¨™ç”¨æˆ¶", file=sys.stderr)
        self.send_log(f"ğŸ¯ å·²æ·»åŠ  {len(targets)} å€‹ç›®æ¨™ç”¨æˆ¶åˆ° AI éŠ·å”®éšŠåˆ—", "info")
    
    # ==================== Batch Send Handlers ====================
    
    _batch_send_active = False
    _batch_send_cancelled = False
    
    async def handle_batch_send_start(self, payload: Dict[str, Any]):
        """é–‹å§‹æ‰¹é‡ç™¼é€ - æ”¯æŒå¤šæ¨¡æ¿å’Œç™¼é€ç­–ç•¥"""
        import sys
        import asyncio
        import random
        
        try:
            targets = payload.get('targets', [])
            message_template = payload.get('message', '')
            messages = payload.get('messages', [])  # å¤šæ¨¡æ¿åˆ—è¡¨
            send_strategy = payload.get('sendStrategy', 'random')  # random/rotate/sequential
            attachments = payload.get('attachments', [])
            config = payload.get('config', {})
            
            min_interval = config.get('minInterval', 30)
            max_interval = config.get('maxInterval', 60)
            account_rotation = config.get('accountRotation', True)
            
            # åˆ¤æ–·æ˜¯å¦å¤šæ¨¡æ¿æ¨¡å¼
            is_multi_template = len(messages) > 1
            if is_multi_template:
                print(f"[BatchSend] å¤šæ¨¡æ¿æ¨¡å¼: {len(messages)} å€‹æ¨¡æ¿, ç­–ç•¥: {send_strategy}", file=sys.stderr)
                self.send_log(f"ğŸ“¨ é–‹å§‹æ‰¹é‡ç™¼é€: {len(targets)} å€‹ç›®æ¨™, {len(messages)} å€‹æ¨¡æ¿ ({send_strategy})", "info")
            else:
                print(f"[BatchSend] é–‹å§‹æ‰¹é‡ç™¼é€: {len(targets)} å€‹ç›®æ¨™", file=sys.stderr)
                self.send_log(f"ğŸ“¨ é–‹å§‹æ‰¹é‡ç™¼é€: {len(targets)} å€‹ç›®æ¨™", "info")
            
            self._batch_send_active = True
            self._batch_send_cancelled = False
            
            # ç²å–å¯ç”¨å¸³è™Ÿï¼ˆæª¢æŸ¥ Online ç‹€æ…‹ï¼‰
            accounts = await db.get_all_accounts()
            available_accounts = [a for a in accounts if a.get('status') in ('Online', 'active')]
            
            # é¡å¤–æª¢æŸ¥ï¼šå¾ TelegramManager ç²å–å¯¦éš›é€£æ¥çš„å®¢æˆ¶ç«¯
            if not available_accounts:
                # å˜—è©¦å¾ TelegramManager ç²å–å·²é€£æ¥çš„å¸³è™Ÿ
                connected_phones = list(self.telegram_manager.clients.keys()) if hasattr(self.telegram_manager, 'clients') else []
                if connected_phones:
                    available_accounts = [a for a in accounts if a.get('phone') in connected_phones]
                    print(f"[BatchSend] é€šé TelegramManager æ‰¾åˆ° {len(available_accounts)} å€‹å·²é€£æ¥å¸³è™Ÿ", file=sys.stderr)
            
            print(f"[BatchSend] å¯ç”¨å¸³è™Ÿ: {len(available_accounts)} å€‹", file=sys.stderr)
            for acc in available_accounts:
                print(f"[BatchSend]   - {acc.get('phone')} ({acc.get('status')})", file=sys.stderr)
            
            if not available_accounts:
                error_msg = "æ²’æœ‰å¯ç”¨çš„ç™¼é€å¸³è™Ÿï¼Œè«‹å…ˆç™»å…¥å¸³è™Ÿ"
                self.send_log(f"âš ï¸ {error_msg}", "warning")
                self.send_event("batch-send:complete", {
                    "success": 0, 
                    "failed": len(targets),
                    "error": error_msg,
                    "failureReasons": {"no_account": len(targets)}
                })
                return
            
            success_count = 0
            failed_count = 0
            failure_reasons = {}  # è¨˜éŒ„å¤±æ•—åŸå› çµ±è¨ˆ
            failed_targets = []   # è¨˜éŒ„å¤±æ•—çš„ç›®æ¨™ï¼ˆç”¨æ–¼é‡è©¦ï¼‰
            
            for idx, target in enumerate(targets):
                if self._batch_send_cancelled:
                    print(f"[BatchSend] ç”¨æˆ¶å–æ¶ˆ", file=sys.stderr)
                    # è¨˜éŒ„å‰©é¤˜æœªç™¼é€çš„ç‚ºå–æ¶ˆ
                    remaining = len(targets) - idx
                    failure_reasons['cancelled'] = failure_reasons.get('cancelled', 0) + remaining
                    break
                
                try:
                    # é¸æ“‡å¸³è™Ÿ
                    if account_rotation:
                        account = available_accounts[idx % len(available_accounts)]
                    else:
                        account = available_accounts[0]
                    
                    phone = account.get('phone')
                    user_id = target.get('telegramId')
                    username = target.get('username', '')
                    first_name = target.get('firstName', target.get('first_name', ''))
                    last_name = target.get('lastName', target.get('last_name', ''))
                    display_name = target.get('displayName', target.get('name', first_name or username or 'æœ‹å‹'))
                    full_name = f"{first_name} {last_name}".strip() or display_name
                    
                    # å¾ target ç²å–ä¾†æºä¿¡æ¯ï¼ˆç”¨æ–¼ {groupName}, {keyword}, {source} è®Šé‡ï¼‰
                    group_name = target.get('groupName', target.get('sourceGroup', target.get('source', '')))
                    keyword = target.get('keyword', target.get('triggeredKeyword', target.get('matchedKeyword', '')))
                    source = target.get('source', target.get('sourceType', ''))
                    
                    # é©—è­‰ç›®æ¨™ç”¨æˆ¶ ID
                    if not user_id:
                        raise ValueError("ç›®æ¨™ç”¨æˆ¶ ID ç‚ºç©º")
                    
                    # æ™‚é–“ç›¸é—œè®Šé‡
                    from datetime import datetime
                    now = datetime.now()
                    hour = now.hour
                    if 5 <= hour < 12:
                        greeting = 'æ—©ä¸Šå¥½'
                    elif 12 <= hour < 14:
                        greeting = 'ä¸­åˆå¥½'
                    elif 14 <= hour < 18:
                        greeting = 'ä¸‹åˆå¥½'
                    elif 18 <= hour < 22:
                        greeting = 'æ™šä¸Šå¥½'
                    else:
                        greeting = 'å¤œæ·±äº†'
                    
                    days = ['æ˜ŸæœŸä¸€', 'æ˜ŸæœŸäºŒ', 'æ˜ŸæœŸä¸‰', 'æ˜ŸæœŸå››', 'æ˜ŸæœŸäº”', 'æ˜ŸæœŸå…­', 'æ˜ŸæœŸæ—¥']
                    date_str = f"{now.month}æœˆ{now.day}æ—¥"
                    time_str = now.strftime('%H:%M')
                    day_str = days[now.weekday()]  # weekday() è¿”å› 0-6ï¼ˆé€±ä¸€åˆ°é€±æ—¥ï¼‰
                    
                    # é¸æ“‡æ¶ˆæ¯æ¨¡æ¿ï¼ˆæ”¯æŒå¤šæ¨¡æ¿æ¨¡å¼ï¼‰
                    if is_multi_template and messages:
                        if send_strategy == 'random':
                            # éš¨æ©Ÿé¸æ“‡ä¸€å€‹æ¨¡æ¿
                            selected_template = random.choice(messages)
                        elif send_strategy == 'rotate':
                            # è¼ªè½‰é¸æ“‡
                            selected_template = messages[idx % len(messages)]
                        else:  # sequential
                            # é †åºé¸æ“‡
                            selected_template = messages[idx % len(messages)]
                        print(f"[BatchSend] å¤šæ¨¡æ¿æ¨¡å¼: ç”¨æˆ¶ {idx+1} ä½¿ç”¨æ¨¡æ¿ #{messages.index(selected_template)+1}", file=sys.stderr)
                    else:
                        selected_template = message_template
                    
                    # æ›¿æ›è®Šé‡ - æ”¯æŒé§å³°å¼å’Œä¸‹åŠƒç·šå…©ç¨®æ ¼å¼
                    message = selected_template
                    
                    # åŸºæœ¬ç”¨æˆ¶ä¿¡æ¯è®Šé‡ï¼ˆæ”¯æŒå…©ç¨®æ ¼å¼ï¼‰
                    message = message.replace('{firstName}', first_name)
                    message = message.replace('{first_name}', first_name)
                    message = message.replace('{lastName}', last_name)
                    message = message.replace('{last_name}', last_name)
                    message = message.replace('{username}', username)
                    message = message.replace('{displayName}', display_name)
                    message = message.replace('{name}', display_name)
                    message = message.replace('{fullName}', full_name)
                    message = message.replace('{full_name}', full_name)
                    
                    # ä¾†æºä¿¡æ¯è®Šé‡ï¼ˆæ–°å¢ï¼‰
                    message = message.replace('{groupName}', group_name)
                    message = message.replace('{group_name}', group_name)
                    message = message.replace('{keyword}', keyword)
                    message = message.replace('{source}', source)
                    
                    # æ™‚é–“ç›¸é—œè®Šé‡
                    message = message.replace('{greeting}', greeting)
                    message = message.replace('{date}', date_str)
                    message = message.replace('{time}', time_str)
                    message = message.replace('{day}', day_str)
                    
                    print(f"[BatchSend] è®Šé‡æ›¿æ›å®Œæˆ: {selected_template[:50]}... -> {message[:50]}...", file=sys.stderr)
                    
                    print(f"[BatchSend] ç™¼é€ {idx + 1}/{len(targets)}: {phone} -> {user_id}", file=sys.stderr)
                    
                    # ç™¼é€æ¶ˆæ¯
                    await self.message_queue.add_message(
                        phone=phone,
                        user_id=user_id,
                        text=message,
                        attachment=attachments[0] if attachments else None,
                        target_username=username
                    )
                    
                    success_count += 1
                    
                except Exception as e:
                    error_str = str(e).lower()
                    print(f"[BatchSend] ç™¼é€å¤±æ•— ({user_id}): {e}", file=sys.stderr)
                    failed_count += 1
                    
                    # åˆ†é¡å¤±æ•—åŸå› 
                    if 'privacy' in error_str or 'private' in error_str:
                        reason = 'privacy_restricted'
                    elif 'flood' in error_str:
                        reason = 'flood_wait'
                    elif 'peer' in error_str or 'not found' in error_str:
                        reason = 'user_not_found'
                    elif 'blocked' in error_str:
                        reason = 'user_blocked'
                    elif 'id' in error_str and 'ç‚ºç©º' in str(e):
                        reason = 'invalid_id'
                    else:
                        reason = 'other'
                    
                    failure_reasons[reason] = failure_reasons.get(reason, 0) + 1
                    failed_targets.append({
                        'target': target,
                        'reason': reason,
                        'error': str(e)
                    })
                
                # æ›´æ–°é€²åº¦ï¼ˆå¸¶è©³ç´°ä¿¡æ¯ï¼‰
                self.send_event("batch-send:progress", {
                    "sent": idx + 1,
                    "success": success_count,
                    "failed": failed_count,
                    "total": len(targets),
                    "currentTarget": display_name or username or user_id,
                    "failureReasons": failure_reasons
                })
                
                # é–“éš”
                if idx < len(targets) - 1 and not self._batch_send_cancelled:
                    interval = random.randint(min_interval, max_interval)
                    await asyncio.sleep(interval)
            
            # å®Œæˆ - ç”Ÿæˆè©³ç´°å ±å‘Š
            self._batch_send_active = False
            
            # æ§‹å»ºå¤±æ•—åŸå› æ‘˜è¦
            reason_summary = []
            reason_labels = {
                'privacy_restricted': 'éš±ç§é™åˆ¶',
                'flood_wait': 'API é™åˆ¶',
                'user_not_found': 'ç”¨æˆ¶ä¸å­˜åœ¨',
                'user_blocked': 'è¢«å°é–',
                'invalid_id': 'ç„¡æ•ˆ ID',
                'cancelled': 'å·²å–æ¶ˆ',
                'other': 'å…¶ä»–éŒ¯èª¤'
            }
            for reason, count in failure_reasons.items():
                label = reason_labels.get(reason, reason)
                reason_summary.append(f"{label}: {count}")
            
            self.send_event("batch-send:complete", {
                "success": success_count,
                "failed": failed_count,
                "failureReasons": failure_reasons,
                "failureSummary": ", ".join(reason_summary) if reason_summary else None,
                "failedTargets": failed_targets[:10]  # åªè¿”å›å‰10å€‹å¤±æ•—ç›®æ¨™
            })
            
            if failed_count > 0:
                self.send_log(f"âš ï¸ æ‰¹é‡ç™¼é€å®Œæˆ: æˆåŠŸ {success_count}, å¤±æ•— {failed_count} ({', '.join(reason_summary)})", "warning")
            else:
                self.send_log(f"âœ… æ‰¹é‡ç™¼é€å®Œæˆ: æˆåŠŸ {success_count}", "success")
            
        except Exception as e:
            print(f"[BatchSend] éŒ¯èª¤: {e}", file=sys.stderr)
            import traceback
            traceback.print_exc(file=sys.stderr)
            self._batch_send_active = False
            self.send_event("batch-send:complete", {"success": 0, "failed": len(targets)})
            self.send_log(f"âŒ æ‰¹é‡ç™¼é€éŒ¯èª¤: {e}", "error")
    
    async def handle_batch_send_cancel(self, payload: Dict[str, Any]):
        """å–æ¶ˆæ‰¹é‡ç™¼é€"""
        self._batch_send_cancelled = True
        self.send_log("â¹ï¸ æ‰¹é‡ç™¼é€å·²å–æ¶ˆ", "info")
    
    # ==================== Batch Invite Handlers ====================
    
    _batch_invite_active = False
    _batch_invite_cancelled = False
    
    async def handle_batch_invite_start(self, payload: Dict[str, Any]):
        """é–‹å§‹æ‰¹é‡æ‹‰ç¾¤"""
        import sys
        import asyncio
        import random
        import pyrogram
        from pyrogram import raw
        
        try:
            targets = payload.get('targets', [])
            group_id = payload.get('groupId', '')
            group_url = payload.get('groupUrl', '')
            config = payload.get('config', {})
            invite_id = payload.get('inviteId', '')  # ğŸ”§ Phase 2: ç²å–é‚€è«‹ ID
            
            batch_size = config.get('batchSize', 10)
            min_interval = config.get('minInterval', 60)
            max_interval = config.get('maxInterval', 120)
            send_welcome_message = config.get('sendWelcomeMessage', False)
            welcome_message = config.get('welcomeMessage', '')
            
            print(f"[BatchInvite] é–‹å§‹æ‰¹é‡æ‹‰ç¾¤: {len(targets)} å€‹ç›®æ¨™ -> {group_url}", file=sys.stderr)
            print(f"[BatchInvite] æ­¡è¿æ¶ˆæ¯: {send_welcome_message}, å…§å®¹: {welcome_message[:50] if welcome_message else 'N/A'}", file=sys.stderr)
            self.send_log(f"ğŸ‘¥ é–‹å§‹æ‰¹é‡æ‹‰ç¾¤: {len(targets)} å€‹ç”¨æˆ¶ -> {group_url}", "info")
            
            self._batch_invite_active = True
            self._batch_invite_cancelled = False
            
            # ç²å–ç®¡ç†å“¡å¸³è™Ÿ
            accounts = await db.get_all_accounts()
            admin_accounts = [a for a in accounts if a.get('status') == 'Online' or a.get('status') == 'active']
            
            if not admin_accounts:
                self.send_log("âš ï¸ æ²’æœ‰å¯ç”¨çš„å¸³è™Ÿ", "warning")
                self.send_event("batch-invite:complete", {
                    "inviteId": invite_id,  # ğŸ”§ Phase 2: è¿”å›é‚€è«‹ ID
                    "success": 0, 
                    "failed": len(targets), 
                    "skipped": 0
                })
                return
            
            success_count = 0
            failed_count = 0
            skipped_count = 0
            
            for idx, target in enumerate(targets):
                if self._batch_invite_cancelled:
                    print(f"[BatchInvite] ç”¨æˆ¶å–æ¶ˆ", file=sys.stderr)
                    break
                
                try:
                    account = admin_accounts[0]
                    phone = account.get('phone')
                    user_id = target.get('telegramId')
                    username = target.get('username', '')
                    
                    # ğŸ”§ P0: é©—è­‰ username æ ¼å¼ï¼ˆå¿…é ˆä»¥å­—æ¯é–‹é ­ï¼Œé•·åº¦ 5-32ï¼‰
                    import re
                    def is_valid_username(uname: str) -> bool:
                        if not uname or len(uname) < 5 or len(uname) > 32:
                            return False
                        # å¿…é ˆä»¥å­—æ¯é–‹é ­ï¼Œåªèƒ½åŒ…å«å­—æ¯ã€æ•¸å­—ã€ä¸‹åŠƒç·š
                        return bool(re.match(r'^[a-zA-Z][a-zA-Z0-9_]{4,31}$', uname))
                    
                    valid_username = is_valid_username(username)
                    print(f"[BatchInvite] é‚€è«‹ {idx + 1}/{len(targets)}: user_id={user_id}, username={username} (valid={valid_username})", file=sys.stderr)
                    
                    # ç²å– Telegram å®¢æˆ¶ç«¯
                    client = self.telegram_manager.get_client(phone)
                    if not client or not client.is_connected:
                        self.send_log(f"âš ï¸ å¸³è™Ÿ {phone} æœªé€£ç·š", "warning")
                        failed_count += 1
                        continue
                    
                    # ğŸ”§ P0: å˜—è©¦ç›´æ¥é‚€è«‹ï¼Œå¤±æ•—å‰‡ç™¼é€é‚€è«‹éˆæ¥
                    invite_success = False
                    link_sent = False
                    first_name = target.get('firstName', '')
                    display_name = target.get('displayName', first_name or username or 'æœ‹å‹')
                    
                    try:
                        # æ–¹æ³•1: å˜—è©¦ç›´æ¥é‚€è«‹ï¼ˆéœ€è¦ access_hashï¼‰
                        peer_to_invite = None
                        
                        # å˜—è©¦é€šé username è§£æï¼ˆæ›´å¯é ï¼‰
                        if valid_username:
                            try:
                                peer_to_invite = await client.resolve_peer(f"@{username}")
                                print(f"[BatchInvite] é€šé @{username} è§£ææˆåŠŸ", file=sys.stderr)
                            except Exception as e:
                                print(f"[BatchInvite] ç„¡æ³•è§£æ @{username}: {e}", file=sys.stderr)
                        
                        # å˜—è©¦é€šé user_id è§£æ
                        if peer_to_invite is None and user_id:
                            try:
                                peer_to_invite = await client.resolve_peer(int(user_id))
                                print(f"[BatchInvite] é€šé user_id={user_id} è§£ææˆåŠŸ", file=sys.stderr)
                            except Exception as e:
                                print(f"[BatchInvite] ç„¡æ³•è§£æ user_id={user_id}: {e}", file=sys.stderr)
                        
                        if peer_to_invite:
                            await client.invoke(
                                pyrogram.raw.functions.channels.InviteToChannel(
                                    channel=await client.resolve_peer(group_url or group_id),
                                    users=[peer_to_invite]
                                )
                            )
                            invite_success = True
                            success_count += 1
                            print(f"[BatchInvite] âœ… ç›´æ¥é‚€è«‹æˆåŠŸ: {display_name}", file=sys.stderr)
                            self.send_log(f"âœ… å·²é‚€è«‹ {display_name} åŠ å…¥ç¾¤çµ„", "success")
                        
                    except Exception as invite_err:
                        err_str = str(invite_err).lower()
                        if 'already' in err_str or 'participant' in err_str:
                            skipped_count += 1
                            print(f"[BatchInvite] {display_name} å·²åœ¨ç¾¤å…§", file=sys.stderr)
                            self.send_log(f"â­ï¸ {display_name} å·²åœ¨ç¾¤å…§", "info")
                            continue
                        elif 'privacy' in err_str or 'restrict' in err_str:
                            print(f"[BatchInvite] {display_name} éš±ç§é™åˆ¶ï¼Œå˜—è©¦ç™¼é€é‚€è«‹éˆæ¥", file=sys.stderr)
                        else:
                            print(f"[BatchInvite] ç›´æ¥é‚€è«‹å¤±æ•—: {invite_err}", file=sys.stderr)
                    
                    # ğŸ”§ P0: æ–¹æ³•2: å¦‚æœç›´æ¥é‚€è«‹å¤±æ•—ï¼Œç™¼é€é‚€è«‹éˆæ¥
                    if not invite_success and group_url:
                        try:
                            # æ§‹å»ºé‚€è«‹æ¶ˆæ¯
                            invite_msg = f"ğŸ‘‹ {display_name}ï¼Œæ‚¨å¥½ï¼\n\n"
                            invite_msg += f"èª æ‘¯é‚€è«‹æ‚¨åŠ å…¥æˆ‘å€‘çš„ç¾¤çµ„ï¼Œé»æ“Šä¸‹æ–¹éˆæ¥å³å¯åŠ å…¥ï¼š\n\n"
                            invite_msg += f"ğŸ”— {group_url}\n\n"
                            invite_msg += f"æœŸå¾…æ‚¨çš„åŠ å…¥ï¼"
                            
                            # å˜—è©¦ç™¼é€ç§ä¿¡
                            if valid_username:
                                await client.send_message(f"@{username}", invite_msg)
                                link_sent = True
                                print(f"[BatchInvite] ğŸ“¨ å·²ç™¼é€é‚€è«‹éˆæ¥çµ¦ @{username}", file=sys.stderr)
                            elif user_id:
                                await client.send_message(int(user_id), invite_msg)
                                link_sent = True
                                print(f"[BatchInvite] ğŸ“¨ å·²ç™¼é€é‚€è«‹éˆæ¥çµ¦ user_id={user_id}", file=sys.stderr)
                            
                            if link_sent:
                                success_count += 1
                                self.send_log(f"ğŸ“¨ å·²ç™¼é€é‚€è«‹éˆæ¥çµ¦ {display_name}", "success")
                                
                        except Exception as msg_err:
                            err_msg = str(msg_err).lower()
                            if 'privacy' in err_msg or 'not mutual' in err_msg or 'peer_id_invalid' in err_msg:
                                print(f"[BatchInvite] âš ï¸ {display_name} éš±ç§è¨­ç½®ä¸å…è¨±æ¥æ”¶æ¶ˆæ¯", file=sys.stderr)
                                self.send_log(f"âš ï¸ {display_name} éš±ç§è¨­ç½®é™åˆ¶ï¼Œç„¡æ³•ç™¼é€é‚€è«‹", "warning")
                                skipped_count += 1
                            else:
                                print(f"[BatchInvite] ç™¼é€é‚€è«‹éˆæ¥å¤±æ•—: {msg_err}", file=sys.stderr)
                                failed_count += 1
                    
                    # å¦‚æœå…©ç¨®æ–¹æ³•éƒ½å¤±æ•—
                    if not invite_success and not link_sent:
                        if 'skipped_count' not in dir() or skipped_count == 0:
                            failed_count += 1
                            self.send_log(f"âŒ ç„¡æ³•é‚€è«‹ {display_name}", "error")
                    
                    # ç™¼é€è‡ªå®šç¾©æ­¡è¿æ¶ˆæ¯ï¼ˆåªåœ¨ç›´æ¥é‚€è«‹æˆåŠŸæ™‚ï¼‰
                    if invite_success and send_welcome_message and welcome_message:
                        try:
                            msg = welcome_message
                            msg = msg.replace('{name}', display_name)
                            msg = msg.replace('{first_name}', first_name)
                            msg = msg.replace('{username}', username)
                            
                            if valid_username:
                                await client.send_message(f"@{username}", msg)
                            elif user_id:
                                await client.send_message(int(user_id), msg)
                                
                            print(f"[BatchInvite] å·²ç™¼é€æ­¡è¿æ¶ˆæ¯çµ¦ {display_name}", file=sys.stderr)
                        except Exception as msg_err:
                            print(f"[BatchInvite] ç™¼é€æ­¡è¿æ¶ˆæ¯å¤±æ•—: {msg_err}", file=sys.stderr)
                    
                except Exception as e:
                    print(f"[BatchInvite] éŒ¯èª¤: {e}", file=sys.stderr)
                    failed_count += 1
                
                # æ›´æ–°é€²åº¦
                self.send_event("batch-invite:progress", {
                    "invited": idx + 1,
                    "success": success_count,
                    "failed": failed_count,
                    "skipped": skipped_count,
                    "total": len(targets)
                })
                
                # æ‰¹æ¬¡é–“éš”
                if idx < len(targets) - 1 and (idx + 1) % batch_size == 0:
                    interval = random.randint(min_interval, max_interval)
                    print(f"[BatchInvite] æ‰¹æ¬¡å®Œæˆï¼Œç­‰å¾… {interval} ç§’", file=sys.stderr)
                    await asyncio.sleep(interval)
                elif idx < len(targets) - 1:
                    # å–®å€‹é–“éš”
                    await asyncio.sleep(random.randint(3, 8))
            
            # å®Œæˆ
            self._batch_invite_active = False
            self.send_event("batch-invite:complete", {
                "inviteId": invite_id,  # ğŸ”§ Phase 2: è¿”å›é‚€è«‹ ID
                "success": success_count,
                "failed": failed_count,
                "skipped": skipped_count
            })
            self.send_log(f"âœ… æ‰¹é‡æ‹‰ç¾¤å®Œæˆ: æˆåŠŸ {success_count}, è·³é {skipped_count}, å¤±æ•— {failed_count}", "success")
            
        except Exception as e:
            print(f"[BatchInvite] éŒ¯èª¤: {e}", file=sys.stderr)
            import traceback
            traceback.print_exc(file=sys.stderr)
            self._batch_invite_active = False
            self.send_event("batch-invite:complete", {
                "inviteId": invite_id if 'invite_id' in locals() else '',  # ğŸ”§ Phase 2
                "success": 0, 
                "failed": len(targets) if 'targets' in locals() else 0, 
                "skipped": 0
            })
            self.send_log(f"âŒ æ‰¹é‡æ‹‰ç¾¤éŒ¯èª¤: {e}", "error")
    
    async def handle_batch_invite_cancel(self, payload: Dict[str, Any]):
        """å–æ¶ˆæ‰¹é‡æ‹‰ç¾¤"""
        self._batch_invite_cancelled = True
        self.send_log("â¹ï¸ æ‰¹é‡æ‹‰ç¾¤å·²å–æ¶ˆ", "info")
    
    async def handle_get_admin_groups(self, payload: Dict[str, Any]):
        """ç²å–ç”¨æˆ¶ä½œç‚ºç®¡ç†å“¡çš„ç¾¤çµ„åˆ—è¡¨"""
        import sys
        
        try:
            # ç²å–å·²ç™»éŒ„å¸³è™Ÿ
            accounts = await db.get_all_accounts()
            online_accounts = [a for a in accounts if a.get('status') == 'Online' or a.get('status') == 'active']
            
            if not online_accounts:
                self.send_event("get-admin-groups-result", {"groups": []})
                return
            
            groups = []
            
            for account in online_accounts[:1]:  # åªä½¿ç”¨ç¬¬ä¸€å€‹å¸³è™ŸæŸ¥è©¢
                phone = account.get('phone')
                client = self.telegram_manager.get_client(phone)
                
                if not client or not client.is_connected:
                    continue
                
                try:
                    # ç²å–ç”¨æˆ¶æ‰€åœ¨çš„æ‰€æœ‰å°è©±
                    dialogs = []
                    async for dialog in client.get_dialogs():
                        if dialog.chat.type in ['group', 'supergroup']:
                            # æª¢æŸ¥æ˜¯å¦ç‚ºç®¡ç†å“¡
                            is_admin = False
                            try:
                                me = await client.get_me()
                                member = await client.get_chat_member(dialog.chat.id, me.id)
                                is_admin = member.status in ['administrator', 'creator']
                            except:
                                pass
                            
                            groups.append({
                                "id": str(dialog.chat.id),
                                "name": dialog.chat.title or dialog.chat.first_name or 'æœªçŸ¥ç¾¤çµ„',
                                "url": dialog.chat.username or f"t.me/c/{str(dialog.chat.id)[4:]}",
                                "memberCount": dialog.chat.members_count or 0,
                                "isAdmin": is_admin,
                                "type": dialog.chat.type
                            })
                except Exception as e:
                    print(f"[GetAdminGroups] ç²å–å°è©±åˆ—è¡¨å¤±æ•—: {e}", file=sys.stderr)
            
            # æŒ‰ç®¡ç†å“¡å„ªå…ˆæ’åº
            groups.sort(key=lambda g: (not g['isAdmin'], g['name']))
            
            self.send_event("get-admin-groups-result", {"groups": groups})
            self.send_log(f"ğŸ“‹ ç²å–ç¾¤çµ„åˆ—è¡¨: {len(groups)} å€‹", "info")
            
        except Exception as e:
            print(f"[GetAdminGroups] éŒ¯èª¤: {e}", file=sys.stderr)
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("get-admin-groups-result", {"groups": [], "error": str(e)})
    
    # ==================== Unified Contacts Handlers ====================
    
    async def handle_unified_contacts_sync(self, payload: Dict[str, Any]):
        """åŒæ­¥æ‰€æœ‰ä¾†æºæ•¸æ“šåˆ°çµ±ä¸€è¯ç¹«äººè¡¨"""
        import sys
        import traceback
        from unified_contacts import get_unified_contacts_manager
        
        try:
            print(f"[Backend] ========== SYNC UNIFIED CONTACTS START ==========", file=sys.stderr)
            self.send_log("ğŸ”„ é–‹å§‹åŒæ­¥æ•¸æ“š...", "info")
            
            # ğŸ”§ FIX: ç¢ºä¿æ•¸æ“šåº«é€£æ¥
            await db.connect()
            print(f"[Backend] Database connected", file=sys.stderr)
            
            manager = get_unified_contacts_manager(db)
            print(f"[Backend] Manager initialized", file=sys.stderr)
            
            stats = await manager.sync_from_sources()
            print(f"[Backend] Sync completed: {stats}", file=sys.stderr)
            
            self.send_event("unified-contacts:sync-result", {
                "success": True,
                "stats": stats
            })
            self.send_log(f"âœ… åŒæ­¥å®Œæˆ: æ–°å¢ {stats['synced']} æ¢, æ›´æ–° {stats['updated']} æ¢", "success")
            print(f"[Backend] ========== SYNC UNIFIED CONTACTS END ==========", file=sys.stderr)
            
        except Exception as e:
            print(f"[Backend] Unified contacts sync error: {e}", file=sys.stderr)
            traceback.print_exc(file=sys.stderr)
            self.send_event("unified-contacts:sync-result", {
                "success": False,
                "error": str(e)
            })
            self.send_log(f"âŒ åŒæ­¥å¤±æ•—: {e}", "error")
    
    async def handle_unified_contacts_get(self, payload: Dict[str, Any]):
        """ç²å–çµ±ä¸€è¯ç¹«äººåˆ—è¡¨"""
        import sys
        from unified_contacts import get_unified_contacts_manager
        
        try:
            print(f"[Backend] Getting unified contacts with payload: {payload}", file=sys.stderr)
            manager = get_unified_contacts_manager(db)
            
            contacts, total = await manager.get_contacts(
                contact_type=payload.get('contactType'),
                source_type=payload.get('sourceType'),
                status=payload.get('status'),
                tags=payload.get('tags'),
                search=payload.get('search'),
                order_by=payload.get('orderBy', 'created_at DESC'),
                limit=payload.get('limit', 100),
                offset=payload.get('offset', 0)
            )
            
            print(f"[Backend] Found {len(contacts)} contacts (total: {total})", file=sys.stderr)
            
            self.send_event("unified-contacts:list", {
                "success": True,
                "contacts": contacts,
                "total": total,
                "limit": payload.get('limit', 100),
                "offset": payload.get('offset', 0)
            })
            
        except Exception as e:
            print(f"[Backend] Get unified contacts error: {e}", file=sys.stderr)
            self.send_event("unified-contacts:list", {
                "success": False,
                "error": str(e),
                "contacts": [],
                "total": 0
            })
    
    async def handle_unified_contacts_stats(self, payload: Dict[str, Any]):
        """ç²å–çµ±ä¸€è¯ç¹«äººçµ±è¨ˆ"""
        import sys
        from unified_contacts import get_unified_contacts_manager
        
        try:
            manager = get_unified_contacts_manager(db)
            stats = await manager.get_stats()
            
            self.send_event("unified-contacts:stats", {
                "success": True,
                "stats": stats
            })
            
        except Exception as e:
            print(f"[Backend] Get unified contacts stats error: {e}", file=sys.stderr)
            self.send_event("unified-contacts:stats", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_unified_contacts_update(self, payload: Dict[str, Any]):
        """æ›´æ–°å–®å€‹è¯ç¹«äºº"""
        import sys
        from unified_contacts import get_unified_contacts_manager
        
        try:
            telegram_id = payload.get('telegramId')
            updates = payload.get('updates', {})
            
            if not telegram_id:
                raise ValueError("Missing telegramId")
            
            manager = get_unified_contacts_manager(db)
            success = await manager.update_contact(telegram_id, updates)
            
            self.send_event("unified-contacts:update-result", {
                "success": success,
                "telegramId": telegram_id
            })
            
        except Exception as e:
            print(f"[Backend] Update unified contact error: {e}", file=sys.stderr)
            self.send_event("unified-contacts:update-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_unified_contacts_add_tags(self, payload: Dict[str, Any]):
        """æ‰¹é‡æ·»åŠ æ¨™ç±¤"""
        import sys
        from unified_contacts import get_unified_contacts_manager
        
        try:
            telegram_ids = payload.get('telegramIds', [])
            tags = payload.get('tags', [])
            
            manager = get_unified_contacts_manager(db)
            updated = await manager.add_tags(telegram_ids, tags)
            
            self.send_event("unified-contacts:add-tags-result", {
                "success": True,
                "updated": updated
            })
            self.send_log(f"âœ… å·²ç‚º {updated} å€‹è¯ç¹«äººæ·»åŠ æ¨™ç±¤", "info")
            
        except Exception as e:
            print(f"[Backend] Add tags error: {e}", file=sys.stderr)
            self.send_event("unified-contacts:add-tags-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_unified_contacts_update_status(self, payload: Dict[str, Any]):
        """æ‰¹é‡æ›´æ–°ç‹€æ…‹ (å¸¶é›™å‘åŒæ­¥)"""
        import sys
        from unified_contacts import get_unified_contacts_manager
        
        try:
            telegram_ids = payload.get('telegramIds', [])
            status = payload.get('status')
            sync_to_leads = payload.get('syncToLeads', True)  # ğŸ†• æ˜¯å¦åŒæ­¥åˆ° leads
            
            manager = get_unified_contacts_manager(db)
            
            # ğŸ†• ä½¿ç”¨å¸¶åŒæ­¥çš„æ›´æ–°æ–¹æ³•
            result = await manager.update_status_with_sync(telegram_ids, status, sync_to_leads)
            
            self.send_event("unified-contacts:update-status-result", {
                "success": True,
                "updated": result['contacts_updated'],
                "leads_updated": result['leads_updated']  # ğŸ†• è¿”å› leads æ›´æ–°æ•¸
            })
            
            # ğŸ†• å¦‚æœæœ‰åŒæ­¥åˆ° leadsï¼Œé€šçŸ¥å‰ç«¯æ›´æ–° leads åˆ—è¡¨
            if result['leads_updated'] > 0:
                await self.send_leads_update()
            
        except Exception as e:
            print(f"[Backend] Update status error: {e}", file=sys.stderr)
            self.send_event("unified-contacts:update-status-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_unified_contacts_delete(self, payload: Dict[str, Any]):
        """
        æ‰¹é‡åˆªé™¤è¯ç¹«äºº
        åŒæ™‚åˆªé™¤è³‡æºä¸­å¿ƒå’Œç™¼é€æ§åˆ¶å°çš„æ•¸æ“šï¼Œç¢ºä¿ä¸€è‡´æ€§
        """
        import sys
        from unified_contacts import get_unified_contacts_manager
        
        try:
            telegram_ids = payload.get('telegramIds', [])
            print(f"[Backend] Deleting {len(telegram_ids)} contacts from resource center", file=sys.stderr)
            
            manager = get_unified_contacts_manager(db)
            result = await manager.delete_contacts(telegram_ids)
            
            # ç™¼é€åˆªé™¤çµæœ
            self.send_event("unified-contacts:delete-result", {
                "success": True,
                "deleted": result.get('unified_deleted', 0),
                "leadsDeleted": result.get('leads_deleted', 0)
            })
            
            # ğŸ†• å¦‚æœæœ‰åˆªé™¤ leadsï¼Œç™¼é€ leads-updated äº‹ä»¶åŒæ­¥ç™¼é€æ§åˆ¶å°
            if result.get('leads_deleted', 0) > 0:
                await self.send_leads_update()
                self.send_log(f"âœ… å·²åˆªé™¤ {result['leads_deleted']} å€‹è¯ç¹«äººï¼ˆè³‡æºä¸­å¿ƒ + ç™¼é€æ§åˆ¶å°ï¼‰", "info")
            else:
                self.send_log(f"âœ… å·²åˆªé™¤ {result.get('unified_deleted', 0)} å€‹è¯ç¹«äºº", "info")
            
        except Exception as e:
            print(f"[Backend] Delete contacts error: {e}", file=sys.stderr)
            import traceback
            traceback.print_exc()
            self.send_event("unified-contacts:delete-result", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_sync_resource_status_to_leads(self, payload: Dict[str, Any]):
        """
        ğŸ†• å¾è³‡æºä¸­å¿ƒåŒæ­¥ç‹€æ…‹åˆ°ç™¼é€æ§åˆ¶å° (leads è¡¨)
        ç•¶ç”¨æˆ¶åœ¨è³‡æºä¸­å¿ƒä¿®æ”¹è¯ç¹«äººç‹€æ…‹æ™‚èª¿ç”¨
        """
        import sys
        from unified_contacts import CONTACT_STATUS_TO_LEAD
        
        try:
            telegram_ids = payload.get('telegramIds', [])
            lead_status = payload.get('status')  # å·²ç¶“æ˜¯ Lead ç‹€æ…‹æ ¼å¼
            
            if not telegram_ids or not lead_status:
                self.send_event("sync-resource-status-to-leads-result", {
                    "success": False,
                    "error": "Missing telegramIds or status"
                })
                return
            
            print(f"[Backend] Syncing resource status to leads: {len(telegram_ids)} contacts -> {lead_status}", file=sys.stderr)
            
            updated = 0
            for tid in telegram_ids:
                try:
                    # æ›´æ–° leads è¡¨ä¸­å°æ‡‰çš„è¨˜éŒ„
                    await db._connection.execute('''
                        UPDATE leads SET status = ? 
                        WHERE userId = ? OR CAST(userId AS TEXT) = ?
                    ''', (lead_status, tid, tid))
                    updated += 1
                except Exception as e:
                    print(f"[Backend] Error updating lead {tid}: {e}", file=sys.stderr)
            
            await db._connection.commit()
            
            self.send_event("sync-resource-status-to-leads-result", {
                "success": True,
                "updated": updated
            })
            
            # åˆ·æ–°å‰ç«¯çš„ leads åˆ—è¡¨
            if updated > 0:
                await self.send_leads_update()
                self.send_log(f"âœ… å·²åŒæ­¥ {updated} å€‹è¯ç¹«äººç‹€æ…‹åˆ°ç™¼é€æ§åˆ¶å°", "info")
            
        except Exception as e:
            print(f"[Backend] Sync resource status to leads error: {e}", file=sys.stderr)
            self.send_event("sync-resource-status-to-leads-result", {
                "success": False,
                "error": str(e)
            })

    # ==================== Analytics Handlers ====================
    
    async def handle_analytics_get_stats(self, payload: Dict[str, Any]):
        """ç²å–åˆ†æçµ±è¨ˆæ•¸æ“š"""
        import sys
        from datetime import datetime, timedelta
        
        try:
            period = payload.get('period', 'week')
            print(f"[Backend] Getting analytics stats for period: {period}", file=sys.stderr)
            
            # æ ¹æ“šé€±æœŸè¨ˆç®—æ™‚é–“ç¯„åœ
            now = datetime.now()
            if period == 'today':
                start_date = now.replace(hour=0, minute=0, second=0, microsecond=0)
            elif period == 'week':
                start_date = now - timedelta(days=7)
            elif period == 'month':
                start_date = now - timedelta(days=30)
            else:  # quarter
                start_date = now - timedelta(days=90)
            
            # å¾æ•¸æ“šåº«ç²å–çµ±è¨ˆæ•¸æ“š
            result = await db.fetch_one("""
                SELECT 
                    COUNT(*) as total_sent,
                    SUM(CASE WHEN status = 'replied' THEN 1 ELSE 0 END) as total_replies,
                    SUM(CASE WHEN status = 'converted' THEN 1 ELSE 0 END) as total_conversions
                FROM message_logs
                WHERE created_at >= ?
            """, (start_date.isoformat(),))
            
            if result:
                total_sent = result['total_sent'] or 0
                total_replies = result['total_replies'] or 0
                total_conversions = result['total_conversions'] or 0
            else:
                total_sent = total_replies = total_conversions = 0
            
            conversion_rate = (total_conversions / total_sent * 100) if total_sent > 0 else 0
            
            # è¨ˆç®—ä¸ŠæœŸæ•¸æ“šé€²è¡Œå°æ¯”
            if period == 'today':
                prev_start = start_date - timedelta(days=1)
                prev_end = start_date
            elif period == 'week':
                prev_start = start_date - timedelta(days=7)
                prev_end = start_date
            elif period == 'month':
                prev_start = start_date - timedelta(days=30)
                prev_end = start_date
            else:
                prev_start = start_date - timedelta(days=90)
                prev_end = start_date
            
            prev_result = await db.fetch_one("""
                SELECT 
                    COUNT(*) as total_sent,
                    SUM(CASE WHEN status = 'replied' THEN 1 ELSE 0 END) as total_replies,
                    SUM(CASE WHEN status = 'converted' THEN 1 ELSE 0 END) as total_conversions
                FROM message_logs
                WHERE created_at >= ? AND created_at < ?
            """, (prev_start.isoformat(), prev_end.isoformat()))
            
            prev_sent = prev_result['total_sent'] or 0 if prev_result else 0
            prev_replies = prev_result['total_replies'] or 0 if prev_result else 0
            prev_conversions = prev_result['total_conversions'] or 0 if prev_result else 0
            
            # è¨ˆç®—è®ŠåŒ–ç‡
            sent_change = ((total_sent - prev_sent) / prev_sent * 100) if prev_sent > 0 else 0
            replies_change = ((total_replies - prev_replies) / prev_replies * 100) if prev_replies > 0 else 0
            conversions_change = ((total_conversions - prev_conversions) / prev_conversions * 100) if prev_conversions > 0 else 0
            prev_rate = (prev_conversions / prev_sent * 100) if prev_sent > 0 else 0
            rate_change = conversion_rate - prev_rate
            
            self.send_event("analytics:stats", {
                "success": True,
                "stats": {
                    "totalSent": total_sent,
                    "totalReplies": total_replies,
                    "totalConversions": total_conversions,
                    "conversionRate": conversion_rate,
                    "sentChange": sent_change,
                    "repliesChange": replies_change,
                    "conversionsChange": conversions_change,
                    "rateChange": rate_change
                }
            })
            
        except Exception as e:
            print(f"[Backend] Analytics stats error: {e}", file=sys.stderr)
            self.send_event("analytics:stats", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_analytics_get_trend(self, payload: Dict[str, Any]):
        """ç²å–è¶¨å‹¢æ•¸æ“š"""
        import sys
        from datetime import datetime, timedelta
        
        try:
            period = payload.get('period', 'week')
            print(f"[Backend] Getting analytics trend for period: {period}", file=sys.stderr)
            
            # ç¢ºå®šå¤©æ•¸
            if period == 'today':
                days = 24  # æŒ‰å°æ™‚
            elif period == 'week':
                days = 7
            elif period == 'month':
                days = 30
            else:
                days = 90
            
            trend = []
            now = datetime.now()
            
            for i in range(min(days, 14)):
                date = now - timedelta(days=i)
                date_str = date.strftime('%Y-%m-%d')
                
                result = await db.fetch_one("""
                    SELECT 
                        COUNT(*) as sent,
                        SUM(CASE WHEN status = 'replied' THEN 1 ELSE 0 END) as replies,
                        SUM(CASE WHEN status = 'converted' THEN 1 ELSE 0 END) as conversions
                    FROM message_logs
                    WHERE date(created_at) = ?
                """, (date_str,))
                
                trend.insert(0, {
                    "date": date_str,
                    "sent": result['sent'] or 0 if result else 0,
                    "replies": result['replies'] or 0 if result else 0,
                    "conversions": result['conversions'] or 0 if result else 0
                })
            
            self.send_event("analytics:trend", {
                "success": True,
                "trend": trend
            })
            
        except Exception as e:
            print(f"[Backend] Analytics trend error: {e}", file=sys.stderr)
            self.send_event("analytics:trend", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_analytics_get_sources(self, payload: Dict[str, Any]):
        """ç²å–ç”¨æˆ¶ä¾†æºåˆ†å¸ƒ"""
        import sys
        
        try:
            print(f"[Backend] Getting analytics sources", file=sys.stderr)
            
            results = await db.fetch_all("""
                SELECT 
                    source_type,
                    COUNT(*) as count
                FROM unified_contacts
                GROUP BY source_type
                ORDER BY count DESC
            """)
            
            colors = {
                'extracted_member': '#3b82f6',
                'discovered_resource': '#10b981',
                'captured_lead': '#f59e0b',
                'manual': '#8b5cf6'
            }
            
            source_names = {
                'extracted_member': 'ç¾¤çµ„æå–',
                'discovered_resource': 'é—œéµè©åŒ¹é…',
                'captured_lead': 'æ½›åœ¨å®¢æˆ¶',
                'manual': 'æ‰‹å‹•æ·»åŠ '
            }
            
            sources = []
            total = sum(r['count'] for r in results) if results else 0
            
            for r in results or []:
                source_type = r['source_type']
                count = r['count']
                sources.append({
                    "source": source_names.get(source_type, source_type),
                    "count": count,
                    "percentage": (count / total * 100) if total > 0 else 0,
                    "color": colors.get(source_type, '#6b7280')
                })
            
            self.send_event("analytics:sources", {
                "success": True,
                "sources": sources
            })
            
        except Exception as e:
            print(f"[Backend] Analytics sources error: {e}", file=sys.stderr)
            self.send_event("analytics:sources", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_analytics_get_hourly(self, payload: Dict[str, Any]):
        """ç²å–æ™‚æ®µæ•¸æ“š"""
        import sys
        from datetime import datetime, timedelta
        
        try:
            print(f"[Backend] Getting analytics hourly data", file=sys.stderr)
            
            # ç²å–éå»7å¤©çš„æ™‚æ®µæ•¸æ“š
            results = await db.fetch_all("""
                SELECT 
                    strftime('%H', created_at) as hour,
                    COUNT(*) as sent,
                    SUM(CASE WHEN status = 'replied' THEN 1 ELSE 0 END) as replies
                FROM message_logs
                WHERE created_at >= datetime('now', '-7 days')
                GROUP BY hour
            """)
            
            hourly = {}
            for h in range(24):
                hourly[h] = 0
            
            for r in results or []:
                hour = int(r['hour'])
                sent = r['sent'] or 0
                replies = r['replies'] or 0
                # è¨ˆç®—å›è¦†ç‡
                hourly[hour] = int((replies / sent * 100) if sent > 0 else 0)
            
            self.send_event("analytics:hourly", {
                "success": True,
                "hourly": hourly
            })
            
        except Exception as e:
            print(f"[Backend] Analytics hourly error: {e}", file=sys.stderr)
            self.send_event("analytics:hourly", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_analytics_generate_insights(self, payload: Dict[str, Any]):
        """AI ç”Ÿæˆæ´å¯Ÿ"""
        import sys
        
        try:
            stats = payload.get('stats', {})
            period = payload.get('period', 'week')
            print(f"[Backend] Generating AI insights", file=sys.stderr)
            
            # åŸºæ–¼æ•¸æ“šç”Ÿæˆæ´å¯Ÿï¼ˆå¯æ¥å…¥çœŸå¯¦ AIï¼‰
            insights = []
            
            conversion_rate = stats.get('conversionRate', 0)
            if conversion_rate > 5:
                insights.append({
                    "icon": "ğŸ‰",
                    "type": "success",
                    "title": "è½‰åŒ–ç‡è¡¨ç¾å„ªç§€",
                    "description": f"ç•¶å‰è½‰åŒ–ç‡ {conversion_rate:.1f}% é«˜æ–¼è¡Œæ¥­å¹³å‡æ°´å¹³ï¼Œç¹¼çºŒä¿æŒï¼"
                })
            elif conversion_rate > 2:
                insights.append({
                    "icon": "ğŸ“Š",
                    "type": "info",
                    "title": "è½‰åŒ–ç‡æ­£å¸¸",
                    "description": f"ç•¶å‰è½‰åŒ–ç‡ {conversion_rate:.1f}%ï¼Œè™•æ–¼æ­£å¸¸æ°´å¹³ã€‚"
                })
            else:
                insights.append({
                    "icon": "âš ï¸",
                    "type": "warning",
                    "title": "è½‰åŒ–ç‡æœ‰å¾…æå‡",
                    "description": f"ç•¶å‰è½‰åŒ–ç‡ {conversion_rate:.1f}% è¼ƒä½ï¼Œå»ºè­°å„ªåŒ–æ¶ˆæ¯æ¨¡æ¿ã€‚"
                })
            
            sent_change = stats.get('sentChange', 0)
            if sent_change > 10:
                insights.append({
                    "icon": "ğŸ“ˆ",
                    "type": "info",
                    "title": "ç™¼é€é‡é¡¯è‘—å¢é•·",
                    "description": f"ç™¼é€é‡è¼ƒä¸ŠæœŸå¢é•· {sent_change:.1f}%ï¼Œè§¸é”æ›´å¤šæ½›åœ¨å®¢æˆ¶ã€‚"
                })
            elif sent_change < -10:
                insights.append({
                    "icon": "ğŸ“‰",
                    "type": "warning",
                    "title": "ç™¼é€é‡ä¸‹é™",
                    "description": f"ç™¼é€é‡è¼ƒä¸ŠæœŸä¸‹é™ {abs(sent_change):.1f}%ï¼Œå»ºè­°å¢åŠ ç™¼é€é »ç‡ã€‚"
                })
            
            # æ™‚æ®µå»ºè­°ï¼ˆä½¿ç”¨æ¨¡æ“¬æ•¸æ“šï¼‰
            insights.append({
                "icon": "â°",
                "type": "tip",
                "title": "æœ€ä½³ç™¼é€æ™‚æ®µï¼š10:00-11:00",
                "description": "è©²æ™‚æ®µå›è¦†ç‡æœ€é«˜ï¼Œå»ºè­°é‡é»å®‰æ’ç™¼é€ã€‚"
            })
            
            insights.append({
                "icon": "ğŸ¯",
                "type": "info",
                "title": "æŒçºŒå„ªåŒ–å»ºè­°",
                "description": "å»ºè­°å®šæœŸæ›´æ–°æ¶ˆæ¯æ¨¡æ¿ï¼Œä¿æŒå…§å®¹æ–°é®®åº¦ã€‚"
            })
            
            self.send_event("analytics:insights", {
                "success": True,
                "insights": insights
            })
            
        except Exception as e:
            print(f"[Backend] Analytics insights error: {e}", file=sys.stderr)
            self.send_event("analytics:insights", {
                "success": False,
                "error": str(e)
            })
    
    async def handle_analytics_export(self, payload: Dict[str, Any]):
        """å°å‡ºåˆ†æå ±å‘Š"""
        import sys
        import json
        from datetime import datetime
        
        try:
            print(f"[Backend] Exporting analytics report", file=sys.stderr)
            
            report = {
                "generated_at": datetime.now().isoformat(),
                "period": payload.get('period', 'week'),
                "stats": payload.get('stats', {}),
                "trend": payload.get('trend', []),
                "sources": payload.get('sources', []),
                "insights": payload.get('insights', [])
            }
            
            # é€™è£¡å¯ä»¥ç”Ÿæˆ PDF æˆ– Excel æ–‡ä»¶
            # ç›®å‰åªè¿”å› JSON æ•¸æ“š
            
            self.send_event("analytics:export", {
                "success": True,
                "report": report,
                "format": "json"
            })
            
            self.send_log("ğŸ“Š å ±å‘Šå·²ç”Ÿæˆ", "info")
            
        except Exception as e:
            print(f"[Backend] Analytics export error: {e}", file=sys.stderr)
            self.send_event("analytics:export", {
                "success": False,
                "error": str(e)
            })

    # ==================== Multi-Role Group Handlers ====================
    
    async def handle_create_multi_role_group(self, payload: Dict[str, Any]):
        """å‰µå»ºå¤šè§’è‰²å”ä½œç¾¤çµ„"""
        import sys
        
        try:
            group_name = payload.get('groupName', 'VIPå°ˆå±¬æœå‹™ç¾¤')
            target_user_id = payload.get('targetUserId')
            target_username = payload.get('targetUsername')
            role_accounts = payload.get('roleAccounts', [])
            invite_message = payload.get('inviteMessage', 'æ‚¨å¥½ï¼Œæˆ‘å€‘ç‚ºæ‚¨å‰µå»ºäº†å°ˆå±¬æœå‹™ç¾¤çµ„ï¼')
            
            print(f"[Backend] Creating multi-role group: {group_name} for {target_user_id}", file=sys.stderr)
            
            if not role_accounts:
                self.send_event("multi-role-group-created", {
                    "success": False,
                    "error": "æœªé…ç½®è§’è‰²å¸³è™Ÿ",
                    "request": payload
                })
                return
            
            # ä½¿ç”¨ç¬¬ä¸€å€‹è§’è‰²å¸³è™Ÿå‰µå»ºç¾¤çµ„
            first_account_id = role_accounts[0].get('accountId')
            
            # ç²å– Telegram å®¢æˆ¶ç«¯
            client = self.telegram_manager.get_client(first_account_id)
            if not client:
                self.send_event("multi-role-group-created", {
                    "success": False,
                    "error": f"å¸³è™Ÿ {first_account_id} æœªé€£æ¥",
                    "request": payload
                })
                return
            
            # æº–å‚™è¦é‚€è«‹çš„ç”¨æˆ¶åˆ—è¡¨
            users_to_invite = []
            
            # æ·»åŠ ç›®æ¨™ç”¨æˆ¶
            if target_username:
                users_to_invite.append(target_username)
            elif target_user_id:
                users_to_invite.append(int(target_user_id) if str(target_user_id).isdigit() else target_user_id)
            
            # æ·»åŠ å…¶ä»–è§’è‰²å¸³è™Ÿï¼ˆå¦‚æœæ˜¯ä¸åŒçš„å¸³è™Ÿï¼‰
            # å¯¦éš›æƒ…æ³ä¸­ï¼Œå¤šå€‹è§’è‰²å¯èƒ½ä½¿ç”¨åŒä¸€å€‹å¸³è™Ÿæˆ–ä¸åŒå¸³è™Ÿ
            # é€™è£¡ç°¡åŒ–è™•ç†
            
            # å‰µå»ºç¾¤çµ„
            try:
                from pyrogram.raw import functions, types
                
                # å‰µå»ºè¶…ç´šç¾¤çµ„
                result = await client.invoke(
                    functions.channels.CreateChannel(
                        title=group_name,
                        about=f"å°ˆå±¬æœå‹™ç¾¤çµ„ - {target_username or target_user_id}",
                        megagroup=True
                    )
                )
                
                # ç²å–å‰µå»ºçš„ç¾¤çµ„
                if hasattr(result, 'chats') and result.chats:
                    telegram_group = result.chats[0]
                    telegram_group_id = telegram_group.id
                    
                    # é‚€è«‹ç›®æ¨™ç”¨æˆ¶
                    if users_to_invite:
                        try:
                            await client.add_chat_members(
                                -1000000000000 - telegram_group_id,  # è¶…ç´šç¾¤çµ„ ID æ ¼å¼
                                users_to_invite
                            )
                        except Exception as invite_err:
                            print(f"[Backend] Failed to invite users: {invite_err}", file=sys.stderr)
                    
                    # ç²å–é‚€è«‹é€£çµ
                    invite_link = None
                    try:
                        link = await client.export_chat_invite_link(-1000000000000 - telegram_group_id)
                        invite_link = link
                    except:
                        pass
                    
                    # ç™¼é€æ­¡è¿æ¶ˆæ¯
                    if invite_message:
                        try:
                            await client.send_message(
                                -1000000000000 - telegram_group_id,
                                invite_message
                            )
                        except:
                            pass
                    
                    # ç”Ÿæˆç¾¤çµ„ ID
                    group_id = f"mrg_{telegram_group_id}_{int(time.time())}"
                    
                    self.send_event("multi-role-group-created", {
                        "success": True,
                        "groupId": group_id,
                        "telegramGroupId": str(telegram_group_id),
                        "inviteLink": invite_link,
                        "request": payload
                    })
                    
                    self.send_log(f"âœ… å¤šè§’è‰²ç¾¤çµ„å‰µå»ºæˆåŠŸ: {group_name}", "info")
                else:
                    self.send_event("multi-role-group-created", {
                        "success": False,
                        "error": "å‰µå»ºç¾¤çµ„å¤±æ•—",
                        "request": payload
                    })
                    
            except Exception as create_err:
                print(f"[Backend] Create group error: {create_err}", file=sys.stderr)
                self.send_event("multi-role-group-created", {
                    "success": False,
                    "error": str(create_err),
                    "request": payload
                })
                
        except Exception as e:
            print(f"[Backend] Multi-role group creation error: {e}", file=sys.stderr)
            self.send_event("multi-role-group-created", {
                "success": False,
                "error": str(e),
                "request": payload
            })
    
    async def handle_multi_role_start_script(self, payload: Dict[str, Any]):
        """é–‹å§‹åŸ·è¡Œå¤šè§’è‰²åŠ‡æœ¬"""
        import sys
        
        try:
            group_id = payload.get('groupId')
            script_id = payload.get('scriptId')
            
            print(f"[Backend] Starting script {script_id} for group {group_id}", file=sys.stderr)
            
            # TODO: å¾æ•¸æ“šåº«è¼‰å…¥åŠ‡æœ¬ä¸¦é–‹å§‹åŸ·è¡Œ
            # é€™è£¡éœ€è¦èˆ‡ script_engine æ•´åˆ
            
            self.send_log(f"ğŸ“ åŠ‡æœ¬ {script_id} å·²é–‹å§‹åŸ·è¡Œ", "info")
            
        except Exception as e:
            print(f"[Backend] Start script error: {e}", file=sys.stderr)
    
    async def handle_multi_role_send_message(self, payload: Dict[str, Any]):
        """ç™¼é€å¤šè§’è‰²æ¶ˆæ¯"""
        import sys
        
        try:
            group_id = payload.get('groupId')
            telegram_group_id = payload.get('telegramGroupId')
            account_id = payload.get('accountId')
            content = payload.get('content')
            
            print(f"[Backend] Sending message to group {telegram_group_id} from account {account_id}", file=sys.stderr)
            
            client = self.telegram_manager.get_client(account_id)
            if not client:
                return
            
            try:
                # ç™¼é€æ¶ˆæ¯åˆ°ç¾¤çµ„
                chat_id = int(telegram_group_id)
                if chat_id > 0:
                    chat_id = -1000000000000 - chat_id
                
                await client.send_message(chat_id, content)
                
                self.send_event("multi-role-group-message", {
                    "groupId": group_id,
                    "senderId": str(account_id),
                    "senderName": "Role",  # TODO: å¾è§’è‰²é…ç½®ç²å–
                    "content": content,
                    "isFromTarget": False
                })
                
            except Exception as send_err:
                print(f"[Backend] Send message error: {send_err}", file=sys.stderr)
                
        except Exception as e:
            print(f"[Backend] Multi-role send message error: {e}", file=sys.stderr)
    
    async def handle_multi_role_ai_reply(self, payload: Dict[str, Any]):
        """AI ç”Ÿæˆå›è¦†"""
        import sys
        
        try:
            group_id = payload.get('groupId')
            message = payload.get('message')
            customer_id = payload.get('customerId')
            
            print(f"[Backend] Generating AI reply for group {group_id}", file=sys.stderr)
            
            # TODO: ä½¿ç”¨ AI ç”Ÿæˆå›è¦†
            # é€™è£¡éœ€è¦èˆ‡ ai_auto_chat æ•´åˆ
            
            # æ¨¡æ“¬ AI å›è¦†
            ai_reply = f"æ„Ÿè¬æ‚¨çš„å›è¦†ï¼æˆ‘å€‘æœƒç›¡å¿«ç‚ºæ‚¨è™•ç†ã€‚"
            
            # ç™¼é€å›è¦†ï¼ˆéœ€è¦ç²å–ç¾¤çµ„çš„å¸³è™Ÿé…ç½®ï¼‰
            # TODO: å¯¦ç¾å®Œæ•´çš„ AI å›è¦†é‚è¼¯
            
        except Exception as e:
            print(f"[Backend] AI reply error: {e}", file=sys.stderr)
    
    async def handle_multi_role_advance_stage(self, payload: Dict[str, Any]):
        """æ¨é€²åŠ‡æœ¬éšæ®µ"""
        import sys
        
        try:
            group_id = payload.get('groupId')
            next_stage_order = payload.get('nextStageOrder')
            
            print(f"[Backend] Advancing to stage {next_stage_order} for group {group_id}", file=sys.stderr)
            
            # TODO: åŸ·è¡Œä¸‹ä¸€éšæ®µçš„åŠ‡æœ¬
            # é€™è£¡éœ€è¦èˆ‡ script_engine æ•´åˆ
            
        except Exception as e:
            print(f"[Backend] Advance stage error: {e}", file=sys.stderr)
    
    # ============ ğŸ†• Phase3: å…¨éˆè·¯è‡ªå‹•åŒ–å·¥ä½œæµ ============
    
    async def handle_multi_role_ai_plan(self, payload: Dict[str, Any]):
        """è™•ç† AI æ™ºèƒ½ç­–åŠƒè«‹æ±‚"""
        import sys
        
        try:
            from automation_workflow import get_automation_workflow_service
            
            service = get_automation_workflow_service()
            result = await service.handle_ai_plan(payload)
            
            self.send_event("multi-role:ai-plan-result", result)
            print(f"[AutomationWorkflow] AI ç­–åŠƒå®Œæˆ: success={result.get('success')}", file=sys.stderr)
            
        except Exception as e:
            print(f"[AutomationWorkflow] AI ç­–åŠƒéŒ¯èª¤: {e}", file=sys.stderr)
            self.send_event("multi-role:ai-plan-result", {"success": False, "error": str(e)})
    
    async def handle_multi_role_start_private_collaboration(self, payload: Dict[str, Any]):
        """é–‹å§‹ç§èŠå”ä½œ"""
        import sys
        
        try:
            from automation_workflow import get_automation_workflow_service
            
            service = get_automation_workflow_service()
            result = await service.handle_start_private_collaboration(payload)
            
            self.send_event("multi-role:private-collaboration-started", result)
            print(f"[AutomationWorkflow] ç§èŠå”ä½œå·²é–‹å§‹: {result.get('executionId')}", file=sys.stderr)
            
        except Exception as e:
            print(f"[AutomationWorkflow] é–‹å§‹ç§èŠå¤±æ•—: {e}", file=sys.stderr)
            self.send_event("multi-role:private-collaboration-started", {"success": False, "error": str(e)})
    
    async def handle_multi_role_auto_create_group(self, payload: Dict[str, Any]):
        """è‡ªå‹•å‰µå»ºç¾¤çµ„"""
        import sys
        
        try:
            from automation_workflow import get_automation_workflow_service
            
            service = get_automation_workflow_service()
            result = await service.handle_auto_create_group(payload)
            
            self.send_event("multi-role:group-created", result)
            print(f"[AutomationWorkflow] å»ºç¾¤çµæœ: success={result.get('success')}", file=sys.stderr)
            
        except Exception as e:
            print(f"[AutomationWorkflow] å»ºç¾¤éŒ¯èª¤: {e}", file=sys.stderr)
            self.send_event("multi-role:group-created", {"success": False, "error": str(e)})
    
    async def handle_multi_role_start_group_collaboration(self, payload: Dict[str, Any]):
        """é–‹å§‹çµ„ç¾¤ç‡ŸéŠ·"""
        import sys
        
        try:
            from automation_workflow import get_automation_workflow_service
            
            service = get_automation_workflow_service()
            result = await service.handle_start_group_collaboration(payload)
            
            self.send_event("multi-role:group-collaboration-started", result)
            print(f"[AutomationWorkflow] çµ„ç¾¤ç‡ŸéŠ·å·²é–‹å§‹: group={payload.get('groupId')}", file=sys.stderr)
            
        except Exception as e:
            print(f"[AutomationWorkflow] çµ„ç¾¤ç‡ŸéŠ·éŒ¯èª¤: {e}", file=sys.stderr)
            self.send_event("multi-role:group-collaboration-started", {"success": False, "error": str(e)})
    
    async def handle_ai_analyze_interest(self, payload: Dict[str, Any]):
        """AI åˆ†æèˆˆè¶£ä¿¡è™Ÿ"""
        import sys
        
        try:
            from automation_workflow import get_automation_workflow_service
            
            service = get_automation_workflow_service()
            result = await service.handle_analyze_interest(payload)
            
            self.send_event("ai:analyze-interest-result", result)
            print(f"[AutomationWorkflow] èˆˆè¶£åˆ†æ: hasInterest={result.get('hasInterest')}", file=sys.stderr)
            
        except Exception as e:
            print(f"[AutomationWorkflow] èˆˆè¶£åˆ†æéŒ¯èª¤: {e}", file=sys.stderr)
            self.send_event("ai:analyze-interest-result", {"success": False, "error": str(e)})
    
    async def handle_workflow_get_executions(self, payload: Dict[str, Any]):
        """ç²å–å·¥ä½œæµåŸ·è¡Œåˆ—è¡¨"""
        import sys
        
        try:
            from automation_workflow import get_automation_workflow_service
            
            service = get_automation_workflow_service()
            executions = service.get_all_executions()
            
            self.send_event("workflow:executions", {"success": True, "executions": executions})
            
        except Exception as e:
            print(f"[AutomationWorkflow] ç²å–åŸ·è¡Œåˆ—è¡¨éŒ¯èª¤: {e}", file=sys.stderr)
            self.send_event("workflow:executions", {"success": False, "error": str(e)})
    
    # ============ ğŸ†• AI Team åŸ·è¡Œç›¸é—œ ============
    
    async def handle_ai_execution_save(self, payload: Dict[str, Any]):
        """ğŸ”§ Phase 4: æŒä¹…åŒ– AI åŸ·è¡Œç‹€æ…‹åˆ°æ•¸æ“šåº«"""
        import sys
        
        try:
            execution_id = payload.get('id')
            if not execution_id:
                return
            
            # ç¢ºä¿è¡¨å­˜åœ¨
            await db.execute("""
                CREATE TABLE IF NOT EXISTS ai_executions (
                    id TEXT PRIMARY KEY,
                    execution_type TEXT NOT NULL,
                    status TEXT DEFAULT 'running',
                    mode TEXT,
                    goal TEXT,
                    target_users TEXT,
                    role_accounts TEXT,
                    group_id TEXT,
                    group_name TEXT,
                    message_history TEXT DEFAULT '[]',
                    stats TEXT DEFAULT '{}',
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    completed_at TIMESTAMP
                )
            """)
            
            # æ’å…¥æˆ–æ›´æ–°
            await db.execute("""
                INSERT OR REPLACE INTO ai_executions 
                (id, execution_type, status, mode, goal, target_users, role_accounts, 
                 group_id, group_name, message_history, stats, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
            """, (
                execution_id,
                payload.get('executionType', 'private'),
                payload.get('status', 'running'),
                payload.get('mode', 'hybrid'),
                payload.get('goal', ''),
                payload.get('targetUsers', '[]'),
                payload.get('roleAccounts', '[]'),
                payload.get('groupId'),
                payload.get('groupName'),
                payload.get('messageHistory', '[]'),
                payload.get('stats', '{}')
            ))
            
            print(f"[AIExecution] âœ“ å·²ä¿å­˜åŸ·è¡Œç‹€æ…‹: {execution_id}", file=sys.stderr)
            
        except Exception as e:
            print(f"[AIExecution] ä¿å­˜åŸ·è¡Œç‹€æ…‹å¤±æ•—: {e}", file=sys.stderr)
    
    async def handle_ai_execution_get_active(self, payload: Dict[str, Any]):
        """ğŸ”§ Phase 4: ç²å–æ´»èºçš„ AI åŸ·è¡Œä»»å‹™"""
        import sys
        
        try:
            executions = []
            
            # ç¢ºä¿è¡¨å­˜åœ¨
            try:
                cursor = await db.execute("""
                    SELECT * FROM ai_executions 
                    WHERE status IN ('running', 'executing', 'paused')
                    ORDER BY updated_at DESC
                    LIMIT 10
                """)
                rows = await cursor.fetchall()
                
                for row in rows:
                    executions.append({
                        'id': row['id'],
                        'executionType': row['execution_type'],
                        'status': row['status'],
                        'mode': row['mode'],
                        'goal': row['goal'],
                        'targetUsers': row['target_users'],
                        'roleAccounts': row['role_accounts'],
                        'groupId': row['group_id'],
                        'groupName': row['group_name'],
                        'messageHistory': row['message_history'],
                        'stats': row['stats']
                    })
                
                print(f"[AIExecution] æ‰¾åˆ° {len(executions)} å€‹æ´»èºåŸ·è¡Œ", file=sys.stderr)
                
            except Exception as query_err:
                if 'no such table' not in str(query_err).lower():
                    print(f"[AIExecution] æŸ¥è©¢å¤±æ•—: {query_err}", file=sys.stderr)
            
            # ğŸ”§ ç™¼é€äº‹ä»¶è¿”å›çµæœ
            self.send_event("ai-execution:active-list", {"executions": executions})
            
        except Exception as e:
            print(f"[AIExecution] ç²å–æ´»èºåŸ·è¡Œå¤±æ•—: {e}", file=sys.stderr)
            self.send_event("ai-execution:active-list", {"executions": [], "error": str(e)})
            return {"executions": [], "error": str(e)}
    
    async def handle_ai_team_start_execution(self, payload: Dict[str, Any]):
        """å•Ÿå‹• AI åœ˜éšŠåŸ·è¡Œï¼ˆæ”¯æŒåŠ‡æœ¬/ç„¡åŠ‡æœ¬/æ··åˆæ¨¡å¼ï¼‰"""
        import sys
        
        try:
            execution_id = payload.get('executionId')
            goal = payload.get('goal', '')
            intent = payload.get('intent', {})
            strategy = payload.get('strategy', {})
            roles = payload.get('roles', [])
            mode = payload.get('mode', 'hybrid')  # scripted / scriptless / hybrid
            account_matches = payload.get('accountMatches', [])
            scriptless_config = payload.get('scriptlessConfig', {})
            analysis_interval = payload.get('analysisInterval', 10)
            target_users = payload.get('targetUsers', [])  # ğŸ†• ç›®æ¨™ç”¨æˆ¶åˆ—è¡¨
            
            print(f"[AITeam] å•Ÿå‹•åŸ·è¡Œ: {execution_id}, æ¨¡å¼: {mode}", file=sys.stderr)
            print(f"[AITeam] ç›®æ¨™: {goal}", file=sys.stderr)
            print(f"[AITeam] è§’è‰²æ•¸é‡: {len(roles)}, å¸³è™ŸåŒ¹é…: {len(account_matches)}, ç›®æ¨™ç”¨æˆ¶: {len(target_users)}", file=sys.stderr)
            
            # å­˜å„²åŸ·è¡Œç‹€æ…‹
            if not hasattr(self, '_ai_team_executions'):
                self._ai_team_executions = {}
            
            self._ai_team_executions[execution_id] = {
                'id': execution_id,
                'goal': goal,
                'intent': intent,
                'strategy': strategy,
                'roles': roles,
                'mode': mode,
                'account_matches': account_matches,
                'scriptless_config': scriptless_config,
                'analysis_interval': analysis_interval,
                'target_users': target_users,  # ğŸ†• ä¿å­˜ç›®æ¨™ç”¨æˆ¶
                'current_target_index': 0,     # ğŸ†• ç•¶å‰è™•ç†çš„ç›®æ¨™ç”¨æˆ¶ç´¢å¼•
                'status': 'running',
                'message_count': 0,
                'response_count': 0,
                'current_phase': 0,
                'message_history': [],  # ğŸ†• æ¶ˆæ¯æ­·å²
                'created_at': datetime.now().isoformat()
            }
            
            target_info = f"ï¼Œç›®æ¨™ {len(target_users)} äºº" if target_users else ""
            self.send_log(f"ğŸš€ AI åœ˜éšŠé–‹å§‹åŸ·è¡Œ: {goal[:30]}...{target_info}", "info")
            self.send_event("ai-team:execution-started", {
                "executionId": execution_id,
                "mode": mode,
                "roleCount": len(roles),
                "targetCount": len(target_users)
            })
            
            # ğŸ”§ Phase 3 ä¿®å¾©ï¼šç¢ºä¿ç§èŠè¼ªè©¢å™¨é‹è¡Œä»¥æ¥æ”¶ç›®æ¨™ç”¨æˆ¶å›è¦†
            await self._ensure_private_poller_running(account_matches)
            
            # æ ¹æ“šæ¨¡å¼å•Ÿå‹•åŸ·è¡Œ
            if mode == 'scriptless':
                # ç„¡åŠ‡æœ¬æ¨¡å¼ï¼šç­‰å¾…å‰ç«¯è§¸ç™¼æ¶ˆæ¯ç”Ÿæˆ
                self.send_log(f"ğŸ“ ç„¡åŠ‡æœ¬æ¨¡å¼å·²å°±ç·’ï¼Œç­‰å¾…å°è©±é–‹å§‹...", "info")
            else:
                # åŠ‡æœ¬æˆ–æ··åˆæ¨¡å¼ï¼šæŒ‰éšæ®µåŸ·è¡Œ
                asyncio.create_task(self._execute_scripted_phase(execution_id))
            
        except Exception as e:
            print(f"[AITeam] Start execution error: {e}", file=sys.stderr)
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.send_event("ai-team:execution-error", {
                "executionId": payload.get('executionId'),
                "error": str(e)
            })
    
    async def _ensure_private_poller_running(self, account_matches: list):
        """ğŸ”§ Phase 3: ç¢ºä¿ç§èŠè¼ªè©¢å™¨é‹è¡Œä»¥æ¥æ”¶ç›®æ¨™ç”¨æˆ¶å›è¦†"""
        import sys
        
        try:
            # ç²å–éœ€è¦ç›£æ§çš„å¸³è™Ÿ
            phones_to_monitor = [m.get('accountPhone') for m in account_matches if m.get('accountPhone')]
            
            if not phones_to_monitor:
                print(f"[AITeam] âš ï¸ æ²’æœ‰å¸³è™Ÿéœ€è¦ç›£æ§ç§èŠ", file=sys.stderr)
                return
            
            print(f"[AITeam] ğŸ”„ ç¢ºä¿ç§èŠè¼ªè©¢å™¨é‹è¡Œï¼Œç›£æ§å¸³è™Ÿ: {phones_to_monitor}", file=sys.stderr)
            
            # ç²å–åœ¨ç·šå®¢æˆ¶ç«¯
            online_clients = {}
            for phone in phones_to_monitor:
                client = self.telegram_manager.get_client(phone)
                if client and client.is_connected:
                    online_clients[phone] = client
            
            if not online_clients:
                print(f"[AITeam] âš ï¸ æ²’æœ‰åœ¨ç·šå¸³è™Ÿå¯ç”¨æ–¼ç§èŠç›£æ§", file=sys.stderr)
                return
            
            # è¨­ç½®äº‹ä»¶å›èª¿ï¼ˆå¦‚æœå°šæœªè¨­ç½®ï¼‰
            if private_message_poller.event_callback is None:
                def wrapped_event_callback(event_name: str, payload: Any):
                    self.send_event(event_name, payload)
                    if event_name == "private-message-received":
                        asyncio.create_task(self.handle_ai_team_customer_reply(payload))
                private_message_poller.event_callback = wrapped_event_callback
                print(f"[AITeam] âœ… ç§èŠè¼ªè©¢å™¨ event_callback å·²è¨­ç½®", file=sys.stderr)
            
            # æ·»åŠ å®¢æˆ¶ç«¯åˆ°è¼ªè©¢å™¨ï¼ˆå¦‚æœå°šæœªé‹è¡Œï¼Œæœƒè‡ªå‹•å•Ÿå‹•ï¼‰
            if not private_message_poller._running:
                await private_message_poller.start_polling(online_clients)
                print(f"[AITeam] âœ… ç§èŠè¼ªè©¢å™¨å·²å•Ÿå‹•ï¼Œç›£æ§ {len(online_clients)} å€‹å¸³è™Ÿ", file=sys.stderr)
            else:
                # æ·»åŠ æ–°å¸³è™Ÿåˆ°ç¾æœ‰è¼ªè©¢
                for phone, client in online_clients.items():
                    if phone not in private_message_poller._clients:
                        await private_message_poller.add_client(phone, client)
                        print(f"[AITeam] âœ… å¸³è™Ÿ {phone} å·²æ·»åŠ åˆ°ç§èŠè¼ªè©¢", file=sys.stderr)
            
        except Exception as e:
            print(f"[AITeam] âš ï¸ ç¢ºä¿ç§èŠè¼ªè©¢å™¨é‹è¡Œå¤±æ•—: {e}", file=sys.stderr)
            import traceback
            traceback.print_exc(file=sys.stderr)
    
    async def _execute_scripted_phase(self, execution_id: str):
        """åŸ·è¡ŒåŠ‡æœ¬éšæ®µ"""
        import sys
        
        execution = self._ai_team_executions.get(execution_id)
        if not execution:
            return
        
        strategy = execution.get('strategy', {})
        phases = strategy.get('phases', [])
        current_phase = execution.get('current_phase', 0)
        
        if current_phase >= len(phases):
            # æ‰€æœ‰éšæ®µå®Œæˆ
            self.send_event("ai-team:execution-completed", {
                "executionId": execution_id,
                "totalSent": execution.get('message_count', 0),
                "totalResponses": execution.get('response_count', 0)
            })
            return
        
        phase = phases[current_phase]
        phase_name = phase.get('name', f'éšæ®µ {current_phase + 1}')
        
        print(f"[AITeam] åŸ·è¡Œéšæ®µ {current_phase + 1}: {phase_name}", file=sys.stderr)
        self.send_event("ai-team:phase-changed", {
            "executionId": execution_id,
            "phase": current_phase,
            "phaseName": phase_name
        })
        
        # TODO: å¯¦ç¾å…·é«”çš„éšæ®µæ¶ˆæ¯ç™¼é€é‚è¼¯
        # é€™è£¡å¯ä»¥èˆ‡ script_engine æ•´åˆ
    
    async def handle_ai_team_adjust_strategy(self, payload: Dict[str, Any]):
        """èª¿æ•´ AI åœ˜éšŠç­–ç•¥ï¼ˆå‹•æ…‹åˆ†æè§¸ç™¼ï¼‰"""
        import sys
        
        try:
            execution_id = payload.get('executionId')
            adjustment = payload.get('adjustment', {})
            
            print(f"[AITeam] èª¿æ•´ç­–ç•¥: {execution_id}", file=sys.stderr)
            print(f"[AITeam] èª¿æ•´å‹•ä½œ: {adjustment.get('action')}, åŸå› : {adjustment.get('reason')}", file=sys.stderr)
            
            execution = self._ai_team_executions.get(execution_id) if hasattr(self, '_ai_team_executions') else None
            if not execution:
                return
            
            action = adjustment.get('action')
            
            if action == 'advance_phase':
                # æ¨é€²éšæ®µ
                new_phase = adjustment.get('newPhase', execution.get('current_phase', 0) + 1)
                execution['current_phase'] = new_phase
                asyncio.create_task(self._execute_scripted_phase(execution_id))
                
            elif action == 'switch_role':
                # åˆ‡æ›è§’è‰²
                new_role = adjustment.get('newRole')
                self.send_event("ai-team:role-switched", {
                    "executionId": execution_id,
                    "newRole": new_role,
                    "reason": adjustment.get('reason')
                })
                
            elif action == 'activate_atmosphere':
                # æ´»èºæ°£æ°›
                self.send_log("ğŸ’¬ å¼•å…¥æ´»èºè§’è‰²å¸¶å‹•æ°£æ°›...", "info")
                
            elif action == 'handle_objection':
                # è™•ç†ç•°è­°
                self.send_log("ğŸ¯ å¼•å…¥å°ˆå®¶è™•ç†å®¢æˆ¶é¡§æ…®...", "info")
            
            self.send_event("ai-team:strategy-adjusted", {
                "executionId": execution_id,
                "adjustment": adjustment
            })
            
        except Exception as e:
            print(f"[AITeam] Adjust strategy error: {e}", file=sys.stderr)
    
    async def handle_ai_team_generate_scriptless_message(self, payload: Dict[str, Any]):
        """ç„¡åŠ‡æœ¬æ¨¡å¼ï¼šAI è‡ªä¸»ç”Ÿæˆå°è©±"""
        import sys
        
        try:
            execution_id = payload.get('executionId')
            role_id = payload.get('roleId')
            role_name = payload.get('roleName', '')
            role_personality = payload.get('rolePersonality', '')
            role_speaking_style = payload.get('roleSpeakingStyle', '')
            prompt = payload.get('prompt', '')
            context = payload.get('context', {})
            
            print(f"[AITeam] ç„¡åŠ‡æœ¬ç”Ÿæˆæ¶ˆæ¯: {role_name}", file=sys.stderr)
            
            # ä½¿ç”¨ AI ç”Ÿæˆæ¶ˆæ¯
            generated_content = await self._generate_ai_message(
                role_name=role_name,
                role_personality=role_personality,
                role_speaking_style=role_speaking_style,
                prompt=prompt,
                context=context
            )
            
            if generated_content:
                self.send_event("ai-team:scriptless-message-generated", {
                    "executionId": execution_id,
                    "roleId": role_id,
                    "content": generated_content,
                    "reasoning": f"æ ¹æ“š {context.get('currentStage', 'å°è©±')} éšæ®µè‡ªå‹•ç”Ÿæˆ"
                })
            else:
                self.send_event("ai-team:scriptless-message-generated", {
                    "executionId": execution_id,
                    "roleId": role_id,
                    "content": None,
                    "error": "ç”Ÿæˆå¤±æ•—"
                })
            
        except Exception as e:
            print(f"[AITeam] Generate scriptless message error: {e}", file=sys.stderr)
            self.send_event("ai-team:scriptless-message-generated", {
                "executionId": payload.get('executionId'),
                "content": None,
                "error": str(e)
            })
    
    async def _generate_ai_message(
        self,
        role_name: str,
        role_personality: str,
        role_speaking_style: str,
        prompt: str,
        context: Dict[str, Any]
    ) -> Optional[str]:
        """ä½¿ç”¨ AI ç”Ÿæˆæ¶ˆæ¯å…§å®¹"""
        import sys
        
        try:
            # ç²å– AI é…ç½® - ğŸ”§ ä¿®å¾©: ä½¿ç”¨æ­£ç¢ºçš„æ–¹æ³•å
            settings = await db.get_all_settings()
            ai_provider = settings.get('ai_provider', 'gemini')
            api_key = settings.get('gemini_api_key') or settings.get('openai_api_key')
            
            if not api_key:
                # ä½¿ç”¨é è¨­å›è¦†
                default_messages = [
                    f"å¤§å®¶å¥½å‘€ï½",
                    f"ä»Šå¤©å¤©æ°£çœŸä¸éŒ¯ï¼",
                    f"æœ‰äººåœ¨å—ï¼Ÿ",
                    f"å‰›çœ‹åˆ°ä¸€å€‹æœ‰æ„æ€çš„è©±é¡Œ",
                    f"é€™å€‹å•é¡Œæˆ‘ä¹Ÿå¾ˆæ„Ÿèˆˆè¶£",
                ]
                import random
                return random.choice(default_messages)
            
            # èª¿ç”¨ AI ç”Ÿæˆ
            if ai_provider == 'gemini' and settings.get('gemini_api_key'):
                return await self._call_gemini_for_message(
                    api_key=settings['gemini_api_key'],
                    prompt=prompt
                )
            elif ai_provider == 'openai' and settings.get('openai_api_key'):
                return await self._call_openai_for_message(
                    api_key=settings['openai_api_key'],
                    prompt=prompt
                )
            else:
                # å‚™ç”¨æ–¹æ¡ˆ
                return f"ä½ å¥½ï¼Œæœ‰ä»€éº¼æˆ‘å¯ä»¥å¹«å¿™çš„å—ï¼Ÿ"
                
        except Exception as e:
            print(f"[AITeam] Generate AI message error: {e}", file=sys.stderr)
            return None
    
    async def _call_gemini_for_message(self, api_key: str, prompt: str) -> Optional[str]:
        """èª¿ç”¨ Gemini ç”Ÿæˆæ¶ˆæ¯"""
        import aiohttp
        
        try:
            url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={api_key}"
            
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    url,
                    json={
                        "contents": [{"parts": [{"text": prompt}]}],
                        "generationConfig": {
                            "temperature": 0.8,
                            "maxOutputTokens": 150
                        }
                    },
                    timeout=aiohttp.ClientTimeout(total=30)
                ) as resp:
                    if resp.status == 200:
                        result = await resp.json()
                        text = result.get('candidates', [{}])[0].get('content', {}).get('parts', [{}])[0].get('text', '')
                        return text.strip() if text else None
                    else:
                        return None
        except Exception as e:
            print(f"[AITeam] Gemini API error: {e}", file=sys.stderr)
            return None
    
    async def _call_openai_for_message(self, api_key: str, prompt: str) -> Optional[str]:
        """èª¿ç”¨ OpenAI ç”Ÿæˆæ¶ˆæ¯"""
        import aiohttp
        
        try:
            url = "https://api.openai.com/v1/chat/completions"
            
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    url,
                    headers={"Authorization": f"Bearer {api_key}"},
                    json={
                        "model": "gpt-4o-mini",
                        "messages": [{"role": "user", "content": prompt}],
                        "max_tokens": 150,
                        "temperature": 0.8
                    },
                    timeout=aiohttp.ClientTimeout(total=30)
                ) as resp:
                    if resp.status == 200:
                        result = await resp.json()
                        text = result.get('choices', [{}])[0].get('message', {}).get('content', '')
                        return text.strip() if text else None
                    else:
                        return None
        except Exception as e:
            print(f"[AITeam] OpenAI API error: {e}", file=sys.stderr)
            return None
    
    async def handle_ai_team_send_scriptless_message(self, payload: Dict[str, Any]):
        """ç™¼é€ç„¡åŠ‡æœ¬æ¨¡å¼ç”Ÿæˆçš„æ¶ˆæ¯åˆ°ç›®æ¨™ç”¨æˆ¶"""
        import sys
        
        try:
            execution_id = payload.get('executionId')
            role_id = payload.get('roleId')
            content = payload.get('content')
            target_user_id = payload.get('targetUserId')  # å¯é¸ï¼šæŒ‡å®šç›®æ¨™ç”¨æˆ¶
            
            execution = self._ai_team_executions.get(execution_id) if hasattr(self, '_ai_team_executions') else None
            if not execution:
                print(f"[AITeam] æœªæ‰¾åˆ°åŸ·è¡Œ {execution_id}", file=sys.stderr)
                return
            
            # æ‰¾åˆ°å°æ‡‰çš„å¸³è™Ÿ
            account_match = next(
                (m for m in execution.get('account_matches', []) if m.get('roleId') == role_id),
                None
            )
            
            if not account_match:
                print(f"[AITeam] æœªæ‰¾åˆ°è§’è‰² {role_id} å°æ‡‰çš„å¸³è™Ÿ", file=sys.stderr)
                return
            
            account_id = account_match.get('accountId')
            account_phone = account_match.get('accountPhone')
            
            # ğŸ†• ç²å–ç›®æ¨™ç”¨æˆ¶
            target_users = execution.get('target_users', [])
            current_target_index = execution.get('current_target_index', 0)
            
            if target_user_id:
                # ä½¿ç”¨æŒ‡å®šçš„ç›®æ¨™ç”¨æˆ¶
                target_user = next((u for u in target_users if str(u.get('id')) == str(target_user_id) or str(u.get('telegramId')) == str(target_user_id)), None)
            elif target_users and current_target_index < len(target_users):
                # ä½¿ç”¨ç•¶å‰ç´¢å¼•çš„ç›®æ¨™ç”¨æˆ¶
                target_user = target_users[current_target_index]
            else:
                target_user = None
            
            send_success = False
            
            if target_user:
                telegram_id = target_user.get('telegramId') or target_user.get('id')
                target_name = target_user.get('firstName') or target_user.get('username') or telegram_id
                
                print(f"[AITeam] æº–å‚™ç™¼é€æ¶ˆæ¯åˆ° {target_name} (ID: {telegram_id}), ä½¿ç”¨å¸³è™Ÿ {account_phone}", file=sys.stderr)
                
                # å¯¦éš›ç™¼é€æ¶ˆæ¯ï¼ˆå¸¶æ“¬äººåŒ–å»¶é²ï¼‰
                try:
                    # ğŸ”§ ä¿®å¾©: ä½¿ç”¨æ­£ç¢ºçš„å®¢æˆ¶ç«¯ç²å–æ–¹å¼
                    client = None
                    if account_phone and account_phone in self.telegram_manager.clients:
                        client = self.telegram_manager.clients[account_phone]
                    
                    if client and client.is_connected:
                        # ğŸ†• æ“¬äººåŒ–å»¶é²ï¼šæ¨¡æ“¬æ‰“å­—æ™‚é–“
                        import random
                        typing_delay = self._calculate_typing_delay(content)
                        
                        # ç™¼é€ã€Œæ­£åœ¨è¼¸å…¥ã€ç‹€æ…‹
                        try:
                            from pyrogram.raw.functions.messages import SetTyping
                            from pyrogram.raw.types import SendMessageTypingAction
                            await client.invoke(
                                SetTyping(
                                    peer=await client.resolve_peer(int(telegram_id)),
                                    action=SendMessageTypingAction()
                                )
                            )
                        except Exception as typing_err:
                            print(f"[AITeam] ç™¼é€è¼¸å…¥ç‹€æ…‹å¤±æ•—: {typing_err}", file=sys.stderr)
                        
                        # ç­‰å¾…æ‰“å­—å»¶é²
                        self.send_log(f"âŒ¨ï¸ æ­£åœ¨è¼¸å…¥... ({typing_delay:.1f}ç§’)", "info")
                        await asyncio.sleep(typing_delay)
                        
                        # ç™¼é€ç§èŠæ¶ˆæ¯
                        await client.send_message(int(telegram_id), content)
                        send_success = True
                        
                        # è¨˜éŒ„æ¶ˆæ¯æ­·å²
                        if 'message_history' not in execution:
                            execution['message_history'] = []
                        execution['message_history'].append({
                            'role': account_match.get('roleName'),
                            'content': content,
                            'targetUser': target_name,
                            'timestamp': datetime.now().isoformat(),
                            'isFromCustomer': False
                        })
                        
                        self.send_log(f"ğŸ“¤ [{account_match.get('roleName')}] â†’ {target_name}: {content[:30]}...", "success")
                    else:
                        self.send_log(f"âš ï¸ å¸³è™Ÿ {account_phone} æœªé€£æ¥", "warning")
                except Exception as send_error:
                    print(f"[AITeam] ç™¼é€æ¶ˆæ¯å¤±æ•—: {send_error}", file=sys.stderr)
                    self.send_log(f"âŒ ç™¼é€å¤±æ•—: {str(send_error)[:50]}", "error")
            else:
                print(f"[AITeam] ç„¡ç›®æ¨™ç”¨æˆ¶ï¼Œæ¶ˆæ¯åƒ…è¨˜éŒ„", file=sys.stderr)
                # åƒ…è¨˜éŒ„æ¶ˆæ¯ï¼ˆç”¨æ–¼æ¼”ç¤ºæˆ–æ¸¬è©¦ï¼‰
                self.send_log(f"ğŸ“ [{account_match.get('roleName')}] (æ¨¡æ“¬): {content[:50]}...", "info")
            
            # æ›´æ–°çµ±è¨ˆ
            execution['message_count'] = execution.get('message_count', 0) + 1
            
            self.send_event("ai-team:message-sent", {
                "executionId": execution_id,
                "roleId": role_id,
                "content": content,
                "totalSent": execution['message_count'],
                "targetUser": target_user.get('firstName') if target_user else None,
                "success": send_success
            })
            
        except Exception as e:
            print(f"[AITeam] Send scriptless message error: {e}", file=sys.stderr)
            import traceback
            traceback.print_exc()
    
    async def handle_ai_team_conversion_signal(self, payload: Dict[str, Any]):
        """è™•ç†è½‰åŒ–ä¿¡è™Ÿ"""
        import sys
        
        try:
            execution_id = payload.get('executionId')
            signal = payload.get('signal', '')
            recommended_role = payload.get('recommendedRole', 'sales_expert')
            
            print(f"[AITeam] æª¢æ¸¬åˆ°è½‰åŒ–ä¿¡è™Ÿ: {signal}", file=sys.stderr)
            
            execution = self._ai_team_executions.get(execution_id) if hasattr(self, '_ai_team_executions') else None
            if not execution:
                return
            
            # è¨˜éŒ„è½‰åŒ–ä¿¡è™Ÿ
            if 'conversion_signals' not in execution:
                execution['conversion_signals'] = []
            
            execution['conversion_signals'].append({
                'signal': signal,
                'timestamp': datetime.now().isoformat(),
                'recommended_role': recommended_role
            })
            
            self.send_log(f"ğŸ¯ è½‰åŒ–ä¿¡è™Ÿ: {signal[:50]}...", "success")
            
            # é€šçŸ¥å‰ç«¯åˆ‡æ›è§’è‰²
            self.send_event("ai-team:conversion-signal-detected", {
                "executionId": execution_id,
                "signal": signal,
                "recommendedRole": recommended_role,
                "action": "switch_to_closer"
            })
            
        except Exception as e:
            print(f"[AITeam] Conversion signal error: {e}", file=sys.stderr)
    
    def _calculate_typing_delay(self, content: str) -> float:
        """
        è¨ˆç®—æ“¬äººåŒ–æ‰“å­—å»¶é²ï¼ˆç§’ï¼‰
        åŸºæ–¼æ¶ˆæ¯é•·åº¦å’Œéš¨æ©Ÿå› ç´ 
        """
        import random
        
        # åŸºç¤æ‰“å­—é€Ÿåº¦ï¼šç´„ 5-8 å€‹å­—ç¬¦/ç§’ï¼ˆè€ƒæ…®æ€è€ƒæ™‚é–“ï¼‰
        chars_per_second = random.uniform(5, 8)
        
        # åŸºæ–¼æ¶ˆæ¯é•·åº¦è¨ˆç®—åŸºç¤å»¶é²
        base_delay = len(content) / chars_per_second
        
        # æœ€å°å»¶é² 1.5 ç§’ï¼Œæœ€å¤§å»¶é² 15 ç§’
        base_delay = max(1.5, min(15, base_delay))
        
        # æ·»åŠ éš¨æ©Ÿæ³¢å‹• (Â±20%)
        variance = base_delay * random.uniform(-0.2, 0.2)
        
        # é¡å¤–çš„ã€Œæ€è€ƒæ™‚é–“ã€ï¼ˆ0.5-2ç§’ï¼‰
        think_time = random.uniform(0.5, 2.0)
        
        return base_delay + variance + think_time
    
    def _get_message_interval(self, execution: Dict[str, Any]) -> float:
        """
        ç²å–æ¶ˆæ¯ç™¼é€é–“éš”ï¼ˆç§’ï¼‰
        åŸºæ–¼å¸³è™Ÿå¥åº·åº¦å’ŒåŸ·è¡Œæ¨¡å¼
        """
        import random
        
        mode = execution.get('mode', 'hybrid')
        message_count = execution.get('message_count', 0)
        
        # åŸºç¤é–“éš”
        if mode == 'scriptless':
            # ç„¡åŠ‡æœ¬æ¨¡å¼ï¼šæ›´è‡ªç„¶çš„é–“éš”
            base_interval = random.uniform(30, 90)
        else:
            # åŠ‡æœ¬æ¨¡å¼ï¼šæŒ‰è¨­å®šé–“éš”
            base_interval = random.uniform(20, 60)
        
        # éš¨è‘—æ¶ˆæ¯å¢å¤šï¼Œé©ç•¶å¢åŠ é–“éš”ï¼ˆé¿å…è¢«èªç‚ºæ˜¯æ©Ÿå™¨äººï¼‰
        fatigue_factor = 1 + (message_count // 5) * 0.1  # æ¯5æ¢æ¶ˆæ¯å¢åŠ 10%é–“éš”
        fatigue_factor = min(2.0, fatigue_factor)  # æœ€å¤š2å€
        
        return base_interval * fatigue_factor
    
    async def handle_ai_team_customer_reply(self, payload: Dict[str, Any]):
        """
        è™•ç†ç›®æ¨™å®¢æˆ¶çš„å›è¦†ï¼ˆå®¢æˆ¶å›è¦†è‡ªå‹•ç›£è½ï¼‰
        ç•¶æ”¶åˆ°ç§ä¿¡æ™‚æª¢æŸ¥æ˜¯å¦ç‚º AI åœ˜éšŠåŸ·è¡Œä»»å‹™çš„ç›®æ¨™ç”¨æˆ¶
        """
        import sys
        
        try:
            user_id = str(payload.get('userId', ''))
            username = payload.get('username', '')
            first_name = payload.get('firstName', '')
            text = payload.get('text', '')
            phone = payload.get('phone', '')
            
            # ğŸ”§ Phase 3 èª¿è©¦ï¼šè¨˜éŒ„æ”¶åˆ°çš„ç§èŠæ¶ˆæ¯
            print(f"[AITeam] ğŸ“¨ æ”¶åˆ°ç§èŠæ¶ˆæ¯: userId={user_id}, username={username}, text={text[:50] if text else 'empty'}...", file=sys.stderr)
            
            if not user_id:
                print(f"[AITeam] âš ï¸ è·³éï¼šuserId ç‚ºç©º", file=sys.stderr)
                return
            
            if not hasattr(self, '_ai_team_executions'):
                print(f"[AITeam] âš ï¸ è·³éï¼šæ²’æœ‰åŸ·è¡Œä¸­çš„ä»»å‹™ (_ai_team_executions æœªåˆå§‹åŒ–)", file=sys.stderr)
                return
            
            if len(self._ai_team_executions) == 0:
                print(f"[AITeam] âš ï¸ è·³éï¼šæ²’æœ‰åŸ·è¡Œä¸­çš„ä»»å‹™ (åˆ—è¡¨ç‚ºç©º)", file=sys.stderr)
                return
            
            print(f"[AITeam] ğŸ” æª¢æŸ¥ {len(self._ai_team_executions)} å€‹åŸ·è¡Œä»»å‹™...", file=sys.stderr)
            
            # éæ­·æ‰€æœ‰åŸ·è¡Œä¸­çš„ä»»å‹™ï¼Œæª¢æŸ¥æ˜¯å¦ç‚ºç›®æ¨™ç”¨æˆ¶
            found_match = False
            for execution_id, execution in self._ai_team_executions.items():
                exec_status = execution.get('status', 'unknown')
                if exec_status != 'running':
                    print(f"[AITeam]   - ä»»å‹™ {execution_id}: ç‹€æ…‹={exec_status} (è·³é)", file=sys.stderr)
                    continue
                
                target_users = execution.get('target_users', [])
                print(f"[AITeam]   - ä»»å‹™ {execution_id}: running, ç›®æ¨™ç”¨æˆ¶={len(target_users)} å€‹", file=sys.stderr)
                
                # ğŸ”§ èª¿è©¦ï¼šåˆ—å‡ºç›®æ¨™ç”¨æˆ¶çš„ ID
                for u in target_users:
                    u_telegram_id = str(u.get('telegramId', ''))
                    u_id = str(u.get('id', ''))
                    u_name = u.get('firstName') or u.get('username') or 'unknown'
                    print(f"[AITeam]     - ç›®æ¨™: {u_name}, telegramId={u_telegram_id}, id={u_id}", file=sys.stderr)
                
                # æª¢æŸ¥ç™¼é€è€…æ˜¯å¦ç‚ºç›®æ¨™ç”¨æˆ¶
                is_target = any(
                    str(u.get('telegramId')) == user_id or str(u.get('id')) == user_id
                    for u in target_users
                )
                
                if not is_target:
                    print(f"[AITeam]     âŒ userId {user_id} ä¸åœ¨ç›®æ¨™ç”¨æˆ¶åˆ—è¡¨ä¸­", file=sys.stderr)
                    continue
                
                found_match = True
                print(f"[AITeam] ğŸ¯ ç›®æ¨™ç”¨æˆ¶å›è¦†ï¼åŸ·è¡ŒID: {execution_id}, ç”¨æˆ¶: {first_name or username}", file=sys.stderr)
                
                # è¨˜éŒ„å®¢æˆ¶å›è¦†åˆ°æ¶ˆæ¯æ­·å²
                if 'message_history' not in execution:
                    execution['message_history'] = []
                
                execution['message_history'].append({
                    'role': 'customer',
                    'content': text,
                    'userId': user_id,
                    'username': username,
                    'firstName': first_name,
                    'timestamp': datetime.now().isoformat(),
                    'isFromCustomer': True
                })
                
                # æ›´æ–°çµ±è¨ˆ
                execution['response_count'] = execution.get('response_count', 0) + 1
                
                # ç™¼é€äº‹ä»¶é€šçŸ¥å‰ç«¯
                self.send_event("ai-team:customer-reply", {
                    "executionId": execution_id,
                    "userId": user_id,
                    "username": username,
                    "firstName": first_name,
                    "text": text,
                    "totalResponses": execution['response_count'],
                    "messageCount": len(execution.get('message_history', []))
                })
                
                self.send_log(f"ğŸ’¬ å®¢æˆ¶å›è¦† [{first_name or username}]: {text[:50]}...", "success")
                
                # ğŸ†• æª¢æŸ¥æ˜¯å¦éœ€è¦è‡ªå‹•è§¸ç™¼ä¸‹ä¸€è¼ª AI å°è©±
                mode = execution.get('mode', 'hybrid')
                if mode in ['scriptless', 'hybrid']:
                    # é€šçŸ¥å‰ç«¯ç”Ÿæˆä¸‹ä¸€æ¢æ¶ˆæ¯
                    self.send_event("ai-team:trigger-next-message", {
                        "executionId": execution_id,
                        "customerMessage": text,
                        "customerId": user_id,
                        "customerName": first_name or username
                    })
                
                # åªè™•ç†ç¬¬ä¸€å€‹åŒ¹é…çš„åŸ·è¡Œä»»å‹™
                break
                
        except Exception as e:
            print(f"[AITeam] Customer reply handling error: {e}", file=sys.stderr)
            import traceback
            traceback.print_exc()

    async def handle_ai_team_send_manual_message(self, payload: Dict[str, Any]):
        """
        è™•ç†æ‰‹å‹•ä»‹å…¥ç™¼é€çš„æ¶ˆæ¯
        ç•¶ç”¨æˆ¶åœ¨æ‰‹å‹•æ¨¡å¼ä¸‹ç™¼é€æ¶ˆæ¯æ™‚èª¿ç”¨
        """
        import sys
        
        try:
            execution_id = payload.get('executionId')
            role_id = payload.get('roleId')
            role_name = payload.get('roleName', 'Unknown')
            content = payload.get('content', '')
            target_user_id = payload.get('targetUserId')
            
            if not execution_id or not content:
                return
            
            execution = self._ai_team_executions.get(execution_id)
            if not execution:
                self.send_log(f"æ‰¾ä¸åˆ°åŸ·è¡Œä»»å‹™: {execution_id}", "warning")
                return
            
            # æŸ¥æ‰¾ç›®æ¨™ç”¨æˆ¶å’Œå°æ‡‰å¸³è™Ÿ
            target_users = execution.get('target_users', [])
            account_matches = execution.get('account_matches', [])
            
            # ğŸ”§ ä¿®å¾©: æŸ¥æ‰¾è§’è‰²å°æ‡‰çš„å¸³è™Ÿï¼ˆåŒæ™‚ç²å– phoneï¼‰
            account_id = None
            account_phone = None
            for match in account_matches:
                if match.get('roleId') == role_id:
                    account_id = match.get('accountId')
                    account_phone = match.get('accountPhone')
                    break
            
            if not account_id:
                # ä½¿ç”¨ç¬¬ä¸€å€‹å¯ç”¨å¸³è™Ÿ
                if account_matches:
                    account_id = account_matches[0].get('accountId')
                    account_phone = account_matches[0].get('accountPhone')
            
            # æŸ¥æ‰¾ç›®æ¨™ç”¨æˆ¶çš„ Telegram ID
            telegram_id = None
            target_name = "æœªçŸ¥ç”¨æˆ¶"
            
            if target_user_id:
                for user in target_users:
                    if str(user.get('id')) == str(target_user_id) or str(user.get('telegramId')) == str(target_user_id):
                        telegram_id = user.get('telegramId') or user.get('id')
                        target_name = user.get('firstName') or user.get('username') or str(telegram_id)
                        break
            
            if not telegram_id and target_users:
                current_idx = execution.get('current_target_index', 0)
                if current_idx < len(target_users):
                    user = target_users[current_idx]
                    telegram_id = user.get('telegramId') or user.get('id')
                    target_name = user.get('firstName') or user.get('username') or str(telegram_id)
            
            send_success = False
            
            if telegram_id and account_phone:
                try:
                    # ğŸ”§ ä¿®å¾©: ä½¿ç”¨æ­£ç¢ºçš„å®¢æˆ¶ç«¯ç²å–æ–¹å¼
                    client = None
                    if account_phone in self.telegram_manager.clients:
                        client = self.telegram_manager.clients[account_phone]
                    
                    if client and client.is_connected:
                        # æ“¬äººåŒ–å»¶é²
                        typing_delay = self._calculate_typing_delay(content)
                        
                        # ç™¼é€ã€Œæ­£åœ¨è¼¸å…¥ã€ç‹€æ…‹
                        try:
                            from pyrogram.raw.functions.messages import SetTyping
                            from pyrogram.raw.types import SendMessageTypingAction
                            await client.invoke(
                                SetTyping(
                                    peer=await client.resolve_peer(int(telegram_id)),
                                    action=SendMessageTypingAction()
                                )
                            )
                        except Exception:
                            pass
                        
                        import asyncio
                        await asyncio.sleep(typing_delay)
                        
                        # ç™¼é€æ¶ˆæ¯
                        await client.send_message(int(telegram_id), content)
                        send_success = True
                        
                        self.send_log(f"ğŸ–ï¸ æ‰‹å‹•æ¶ˆæ¯ [{role_name}] â†’ {target_name}: {content[:30]}...", "success")
                        
                except Exception as send_err:
                    print(f"[AITeam] æ‰‹å‹•æ¶ˆæ¯ç™¼é€å¤±æ•—: {send_err}", file=sys.stderr)
                    self.send_log(f"æ‰‹å‹•æ¶ˆæ¯ç™¼é€å¤±æ•—: {send_err}", "error")
            
            # è¨˜éŒ„åˆ°æ¶ˆæ¯æ­·å²
            message_history = execution.get('message_history', [])
            message_history.append({
                'role': role_name,
                'content': content,
                'timestamp': datetime.now().isoformat(),
                'isFromCustomer': False,
                'isManual': True  # æ¨™è¨˜ç‚ºæ‰‹å‹•æ¶ˆæ¯
            })
            execution['message_history'] = message_history
            
            # æ›´æ–°çµ±è¨ˆ
            execution['message_count'] = execution.get('message_count', 0) + 1
            
            # ç™¼é€äº‹ä»¶
            self.send_event("ai-team:manual-message-sent", {
                "executionId": execution_id,
                "roleId": role_id,
                "roleName": role_name,
                "content": content,
                "targetUserId": telegram_id,
                "success": send_success
            })
            
        except Exception as e:
            print(f"[AITeam] Manual message error: {e}", file=sys.stderr)
            import traceback
            traceback.print_exc()

    async def handle_ai_team_send_private_message(self, payload: Dict[str, Any]):
        """
        ğŸ†• P0: è™•ç† AI åœ˜éšŠè‡ªå‹•ç§èŠç™¼é€
        è‡ªå‹•ç™¼é€ç§èŠæ¶ˆæ¯çµ¦ç›®æ¨™ç”¨æˆ¶
        """
        import sys
        
        try:
            execution_id = payload.get('executionId')
            account_id = payload.get('accountId')
            account_phone = payload.get('accountPhone')
            role_id = payload.get('roleId')
            role_name = payload.get('roleName', 'AI')
            target_user_id = payload.get('targetUserId')
            target_user_name = payload.get('targetUserName', 'User')
            content = payload.get('content', '')
            is_first_touch = payload.get('isFirstTouch', False)
            
            if not execution_id or not content or not target_user_id:
                self.send_log("ç§èŠç™¼é€åƒæ•¸ä¸å®Œæ•´", "warning")
                return
            
            print(f"[AITeam] ğŸš€ ç™¼é€ç§èŠ: {role_name} â†’ {target_user_name}", file=sys.stderr)
            self.send_log(f"ğŸš€ é–‹å§‹ç§èŠè§¸é”: {role_name} â†’ {target_user_name}", "info")
            
            send_success = False
            
            # ç²å–å®¢æˆ¶ç«¯ä¸¦ç™¼é€
            try:
                # ğŸ”§ ä¿®å¾©: ä½¿ç”¨æ­£ç¢ºçš„å®¢æˆ¶ç«¯ç²å–æ–¹å¼
                client = None
                if account_phone and account_phone in self.telegram_manager.clients:
                    client = self.telegram_manager.clients[account_phone]
                
                if client and client.is_connected:
                    # æ“¬äººåŒ–å»¶é²
                    typing_delay = self._calculate_typing_delay(content)
                    
                    # ç™¼é€ã€Œæ­£åœ¨è¼¸å…¥ã€ç‹€æ…‹
                    try:
                        from pyrogram.raw.functions.messages import SetTyping
                        from pyrogram.raw.types import SendMessageTypingAction
                        await client.invoke(
                            SetTyping(
                                peer=await client.resolve_peer(str(target_user_id)),
                                action=SendMessageTypingAction()
                            )
                        )
                    except Exception as typing_err:
                        print(f"[AITeam] è¼¸å…¥ç‹€æ…‹ç™¼é€å¤±æ•—: {typing_err}", file=sys.stderr)
                    
                    # ç­‰å¾…æ‰“å­—å»¶é²
                    self.send_log(f"âŒ¨ï¸ æ­£åœ¨è¼¸å…¥... ({typing_delay:.1f}ç§’)", "info")
                    await asyncio.sleep(typing_delay)
                    
                    # ç™¼é€æ¶ˆæ¯
                    # å˜—è©¦å¤šç¨®æ–¹å¼è§£æç”¨æˆ¶ ID
                    try:
                        # å¦‚æœæ˜¯ç´”æ•¸å­—ï¼Œç›´æ¥ä½¿ç”¨
                        if str(target_user_id).isdigit():
                            await client.send_message(int(target_user_id), content)
                        else:
                            # å¯èƒ½æ˜¯ username
                            await client.send_message(str(target_user_id), content)
                        send_success = True
                    except Exception as send_err:
                        print(f"[AITeam] ç™¼é€å¤±æ•—ï¼Œå˜—è©¦ä½¿ç”¨ username: {send_err}", file=sys.stderr)
                        # å˜—è©¦ä½œç‚º username
                        try:
                            await client.send_message(f"@{target_user_id}", content)
                            send_success = True
                        except Exception as retry_err:
                            print(f"[AITeam] é‡è©¦ä¹Ÿå¤±æ•—: {retry_err}", file=sys.stderr)
                    
                    if send_success:
                        log_prefix = "ğŸ¯ é¦–æ¬¡è§¸é”" if is_first_touch else "ğŸ’¬ æ¶ˆæ¯ç™¼é€"
                        self.send_log(f"{log_prefix} [{role_name}] â†’ {target_user_name}: {content[:30]}...", "success")
                else:
                    self.send_log(f"å¸³è™Ÿ {account_phone} æœªé€£æ¥ï¼Œç„¡æ³•ç™¼é€", "error")
                    
            except Exception as client_err:
                print(f"[AITeam] å®¢æˆ¶ç«¯éŒ¯èª¤: {client_err}", file=sys.stderr)
                self.send_log(f"ç™¼é€å¤±æ•—: {client_err}", "error")
            
            # è¨˜éŒ„åˆ°åŸ·è¡Œç‹€æ…‹
            if hasattr(self, '_ai_team_executions') and execution_id in self._ai_team_executions:
                execution = self._ai_team_executions[execution_id]
                message_history = execution.get('message_history', [])
                message_history.append({
                    'role': role_name,
                    'content': content,
                    'timestamp': datetime.now().isoformat(),
                    'isFromCustomer': False,
                    'isFirstTouch': is_first_touch,
                    'targetUserId': target_user_id
                })
                execution['message_history'] = message_history
                execution['message_count'] = execution.get('message_count', 0) + 1
            
            # ç™¼é€äº‹ä»¶
            self.send_event("ai-team:private-message-sent", {
                "executionId": execution_id,
                "roleId": role_id,
                "roleName": role_name,
                "targetUserId": target_user_id,
                "targetUserName": target_user_name,
                "content": content,
                "success": send_success,
                "isFirstTouch": is_first_touch
            })
            
        except Exception as e:
            print(f"[AITeam] Private message error: {e}", file=sys.stderr)
            import traceback
            traceback.print_exc()

    async def handle_ai_team_request_suggestion(self, payload: Dict[str, Any]):
        """
        è™•ç† AI å»ºè­°è«‹æ±‚ï¼ˆæ‰‹å‹•æ¨¡å¼ä¸‹ç‚ºç”¨æˆ¶æä¾›ä¸‹ä¸€æ­¥å»ºè­°ï¼‰
        """
        import sys
        
        try:
            execution_id = payload.get('executionId')
            message_history = payload.get('messageHistory', [])
            current_stage = payload.get('currentStage', 'contact')
            
            if not execution_id:
                return
            
            execution = self._ai_team_executions.get(execution_id)
            if not execution:
                return
            
            # æ§‹å»º AI è«‹æ±‚
            goal = execution.get('goal', '')
            
            # æ ¼å¼åŒ–æ¶ˆæ¯æ­·å²
            history_text = ""
            for msg in message_history[-10:]:
                sender = "å®¢æˆ¶" if msg.get('isFromCustomer') else msg.get('role', 'AI')
                history_text += f"ã€{sender}ã€‘: {msg.get('content', '')}\n"
            
            # AI æç¤ºè©
            prompt = f"""ä½ æ˜¯ä¸€å€‹éŠ·å”®å°ˆå®¶ï¼Œæ­£åœ¨å¹«åŠ©ç”¨æˆ¶é€²è¡Œå®¢æˆ¶è½‰åŒ–ã€‚

ç‡ŸéŠ·ç›®æ¨™ï¼š{goal}
ç•¶å‰éšæ®µï¼š{current_stage}

æœ€è¿‘å°è©±ï¼š
{history_text}

è«‹åŸºæ–¼ä»¥ä¸Šå°è©±ï¼Œçµ¦å‡ºä¸‹ä¸€æ¢æœ€ä½³å›è¦†çš„å»ºè­°ã€‚è¦æ±‚ï¼š
1. è‡ªç„¶ã€å‹å¥½ï¼Œä¸è¦å¤ªéŠ·å”®åŒ–
2. æ¨é€²åˆ°ä¸‹ä¸€å€‹è½‰åŒ–éšæ®µ
3. ç°¡çŸ­ï¼ˆ1-2å¥è©±ï¼‰
4. å¦‚æœå®¢æˆ¶è¡¨ç¾å‡ºèˆˆè¶£ï¼Œå¯ä»¥é©ç•¶æ¨é€²
5. å¦‚æœå®¢æˆ¶æœ‰ç–‘æ…®ï¼Œå…ˆè§£æ±ºç–‘æ…®

ç›´æ¥è¼¸å‡ºå»ºè­°çš„å›è¦†å…§å®¹ï¼Œä¸è¦è§£é‡‹ï¼š"""

            # èª¿ç”¨ AI ç”Ÿæˆå»ºè­°
            suggestion = await self._generate_ai_suggestion(prompt)
            
            if suggestion:
                self.send_event("ai-team:suggestion-update", {
                    "executionId": execution_id,
                    "suggestion": suggestion
                })
            
        except Exception as e:
            print(f"[AITeam] Suggestion request error: {e}", file=sys.stderr)

    async def _generate_ai_suggestion(self, prompt: str) -> str:
        """ç”Ÿæˆ AI å»ºè­°"""
        try:
            # å˜—è©¦ä½¿ç”¨å·²é…ç½®çš„ AI æœå‹™ - ğŸ”§ ä¿®å¾©: ä½¿ç”¨æ­£ç¢ºçš„æ–¹æ³•å
            settings = await db.get_all_settings()
            provider = settings.get('ai_provider', 'gemini')
            api_key = settings.get('gemini_api_key') or settings.get('openai_api_key')
            
            if not api_key:
                return "ï¼ˆéœ€è¦é…ç½® AI API å¯†é‘°æ‰èƒ½ç”Ÿæˆå»ºè­°ï¼‰"
            
            if provider == 'gemini':
                import google.generativeai as genai
                genai.configure(api_key=api_key)
                model = genai.GenerativeModel('gemini-1.5-flash')
                response = await asyncio.get_event_loop().run_in_executor(
                    None,
                    lambda: model.generate_content(prompt)
                )
                return response.text.strip() if response.text else ""
            else:
                import openai
                client = openai.OpenAI(api_key=api_key)
                response = await asyncio.get_event_loop().run_in_executor(
                    None,
                    lambda: client.chat.completions.create(
                        model="gpt-3.5-turbo",
                        messages=[{"role": "user", "content": prompt}],
                        max_tokens=200
                    )
                )
                return response.choices[0].message.content.strip() if response.choices else ""
                
        except Exception as e:
            print(f"[AITeam] AI suggestion generation error: {e}", file=sys.stderr)
            return ""

    # ==================== AI åœ˜éšŠéšŠåˆ—ç®¡ç† ====================
    
    async def handle_ai_team_user_completed(self, payload: Dict[str, Any]):
        """æ¨™è¨˜ç•¶å‰ç”¨æˆ¶è™•ç†å®Œæˆï¼Œæº–å‚™è™•ç†ä¸‹ä¸€å€‹"""
        import sys
        try:
            execution_id = payload.get('executionId')
            user_id = payload.get('userId')
            result = payload.get('result', 'completed')  # completed, converted, skipped
            
            print(f"[AITeam] ç”¨æˆ¶ {user_id} è™•ç†å®Œæˆ: {result}", file=sys.stderr)
            
            # æ›´æ–°æ•¸æ“šåº«è¨˜éŒ„
            await db.execute("""
                UPDATE unified_contacts 
                SET last_contact_at = CURRENT_TIMESTAMP,
                    funnel_stage = CASE WHEN ? = 'converted' THEN 'converted' ELSE funnel_stage END
                WHERE telegram_user_id = ?
            """, (result, user_id))
            
            # ç™¼é€å®Œæˆäº‹ä»¶
            self.send_event("ai-team:user-completed", {
                "executionId": execution_id,
                "userId": user_id,
                "result": result
            })
            
        except Exception as e:
            print(f"[AITeam] User completed error: {e}", file=sys.stderr)
    
    async def handle_ai_team_queue_completed(self, payload: Dict[str, Any]):
        """æ•´å€‹éšŠåˆ—è™•ç†å®Œæˆ"""
        import sys
        try:
            execution_id = payload.get('executionId')
            stats = payload.get('stats', {})
            
            print(f"[AITeam] éšŠåˆ—å®Œæˆ: {execution_id}", file=sys.stderr)
            print(f"[AITeam] çµ±è¨ˆ: ç™¼é€={stats.get('sent', 0)}, å›è¦†={stats.get('replied', 0)}, è½‰åŒ–={stats.get('converted', 0)}", file=sys.stderr)
            
            self.send_log(f"âœ… AI åœ˜éšŠåŸ·è¡Œå®Œæˆ: ç™¼é€ {stats.get('sent', 0)} æ¢ï¼Œå›è¦† {stats.get('replied', 0)} æ¢", "success")
            
            self.send_event("ai-team:execution-completed", {
                "executionId": execution_id,
                "stats": stats
            })
            
        except Exception as e:
            print(f"[AITeam] Queue completed error: {e}", file=sys.stderr)
    
    async def handle_ai_team_next_user(self, payload: Dict[str, Any]):
        """é–‹å§‹è™•ç†ä¸‹ä¸€å€‹ç›®æ¨™ç”¨æˆ¶"""
        import sys
        try:
            execution_id = payload.get('executionId')
            next_user = payload.get('nextUser')
            
            if not next_user:
                print(f"[AITeam] éšŠåˆ—å·²ç©ºï¼Œæ²’æœ‰ä¸‹ä¸€å€‹ç”¨æˆ¶", file=sys.stderr)
                return
            
            user_id = next_user.get('id') or next_user.get('userId')
            username = next_user.get('username', 'Unknown')
            
            print(f"[AITeam] é–‹å§‹è™•ç†ä¸‹ä¸€ç”¨æˆ¶: {username} ({user_id})", file=sys.stderr)
            
            self.send_event("ai-team:next-user-started", {
                "executionId": execution_id,
                "userId": user_id,
                "username": username
            })
            
        except Exception as e:
            print(f"[AITeam] Next user error: {e}", file=sys.stderr)

    async def handle_graceful_shutdown(self):
        """Handle graceful shutdown - disconnect all clients and close database"""
        import sys
        print("[Backend] Graceful shutdown initiated...", file=sys.stderr)
        
        try:
            # 1. Stop monitoring if running
            if self.is_monitoring:
                print("[Backend] Stopping monitoring...", file=sys.stderr)
                try:
                    await self.telegram_manager.stop_monitoring()
                    self.is_monitoring = False
                except Exception as e:
                    print(f"[Backend] Error stopping monitoring: {e}", file=sys.stderr)
            
            # 2. Disconnect all Telegram clients
            print("[Backend] Disconnecting all Telegram clients...", file=sys.stderr)
            try:
                await self.telegram_manager.disconnect_all()
            except Exception as e:
                print(f"[Backend] Error disconnecting clients: {e}", file=sys.stderr)
            
            # 3. Stop scheduler
            print("[Backend] Stopping scheduler...", file=sys.stderr)
            try:
                await scheduler.stop()
            except Exception as e:
                print(f"[Backend] Error stopping scheduler: {e}", file=sys.stderr)
            
            # 4. Close database connection
            print("[Backend] Closing database connection...", file=sys.stderr)
            try:
                await db.close()
            except Exception as e:
                print(f"[Backend] Error closing database: {e}", file=sys.stderr)
            
            # 5. Cancel all background tasks
            print("[Backend] Cancelling background tasks...", file=sys.stderr)
            for task in self.background_tasks:
                try:
                    task.cancel()
                except Exception as e:
                    pass
            
            print("[Backend] Graceful shutdown completed", file=sys.stderr)
            
            # Send confirmation and exit
            self.send_event("shutdown-complete", {"success": True})
            
            # Stop the running flag to exit the main loop
            self.running = False
            
        except Exception as e:
            print(f"[Backend] Error during graceful shutdown: {e}", file=sys.stderr)
            import traceback
            traceback.print_exc(file=sys.stderr)
        
        # Exit the process
        print("[Backend] Exiting...", file=sys.stderr)
        sys.exit(0)


async def main():
    """Main entry point"""
    service = BackendService()
    await service.run()


if __name__ == "__main__":
    # Run the async main function
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        pass

