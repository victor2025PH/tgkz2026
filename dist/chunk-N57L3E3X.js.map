{
  "version": 3,
  "sources": ["src/environments/environment.ts", "src/core/auth.guard.ts"],
  "sourcesContent": ["/**\r\n * 開發環境配置\r\n */\r\nexport const environment = {\r\n  production: false,\r\n  \r\n  // API 模式: 'auto' | 'ipc' | 'http'\r\n  // auto: 自動檢測（Electron 用 IPC，瀏覽器用 HTTP）\r\n  apiMode: 'auto',\r\n  \r\n  // HTTP API 配置（僅 http 模式使用）\r\n  apiBaseUrl: 'http://localhost:8000',\r\n  wsUrl: 'ws://localhost:8000/ws',\r\n  \r\n  // 功能開關\r\n  features: {\r\n    maxAccounts: 999,\r\n    aiEnabled: true,\r\n    teamFeatures: true,\r\n    apiAccess: true,\r\n    debug: true\r\n  },\r\n  \r\n  // 版本信息\r\n  version: '2.1.1',\r\n  buildDate: new Date().toISOString()\r\n};\r\n", "/**\r\n * 認證守衛\r\n * \r\n * 優化設計：\r\n * 1. 支持多種路由保護策略\r\n * 2. 訂閱級別檢查\r\n * 3. 功能權限檢查\r\n * 4. 重定向到登入頁\r\n */\r\n\r\nimport { inject } from '@angular/core';\r\nimport { Router, CanActivateFn, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';\r\nimport { AuthService } from './auth.service';\r\nimport { environment } from '../environments/environment';\r\n\r\n/**\r\n * 基礎認證守衛\r\n * 檢查用戶是否已登入\r\n */\r\nexport const authGuard: CanActivateFn = (\r\n  route: ActivatedRouteSnapshot,\r\n  state: RouterStateSnapshot\r\n) => {\r\n  const authService = inject(AuthService);\r\n  const router = inject(Router);\r\n  \r\n  // 本地版（Electron）不需要認證\r\n  // 必須同時滿足：1) apiMode 為 ipc 2) 在 Electron 環境中\r\n  const isElectron = !!(window as any).electronAPI || !!(window as any).electron;\r\n  if (environment.apiMode === 'ipc' && isElectron) {\r\n    return true;\r\n  }\r\n  \r\n  // SaaS 模式：嚴格檢查認證狀態\r\n  if (authService.isAuthenticated()) {\r\n    // 額外驗證：確保有有效的 token\r\n    const token = authService.accessToken();\r\n    if (token && token.length > 10) {\r\n      return true;\r\n    }\r\n  }\r\n  \r\n  // 清除可能的無效狀態\r\n  authService.clearSession();\r\n  \r\n  // 保存原始 URL 用於登入後重定向\r\n  const returnUrl = state.url;\r\n  router.navigate(['/auth/login'], { queryParams: { returnUrl } });\r\n  return false;\r\n};\r\n\r\n/**\r\n * 訪客守衛\r\n * 已登入用戶無法訪問（如登入頁）\r\n */\r\nexport const guestGuard: CanActivateFn = () => {\r\n  const authService = inject(AuthService);\r\n  const router = inject(Router);\r\n  \r\n  // 嚴格檢查認證狀態\r\n  const isAuthenticated = authService.isAuthenticated();\r\n  const hasValidToken = authService.accessToken() && (authService.accessToken()?.length || 0) > 10;\r\n  \r\n  if (!isAuthenticated || !hasValidToken) {\r\n    return true;\r\n  }\r\n  \r\n  // 已登入，重定向到首頁\r\n  router.navigate(['/dashboard']);\r\n  return false;\r\n};\r\n\r\n/**\r\n * 訂閱級別守衛工廠\r\n * 檢查用戶訂閱級別\r\n */\r\nexport function subscriptionGuard(requiredTier: string): CanActivateFn {\r\n  const tierLevels: Record<string, number> = {\r\n    'free': 0,\r\n    'basic': 1,\r\n    'pro': 2,\r\n    'enterprise': 3\r\n  };\r\n  \r\n  return (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\r\n    const authService = inject(AuthService);\r\n    const router = inject(Router);\r\n    \r\n    // 本地版不限制\r\n    if (environment.apiMode === 'ipc') {\r\n      return true;\r\n    }\r\n    \r\n    if (!authService.isAuthenticated()) {\r\n      router.navigate(['/login'], { queryParams: { returnUrl: state.url } });\r\n      return false;\r\n    }\r\n    \r\n    const userTier = authService.subscriptionTier();\r\n    const userLevel = tierLevels[userTier] || 0;\r\n    const requiredLevel = tierLevels[requiredTier] || 0;\r\n    \r\n    if (userLevel >= requiredLevel) {\r\n      return true;\r\n    }\r\n    \r\n    // 訂閱級別不足，重定向到升級頁面\r\n    router.navigate(['/upgrade'], { \r\n      queryParams: { \r\n        required: requiredTier,\r\n        feature: route.data?.['feature'] || 'this feature'\r\n      } \r\n    });\r\n    return false;\r\n  };\r\n}\r\n\r\n/**\r\n * 功能權限守衛工廠\r\n */\r\nexport function featureGuard(feature: string): CanActivateFn {\r\n  return () => {\r\n    const authService = inject(AuthService);\r\n    const router = inject(Router);\r\n    \r\n    // 本地版不限制\r\n    if (environment.apiMode === 'ipc') {\r\n      return true;\r\n    }\r\n    \r\n    if (authService.hasFeature(feature)) {\r\n      return true;\r\n    }\r\n    \r\n    router.navigate(['/upgrade'], { queryParams: { feature } });\r\n    return false;\r\n  };\r\n}\r\n\r\n/**\r\n * 管理員守衛\r\n */\r\nexport const adminGuard: CanActivateFn = () => {\r\n  const authService = inject(AuthService);\r\n  const router = inject(Router);\r\n  \r\n  const user = authService.user();\r\n  if (user?.role === 'admin') {\r\n    return true;\r\n  }\r\n  \r\n  router.navigate(['/']);\r\n  return false;\r\n};\r\n\r\n/**\r\n * 帳號數量守衛\r\n * 檢查用戶是否可以添加更多帳號\r\n */\r\nexport const accountLimitGuard: CanActivateFn = async () => {\r\n  const authService = inject(AuthService);\r\n  const router = inject(Router);\r\n  \r\n  // 本地版不限制\r\n  if (environment.apiMode === 'ipc') {\r\n    return true;\r\n  }\r\n  \r\n  // TODO: 獲取當前帳號數量並與 maxAccounts 比較\r\n  const maxAccounts = authService.maxAccounts();\r\n  \r\n  // 暫時允許\r\n  return true;\r\n};\r\n"],
  "mappings": ";;;;;;;;;;;AAGO,IAAM,cAAc;EACzB,YAAY;;;EAIZ,SAAS;;EAGT,YAAY;EACZ,OAAO;;EAGP,UAAU;IACR,aAAa;IACb,WAAW;IACX,cAAc;IACd,WAAW;IACX,OAAO;;;EAIT,SAAS;EACT,YAAW,oBAAI,KAAI,GAAG,YAAW;;;;ACN5B,IAAM,YAA2B,CACtC,OACA,UACE;AACF,QAAM,cAAc,OAAO,WAAW;AACtC,QAAM,SAAS,OAAO,MAAM;AAI5B,QAAM,aAAa,CAAC,CAAE,OAAe,eAAe,CAAC,CAAE,OAAe;AACtE,MAAI,YAAY,YAAY,SAAS,YAAY;AAC/C,WAAO;EACT;AAGA,MAAI,YAAY,gBAAe,GAAI;AAEjC,UAAM,QAAQ,YAAY,YAAW;AACrC,QAAI,SAAS,MAAM,SAAS,IAAI;AAC9B,aAAO;IACT;EACF;AAGA,cAAY,aAAY;AAGxB,QAAM,YAAY,MAAM;AACxB,SAAO,SAAS,CAAC,aAAa,GAAG,EAAE,aAAa,EAAE,UAAS,EAAE,CAAE;AAC/D,SAAO;AACT;AAMO,IAAM,aAA4B,MAAK;AAC5C,QAAM,cAAc,OAAO,WAAW;AACtC,QAAM,SAAS,OAAO,MAAM;AAG5B,QAAM,kBAAkB,YAAY,gBAAe;AACnD,QAAM,gBAAgB,YAAY,YAAW,MAAO,YAAY,YAAW,GAAI,UAAU,KAAK;AAE9F,MAAI,CAAC,mBAAmB,CAAC,eAAe;AACtC,WAAO;EACT;AAGA,SAAO,SAAS,CAAC,YAAY,CAAC;AAC9B,SAAO;AACT;",
  "names": []
}
