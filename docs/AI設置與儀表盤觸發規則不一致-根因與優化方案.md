# AI 設置已開啟但儀表盤顯示未啟用、觸發規則無法調用 AI — 根因與優化方案

## 一、問題現象

- **智能引擎設置頁**：AI 已連接、AI 自動聊天開關已打開、全自動模式、自動問候/自動回覆已勾選，且顯示「引擎設置已保存」。
- **儀表盤一鍵運行中心**：AI 聊天顯示「**未啟用**」。
- **觸發規則**：規則已配置為「AI 智能对话(全自动)」，但觸發 0 次、成功 0 次，實際無法調用 AI；另存在「沒有可用的發送帳號」提示。

---

## 二、根因分析（簡要）

| 根因 | 說明 |
|------|------|
| **1. 雙數據源未統一** | 儀表盤/系統狀態讀取的是**全局 `settings` 表**（無 `user_id`）；智能引擎在 Web/SaaS 下保存到**按用戶隔離的 `ai_settings` 表**（有 `user_id`）。兩處讀寫的不是同一套數據，故儀表盤永遠看不到用戶在「智能引擎」頁的開關狀態。 |
| **2. 多租戶下讀寫不一致** | `get_system_status`、一鍵啟動、監控檢查、私信輪詢等均通過 `db.get_ai_settings()` / `db.update_ai_settings()` 訪問**全局 settings**；而 HTTP API 的「獲取/保存 AI 設置」使用 **ai_settings(user_id)**。SaaS 多用戶場景下，儀表盤與「智能引擎」頁的數據源徹底分離。 |
| **3. 發送帳號缺失** | 觸發規則執行「AI 智能对话」時需要**發送帳號**才能把 AI 回覆發出去。若帳號管理中沒有設置為「發送」角色的可用帳號，則規則即使觸發也無法完成發送，表現為「無法調用」或 0 成功。 |
| **4. 前端保存路徑分流** | 智能引擎頁在 Web 模式下可能走 HTTP PUT `/api/v1/ai/settings`（寫入 ai_settings），而 Electron 或部分流程走 `update-ai-chat-settings`（可能寫入全局 settings）。不同入口寫入不同存儲，加劇儀表盤與設置頁不一致。 |

---

## 三、多視角優化方案（無代碼，僅方案）

### 1. 全棧技術總監視角（架構與數據源）

- **統一 AI 開關與模式的「唯一數據源」**
  - 在當前多租戶一庫架構下，明確：**所有「AI 是否啟用、模式、問候/回覆」等開關與策略，只存一份、只從一份讀**。
  - 建議：以**按用戶/租戶隔離的存儲**為準（例如 `ai_settings` 表按 `user_id` 或等價租戶鍵），廢棄或遷移「全局 settings 表」中與 AI 開關/模式相關的項；所有讀寫 AI 開關的後端邏輯（含 get_system_status、一鍵啟動、監控檢查、私信輪詢、觸發規則執行）都改為從該同一套 API/表讀寫。
- **明確寫入路徑**
  - 智能引擎頁「保存設置」無論 Web 還是 Electron，都應調用同一套後端接口，寫入上述唯一數據源；避免同一份 UI 在不同模式下寫入不同表。
- **向後兼容與遷移**
  - 若現網已有全局 `settings` 中的 AI 配置，需提供一次性遷移腳本：按當前登錄用戶或默認租戶寫入 `ai_settings`，並在過渡期後改為僅讀寫 `ai_settings`。

---

### 2. UI/UX 與交互視角

- **儀表盤與設置頁的狀態一致**
  - 儀表盤「AI 聊天」狀態必須與智能引擎頁的「AI 自動聊天」開關、模式一致。實現上依賴後端統一數據源；前端僅需保證：進入儀表盤時拉取的 `system-status` 與進入智能引擎頁時拉取的 AI 設置來自同一後端邏輯。
- **保存後的即時反饋與同步**
  - 在智能引擎頁點擊「保存設置」後，除當前頁顯示「已保存」外，應觸發一次「系統狀態」刷新（或事件），使儀表盤、一鍵運行中心等處的 AI 狀態在無需手動刷新下即可更新。
- **發送帳號不足時的可發現性**
  - 若「沒有可用的發送帳號」會導致觸發規則無法發送 AI 回覆，應在「觸發規則」列表/詳情或一鍵運行中心明確提示：「需要至少一個發送帳號才能發送 AI 回覆」，並提供跳轉到帳號管理的入口。
- **觸發規則 0 次觸發的說明**
  - 規則配置為 AI 響應但「觸發 0 次」時，在 UI 上區分：是「尚未有關鍵詞匹配」還是「已觸發但發送失敗（如缺發送帳號）」。必要時在規則詳情或日誌中給出短語說明，減少用戶困惑。

---

### 3. 數據庫與數據一致性視角

- **表職責與唯一真相**
  - 定義清晰：`settings` 表僅存**全局、與租戶無關**的系統配置；**所有按用戶/租戶的 AI 開關與策略**僅存於 `ai_settings`（或等價的按 user_id/tenant 的表）中，並在 schema 上標註為「AI 運行開關與策略的唯一來源」。
- **讀寫都帶租戶**
  - 所有讀寫 AI 開關/模式的後端方法都應帶上當前請求的 `user_id`（或 tenant_id），從 `ai_settings` 的對應行讀寫；禁止在無租戶上下文下讀寫「當前用戶的 AI 是否啟用」。
- **遷移與審計**
  - 對歷史 `settings` 中與 AI 相關鍵做一次性遷移並記錄；後續僅在 `ai_settings` 上做變更，便於審計與排查「誰在何時改了 AI 開關」。

---

### 4. 核心功能與業務邏輯視角

- **get_system_status 的 AI 狀態來源**
  - `handle_get_system_status` 中「AI 是否啟用、模式」不應再從 `db.get_ai_settings()`（全局 settings）讀取，而應改為從**當前租戶/用戶的 ai_settings** 讀取（與智能引擎保存處一致）。一鍵啟動、監控健康檢查、私信輪詢等同理，統一改為「按當前用戶讀 AI 設置」。
- **觸發規則執行鏈**
  - 規則觸發後執行「AI 智能对话」時：先解析出當前用戶/租戶 → 用該用戶的 AI 設置判斷是否允許 AI 回覆 → 再取該用戶的**發送帳號列表**；若無發送帳號，應在日誌與可選的用戶側提示中明確「因無發送帳號而未發送」，而不是靜默失敗。
- **一鍵啟動與 AI 開關**
  - 一鍵啟動時若會「自動開啟 AI」，寫入的也應是當前用戶的 ai_settings，並在啟動完成後觸發 system-status 刷新，使儀表盤立即顯示「已啟用」。

---

### 5. 代碼質量與可維護性視角

- **單一入口讀寫 AI 開關**
  - 後端對外只暴露一組「按當前請求用戶讀/寫 AI 運行設置」的接口（或內部統一方法），get_system_status、一鍵啟動、觸發規則、私信輪詢等全部經由該入口訪問，避免多處直接查不同表。
- **命名與文檔**
  - 區分「AI 引擎設置」（模型、端點、人格等）與「AI 運行開關」（是否啟用自動聊天、模式、問候/回覆）。在代碼註釋與內部文檔中標明：儀表盤「AI 聊天」對應的正是「AI 運行開關」，且僅來自 ai_settings（按用戶）。
- **測試**
  - 增加場景：當前用戶在智能引擎頁開啟並保存 → 調用 get_system_status → 返回的 ai.enabled 為 true；另一用戶未開啟 → 其 get_system_status 為 false。並覆蓋「無發送帳號時觸發規則不發送」的預期行為。

---

### 6. 安全視角

- **隔離**
  - 嚴禁在未帶租戶/用戶上下文的情況下讀寫「當前用戶的 AI 開關」；否則會造成跨用戶看到或改寫他人 AI 設置。
- **審計**
  - 對 AI 開關、模式的變更做日誌（誰、何時、從何 IP/請求），便於事後排查與合規。

---

### 7. SRE 與性能視角

- **緩存與失效**
  - 若對「當前用戶 AI 是否啟用」做緩存，必須以 user_id（或 tenant_id）為鍵，且保存/一鍵啟動後即時失效該用戶的緩存，避免儀表盤長時間顯示舊狀態。
- **依賴與健康**
  - 儀表盤「AI 聊天」狀態若依賴外部 AI 服務（如 Ollama）的連接狀態，建議與「開關」分開：開關來自數據庫，連接狀態來自健康檢查；避免因短暫連不通就顯示「未啟用」造成誤解。

---

### 8. QA 與邊界用例視角

- **多用戶並行**
  - 用戶 A 開啟 AI、用戶 B 關閉；各自儀表盤與觸發規則只反映自己的開關與發送帳號。
- **無發送帳號**
  - 用戶已開啟 AI 且規則為「AI 智能对话」，但帳號管理中無「發送」角色帳號：預期為規則可觸發、AI 可生成回覆，但發送步驟失敗並有明確日誌/提示。
- **首次保存**
  - 用戶首次在智能引擎頁打開開關並保存後，不刷新頁面切到儀表盤，應在短時間內（或一次輪詢/推送內）看到「已啟用」；可通過「保存後觸發 system-status 刷新」覆蓋。

---

### 9. 商業與產品視角

- **信任與預期**
  - 用戶在「智能引擎」頁看到已連接、已開啟並已保存，會自然預期儀表盤與觸發規則立即生效；若不一致會直接損害對產品可靠性的信任，優先修復可提升留存與口碑。
- **轉化與使用門檻**
  - 「沒有可用的發送帳號」應作為明確的引導步驟：在觸發規則或一鍵運行中心提示「請先到帳號管理添加並設為發送角色」，降低因配置遺漏導致的「以為 AI 沒用」的流失。
- **可觀測性**
  - 在運營側提供「按用戶的 AI 開關與觸發規則執行情況」的簡單統計（如多少用戶開啟了 AI、規則觸發/成功數），便於評估功能使用情況與迭代方向。

---

## 四、實施優先級建議

| 優先級 | 項 | 說明 |
|--------|----|------|
| P0 | 統一 AI 開關數據源 | 儀表盤、get_system_status、一鍵啟動、觸發規則、私信輪詢全部改為「按當前用戶從 ai_settings 讀寫」；棄用或遷移 settings 表中 AI 開關相關項。 |
| P0 | 保存後刷新系統狀態 | 智能引擎頁保存成功後，後端推送或前端請求一次 system-status，使儀表盤即時顯示「已啟用」。 |
| P1 | 發送帳號檢查與提示 | 觸發規則執行前/或一鍵運行中心展示時，檢查當前用戶是否有發送帳號；若無，在 UI 明確提示並引導至帳號管理。 |
| P1 | 觸發規則執行鏈帶租戶與發送帳號 | 規則執行「AI 智能对话」時帶當前用戶上下文取 AI 設置與發送帳號，無發送帳號時記錄日誌並可選提示。 |
| P2 | 遷移腳本與文檔 | 將現有 settings 中 AI 相關項遷移到 ai_settings（按默認/當前用戶），並更新架構文檔標明「AI 運行開關唯一來源」。 |
| P2 | 測試與監控 | 增加多租戶 AI 開關與觸發規則的自動化用例；可選在運營後台增加「AI 啟用/規則執行」的簡單統計。 |

---

## 五、總結

- **根因**：儀表盤與系統狀態讀的是**全局 settings**，智能引擎在 Web 下寫的是**按用戶的 ai_settings**，兩套數據源導致「設置頁已開啟、儀表盤仍顯示未啟用」；觸發規則端除同一問題外，還受「無發送帳號」影響無法完成發送。
- **方向**：以**按用戶的 ai_settings 為 AI 開關與模式的唯一數據源**，所有讀寫（含 get_system_status、一鍵啟動、觸發規則、私信輪詢）都與智能引擎頁對齊；同時在發送側補齊「發送帳號」檢查與提示，並在保存後即時刷新儀表盤狀態。按上述優先級落地即可從根本上消除不一致並恢復觸發規則對 AI 的可用性。

---

## 六、實施結果與本輪優化（已完成）

### 6.1 已實施內容

| 優先級 | 項 | 實施方式 |
|--------|----|----------|
| P0 | 統一 AI 開關數據源 | `db.get_ai_settings()` / `db.update_ai_settings()` 改為讀寫 **ai_settings(user_id, key)**，user_id 由 `get_owner_user_id()` 提供；無數據時回退到舊 **settings** 表。主庫 `_migrate_db` 中增加 **ai_settings** 建表。 |
| P0 | 保存後刷新系統狀態 | 智能引擎保存（`handle_update_ai_chat_settings`）成功後調用 `handle_get_system_status()` 並 `send_event("system-status", status)`，儀表盤即時顯示「已啟用」。 |
| P1 | 發送帳號檢查與提示 | `handle_get_system_status` 增加 `senders_online`/`senders_total` 及 `warnings`；當 AI 已啟用且 `senders_online === 0` 時推送 `NO_SENDER_ACCOUNT` 警告。儀表盤一鍵運行中心在該警告時展示橫幅與「前往帳號管理」按鈕。 |
| P1 | 觸發規則執行鏈帶租戶 | `execute_matching_trigger_rules` 在取帳號前根據規則的 `owner_user_id` 設置 `set_current_tenant`，再 `get_all_accounts()` / AI 生成，結束後 `clear_current_tenant`，確保多用戶下使用規則所屬用戶的發送號與 AI 設置。 |
| P2 | 遷移與表結構 | 新增 **0030_migrate_ai_settings_from_settings**：將 **settings** 表中 AI 相關鍵複製到 **ai_settings(user_id='local_user')**，便於 Electron/單用戶升級後儀表盤正確顯示。 |

### 6.2 在方案基礎上的細化與優化

- **讀取鍵名兼容**：從 **ai_settings** 讀取時對 `autoChatEnabled` / `autoChatMode` / `autoGreeting` 做別名映射為 snake_case，與現有後端與前端（HTTP 保存）兼容。
- **單一建表與回退**：在 **database.py** 的 `_migrate_db` 中統一創建 **ai_settings**，避免僅依賴 keyword 模塊首次調用才建表；**get_ai_settings** 在 **ai_settings** 無行或異常時回退到 **settings**，保證舊庫無縫過渡。
- **觸發規則租戶注入時機**：在選定「第一條規則」後立即根據 `rule.owner_user_id` 注入租戶，再取帳號與執行後續邏輯，避免在無規則或未選規則時改動上下文；並在 `finally` 中清理 tenant token，避免洩漏。
- **儀表盤提示可操作**：`NO_SENDER_ACCOUNT` 不僅提示文案，且提供「前往帳號管理」按鈕，減少用戶找不到入口的問題。

### 6.3 下一階段建議實施與改進

1. **Web 模式保存後刷新**  
   智能引擎在 **純 Web**（僅 HTTP、無 IPC）保存時，前端在 PUT `/api/v1/ai/settings` 成功後主動請求一次「系統狀態」（若存在 GET 則調用，或通過 WebSocket 發送 get-system-status），使儀表盤在 Web 下也能在保存後即時更新。

2. **觸發規則頁內提示**  
   在觸發規則列表頁當存在「AI 智能对话」規則且 `status.accounts.senders_online === 0` 時，在頁內顯示與儀表盤一致的短提示（如「需配置發送帳號才能發送 AI 回覆」+ 跳轉帳號管理），與儀表盤形成雙入口提醒。

3. **自動化測試**  
   為「當前用戶在智能引擎開啟並保存 → get_system_status 返回 ai.enabled true」及「無發送帳號時觸發規則不發送並有日誌/警告」編寫 E2E 或後端單測，回歸防止數據源或租戶上下文再次錯位。

4. **可觀測性（可選）**  
   在運營或管理後台增加「按用戶的 AI 啟用數 / 觸發規則執行次數」的簡單統計，便於評估功能使用與後續迭代。
