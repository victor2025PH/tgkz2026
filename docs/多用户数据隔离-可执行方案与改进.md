# 多用户数据隔离：方案可行性分析与可执行优化方案

## 一、原方案是否足以解决问题

### 1.1 结论：**可以解决，但需落到可执行动作**

原《多用户数据隔离问题-根因分析与优化方案》中的根因判断与多视角方案在方向上是对的：

- 根因：读路径未加租户条件、部分表无 `owner_user_id`、Phase7 错误归属、前端每次加载都弹 toast。
- 方案：统一「共享库 + owner_user_id」、补齐读/写租户条件、移除错误归属、收敛前端提示。

**不足在于**：未指定具体文件、函数、迁移顺序和验收方式，执行时容易遗漏或顺序不当。下面在保留原方案思路的前提下，给出**可执行版本**和**改进点**。

### 1.2 改进要点（相对原方案的增强）

| 改进点 | 说明 |
|--------|------|
| 明确采用「共享库 + owner_user_id」 | 不改为每租户一库，避免大改连接与 mixin 架构；在现有共享连接上统一加过滤与写入 owner。 |
| 统一入口：租户上下文必须可靠 | 确保 HTTP 与 WebSocket 在认证后都设置 `request['tenant_id']` 与 `set_current_tenant()`，且业务层只用 `get_owner_user_id()`，避免漏设导致过滤失效。 |
| 先改读、再改写、最后删 Phase7 | 先让「看到的数据」正确，再保证「写入/更新/删除」带 owner 与校验，最后移除会改写归属的 Phase7。 |
| 清单化文件与函数 | 每个改动点对应到文件路径和函数名，便于排期与 Code Review。 |
| 前端 toast 仅一次 | 用「会话内仅弹一次」标志位，避免切换标签/窗口重复弹「载入 N 条」。 |
| 触发规则更新加归属校验 | `update_trigger_rule` / `delete_trigger_rule` 的 WHERE 中必须带 `owner_user_id = ?`，防止跨户覆盖。 |

---

## 二、可执行方案总览

- **阶段 0**：前置条件（租户上下文 + 表结构）  
- **阶段 1**：读路径租户过滤（leads、聊天模板、触发规则、监控群组、关键词集）  
- **阶段 2**：写路径 owner 写入与归属校验（含 unified_contacts、触发规则 update/delete）  
- **阶段 3**：移除 Phase7 错误归属逻辑  
- **阶段 4**：前端 toast 仅一次 + 错误文案  
- **阶段 5**：验证与回归清单  

以下按阶段列出**具体文件、函数与动作**，便于直接执行与验收。

---

## 三、阶段 0：前置条件

### 0.1 确认租户上下文在业务请求中必设

- **目标**：所有访问租户数据的 API/WS 在认证后都能拿到 `tenant_id`，且 `get_owner_user_id()` 有值。  
- **动作**：  
  - 确认 HTTP 使用 `auth/middleware.py` 的 `create_auth_middleware()`，且顺序在业务路由之前。  
  - 确认 WebSocket 在 `api/http_server.py` 的 `websocket_handler` 里，在处理命令前根据 `request.get('tenant_id')` 或 `request.get('tenant')` 调用 `set_current_tenant(...)`。  
- **验收**：在任意租户接口内打日志或断点，确认 `get_owner_user_id()` 为当前登录用户 ID（非空、非 `local_user`，除非确为 Electron 模式）。

### 0.2 表结构：unified_contacts 增加 owner_user_id

- **目标**：客户名单能按用户隔离，历史数据可迁移。  
- **文件**：  
  - 新建迁移脚本，例如 `backend/migrations/xxxx_add_owner_to_unified_contacts.py`（或在你现有迁移框架下等价脚本）。  
  - 参考 `backend/core/tenant_schema.py` 中 `unified_contacts` 定义，确保与现有列兼容。  
- **动作**：  
  1. `ALTER TABLE unified_contacts ADD COLUMN owner_user_id TEXT;`  
  2. 历史数据迁移策略二选一（或组合）：  
     - **策略 A**：将现有所有行的 `owner_user_id` 设为某个默认值（如 `'legacy'`），后续仅对「当前用户」的查询用 `owner_user_id = ? OR owner_user_id = 'legacy'`（仅在你确认 legacy 可被多用户共享时使用）；  
     - **策略 B（推荐）**：若有其他表可推断归属（如从 `extracted_members` / 采集账号关联），用迁移脚本按业务规则更新 `unified_contacts.owner_user_id`；无法推断的保持 NULL，读路径用 `(owner_user_id = ? OR owner_user_id IS NULL)` 仅对「当前用户」可见（或规定 NULL 仅管理员可见，视产品而定）。  
  3. 若希望严格隔离，迁移后对 `owner_user_id` 加 NOT NULL 默认（新库）或对新插入强制带值。  
- **验收**：表中有 `owner_user_id` 列；历史数据按选定策略填完或标记完毕。

### 0.3 tenant_filter 中统一包含 unified_contacts

- **文件**：`backend/core/tenant_filter.py`  
- **动作**：确认 `TENANT_ISOLATED_TABLES` 中包含 `'unified_contacts'`（若当前没有则加入）。  
- **验收**：`should_apply_tenant_filter('unified_contacts')` 在非 Electron 且已登录时为 True。

---

## 四、阶段 1：读路径租户过滤

所有「只读」列表/详情接口对租户表必须带 `owner_user_id = ?`（或经 `add_tenant_filter` 等价实现）。  
**注意**：`add_tenant_filter` 默认条件为 `owner_user_id = ?`，参数来自 `get_owner_user_id()`；若表名列名不同，需在下方注明。

### 1.1 客户名单（leads）— unified_contacts

- **文件**：`backend/db/campaign_queue_mixin.py`  
- **函数与改动**：  
  - `get_all_leads`：  
    - 将 `FROM unified_contacts WHERE contact_type = 'user'` 的查询改为先 `query = '...'`，再 `query, params = add_tenant_filter(query, 'unified_contacts', params)`，最后 `fetch_all(query, params)`。  
  - `get_leads_with_total`：  
    - 同上，对 `SELECT COUNT(*)... FROM unified_contacts` 与 `SELECT ... FROM unified_contacts` 两处都加 `add_tenant_filter(..., 'unified_contacts', params)`。  
  - `get_leads_paginated`：  
    - 对 `base_query`（FROM unified_contacts WHERE ...）先组好 base_query 与 params，再对整条 SELECT 用 `add_tenant_filter` 加上 owner 条件（注意 ORDER BY/LIMIT/OFFSET 的位置，与 `tenant_filter.add_tenant_filter` 的实现保持一致）。  
- **导入**：在文件顶部或函数内 `from core.tenant_filter import add_tenant_filter`。  
- **验收**：用户 A 与用户 B 各登录，A 有 21 条、B 为 0 条时，B 的发送控制台为 0 条且总数 0。

### 1.2 聊天模板

- **文件**：`backend/db/chat_funnel_mixin.py`  
- **函数**：`get_chat_templates`  
- **改动**：  
  - 将 `SELECT * FROM chat_templates ORDER BY ...` 改为先 `query = 'SELECT * FROM chat_templates ORDER BY usage_count DESC, created_at DESC'`，再 `query, params = add_tenant_filter(query, 'chat_templates', [])`，用 `fetch_all`/cursor 执行 query 与 params。  
- **导入**：`from core.tenant_filter import add_tenant_filter`。  
- **验收**：用户 A 创建模板后，用户 B 登录不可见；B 创建模板 A 不可见。

### 1.3 触发规则（列表与单条）

- **文件**：`backend/db/keyword_group_mixin.py`  
- **函数与改动**：  
  - `get_all_trigger_rules`：  
    - 将 `SELECT * FROM trigger_rules ORDER BY ...` 改为经 `add_tenant_filter(query, 'trigger_rules', [])` 再执行。  
  - `get_active_trigger_rules`：  
    - 将 `SELECT * FROM trigger_rules WHERE is_active = 1 ...` 经 `add_tenant_filter` 加上 owner 条件再执行。  
  - `get_trigger_rule(self, rule_id)`：  
    - 改为 `SELECT * FROM trigger_rules WHERE id = ? AND owner_user_id = ?`，参数为 (rule_id, get_owner_user_id())；若表无 `owner_user_id`，需先加列并迁移（与 chat_templates 类似，应为已有列）。  
- **验收**：用户 A 有一条规则，用户 B 列表为空；B 创建一条后，A 仍只看到自己的那条。

### 1.4 监控群组、关键词集（仅去掉 Phase7，读已过滤）

- **文件**：`backend/db/keyword_group_mixin.py`  
- **说明**：`get_all_groups`、`get_all_keyword_sets` 已使用 `add_tenant_filter`，读路径正确。  
- **本阶段**：仅确认两者在未登录时不会因 Phase7 误改数据（阶段 3 再删 Phase7）。本阶段可只做验收：两用户各自只能看到自己的群组/词集（需先完成阶段 3 移除 Phase7，否则仍会错归属）。

---

## 五、阶段 2：写路径 owner 写入与归属校验

### 2.1 unified_contacts 所有写入带 owner_user_id

- **文件**：  
  - `backend/unified_contacts.py`（所有 `INSERT INTO unified_contacts` 与 `UPDATE unified_contacts`）  
  - `backend/db/campaign_queue_mixin.py`（若有直接写 unified_contacts 处）  
  - `backend/api/business_routes_mixin.py`（score_leads 等中的 UPDATE unified_contacts）  
- **动作**：  
  - 每条 INSERT 增加一列 `owner_user_id`，值来自 `get_owner_user_id()`。  
  - 每条 UPDATE 的 WHERE 中增加 `AND owner_user_id = ?`（或仅更新当前用户的行），避免跨户更新。  
- **注意**：`UnifiedContactsManager` 由 `get_unified_contacts_manager(db)` 取得，若 db 为全局单例，则需在写入时显式传入或从 context 取 `get_owner_user_id()`。  
- **验收**：新采集/导入的客户只出现在当前用户下；用另一用户更新/删除不会影响其他用户数据。

### 2.2 聊天模板删除带归属校验

- **文件**：`backend/db/chat_funnel_mixin.py`  
- **函数**：`delete_chat_template(self, template_id)`  
- **改动**：  
  - `DELETE FROM chat_templates WHERE id = ?` 改为 `WHERE id = ? AND owner_user_id = ?`，参数 (template_id, get_owner_user_id())。  
  - 若影响行数为 0，返回 False（表示无权限或不存在）。  
- **验收**：用户 B 无法通过传 A 的模板 ID 删除 A 的模板。

### 2.3 触发规则：update / delete / toggle 带 owner 校验

- **文件**：`backend/db/keyword_group_mixin.py`  
- **函数与改动**：  
  - `update_trigger_rule(self, rule_id, rule_data)`：  
    - `UPDATE trigger_rules SET ... WHERE id = ?` 改为 `WHERE id = ? AND owner_user_id = ?`，参数末尾加 `get_owner_user_id()`。  
    - 根据 `execute` 返回的影响行数，若为 0 返回 False。  
  - `delete_trigger_rule(self, rule_id)`：  
    - `DELETE FROM trigger_rules WHERE id = ?` 改为 `WHERE id = ? AND owner_user_id = ?`。  
  - `toggle_trigger_rule(self, rule_id, is_active)`：  
    - 同上，WHERE 加 `AND owner_user_id = ?`。  
  - `increment_trigger_rule_stats(self, rule_id, success)`：  
    - WHERE 加 `AND owner_user_id = ?`，避免为他人规则增加统计。  
- **验收**：用户 B 传用户 A 的规则 ID 做更新/删除/切换，后端返回失败或 0 行；B 只能改自己的规则。

### 2.4 触发规则「创建」语义：禁止误用 update

- **文件**：`backend/domain/automation/trigger_handlers_impl.py`  
- **函数**：`handle_save_trigger_rule`  
- **逻辑**：当前已是 `if rule_id: update ... else: add ...`。  
- **改进**：在「更新」分支中，先调用 `get_trigger_rule(rule_id)`；若返回 None 或返回的记录的 `owner_user_id != get_owner_user_id()`，则直接返回错误「無權限修改該規則」或「規則不存在」，不执行 update。这样即使前端误传他人规则 ID，也不会覆盖。  
- **验收**：用户 B 在未过滤时代码曾误传 A 的规则 ID；修复后应得到权限错误而非成功更新。

---

## 六、阶段 3：移除 Phase7 错误归属逻辑

- **文件**：`backend/db/keyword_group_mixin.py`  
- **函数**：`get_all_groups`、`get_all_keyword_sets`  
- **动作**：  
  - 删除两处「Phase7 修復」整块：  
    - `UPDATE monitored_groups SET owner_user_id = ? WHERE owner_user_id IS NULL OR ...`  
    - `UPDATE keyword_sets SET owner_user_id = ? WHERE ...`  
  - 仅保留后面的 `add_tenant_filter` 查询。  
- **说明**：历史 NULL/空 owner 数据不再自动划给当前用户；若需修复，应使用单独的管理/迁移脚本，按业务规则明确归属，而不是在列表查询时改写。  
- **验收**：用户 A 原有群组/词集（无 owner）仍只对 A 可见（若 A 的 tenant 正确）；用户 B 首次访问不会「抢走」A 的数据。

---

## 七、阶段 4：前端「载入 N 条」仅提示一次 + 错误文案

### 7.1 Toast 仅一次

- **文件**：`src/ipc-handlers/data-sync-ipc.ts`  
- **位置**：`leads-paginated` 事件处理中，当前有 `this.toastService.success(\`數據加載完成：共 ${mappedLeads.length} 條\`)`（约第 617 行，当 `!data.hasMore` 时）。  
- **改动**：  
  - 在组件/服务中增加一个标志，例如 `private hasShownLeadsLoadedToast = false`（或放在 state 中）。  
  - 仅在 `!data.hasMore` 且 `!this.hasShownLeadsLoadedToast` 时调用 `this.toastService.success(...)`，并在调用后设 `this.hasShownLeadsLoadedToast = true`。  
  - 若希望「重新加载」时能再弹一次，可提供「重置」入口（如用户点击「刷新」时重置该标志）；否则同一会话只弹一次。  
- **验收**：同一浏览器会话中，多次切换标签或窗口后，不再重复出现「数据加载完成：共 21 条」；新开浏览器首次加载完成仍可弹一次。

### 7.2 「database is locked」友好文案

- **文件**：前端调用保存触发规则、保存模板等接口处（如通过 command/API 的 response 或事件）。  
- **动作**：  
  - 当后端返回错误信息包含 `database is locked` 或错误码对应锁等待时，前端不直接展示原始错误，改为提示「系統繁忙，請稍後再試」；可选：自动重试 1～2 次（带短暂延迟）。  
- **验收**：用户看到的是友好提示，且重试后成功率提升（若后端配合 WAL/busy_timeout 已优化）。

---

## 八、阶段 5：验证与回归清单

### 8.1 多租户数据隔离

- [ ] **客户名单**：用户 A 有 21 条、用户 B 0 条；B 登录后发送控制台为 0；B 采集/添加的客户只出现在 B 的列表。  
- [ ] **监控群组**：A 的群组仅 A 可见；B 的群组仅 B 可见；B 创建新群组后，A 的列表不变。  
- [ ] **关键词集**：同上，互不可见、互不影响。  
- [ ] **聊天模板**：A 与 B 各自只能看到自己的模板；删除仅能删自己的。  
- [ ] **触发规则**：A 有一条、B 没有；B 新建一条后，A 仍只有一条；B 无法更新/删除 A 的规则。

### 8.2 前端行为

- [ ] 同一会话内「数据加载完成：共 N 条」仅出现一次（或按产品约定在刷新后再出现一次）。  
- [ ] 出现锁错误时展示「系統繁忙，請稍後再試」且可重试。

### 8.3 安全与边界

- [ ] 未登录或 Token 无效时，租户数据接口返回 401，不返回他人数据。  
- [ ] 按 ID 的 update/delete（模板、规则等）均校验 owner，横向越权返回错误。

---

## 九、建议执行顺序与工期（参考）

| 顺序 | 内容 | 预估 |
|------|------|------|
| 1 | 阶段 0：表结构 + tenant_filter 含 unified_contacts + 确认租户上下文 | 0.5 天 |
| 2 | 阶段 1：leads / 聊天模板 / 触发规则 读路径过滤 | 1 天 |
| 3 | 阶段 2：unified_contacts 写入 owner + 模板删除 + 触发规则 update/delete 校验 | 1 天 |
| 4 | 阶段 3：移除 Phase7 | 0.5 天 |
| 5 | 阶段 4：前端 toast 一次 + 错误文案 | 0.5 天 |
| 6 | 阶段 5：按清单回归 + 双用户场景测试 | 1 天 |

合计约 **4.5 天**（1 人），可根据并行与风险调整。

---

## 十、总结

- **原方案能否解决问题**：能，前提是落实到「每张表、每个读/写函数」和「迁移与移除 Phase7」的具体动作。  
- **本可执行方案**：在保持「共享库 + owner_user_id」的前提下，按阶段 0～5 的顺序，对**客户名单、监控群组、关键词集、聊天模板、触发规则**统一加读过滤与写归属，移除错误归属逻辑，并收敛前端提示与错误展示。  
- **改进点**：明确采用共享库方案、清单化文件与函数、先读后写再删 Phase7、触发规则更新/删除加归属校验、toast 仅一次，并给出验收清单与建议工期，便于直接排期与执行。

按本可执行方案落地后，多用户间数据将按 `owner_user_id` 严格隔离，且不会因 Phase7 或前端重复提示产生混淆或误覆盖。
