# 多用户数据隔离问题：根因分析与优化方案

> 文档视角：全栈技术总监、UI/UX、数据库与数据完整性、核心功能、代码质量、安全、SRE/性能、QA/边界、商业价值  
> 本文档仅提供分析与方案，不包含具体代码实现。

---

## 一、问题现象汇总

| 序号 | 现象 | 涉及功能 |
|------|------|----------|
| 1 | 两个用户看到相同的客户名单（21 条）；用户二登录后没有自己的登录账号和采集信息，却出现与用户一相同的客户列表 | 发送控制台 / 潜在客户（leads） |
| 2 | 用户二进入监控群组时先看到用户一的群组；用户二创建自己的群组后，用户一的群组从用户二界面消失，仅显示用户二的群组 | 监控群组 |
| 3 | 与监控群组类似：未设置前显示用户一的关键词集；用户二创建新词集后，用户一的词集消失 | 关键词集 |
| 4 | 用户一与用户二的聊天模板完全共用：用户一创建的模板用户二可见，用户二新建的模板用户一也可见 | 聊天模板 |
| 5 | 用户二在触发规则中创建规则失败；创建第一个规则时把用户一的规则替换掉；界面出现「database is locked」 | 触发规则 |
| 6 | 两个浏览器（无痕 + 正常）切换时，每次切换都会弹出「载入 21 条数据」的相同提示 | 前端加载与提示 |

仅有「账号信息」在用户间是独立的，其余业务数据存在混用、覆盖或误展示。

---

## 二、根因分析（技术层面）

### 2.1 架构与数据层

- **双轨并存、未统一**  
  - 存在两种隔离思路：**按租户的独立库**（`get_tenant_connection()` / `tenant_xxx.db`）与 **共享库 + `owner_user_id` 过滤**（`add_tenant_filter`）。  
  - 实际业务读写（leads、聊天模板、触发规则、部分监控/关键词）走的是**共享连接 + 单库**，未使用租户库连接，也未在查询中统一施加租户条件。

- **读路径未做租户过滤**  
  - **客户名单（leads）**：从 `unified_contacts` 查询时仅按 `contact_type = 'user'` 过滤，**没有任何 `owner_user_id` 或租户维度**；且 `unified_contacts` 表结构本身未包含 `owner_user_id` 字段，无法做行级归属。  
  - **聊天模板**：`get_chat_templates()` 直接 `SELECT * FROM chat_templates`，未加租户条件；写入时虽写了 `owner_user_id`，但读未过滤，导致多用户看到同一批模板。  
  - **触发规则**：`get_all_trigger_rules()` / `get_active_trigger_rules()` 同样未加租户过滤；列表展示所有用户的规则，用户二「创建」时若前端或后端误用同一 ID，会变成**更新**用户一的规则，表现为「替换」。

- **监控群组 / 关键词集：过滤与「修复」逻辑并存**  
  - 读路径已使用 `add_tenant_filter`，但存在 **Phase7「修复」逻辑**：将 `owner_user_id` 为 NULL 或 `'local_user'` 的行**批量更新为当前用户**。  
  - 结果：用户一的历史数据若未带 `owner_user_id`，在用户二首次访问时被**错误地归属给用户二**，用户二创建新数据后，这些数据就只出现在用户二名下，用户一界面「消失」实为被改主。

- **租户上下文依赖请求链路**  
  - 租户 ID 依赖认证中间件（如 auth middleware）设置 `request['tenant']` / `request['tenant_id']`，并通过 `set_current_tenant()` 写入 context。  
  - 若某请求未走认证或未带 Token（如部分 WebSocket 首次握手、或未带 Bearer 的请求），`get_user_id()` 为空，`should_apply_tenant_filter` 为 false，所有依赖「当前用户」的过滤都不会生效，等价于看到全局数据。

### 2.2 触发规则「替换」与「database is locked」

- **替换**：要么后端在「创建」时误用了已有规则 ID 走了 update，要么前端在编辑/创建时传了同一 ID；在无租户过滤的情况下，更新会直接改到唯一可见的那条规则（用户一的）。  
- **database is locked**：SQLite 单写、多连接并发写或长时间持锁会导致锁等待；多用户共享同一库文件且无连接池/超时策略时，用户二保存规则时易与用户一或其它请求冲突。

### 2.3 前端「载入 21 条数据」反复出现

- 每次收到 `initial-state` / `initial-state-data`（或 leads 更新）时，前端会 toaster 提示「数据加载完成：共 N 条」（N 为当前 leads 条数，如 21）。  
- 切换浏览器/标签页会触发重新请求或重新拉取初始状态；由于后端未按用户隔离，两用户拿到的是同一批 21 条，且每次切换都弹一次提示，形成「每次切换都弹出相同 21 条」的体验。

---

## 三、多视角优化方案（无代码，仅方案）

### 3.1 全栈技术总监视角：统一隔离模型与落地顺序

- **明确唯一隔离模型**  
  - 在「每租户独立库」与「共享库 + 行级 `owner_user_id`」中选一作为主方案，并在全栈（后端 API、WebSocket、定时任务、迁移脚本）统一执行。  
  - 若选**独立库**：所有业务读写必须通过 `get_tenant_connection()` 获取当前租户连接，禁止再使用全局/共享连接访问租户数据。  
  - 若选**共享库 + owner**：所有租户表必须包含 `owner_user_id`，且**所有**读/写/删/统计接口统一通过 `add_tenant_filter` 或等价方式施加租户条件；禁止裸查、裸更新。

- **落地顺序建议**  
  1. 认证与租户上下文：保证所有 API/WS 入口在认证后必设 `tenant_id` 与 `set_current_tenant`，未认证不允许访问任何租户数据接口。  
  2. 数据模型：为尚未具备 `owner_user_id` 的表（如 `unified_contacts`）做 schema 变更与数据迁移，并为历史数据按业务规则补全 owner。  
  3. 读路径：按模块（leads、聊天模板、触发规则、监控群组、关键词集）逐个为查询加上租户条件，并移除或重写「将 NULL owner 归为当前用户」的 Phase7 逻辑，改为仅过滤或仅修复当前租户的脏数据。  
  4. 写路径：所有 insert/update 明确设置 `owner_user_id`，且 update/delete 必须带租户条件，防止跨户覆盖。  
  5. 前端：初始状态与列表接口按当前用户拉取，toast 仅在真正「首次加载完成」时提示一次，避免每次焦点/切换都弹。

### 3.2 UI/UX 与交互视角

- **加载与提示**  
  - 「数据加载完成：共 N 条」改为：仅在一次会话内**首次**加载 leads 完成时提示；标签页切换、窗口切换不再重复弹同一提示。  
  - 多窗口/多标签时，考虑「当前窗口是否已加载过」的状态，避免每个窗口都弹一遍。

- **多用户场景下的心智模型**  
  - 发送控制台、监控群组、关键词集、聊天模板、触发规则均应在界面/文案上让用户明确感知「仅本人数据」（如空状态提示「您还没有添加…」而非「暂无数据」）。  
  - 若存在「模板市场」等跨用户能力，应在产品上明确区分「我的模板」与「公共/市场模板」，而不是当前这种混在一起的效果。

- **错误与锁冲突**  
  - 「database is locked」应对用户展示为友好文案（如「系统繁忙，请稍后再试」），并在前端做重试或延迟重试，避免裸报错。

### 3.3 数据库与数据完整性视角

- **表结构**  
  - 所有需隔离的租户表必须有 `owner_user_id`（或等效租户键），且 NOT NULL（或通过默认值 + 约束保证写入时必有值）。  
  - `unified_contacts` 增加 `owner_user_id`，并做历史数据迁移（按来源、采集账号等业务规则推断或标记为「需人工归属」）。

- **查询规范**  
  - 所有 SELECT/UPDATE/DELETE 在租户表上必须带 `owner_user_id = :current_user_id`（或通过统一封装保证）。  
  - 禁止在业务层用「UPDATE … SET owner_user_id = ? WHERE owner_user_id IS NULL」把未归属数据批量划给当前用户；修复脚本应限定在明确属于「当前租户但漏填」的数据上。

- **并发与锁**  
  - 若继续使用 SQLite 共享库：写操作使用短事务、避免长事务持锁；对高并发写考虑 WAL、busy_timeout、或写队列。  
  - 若采用每租户一库：从根本避免跨户锁竞争，仍建议每个租户库配置 WAL 与合理 timeout。

### 3.4 核心功能视角

- **发送控制台 / 客户名单**  
  - 数据源（如 `unified_contacts` 或等价表）必须按 `owner_user_id` 过滤；采集、同步、导入写库时必须写入当前用户的 `owner_user_id`。  
  - 确保「登录账号」「采集信息」与客户名单来自同一租户上下文，避免用户二看到用户一的账号与采集结果。

- **监控群组 / 关键词集**  
  - 读：仅返回当前用户的群组/词集；移除「将 NULL owner 改为当前用户」的自动归属逻辑，或仅在管理端、迁移脚本中针对明确脏数据执行。  
  - 写：创建/更新时强制带 `owner_user_id`，且更新/删除时条件中必须包含 `owner_user_id`。

- **聊天模板**  
  - 读：`get_chat_templates()` 必须带 `owner_user_id = ?`。  
  - 写：已有 `owner_user_id` 的写入保持；删除时校验 `owner_user_id` 防止删他人模板。

- **触发规则**  
  - 读：列表与单条查询均按 `owner_user_id` 过滤。  
  - 创建：仅 INSERT，且必须设置 `owner_user_id`；禁止在「创建」语义下对他人规则做 UPDATE。  
  - 更新/删除：WHERE 中必须包含 `id` + `owner_user_id`，避免误改他人规则。  
  - 若出现「创建失败」：区分「数据库锁」「唯一约束」「权限」等，返回明确错误类型，便于前端提示与重试策略。

### 3.5 代码质量与开发视角

- **单一数据访问层**  
  - 租户表访问集中到少数模块或封装函数；所有 SQL 经同一层生成，便于统一加 `owner_user_id` 条件和审计。

- **清单与回归**  
  - 维护「租户表 + 读/写接口」清单，每次改表或新增接口时检查是否已加租户条件；在 Code Review 中强制检查。

- **测试**  
  - 多租户用例：同一接口用用户 A、用户 B 分别调用，验证 A 看不到 B 的数据、B 的创建不会覆盖 A。  
  - 覆盖：客户名单、监控群组、关键词集、聊天模板、触发规则的 CRUD 及列表接口。

### 3.6 安全视角

- **横向越权**  
  - 所有按 ID 访问资源的接口（如 get/update/delete rule by id）必须在后端校验「该 ID 属于当前 `owner_user_id`」，不能仅靠前端不传他人 ID。

- **租户上下文**  
  - 任何未带有效认证的请求不得设置 `tenant_id`；未认证用户不得访问租户数据接口（返回 401），避免「无 token 时看到全局数据」的漏洞。

- **审计**  
  - 对敏感写操作（如批量更新、删除、归属变更）记录操作人、租户、时间，便于事后排查越权或误操作。

### 3.7 SRE 与性能视角

- **连接与锁**  
  - 若使用共享 SQLite：配置 WAL、合理 `busy_timeout`，并控制并发写；必要时对「保存规则」等写操作做队列或限流，降低「database is locked」概率。  
  - 若使用每租户一库：管理连接池与空闲释放，避免连接数无限增长。

- **监控与告警**  
  - 对「database is locked」、写超时、租户上下文缺失（如日志中 tenant_id 为空却访问了租户接口）做监控与告警。

### 3.8 QA 与边界视角

- **测试场景**  
  - 两用户（如两个浏览器/无痕）同时登录；各自创建客户、群组、词集、模板、规则；验证彼此不可见、不可改。  
  - 用户二「创建第一条规则」：验证为新增一条，且用户一原有规则仍存在且未被修改。  
  - 快速切换浏览器/标签：验证 toast 不重复刷「载入 21 条数据」，且每用户仅看到自己的条数。

- **边界**  
  - 历史数据中 `owner_user_id` 为 NULL 或无效：迁移策略（归属到某用户 vs 标记待处理）、以及迁移后新逻辑下是否仍会误归属，需专门用例覆盖。

### 3.9 商业价值视角

- **信任与合规**  
  - 多用户/多租户场景下，数据混用会直接导致客户信任与合规风险；修复是 SaaS 可售性的前提。

- **优先级**  
  - 发送控制台（客户名单）和触发规则直接影响日常使用与自动化效果，建议与「聊天模板 / 监控群组 / 关键词集」一起作为同一期数据隔离上线，避免只修部分模块导致现象仍存在。

- **沟通**  
  - 若已有客户反馈「看到别人数据」或「自己的数据消失」，建议在修复后做简短说明（如「已修复多用户数据隔离问题」），不涉及实现细节即可。

---

## 四、总结：为什么只有账号独立而其它不独立

- **账号信息**走的是已做租户隔离的路径（或仅读当前用户的账号列表），因此表现正常。  
- **客户名单、监控群组、关键词集、聊天模板、触发规则**要么未在读写路径上加租户条件，要么在「修复」逻辑中错误地改写了归属，再加上共享库与 SQLite 锁竞争，形成：  
  - 两用户看到同一批数据；  
  - 用户二创建后「覆盖」或「替换」用户一的数据；  
  - 切换浏览器时反复收到同一条数的加载提示。

按上述多视角方案统一隔离模型、补齐读/写租户条件、移除错误归属逻辑、并收敛前端提示行为，即可实现用户间数据真正独立且稳定可维护。
