# 📋 TG-AI智控王 技術架構摘要

**為技術顧問準備的系統架構文檔**

---

## 目錄

1. [核心文件結構](#1-核心文件結構)
2. [數據流向邏輯](#2-數據流向邏輯)
3. [當前狀態管理](#3-當前狀態管理)
4. [關鍵函數代碼片段](#4-關鍵函數代碼片段)
5. [前後端通訊架構](#5-前後端通訊架構)
6. [TTS 說明](#6-tts-說明)
7. [升級建議方向](#7-升級建議方向多智能體協同)

---

## 1. 核心文件結構

### 📁 按功能分類的核心模組

| 類別 | 文件 | 職責 |
|------|------|------|
| **帳號連接管理** | `telegram_client.py` | Pyrogram 客戶端管理器，處理多帳號連接、登錄、Session 維護 |
| | `config.py` | 配置管理，Session 路徑 (`backend/sessions/`) |
| | `device_fingerprint.py` | 設備指紋生成（防封） |
| | `qr_auth_manager.py` | QR 碼登錄支持 |
| **消息監聽與處理** | `private_message_handler.py` | 私信消息處理器，觸發 AI 自動回復 |
| | `discussion_watcher.py` | 群組消息監聽 |
| | `keyword_matcher.py` / `trie_keyword_matcher.py` | 關鍵詞匹配引擎 |
| **消息發送** | `message_queue.py` | 消息隊列系統，帳號輪換、限流、重試 |
| | `ad_broadcaster.py` | 廣告廣播發送 |
| | `marketing_outreach_service.py` | 營銷外發服務 |
| **AI/LLM 調用** | `ai_auto_chat.py` | AI 自動聊天核心，調用 Ollama/OpenAI API |
| | `ai_context_manager.py` | 上下文管理（對話歷史、用戶畫像） |
| | `ai_response_strategy.py` | 回復策略管理 |
| | `telegram_rag_system.py` | RAG 知識增強系統 |
| | `knowledge_learner.py` | 知識學習模組 |
| **數據存儲** | `database.py` | SQLite 數據庫（帳號、聊天記錄、用戶畫像等） |
| | `vector_memory.py` | 向量記憶系統 |
| **主入口** | `main.py` | IPC 通訊入口，接收 Electron 命令 |

### 📂 目錄結構概覽

```
tgkz2026/
├── backend/                     # Python 後端
│   ├── main.py                 # 主入口，IPC 通訊
│   ├── telegram_client.py      # Telegram 客戶端管理
│   ├── ai_auto_chat.py         # AI 自動聊天
│   ├── private_message_handler.py  # 私信處理
│   ├── message_queue.py        # 消息隊列
│   ├── database.py             # 數據庫操作
│   ├── config.py               # 配置管理
│   ├── sessions/               # Session 文件存儲
│   │   └── {phone}.session
│   ├── data/                   # 數據存儲
│   │   ├── tgmatrix.db        # 主數據庫
│   │   └── tgai_server.db     # 卡密數據庫
│   └── chroma_db/              # 向量數據庫 (RAG)
├── src/                        # Angular 前端
│   ├── app.component.ts        # 主組件
│   └── ...
├── electron.js                 # Electron 主進程
└── admin-panel/                # 管理後台 (Vue.js)
```

---

## 2. 數據流向邏輯

### 🔄 消息接收與 AI 回復流程

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           Telegram 服務器                                    │
└────────────────────────────────────┬────────────────────────────────────────┘
                                     │ WebSocket/MTProto
                                     ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  telegram_client.py (Pyrogram Client)                                       │
│  • 多帳號連接管理                                                            │
│  • 消息監聽註冊 (MessageHandler)                                             │
└────────────────────────────────────┬────────────────────────────────────────┘
                                     │ 觸發 on_message 回調
                                     ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  private_message_handler.py                                                 │
│  • 過濾：只處理私信、非自己發送、非 DNC                                       │
│  • 保存消息到 database.py (chat_history 表)                                  │
│  • 更新用戶畫像 (user_profiles 表)                                           │
└────────────────────────────────────┬────────────────────────────────────────┘
                                     │ 調用 AI 處理
                                     ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  ai_auto_chat.py (AIAutoChatService)                                        │
│  ├── 檢查 auto_chat_enabled 開關                                             │
│  ├── 構建上下文 (ai_context_manager.py)                                      │
│  │   ├── 獲取歷史消息 (最近 20 條)                                           │
│  │   ├── 獲取用戶畫像 (漏斗階段、興趣度)                                      │
│  │   └── 獲取 RAG 相關知識 (telegram_rag_system.py)                          │
│  └── 調用 _call_ai_api()                                                     │
└────────────────────────────────────┬────────────────────────────────────────┘
                                     │ HTTP POST
                                     ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  外部 LLM API (Ollama / OpenAI 兼容)                                         │
│  端點: local_ai_endpoint (用戶配置)                                          │
│  格式: POST /v1/chat/completions 或 /api/generate                           │
│  模型: local_ai_model (如 qwen2.5:7b)                                        │
└────────────────────────────────────┬────────────────────────────────────────┘
                                     │ JSON Response
                                     ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  ai_auto_chat.py (處理回復)                                                  │
│  ├── 解析 AI 回復 (OpenAI/Ollama 兩種格式)                                   │
│  ├── 質量檢查 (ai_quality_checker.py)                                        │
│  └── 保存 AI 回復到 chat_history                                             │
└────────────────────────────────────┬────────────────────────────────────────┘
                                     │ 根據模式處理
                          ┌──────────┴──────────┐
                          ▼                     ▼
              ┌───────────────────┐  ┌───────────────────┐
              │  全自動模式 (full) │  │ 半自動模式 (semi) │
              │  直接發送消息      │  │ 返回前端等待確認   │
              └─────────┬─────────┘  └─────────┬─────────┘
                        │                      │
                        ▼                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  Pyrogram client.send_message()                                             │
│  或 message_queue.py (排隊發送)                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 📤 主動發送消息流程

```
Electron 前端 
    │
    │ IPC (stdin/stdout)
    ▼
main.py (BackendService)
    │
    │ 調用 send_message / queue_message
    ▼
message_queue.py
    │
    ├── AccountRotator 選擇最佳帳號
    │   └── 計算健康分數、檢查限額、避開冷卻
    │
    └── 發送消息
        │
        ▼
telegram_client.py
    │
    └── Pyrogram client.send_message()
```

### 📥 群組關鍵詞監聽流程

```
telegram_client.py (MessageHandler)
    │
    │ 監聽指定群組消息
    ▼
keyword_matcher.py / trie_keyword_matcher.py
    │
    │ 匹配關鍵詞
    ▼
觸發規則 (trigger_rules)
    │
    ├── 自動問候新用戶
    ├── 發送預設模板
    └── 觸發 AI 回復
```

---

## 3. 當前狀態管理

### 🗄️ 數據存儲架構

| 存儲類型 | 路徑 | 用途 |
|----------|------|------|
| **主數據庫** | `backend/data/tgmatrix.db` | 帳號、群組、關鍵詞、聊天記錄、用戶畫像 |
| **卡密數據庫** | `backend/data/tgai_server.db` | 會員等級、卡密、訂單 |
| **Session 文件** | `backend/sessions/{phone}.session` | Pyrogram 登錄憑證 |
| **向量數據庫** | `backend/chroma_db/` | RAG 知識向量 |

### 📊 帳號區分機制

```python
# telegram_client.py 中的多帳號管理
class TelegramClientManager:
    clients: Dict[str, Client] = {}        # phone -> Pyrogram Client
    client_status: Dict[str, str] = {}     # phone -> 狀態 (Online/Offline/...)
    monitoring_info: Dict[str, Dict] = {}  # phone -> 監控配置
    keyword_matchers: Dict[str, KeywordMatcher] = {}  # phone -> 關鍵詞匹配器
```

**Session 文件命名規則：**

```
backend/sessions/
├── 8613812345678.session     # 帳號1
├── 8613987654321.session     # 帳號2
├── 8618888888888.session     # 帳號3
└── ...
```

### 💬 對話上下文存儲

**chat_history 表結構：**

```sql
CREATE TABLE chat_history (
    id INTEGER PRIMARY KEY,
    user_id TEXT NOT NULL,           -- Telegram 用戶 ID
    role TEXT NOT NULL,              -- 'user' 或 'assistant'
    content TEXT NOT NULL,           -- 消息內容
    account_phone TEXT,              -- 使用的帳號
    source_group TEXT,               -- 來源群組
    message_id TEXT,                 -- Telegram 消息 ID
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**user_profiles 表結構 (用戶畫像)：**

```sql
CREATE TABLE user_profiles (
    user_id TEXT PRIMARY KEY,
    username TEXT,
    first_name TEXT,
    last_name TEXT,
    funnel_stage TEXT,               -- 漏斗階段 (new/contacted/replied/interested/negotiating/converted/churned)
    interest_level INTEGER,          -- 興趣度 1-5
    total_messages INTEGER DEFAULT 0,
    first_contact_at TIMESTAMP,
    last_interaction TIMESTAMP
);
```

**ai_memories 表結構 (長期記憶)：**

```sql
CREATE TABLE ai_memories (
    id INTEGER PRIMARY KEY,
    user_id TEXT NOT NULL,
    memory_type TEXT,                -- 'preference' / 'fact' / 'important'
    content TEXT,
    importance REAL DEFAULT 0.5,
    created_at TIMESTAMP
);
```

---

## 4. 關鍵函數代碼片段

### 🤖 調用 LLM (Ollama/OpenAI)

**文件：** `backend/ai_auto_chat.py`

```python
async def _call_ai_api(self, messages: List[Dict[str, str]]) -> Optional[str]:
    """調用 AI API 端點"""
    request_data = {
        "model": self.local_ai_model or "default",
        "messages": messages,
        "max_tokens": 500,
        "temperature": 0.7,
        "stream": False
    }
    
    # 智能檢測端點格式，避免路徑重複
    base_endpoint = self.local_ai_endpoint.rstrip('/')
    endpoints_to_try = []
    
    # 檢查用戶是否已經提供完整路徑
    if '/v1/chat/completions' in base_endpoint or '/chat/completions' in base_endpoint:
        endpoints_to_try.append(base_endpoint)
    elif '/api/generate' in base_endpoint:
        endpoints_to_try.append(base_endpoint)
    else:
        # 用戶只提供基礎 URL，嘗試多種路徑
        endpoints_to_try = [
            f"{base_endpoint}/v1/chat/completions",  # OpenAI 格式
            f"{base_endpoint}/chat/completions",
            f"{base_endpoint}/api/generate",          # Ollama 格式
            base_endpoint
        ]
    
    async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=60)) as session:
        for endpoint in endpoints_to_try:
            try:
                async with session.post(endpoint, json=request_data) as response:
                    if response.status == 200:
                        result = await response.json()
                        
                        # OpenAI 格式
                        if 'choices' in result:
                            return result['choices'][0]['message']['content']
                        
                        # Ollama 格式
                        if 'response' in result:
                            return result['response']
                        
                        # 直接內容
                        if 'content' in result:
                            return result['content']
            except Exception:
                continue
    
    # 所有端點都失敗，使用備用回覆
    return self._get_fallback_response(messages)
```

### 📨 發送 Telegram 消息

**文件：** `backend/private_message_handler.py`

```python
async def handle_private_message(client_instance: Client, message: Message):
    """處理私信並觸發 AI 回復"""
    # 只處理私信（非群組消息）
    if message.chat.type.name != "PRIVATE":
        return
    
    # 跳過自己發送的消息
    if message.outgoing:
        return
    
    user = message.from_user
    user_id = str(user.id)
    username = safe_get_username(user)
    message_text = sanitize_text(message.text or '')
    
    if not message_text:
        return
    
    # 保存消息到聊天歷史
    await db.add_chat_message(
        user_id=user_id,
        role='user',
        content=message_text,
        account_phone=phone,
        message_id=str(message.id)
    )
    
    # 檢查 AI 自動聊天是否啟用
    ai_settings = await db.get_ai_settings()
    auto_chat_enabled = ai_settings.get('auto_chat_enabled', 0) == 1
    
    if not auto_chat_enabled:
        return
    
    # 生成 AI 回復
    ai_response = await ai_auto_chat.process_incoming_message(
        user_id=user_id,
        username=username,
        message=message_text,
        account_phone=phone,
        first_name=user.first_name
    )
    
    if ai_response:
        mode = ai_auto_chat.settings.get('auto_chat_mode', 'semi')
        
        if mode == 'full':
            # 全自動模式：直接發送消息
            await client_instance.send_message(
                chat_id=int(user_id),
                text=ai_response
            )
            
            # 保存 AI 回復到聊天歷史
            await db.add_chat_message(
                user_id=user_id,
                role='assistant',
                content=ai_response,
                account_phone=phone
            )
        else:
            # 半自動模式：發送事件到前端等待確認
            self.event_callback("ai-response-generated", {
                "userId": user_id,
                "username": username,
                "userMessage": message_text,
                "aiResponse": ai_response,
                "mode": mode,
                "requiresApproval": True
            })
```

### 🔄 消息隊列與帳號輪換

**文件：** `backend/message_queue.py`

```python
class AccountRotator:
    """帳號輪換器 - 自動選擇最適合的發送帳號"""
    
    def __init__(self, database):
        self.database = database
        self.strategy = RotationStrategy.HEALTH_FIRST  # 默認健康優先
        self._cooldown_accounts: Dict[str, float] = {}  # 帳號冷卻時間
        self._flood_wait_accounts: Dict[str, float] = {}  # FloodWait 帳號
    
    def calculate_health_score(self, account: Dict[str, Any]) -> float:
        """計算帳號健康分數 (0-100)"""
        score = 100.0
        phone = account.get('phone')
        
        # 1. 基礎健康分（從數據庫）
        db_health = account.get('health_score', 85)
        score = min(score, db_health)
        
        # 2. 今日發送比例扣分
        daily_limit = account.get('daily_send_limit', 50)
        daily_count = account.get('daily_send_count', 0)
        usage_ratio = daily_count / max(daily_limit, 1)
        if usage_ratio > 0.8:
            score -= 20  # 接近限制扣20分
        elif usage_ratio > 0.5:
            score -= 10  # 超過一半扣10分
        
        # 3. 失敗率扣分
        if sent_today > 0:
            fail_rate = failed_today / sent_today
            if fail_rate > 0.3:
                score -= 30
            elif fail_rate > 0.1:
                score -= 15
        
        # 4. 冷卻中扣分
        if not self.is_account_available(phone):
            score -= 50
        
        return max(0, min(100, score))
    
    async def select_account(self, exclude_phones: List[str] = None) -> Optional[Dict]:
        """根據策略選擇一個發送帳號"""
        accounts = await self.get_sender_accounts()
        
        # 排除指定帳號
        if exclude_phones:
            accounts = [a for a in accounts if a.get('phone') not in exclude_phones]
        
        # 過濾掉不可用的帳號（冷卻/FloodWait）
        available = [a for a in accounts if self.is_account_available(a.get('phone'))]
        
        if not available:
            return None
        
        # 按健康分數排序，選擇最高的
        accounts_with_scores = [(acc, self.calculate_health_score(acc)) for acc in available]
        accounts_with_scores.sort(key=lambda x: x[1], reverse=True)
        
        return accounts_with_scores[0][0]
```

### 🧠 RAG 上下文構建

**文件：** `backend/ai_auto_chat.py`

```python
async def _generate_response_with_prompt(self, user_id: str, user_message: str, 
                                          custom_prompt: Optional[str] = None) -> Optional[str]:
    """生成帶 RAG 上下文的 AI 回復"""
    
    # 基礎系統提示
    system_prompt = self.settings.get('system_prompt', '') or """你是朋友般的聊天助手。回覆規則：
1. 每次回覆必須簡短（15-50字以內）
2. 像微信/Telegram聊天一樣自然
3. 可以用emoji但不要太多
4. 直接回應問題，不要囉嗦"""
    
    # === RAG: 獲取相關知識庫內容 ===
    rag_context = ""
    if self.settings.get('rag_enabled', True):
        # 方法1：TelegramRAG 系統
        if RAG_AVAILABLE:
            rag_context = await telegram_rag.build_rag_context(
                user_message=user_message,
                user_id=user_id,
                max_items=3,
                max_tokens=800
            )
        
        # 方法2：知識學習器（備用）
        if not rag_context:
            learned_context = await knowledge_learner.get_relevant_context(user_message, user_id)
            if learned_context:
                rag_context = learned_context
        
        if rag_context:
            rag_context += "\n請參考以上信息回答，但不要直接複製。"
    
    # 添加 RAG 上下文到系統提示
    full_system_prompt = system_prompt + rag_context
    
    # === 獲取用戶畫像 ===
    profile = await db.get_user_profile(user_id)
    if profile:
        stage = profile.get('funnel_stage', 'new')
        interest = profile.get('interest_level', 1)
        stage_hint = self._get_stage_prompt(stage, interest)
        if stage_hint:
            full_system_prompt += f"\n\n[用戶階段提示]\n{stage_hint}"
    
    # 構建消息列表（包含歷史對話）
    messages = await ai_context.build_context(
        user_id=user_id,
        system_prompt=full_system_prompt,
        max_messages=20
    )
    
    # 調用 AI API
    return await self._call_ai_api(messages)
```

---

## 5. 前後端通訊架構

### 架構圖

```
┌─────────────────┐     IPC (stdin/stdout)     ┌─────────────────┐
│   Electron      │ ◄──────────────────────── │    Python       │
│   (Node.js)     │         JSON              │    Backend      │
│                 │ ────────────────────────► │    (main.py)    │
│   electron.js   │                           │                 │
└────────┬────────┘                           └────────┬────────┘
         │                                             │
         │ Angular IPC Service                         │ Pyrogram
         ▼                                             ▼
┌─────────────────┐                           ┌─────────────────┐
│   Angular       │                           │   Telegram API  │
│   Frontend      │                           │   (MTProto)     │
│   (TypeScript)  │                           │                 │
└─────────────────┘                           └─────────────────┘
```

### IPC 消息格式

**命令 (Electron → Python)：**

```json
{
    "command": "send-message",
    "payload": {
        "phone": "+8613812345678",
        "targetUserId": "123456789",
        "message": "你好！"
    },
    "message_id": "550e8400-e29b-41d4-a716-446655440000"
}
```

**事件 (Python → Electron)：**

```json
{
    "event": "ai-response-generated",
    "payload": {
        "userId": "123456789",
        "username": "test_user",
        "userMessage": "你們的產品怎麼賣？",
        "aiResponse": "你好！我們有多種套餐可選，你想了解哪方面？",
        "mode": "semi",
        "requiresApproval": true
    }
}
```

### 主要 IPC 命令列表

| 命令 | 方向 | 用途 |
|------|------|------|
| `add-account` | → Python | 添加 Telegram 帳號 |
| `connect-account` | → Python | 連接帳號 |
| `send-message` | → Python | 發送消息 |
| `start-monitoring` | → Python | 啟動監控 |
| `get-ai-settings` | → Python | 獲取 AI 設置 |
| `save-trigger-rule` | → Python | 保存觸發規則 |
| `accounts-updated` | ← Python | 帳號狀態更新 |
| `message-sent` | ← Python | 消息發送結果 |
| `ai-response-generated` | ← Python | AI 生成回復 |
| `keyword-triggered` | ← Python | 關鍵詞觸發 |

---

## 6. TTS 說明

### 當前狀態

TTS (Text-to-Speech) 功能在前端有配置入口，但**尚未集成到自動回復流程中**。

**前端配置（localStorage）：**

```typescript
// src/app.component.ts
localStorage.setItem('tts_endpoint', this.ttsEndpoint());  // TTS 服務地址
localStorage.setItem('tts_enabled', String(this.ttsEnabled()));
localStorage.setItem('tts_voice', this.ttsVoice());
localStorage.setItem('stt_endpoint', this.sttEndpoint());  // STT 服務地址
```

### 實現「AI 回復 → TTS → 發送語音」的建議

如需完整實現，需要新增以下模組：

1. **TTS API 調用模組** (`tts_service.py`)
   ```python
   async def text_to_speech(text: str, voice: str = "default") -> bytes:
       """調用 TTS API 將文本轉換為語音"""
       async with aiohttp.ClientSession() as session:
           async with session.post(tts_endpoint, json={
               "text": text,
               "voice": voice
           }) as response:
               return await response.read()
   ```

2. **語音消息發送邏輯**
   ```python
   # 使用 Pyrogram 發送語音
   await client.send_voice(
       chat_id=user_id,
       voice=audio_bytes,
       caption="語音消息"
   )
   ```

---

## 7. 升級建議方向（多智能體協同）

基於當前架構，實現「多智能體無劇本協同」可考慮以下升級方向：

### 現有基礎 vs 升級方向

| 模組 | 現有基礎 | 升級方向 |
|------|----------|----------|
| **Agent 身份** | `multi_role_manager.py` | 擴展為獨立 Agent 類，支持不同人格/知識庫/目標 |
| **協作調度** | `collaboration_coordinator.py` | 實現 Agent 間消息路由、任務分配、衝突解決 |
| **共享記憶** | `vector_memory.py` + RAG | 建立共享知識圖譜，Agent 可讀寫，支持跨對話記憶 |
| **對話狀態機** | `auto_funnel_manager.py` | 升級為有限狀態機，支持多 Agent 接力對話 |
| **策略引擎** | `ai_response_strategy.py` | 增加多 Agent 策略選擇，動態切換對話風格 |

### 建議架構升級

```
┌────────────────────────────────────────────────────────────────────┐
│                      Multi-Agent Orchestrator                       │
│  • Agent Registry (註冊中心)                                        │
│  • Task Dispatcher (任務分發)                                       │
│  • Conflict Resolver (衝突解決)                                     │
└────────────────────────────────────────┬───────────────────────────┘
                                         │
         ┌───────────────────────────────┼───────────────────────────┐
         ▼                               ▼                           ▼
┌─────────────────┐           ┌─────────────────┐           ┌─────────────────┐
│   Sales Agent   │           │  Support Agent  │           │  Expert Agent   │
│   (銷售角色)     │           │   (客服角色)     │           │   (專家角色)     │
│                 │           │                 │           │                 │
│  • 產品介紹      │           │  • 問題解答      │           │  • 深度諮詢      │
│  • 價格談判      │           │  • 投訴處理      │           │  • 技術支持      │
│  • 成交推進      │           │  • 售後服務      │           │  • 方案設計      │
└────────┬────────┘           └────────┬────────┘           └────────┬────────┘
         │                             │                             │
         └─────────────────────────────┼─────────────────────────────┘
                                       ▼
                        ┌─────────────────────────────┐
                        │   Shared Memory & Context   │
                        │   (共享記憶與上下文)          │
                        │                             │
                        │  • 對話歷史                  │
                        │  • 用戶畫像                  │
                        │  • 知識圖譜                  │
                        │  • 決策記錄                  │
                        └─────────────────────────────┘
```

---

## 附錄：技術棧總覽

| 層級 | 技術 | 版本 |
|------|------|------|
| **前端框架** | Angular | 17+ |
| **桌面框架** | Electron | 28+ |
| **後端語言** | Python | 3.11+ |
| **Telegram API** | Pyrogram | 2.0+ |
| **數據庫** | SQLite | 3.x |
| **向量數據庫** | ChromaDB | 0.4+ |
| **LLM 接口** | OpenAI API / Ollama | 兼容 |
| **UI 樣式** | Tailwind CSS | 3.x |

---

**文檔生成時間：** 2026-01-22  
**系統版本：** TG-AI智控王 v1.1.0  
**文檔作者：** AI 自動生成
