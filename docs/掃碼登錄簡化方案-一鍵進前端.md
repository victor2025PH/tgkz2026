# 掃碼登錄簡化方案：一鍵進前端

## 可行性分析（實施前確認）

### 數據流與一致性

| 環節 | 當前（Electron 無 api_server） | 改後（使用 defaultLoginApiUrl） |
|------|--------------------------------|----------------------------------|
| 生成二維碼 | 請求 localhost:api_port → Token 寫入**本地 DB** | 請求 defaultLoginApiUrl → Token 寫入**服務器 DB** ✅ |
| Bot 確認 | 服務器 Bot 查服務器 DB → **找不到** Token ❌ | 服務器 Bot 查服務器 DB → **找到** Token ✅ |
| 登錄成功後 auth/me | AuthService.getApiBaseUrl() → localhost:8000，帶**服務器**簽發的 token → **401** ❌ | getApiBaseUrl() → defaultLoginApiUrl，帶服務器 token → **200** ✅ |
| 刷新 Token | 同上，refresh 發到 localhost → 失敗 | refresh 發到 defaultLoginApiUrl → 成功 ✅ |

結論：只要**掃碼相關與登錄後所有 auth 請求**都走同一基址（有存則用 api_server，無存則用 defaultLoginApiUrl），登錄與掃碼即可正常；方案可行。

### 需統一取「有效 API 基址」的場所

1. **登錄頁**：`getApiBaseForFetch()`、`getWsHost()`、`getWsProtocol()` — 用於創建 Token、WebSocket。
2. **AuthService**：`getApiBaseUrl()` — 用於 auth/me、auth/refresh、logout 等。
3. **Auth 攔截器**：刷新 Token 時組 baseUrl — 用於 auth/refresh。

上述三處在「無 api_server」時均改為使用 `defaultLoginApiUrl`（且僅在 Electron 或本地開發 localhost:4200/4201 時），網頁正式環境同源不變。

### 不影響的範圍

- 網頁訪問正式站（如 https://tgw.usdt2026.cc）：同源，不讀 defaultLoginApiUrl，行為不變。
- Electron 下其他 IPC 命令（如 get-accounts、get-settings）：仍走本地後端，與登錄基址分離，無需改動。

---

## 一、目標

- **用戶體驗**：打開登錄頁 → 看到二維碼 → 用手機掃碼 → Bot 正常回覆「登錄成功」→ 網頁/客戶端自動進前端。**無需輸入服務器地址、無需區分網頁端/安裝版/開發版**。
- **適用範圍**：網頁端、安裝版（Electron）、開發端，流程一致、越簡單越好，不讓用戶困惑。
- **掃碼登錄有正常回覆**：Bot 只會回覆成功或少量可理解的失敗提示（如「登錄已過期，請重新掃碼」），不再出現「Token 不存在」或連刷多條失敗。

---

## 二、原則（為什麼能「簡單」）

掃碼登錄要成功，只需滿足一條：

- **生成登錄 Token 的後端** 和 **Telegram Bot 確認 Token 的後端** 必須是**同一套**（同一進程或同一數據庫）。

因此：

- **網頁端**：用戶訪問的就是你的網站（例如 `https://tgw.usdt2026.cc`），二維碼由該站同源 API 生成，Bot 也配置在該服務器 → 天然一致，無需任何配置。
- **安裝版 / 開發端**：若二維碼用「本機後端」（localhost）生成，Bot 在服務器上，兩邊不一致 → 會出現「Token 不存在」。  
  解決辦法：**安裝版/開發端在「掃碼登錄」時，默認使用與 Bot 相同的後端**（一個內置的默認地址），而不是本機。這樣用戶不用填任何東西，掃碼就能正常得到 Bot 成功回覆並進入前端。

---

## 三、方案概述

| 端       | 當前痛點                     | 簡化做法 |
|----------|------------------------------|----------|
| 網頁端   | 已簡單（同源即後端）         | 保持不變，無需配置。 |
| 安裝版   | 默認用本機後端，Bot 在服務器 → Token 不存在 | **默認使用內置「登錄後端」URL** 生成二維碼與登錄 WebSocket；不展示「使用服務器登錄」為必填，可收起到「高級」。 |
| 開發端   | 同上                         | 與安裝版一致：默認使用同一「登錄後端」URL（可為生產或開發服務器），掃碼即正常。 |

核心一點：**掃碼相關的請求（創建 token、登錄 WebSocket、登錄後的 auth/me）統一走「默認登錄後端」**；其餘能力（如安裝版內 IPC 調本地 Python）可按需保留，不影響「掃碼一鍵進前端」。

---

## 四、實施要點

### 4.1 前端：默認登錄後端 URL

- **新增配置**（如 `environment` 或構建時注入）：
  - `defaultLoginApiUrl`：用於**僅掃碼登錄**的 API 基址（例如 `https://tgw.usdt2026.cc`）。
  - 開發環境可設為生產地址（與 Bot 一致）或自建開發服務器地址；生產安裝版設為正式環境地址。
- **登錄頁取 API 基址的優先級**（`getApiBaseForFetch()` 或等價邏輯）：
  1. 用戶已保存的 `api_server`（若存在）
  2. **否則**：在 **Electron / 非同源環境** 下使用 **`defaultLoginApiUrl`**
  3. 再否則：本機（如 `http://localhost:8000` 或 `api_port`）
- 這樣在安裝版/開發端**不填任何東西**時，也會用默認後端生成二維碼，Bot 能確認 → 掃碼即有正常回覆並進前端。

### 4.2 登錄頁 UI：不強調「使用服務器登錄」

- 「使用服務器登錄」改為**默認折疊**或放入「高級 / 高級設置」。
- 文案可改為：「高級：自定義登錄服務器（一般無需修改）」。
- 新用戶只需：打開頁面 → 選掃碼 → 掃碼 → 完成，無需看到或填寫服務器地址。

### 4.3 掃碼成功後的前端行為（保持現狀即可）

- 登錄成功後：寫入 token、跳轉到前端；Bot 側已有成功文案與歡迎語。
- 若之前做過「同一 token 60 秒內只發一條失敗」與「Token 不存在 → 友善提示」的優化，保留即可，無需再讓用戶區分「本地/服務器」。

### 4.4 各端默認值與部署

- **網頁端**：同源即後端，不讀 `defaultLoginApiUrl` 也可（或讀了也與同源一致）。
- **安裝版**：構建時或運行時注入 `defaultLoginApiUrl` 為正式環境（如 `https://tgw.usdt2026.cc`），發包即帶默認值。
- **開發端**：`environment.ts`（或開發環境配置）中設 `defaultLoginApiUrl` 為當前用於掃碼的後端（建議與 Bot 一致，如生產地址），開發者無需每次手動填。

### 4.5 與現有「使用服務器登錄」的關係

- 保留「使用服務器登錄」作為**高級選項**：需要切到自建/其他環境的用戶仍可填寫並保存。
- 邏輯上：**有保存的 `api_server` 則優先使用；否則用 `defaultLoginApiUrl`；再否則才用本機**。這樣既滿足「默認一鍵掃碼」，又保留靈活性。

### 4.6 服務器端：Bot 與 API 必須同一後端（排查「Token 不存在」）

若前端已用 `defaultLoginApiUrl`（如 https://tgw.usdt2026.cc）生成二維碼且 WebSocket 已顯示 `login_token_connected`，但 Bot 仍回覆「Token 不存在」，說明 **Bot 調用的後端與生成 Token 的後端不是同一套**。請在**運行 Bot 的服務器**上確認：

1. **`INTERNAL_API_URL`**  
   Bot 用此變量請求 `GET /api/v1/auth/login-token/{token}` 和 `POST .../confirm`。  
   - 必須設為**與創建 Token 的 API 同一個基址**（例如 `https://tgw.usdt2026.cc`）。  
   - 默認為 `http://localhost:8000`；若服務僅通過 Nginx 對外暴露、本機未監聽 8000，會導致 Bot 請求失敗或打到錯誤實例。  
   - 建議：生產環境設為對外 API 基址，如 `INTERNAL_API_URL=https://tgw.usdt2026.cc`。

2. **Telegram Bot Webhook**  
   - Webhook 必須指向**與上述 API 同一部署**的服務器（同一台或同一集群且共享同一數據庫）。  
   - 若 Webhook 指向其他機器或另一套環境，該環境的數據庫裡沒有剛創建的 Token，就會回「Token 不存在」。

3. **多實例 / 負載均衡**  
   - 若 API 有多個實例，`login_tokens` 必須存於**共享存儲**（同一 DB 或 Redis），且 Bot 調用的 `INTERNAL_API_URL` 必須能訪問到寫入該 Token 的同一後端（或通過負載均衡保證會話親和/寫入可被讀到）。

日誌排查：當 Bot 報「Token 不存在」時，日誌中會輸出當前使用的 `INTERNAL_API_URL`（見 `[Bot] INTERNAL_API_URL=...` 及 GET login-token 失敗時的日誌），可據此核對是否與前端使用的基址一致。

---

## 四、為什麼服務器與本地開發者模式必須「用同一套系統」

### 4.7 能統一，且應當統一

**結論：服務器（網頁）和本地開發者模式的掃碼登錄可以、也應該用同一套系統。** 當前方案就是按「同一套」設計的。

| 使用方式           | 掃碼時用的後端           | 與 Bot 的關係     |
|--------------------|--------------------------|-------------------|
| 服務器網頁         | 同源 API（如 tgw）       | 同一套 ✅         |
| 本地開發（localhost:4200） | defaultLoginApiUrl（如 tgw） | 同一套 ✅         |
| 安裝版（Electron） | defaultLoginApiUrl（如 tgw） | 同一套 ✅         |

也就是說：**只要掃碼相關請求（創建 Token、WebSocket、登錄後 auth）都走同一個 API 基址**，服務器用戶和本地開發者用的就是**同一套系統**（同一份 Token 存儲、同一個 Bot、同一套登錄態）。

### 4.8 為什麼不能「服務器用服務器、本地用本地」兩套並存

若改成「服務器用服務器後端、本地開發用本地後端（localhost:8000）」：

- **Bot 只能跑在一處**（通常是生產服務器），且只會調用**該處的 API**（`INTERNAL_API_URL`）查詢 / 確認 Token。
- 本地創建的 Token 只存在**本地 DB**，服務器上的 Bot **無法訪問**，會報「Token 不存在」。
- 因此：**生成 Token 的後端** 和 **Bot 使用的後端** 必須是同一套（同一進程或同一數據庫）。要麼大家都用服務器這套（統一），要麼本地自建「API + Bot」另一套（兩套獨立系統，一般不這麼做）。

所以設計上：**不讓本地掃碼走本地後端**，而是讓本地開發也走 **defaultLoginApiUrl**（與 Bot 相同的生產後端），這樣服務器與本地開發者模式就**共用同一套系統**，掃碼流程一致、無需維護兩套。

### 4.9 配置要點（保證是同一套）

- **前端**：`environment` 中 `defaultLoginApiUrl` 設為與 Bot 一致的後端（如 `https://tgw.usdt2026.cc`）。本地開發、安裝版在未填「使用服務器登錄」時都會用該地址，與服務器網頁共用同一後端。
- **服務器**：`INTERNAL_API_URL` 設為同一基址；Telegram Webhook 指向該部署。這樣 Bot 查到的就是前端創建 Token 的那套系統。

按上述配置後，**不存在「服務器一套、本地另一套」**，兩者就是同一套系統。

---

## 五、預期效果

- **網頁端**：不變，繼續同源登錄，掃碼正常。
- **安裝版**：用戶安裝後打開 → 看到二維碼 → 掃碼 → Bot 正常回覆「登錄成功」→ 自動進前端，**無需輸入服務器地址**。
- **開發端**：本地跑前端，默認用配置的登錄後端（如生產）生成二維碼，掃碼即成功，**無需每次填地址**。
- 掃碼登錄有正常回覆（成功或少量清晰失敗提示），不再出現「Token 不存在」或連刷多條失敗，用戶不困惑。

---

## 六、小結

| 項目         | 內容 |
|--------------|------|
| 目標         | 一鍵掃碼進前端，不輸入服務器地址；網頁/安裝/開發一致、簡單。 |
| 原則         | 生成 Token 的後端 = Bot 確認的後端。 |
| 手段         | 安裝版/開發端內置「默認登錄後端」URL，掃碼相關請求默認走該後端；登錄頁不強調「使用服務器登錄」。 |
| 可選保留     | 「使用服務器登錄」收起到高級，供自建/多環境用戶使用。 |

按此方案實施後，用戶在任意端都只需：**打開 → 掃碼 → 得到正常回覆 → 進入前端**，無需理解「服務器地址」「本地/遠程」等概念。
