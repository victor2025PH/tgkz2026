# 数据库模式分析：当前架构与解决方案

## 一、结论（先给答案）

| 问题 | 答案 |
|------|------|
| **当前业务数据实际使用哪种模式？** | **多用户同一数据库**（一个共享的 `tgmatrix.db` 文件） |
| **是否存在「每用户一库」的基础设施？** | **有**，但**未用于业务数据**；仅部分管理/迁移场景使用 |

因此，多用户数据混用、互相覆盖的根本原因是：**所有用户读写同一个库、同一批表，且多数查询未按 `owner_user_id` 过滤**。  
解决方案应基于「**共享库 + 行级隔离（owner_user_id）**」实施，与《多用户数据隔离-可执行方案与改进》一致。

---

## 二、当前数据库模式分析

### 2.1 业务数据实际走的路径：**单库单文件**

- **配置文件**  
  - `config.py`：`DATABASE_PATH = DATABASE_DIR / "tgmatrix.db"`  
  - 所有环境（开发/生产）下，主库路径均为**一个** `tgmatrix.db` 文件。

- **Database 类与全局实例**  
  - `database.py`：  
    - `class Database(...)` 的 `__init__(self, db_path: Path = DB_PATH)` 使用 `DB_PATH = DATABASE_PATH`。  
    - `connect()` 使用 `await aiosqlite.connect(str(self.db_path), ...)`，即连接**这一个**文件。  
    - 文件末尾：`db = Database()`，即**进程内全局单例**。

- **业务代码使用的 db**  
  - `service/init_startup_mixin.py`：`from database import db`，并把该 `db` 放入 `ServiceContext(db=db, ...)`。  
  - 所有 domain handlers（监控、触发规则、客户名单、聊天模板等）通过 `get_service_context().db` 拿到的都是**这个全局 `db`**。  
  - 该 `db` 的 `self.db_path` 始终是 `tgmatrix.db`，**与当前登录用户无关**。

因此可以确定：  
**当前业务数据（客户名单、监控群组、关键词集、聊天模板、触发规则等）全部读写同一个数据库文件 `tgmatrix.db`，即「多用户同一数据库」模式。**

### 2.2 「每用户一库」的基础设施存在但未接入业务

- **租户库管理器**  
  - `core/tenant_database.py`：  
    - `TenantDatabaseManager`：按 `tenant_id` 提供独立库文件。  
    - `_get_tenant_db_path(tenant_id)`：  
      - `tenant_id == LOCAL_USER_ID` 时返回 `DATABASE_DIR / "tgmatrix.db"`（与主库同文件）；  
      - 否则返回 `TENANTS_DIR / f"tenant_{safe_id}.db"`（即 `data/tenants/tenant_xxx.db`）。  
    - `get_tenant_connection(tenant_id)`：返回该租户对应的 **sqlite3.Connection**（同步连接）。

- **在请求中的注入**  
  - `auth/middleware.py`：认证成功后设置  
    - `request['tenant_db'] = db_manager.get_tenant_connection(tenant_id)`  
    - `request['tenant_id'] = tenant_id`  
  - 即 HTTP 请求里可以拿到「当前用户的租户库连接」。

- **业务层并未使用该连接**  
  - 所有 mixin（如 `CampaignQueueMixin`、`ChatFunnelMixin`、`KeywordGroupMixin`）和 handler 使用的都是 `ServiceContext.db`，即全局 `database.db`（连接 `tgmatrix.db`）。  
  - 没有任何业务逻辑把 `request['tenant_db']` 或 `get_tenant_connection()` 用作 leads、templates、trigger_rules、monitored_groups、keyword_sets 的读写连接。  
  - `core/db_operations.py` 中的 `TenantDB`、`get_tenant_db()` 等是另一套封装，当前主流程的 Domain 层并未使用。

因此：  
**架构上存在「每用户一库」的能力（tenant_xxx.db + get_tenant_connection），但业务数据路径并未使用，实际仍是「多用户同一数据库」。**

### 2.3 小结表

| 项目 | 当前状态 |
|------|----------|
| 业务库文件 | 单一：`data/tgmatrix.db` |
| 业务使用的连接 | 全局单例 `database.db` → 始终连 `tgmatrix.db` |
| 是否按请求/用户切换库连接 | **否** |
| 租户库（tenant_xxx.db） | 存在，仅部分管理/迁移使用，业务未用 |
| 数据隔离方式 | 部分表有 `owner_user_id`，但多数读路径未过滤 → **实际未隔离** |

结论重复一遍：**当前模式是「多用户同一数据库」；要解决多用户数据混用，必须在共享库上做行级隔离（owner_user_id），或改为业务全面走租户库（大改）。**

---

## 三、解决方案（基于当前架构）

在**不改变「单进程 + 单库文件」**的前提下，唯一可行且改动范围可控的方式是：  
**继续使用一个 tgmatrix.db，在表结构和所有读/写/删上统一按 `owner_user_id` 做行级隔离。**

这与《多用户数据隔离-可执行方案与改进》中的方案一致，具体包括：

1. **表结构**  
   - 所有需隔离的租户表必须有 `owner_user_id`（如 `unified_contacts` 当前没有，需加列并做历史数据迁移）。

2. **读路径**  
   - 客户名单（unified_contacts）、聊天模板、触发规则、监控群组、关键词集等所有「列表/详情」查询，统一通过 `add_tenant_filter` 或等价方式加上 `owner_user_id = ?`（参数来自 `get_owner_user_id()`）。

3. **写路径**  
   - INSERT 必须写入当前用户的 `owner_user_id`；  
   - UPDATE/DELETE 的 WHERE 中必须带 `owner_user_id = ?`，避免跨户覆盖。

4. **移除错误逻辑**  
   - 删除 Phase7 中「将 NULL/空 owner 批量更新为当前用户」的 UPDATE，避免把他人或未归属数据划给当前用户。

5. **认证与上下文**  
   - 保证所有访问租户数据的 API/WebSocket 在认证后都设置 `tenant_id` 并调用 `set_current_tenant()`，使 `get_owner_user_id()` 在业务逻辑中始终有值。

按上述方式落地后，**在不改为「每用户一库」的前提下**，即可在现有「多用户同一数据库」上实现多用户数据隔离。

---

## 四、若未来要改为「每用户一库」

若产品后续希望物理隔离（每用户一个库文件），需要做架构级调整，例如：

- **连接按请求切换**  
  - 每个请求（或 WebSocket 命令）在处理前根据 `tenant_id` 取得 `get_tenant_connection(tenant_id)`，  
  - 将该连接注入到本请求使用的「Database 封装」或等价访问层，使该请求内所有 mixin 的 `fetch_all`/`execute` 都走该连接，而不是全局 `database.db`。

- **Database 实例不再全局单例**  
  - 要么改为「每请求一个 Database 实例（绑定租户连接）」，要么在现有 Database 上增加「当前连接可切换」的机制，并由中间件/WS 在处理前设置当前请求的租户连接。

- **迁移与兼容**  
  - 现有 `tgmatrix.db` 中的数据需按 `owner_user_id` 拆分到各 `tenant_xxx.db`；  
  - Electron 本地单用户可继续使用 `tgmatrix.db`（与当前 `_get_tenant_db_path(LOCAL_USER_ID)` 行为一致）。

这类改造涉及所有使用 `get_service_context().db` 的代码路径，工作量大，建议在完成「共享库 + owner_user_id 隔离」并稳定后再评估是否必要。

---

## 五、总结

| 问题 | 结论 |
|------|------|
| 现在是每用户一库还是多用户同一数据库？ | **多用户同一数据库**（业务全部使用同一个 `tgmatrix.db`）。 |
| 每用户一库有没有？ | **有基础设施**（tenant_xxx.db + get_tenant_connection），但**业务未使用**。 |
| 推荐解决方案？ | 在**保持当前共享库**的前提下，按《多用户数据隔离-可执行方案与改进》做 **owner_user_id 行级隔离**（表结构、读过滤、写归属、去 Phase7、租户上下文保障）。 |

这样即可在不大改架构的前提下，解决多用户数据混用与互相覆盖的问题。

---

## 六、在现有架构下：改「多用户同一库」还是「每用户不同库」更好？

### 6.1 两种方案对比

| 维度 | 方案 A：多用户同一数据库（共享库 + owner_user_id） | 方案 B：每用户不同数据库（tenant_xxx.db） |
|------|---------------------------------------------------|------------------------------------------|
| **改造成本** | 低：补表结构、读/写加过滤与归属，删 Phase7；改动集中在 DB mixin 与少量 handler。 | 高：需让「当前请求」使用的 db 连接来自租户库；ServiceContext.db 需按请求注入或 Database 支持切换连接；所有用 `db` 的代码路径都要在「有租户上下文」的请求内执行。 |
| **遗漏风险** | 有：漏加一处过滤就会泄露数据；需清单化所有读/写并 Code Review。 | 低：连错库就查不到数据，不会串户；但若某处仍用全局 db，会变成「永远看不到数据」或报错，易暴露。 |
| **隔离强度** | 逻辑隔离：同库同行，靠 WHERE owner_user_id 保证；SQL 写错或漏条件会越权。 | 物理隔离：不同文件，无法跨文件查询；单库损坏只影响一用户。 |
| **性能** | 单库单文件，多用户并发写争同一 WAL；用户多时锁竞争更明显（你已遇到 database is locked）。 | 每用户一文件，写分散，锁按用户隔离；单库体积小，备份/恢复也按用户。 |
| **运维** | 备份/恢复/迁移是一份库；扩容是单库优化或换库。 | 备份/恢复/迁移可按用户做；可把大租户迁到独立实例；小文件多，需管理目录与连接数。 |
| **与现有代码契合度** | 高：不改变「全局 db + mixin」模型，只给 SQL 加条件、给 INSERT 加列。 | 低：要么每请求构造「绑定租户连接的 Database 封装」并注入 ServiceContext，要么大改 Database 为「当前连接可切换」，两者都牵涉所有拿 `get_service_context().db` 的地方。 |
| **Electron 单机版** | 继续用 tgmatrix.db + local_user 即可，逻辑一致。 | 已有 `LOCAL_USER_ID` 映射到 tgmatrix.db，可保持兼容；若统一用 tenant_db，本地版即「单租户单库」。 |

### 6.2 结论与建议

**在现有架构下，更推荐先做「多用户同一数据库」方案（方案 A）。**

- **原因简要**：  
  - 改动面小、上线快，只需在现有共享库上补齐 `owner_user_id` 的读过滤与写归属，并去掉 Phase7，即可消除当前的数据混用与覆盖问题。  
  - 你已有 `tenant_filter`、`add_tenant_filter`、租户上下文，只需在未过滤的接口上系统加一层，并保证所有写操作带 owner、更新/删除带归属校验。  
  - 若改为每用户一库，需要把「当前请求用哪个 db」贯穿到整个 ServiceContext / Database 使用链，工作量大、回归面广，且当前业务并未依赖「物理隔离」才能满足合规或安全要求。

**何时再考虑「每用户不同数据库」（方案 B）更合适：**

- 需要**按用户/租户做物理隔离**（合规、审计、或「单租户可迁出」）。  
- 单库**锁竞争或体积**已成为瓶颈，且希望按用户拆分负载或做冷热分离。  
- 已有能力做**请求级/协程级 db 注入**（或愿意做一轮架构改造），再切到租户库连接。

**实施顺序建议：**

1. **现阶段**：按《多用户数据隔离-可执行方案与改进》落实**方案 A**（共享库 + owner_user_id），先解决数据混用与覆盖。  
2. **稳定后**：若确有物理隔离或性能需求，再评估把业务数据路径从「全局 db」改为「请求内租户 db」，并做数据迁移（按 owner_user_id 拆到各 tenant_xxx.db）。
