# 登錄與管理後台數據對齊說明

## 目標

- **網站版**、**本地安裝版**、**開發版** 登錄走同一套數據。
- 所有登錄用戶在 **管理後台** 可見，並可統一 **管理會員等級**。

## 架構要點

1. **單一後端、單一數據庫**  
   服務器上部署一個後端（如 `https://tgw.usdt2026.cc`），使用同一個數據庫（`users` 表）。管理後台與登錄 API 都連此後端，數據自然一致。

2. **客戶端 API 地址可配置**  
   各端通過 `localStorage['api_server']` 指向同一服務器後，登錄、刷新、會員等請求都會發往該服務器，實現數據對齊。

## 使用方式

### 服務器網站版（已部署在同一域名）

- 前端與後端同域（例如 `https://tgw.usdt2026.cc`）。  
- 不設置 `api_server` 時，請求走同源，即該服務器後端。  
- 管理後台（如 `https://tgw.usdt2026.cc/admin/index.html`）不設置時也走同源，與登錄共用同一套數據。

### 本地安裝版（Electron）與開發版

需要與服務器數據對齊時：

1. 打開 **登錄頁**。
2. 點擊 **「使用服務器登錄（與管理後台同一套數據）」**。
3. 輸入服務器地址，例如：`https://tgw.usdt2026.cc`。
4. 點擊 **「保存」**。

之後登錄、掃碼、刷新 Token、會員等都會請求該服務器，用戶與會員等級與管理後台一致。

### 管理後台

- 若在 **同一服務器** 打開（如 `https://tgw.usdt2026.cc/admin/`），無需設置，即使用該服務器 API。
- 若在 **其他域名** 打開（如 GitHub Pages），需在登錄前設置：
  - 控制台執行：`localStorage.setItem('api_server', 'https://tgw.usdt2026.cc')`
  - 或在管理後台登錄頁填寫「API 服務器」並保存。

## 後端要求

- 後端需使用 **同一個數據庫**（`config.DATABASE_PATH` / 同一 `users` 表）。
- 管理後台用戶列表已改為從 **users** 表讀取，掃碼登錄等寫入的用戶會在「用戶管理」中顯示。
- 會員等級在後台「用戶管理」中對用戶進行續費/等級操作即可。

## 小結

| 端         | 與服務器數據對齊方式 |
|------------|----------------------|
| 網站版     | 同域部署即可，無需設置 |
| 本地安裝版 | 登錄頁設置「使用服務器登錄」為服務器地址並保存 |
| 開發版     | 同上，設置 `api_server` 為服務器地址 |
| 管理後台   | 同域無需設置；異域時設置 `api_server` 為同一服務器地址 |

所有端指向同一 `api_server` 後，登錄與會員數據一致，管理後台可統一管理會員等級。

---

## 常見問題

### 控制台出現 chunk-xxx.js 404（Failed to fetch dynamically imported module）

開發時懶加載的頁面（如升級方案、我的錢包等）對應的 JS 文件找不到，多數是 **緩存了舊的入口頁**，而新編譯的 chunk 哈希已變。

**處理方式：**

1. **強制刷新**：`Ctrl + Shift + R`（Windows）或 `Cmd + Shift + R`（Mac），讓瀏覽器重新拉取 index 和最新 chunk。
2. **開發模式**：先停掉 `npm run start:dev`，再重新執行一次，然後刷新頁面。
3. **Electron 開發**：關閉當前窗口再重新打開，或重啟 `npm run start:dev`，確保載入的是當前編譯結果。

### Access token expired / refresh token valid 日誌很多

Access token 過期後會用 refresh token 在背景刷新，屬正常。為避免控制台刷屏，已改為同一種情況只打一次日誌；若仍看到多次，做一次強制刷新即可。

### 本地開發者模式，後台沒有用戶增加顯示

**原因：** 管理後台（用戶管理）顯示的用戶來自**當前後台所連的後端**。若你在本地用 `npm run start:dev` 登錄（Flora 等用戶寫入的是**本地** `backend/data/tgmatrix.db`），但打開的「後台」是 **https://tgw.usdt2026.cc/admin/**，則後台請求的是**服務器**的 API 和數據庫，自然看不到本地剛登錄的用戶。

**處理方式：**

- **要看到本地登錄的用戶**：讓管理後台連到本地後端。
  - 打開管理後台登錄頁（若無單獨頁面，可先打開 `https://tgw.usdt2026.cc/admin/` 或你本地提供的 admin 入口）。
  - 在登錄頁的「API 服務器」中填寫 **`http://localhost:8000`** 並保存（或控制台執行：`localStorage.setItem('api_server', 'http://localhost:8000')`），然後刷新並重新登錄後台。
  - 進入「用戶管理」並點「刷新」，即可看到本地數據庫中的用戶（含掃碼登錄的 Flora 等）。
- **要讓本地與線上數據一致**：在主應用登錄頁設置「使用服務器登錄」為 `https://tgw.usdt2026.cc`，則本地登錄也會寫入服務器 DB，再用同一域名打開後台即可看到。

### 網頁版掃碼「找不到 bot，該用戶不存在」

**原因：** 掃碼登錄的二維碼指向 Telegram 某個 Bot（如 `@tgzkw_bot`）。若**網站所在後端**（例如 https://tgw.usdt2026.cc 對應的服務器）未正確配置該 Bot，或 Bot 在 Telegram 上不存在/已刪除，掃碼時 Telegram 會提示「該用戶似乎不存在」。

**處理方式：**

1. **在網站後端服務器上配置 Bot**（與 BotFather 一致）：
   - 環境變量：`TELEGRAM_BOT_USERNAME=tgzkw_bot`（或你實際創建的 Bot 用戶名，不含 @）
   - 環境變量：`TELEGRAM_BOT_TOKEN=<BotFather 發給你的 token>`
   - 重啟後端使配置生效。
2. **確認 Bot 存在**：在 Telegram 搜尋 `@tgzkw_bot`（或你配置的用戶名），能打開並可發送 /start 即表示存在。
3. 若配置錯誤或 Token 無效，登錄頁生成二維碼後會顯示黃色提示「登入 Bot 未配置或不存在…」，請依提示在後端檢查上述兩項配置。
4. **僅本地有配置、網頁版仍報錯**：網頁版請求的是**線上後端**（tgw.usdt2026.cc），必須在**該服務器**上配置 Bot，而不是只在本地 .env 配置。

### 服務器之前能掃碼登錄，最近沒改代碼也沒上傳 Git，為何突然不能用了？本地開發卻可以

**原因說明：** 代碼沒有改動時，多數是**服務器上的運行環境**和本地不一致了。

- 後端生成二維碼時會讀 **環境變量**：`TELEGRAM_BOT_USERNAME`、`TELEGRAM_BOT_TOKEN`。
- 若這兩個變量**未設置**，代碼會用默認 Bot 用戶名 `tgzkw_bot` 生成連結（見 `auth_oauth_mixin.py`、`auth_core_mixin.py`）。建議仍在服務器上配置 `TELEGRAM_BOT_USERNAME`，以便與實際 Bot 一致。
- **本地**能用的原因：本地有 `.env`（或啟動時手動導出）配置了 `TELEGRAM_BOT_USERNAME=tgzkw_bot` 等，所以生成的是 `t.me/tgzkw_bot?start=...`，掃碼正常。
- **服務器**之前能用，說明當時進程是有正確環境變量的；若之後出現「不能用了」，常見情況是：
  - 服務器進程**重啟過**（主機重啟、PM2/systemd 重啟、重新部署等），重啟時**沒有**把 `TELEGRAM_BOT_USERNAME`、`TELEGRAM_BOT_TOKEN` 載入到該進程的環境裡；
  - 或從未寫入到生產環境的配置（例如只在本機 .env 或某台機器的 shell 裡設過，部署時沒有帶上）。

**排查與處理：**

1. **在服務器上確認後端進程的環境變量**  
   登錄到 tgw.usdt2026.cc，用你實際跑後端的方式查看（例如）：
   - 若用 systemd：`systemctl show your-service-name --property=Environment`
   - 若用 PM2：`pm2 env <id>` 或看對應 ecosystem 裡是否寫了 `TELEGRAM_BOT_USERNAME`、`TELEGRAM_BOT_TOKEN`
   - 若用 Docker：`docker exec <container> env | grep TELEGRAM`
   確認這兩個變量在**當前正在跑的後端進程**裡是否存在且為正確值。

2. **若沒有或為空**  
   在服務器上把 `TELEGRAM_BOT_USERNAME`、`TELEGRAM_BOT_TOKEN` 配進**該後端進程的啟動環境**（systemd 的 `Environment=`、PM2 的 `env`、Docker 的 `environment` 或 `.env` 等），然後**重啟後端進程**（不要只重載 Nginx）。

3. **與本地保持一致**  
   本地能掃碼是因為用了 tgzkw_bot；服務器上建議設成同一套：  
   `TELEGRAM_BOT_USERNAME=tgzkw_bot`，`TELEGRAM_BOT_TOKEN=<BotFather 的 token>`。

總結：沒有改代碼、沒上傳 Git，卻出現「服務器不能掃碼、本地能掃碼」，通常是**服務器重啟或部署時未載入 Bot 環境變量**，按上面檢查並補上即可。

**驗證結果（2026-02-22）：** 此前對線上後端請求 `POST /api/v1/auth/login-token` 曾返回 `bot_username: TGSmartKingBot`（舊默認值），導致「未找到用户名 @TGSmartKingBot」。代碼已將默認值改為 **`tgzkw_bot`**（`auth_oauth_mixin.py`、`auth_core_mixin.py`），未配置環境變量時也會使用正確 Bot。部署新版本後掃碼登錄應正常。
