# å…³é”®ç™»å½•é€»è¾‘ä¿®å¤å®Œæˆè¯´æ˜

## âœ… ä¿®å¤å®Œæˆ

### é—®é¢˜åˆ†æ

æ ¹æ®æ‚¨æä¾›çš„æ—¥å¿—å’Œé—®é¢˜æè¿°ï¼Œæ ¸å¿ƒé—®é¢˜åŒ…æ‹¬ï¼š

1. **WinError 32 (æ–‡ä»¶é”å®š)**ï¼šåœ¨åˆ é™¤ session æ–‡ä»¶æ—¶ï¼Œä¹‹å‰çš„ `Client` å®ä¾‹æ²¡æœ‰æ­£ç¡®åœæ­¢/æ–­å¼€è¿æ¥
2. **phone_code_hash ä¸¢å¤±**ï¼šåœ¨å®¢æˆ·ç«¯é‡æ–°åˆ›å»ºè¿‡ç¨‹ä¸­ï¼Œ`phone_code_hash` è¢«æ¸…é™¤ï¼Œå¯¼è‡´ç”¨æˆ·è¾“å…¥çš„éªŒè¯ç æ— æ³•ä½¿ç”¨
3. **PhoneCodeExpired å¤„ç†é”™è¯¯**ï¼šå½“éªŒè¯ç è¿‡æœŸæ—¶ï¼Œç³»ç»Ÿç»§ç»­æ‰§è¡Œé‡æ–°åˆ›å»ºå®¢æˆ·ç«¯çš„é€»è¾‘ï¼Œè€Œä¸æ˜¯ç«‹å³è¿”å›é”™è¯¯
4. **éåŸå­æ“ä½œ**ï¼šå³ä½¿ session æ–‡ä»¶åˆ é™¤å¤±è´¥ï¼Œç³»ç»Ÿä»ç„¶ç»§ç»­æ‰§è¡Œï¼Œå¯¼è‡´çŠ¶æ€ä¸ä¸€è‡´

---

## ğŸ”§ å®æ–½çš„ä¿®å¤

### 1. ç«‹å³å¤„ç† PhoneCodeExpired é”™è¯¯ âœ…

**ä¿®å¤å‰ï¼š**
- å½“æ•è·åˆ° `PhoneCodeExpired` æ—¶ï¼Œä»£ç ç»§ç»­æ‰§è¡Œé‡æ–°åˆ›å»ºå®¢æˆ·ç«¯çš„é€»è¾‘
- è¿™å¯¼è‡´ `phone_code_hash` è¢«æ¸…é™¤ï¼Œä½†ç”¨æˆ·å·²ç»è¾“å…¥äº†éªŒè¯ç 

**ä¿®å¤åï¼š**
- å½“æ•è·åˆ° `PhoneCodeExpired` æ—¶ï¼Œç«‹å³è¿”å›é”™è¯¯ï¼Œä¸ç»§ç»­æ‰§è¡Œ
- æ¸…é™¤ç™»å½•çŠ¶æ€å’Œå›è°ƒ
- è¿”å›æ˜ç¡®çš„é”™è¯¯æ¶ˆæ¯ï¼ŒåŒ…å« `code_expired: True`

**å…³é”®æ”¹è¿›ï¼š**
```python
except PhoneCodeExpired:
    # CRITICAL: Code expired - immediately return error, do NOT recreate client
    print(f"[TelegramClient] ERROR: Verification code expired. Cannot proceed with login.", file=sys.stderr)
    self.login_callbacks.pop(phone, None)
    self._pending_login_state.pop(phone, None)
    return {
        "success": False,
        "status": "error",
        "message": "Verification code expired. Please request a new code.",
        "code_expired": True
    }
```

---

### 2. ä¼˜é›…æ–­å¼€å®¢æˆ·ç«¯ï¼ˆä¿®å¤ WinError 32ï¼‰âœ…

**ä¿®å¤å‰ï¼š**
- åœ¨åˆ é™¤ session æ–‡ä»¶å‰ï¼Œæ²¡æœ‰ç¡®ä¿å®¢æˆ·ç«¯å®Œå…¨åœæ­¢å’Œæ–­å¼€è¿æ¥
- å¯¼è‡´æ–‡ä»¶å¥æŸ„æ²¡æœ‰è¢«é‡Šæ”¾ï¼Œå‡ºç° WinError 32

**ä¿®å¤åï¼š**
- åœ¨åˆ é™¤ session æ–‡ä»¶å‰ï¼Œå¼ºåˆ¶åœæ­¢å’Œæ–­å¼€å®¢æˆ·ç«¯
- ä½¿ç”¨ `client.stop()` å’Œ `client.disconnect()`
- ç­‰å¾…è¶³å¤Ÿçš„æ—¶é—´è®©æ“ä½œç³»ç»Ÿé‡Šæ”¾æ–‡ä»¶å¥æŸ„
- å¼ºåˆ¶åƒåœ¾å›æ”¶

**å…³é”®æ”¹è¿›ï¼š**
```python
# CRITICAL: Gracefully disconnect client BEFORE attempting file deletion
# Force stop first (releases file handles)
if hasattr(client, 'stop'):
    await client.stop()
    await asyncio.sleep(0.3)  # Wait after stop

if client.is_connected:
    await client.disconnect()

# Remove from manager
self.clients.pop(phone, None)
# Force garbage collection
del client
gc.collect()
await asyncio.sleep(0.5)  # Wait for file handles to be released
```

---

### 3. ä¿ç•™ç™»å½•çŠ¶æ€ï¼ˆphone_code_hashï¼‰âœ…

**ä¿®å¤å‰ï¼š**
- å½“å®¢æˆ·ç«¯é‡æ–°åˆ›å»ºæ—¶ï¼Œ`phone_code_hash` è¢«æ¸…é™¤
- ç”¨æˆ·å·²ç»è¾“å…¥çš„éªŒè¯ç æ— æ³•ä½¿ç”¨

**ä¿®å¤åï¼š**
- åœ¨å®¢æˆ·ç«¯é‡æ–°åˆ›å»ºå‰ï¼Œå°† `phone_code_hash` å’Œ `phone_code` ä¿å­˜åˆ° `_pending_login_state`
- åœ¨å®¢æˆ·ç«¯é‡æ–°åˆ›å»ºåï¼Œä» `_pending_login_state` æ¢å¤
- ç¡®ä¿æ–°çš„å®¢æˆ·ç«¯å¯ä»¥ä½¿ç”¨ä¿å­˜çš„ `phone_code_hash`

**å…³é”®æ”¹è¿›ï¼š**
```python
# Before client recreation
if phone_code and phone_code_hash:
    self._pending_login_state[phone] = {
        "phone_code_hash": phone_code_hash,
        "phone_code": phone_code,
        "timestamp": time.time()
    }

# After client recreation
if phone in self._pending_login_state:
    pending_state = self._pending_login_state[phone]
    restored_hash = pending_state.get("phone_code_hash")
    restored_code = pending_state.get("phone_code")
    
    if restored_hash and restored_code:
        self.login_callbacks[phone] = {
            "phone_code_hash": restored_hash,
            "client": client,
            "phone_code": restored_code,
            "restored": True
        }
```

---

### 4. åŸå­æ“ä½œï¼ˆSession æ–‡ä»¶åˆ é™¤ï¼‰âœ…

**ä¿®å¤å‰ï¼š**
- å³ä½¿ session æ–‡ä»¶åˆ é™¤å¤±è´¥ï¼Œç³»ç»Ÿä»ç„¶ç»§ç»­æ‰§è¡Œ
- è¿™å¯¼è‡´çŠ¶æ€ä¸ä¸€è‡´

**ä¿®å¤åï¼š**
- å¦‚æœç”¨æˆ·å·²ç»æäº¤äº†éªŒè¯ç ï¼Œä¸”åˆ é™¤å¤±è´¥ï¼Œä½¿ç”¨ä¸´æ—¶æ–‡ä»¶ç»§ç»­
- å¦‚æœç”¨æˆ·è¿˜æ²¡æœ‰æäº¤éªŒè¯ç ï¼Œä¸”åˆ é™¤å¤±è´¥ï¼ŒæŠ›å‡ºå¼‚å¸¸ï¼Œä¸ç»§ç»­æ‰§è¡Œ
- ç¡®ä¿æ“ä½œçš„åŸå­æ€§

**å…³é”®æ”¹è¿›ï¼š**
```python
# ATOMIC OPERATION: If deletion fails after all retries
if preserved_hash and preserved_code:
    # User has submitted code - we MUST preserve the hash
    # Use temporary session file to continue
    temp_session_path = session_path.parent / f"{session_path.stem}_temp_{timestamp}.session"
    use_temp_session = True
else:
    # No code submitted yet - can fail safely
    raise Exception(f"Cannot delete session file after {max_retries} attempts: {pe}")
```

---

### 5. æ”¹è¿› remove_client æ–¹æ³• âœ…

**ä¿®å¤å‰ï¼š**
- `remove_client` æ–¹æ³•æ²¡æœ‰ä¿ç•™ç™»å½•çŠ¶æ€çš„é€‰é¡¹
- åœ¨åˆ é™¤å®¢æˆ·ç«¯æ—¶ï¼Œæ€»æ˜¯æ¸…é™¤ `login_callbacks`

**ä¿®å¤åï¼š**
- æ·»åŠ  `preserve_login_state` å‚æ•°
- å¦‚æœ `preserve_login_state=True`ï¼Œåœ¨åˆ é™¤å®¢æˆ·ç«¯å‰ä¿å­˜ç™»å½•çŠ¶æ€åˆ° `_pending_login_state`
- ä¸æ¸…é™¤ `login_callbacks`ï¼ˆå¦‚æœä¿ç•™çŠ¶æ€ï¼‰

**å…³é”®æ”¹è¿›ï¼š**
```python
async def remove_client(self, phone: str, wait_for_disconnect: bool = True, preserve_login_state: bool = False) -> bool:
    # CRITICAL: Preserve login state if requested (before clearing callbacks)
    if preserve_login_state and phone in self.login_callbacks:
        login_callback = self.login_callbacks[phone]
        preserved_hash = login_callback.get("phone_code_hash")
        preserved_code = login_callback.get("phone_code")
        if preserved_hash:
            self._pending_login_state[phone] = {
                "phone_code_hash": preserved_hash,
                "phone_code": preserved_code,
                "timestamp": time.time()
            }
    
    # ... disconnect and cleanup ...
    
    # Remove from dictionaries (but preserve login state if requested)
    if not preserve_login_state:
        self.login_callbacks.pop(phone, None)
```

---

### 6. æ”¹è¿› sign_in æµç¨‹ä¸­çš„çŠ¶æ€æ¢å¤ âœ…

**ä¿®å¤å‰ï¼š**
- åœ¨ `sign_in` æ—¶ï¼Œå¦‚æœæ‰¾ä¸åˆ° callback clientï¼Œç›´æ¥è¿”å›é”™è¯¯
- æ²¡æœ‰æ£€æŸ¥ `_pending_login_state`

**ä¿®å¤åï¼š**
- åœ¨ `sign_in` æ—¶ï¼Œé¦–å…ˆæ£€æŸ¥ `login_callbacks`
- å¦‚æœæ‰¾ä¸åˆ°ï¼Œæ£€æŸ¥ `_pending_login_state`
- å¦‚æœæ‰¾åˆ°åŒ¹é…çš„ hashï¼Œä½¿ç”¨å½“å‰å®¢æˆ·ç«¯å¹¶æ›´æ–° `login_callbacks`

**å…³é”®æ”¹è¿›ï¼š**
```python
# First check login_callbacks
if phone in self.login_callbacks:
    callback_client = self.login_callbacks[phone].get("client")
    callback_hash = self.login_callbacks[phone].get("phone_code_hash")
    restored_state = self.login_callbacks[phone].get("restored", False)

# If not found in callbacks, check pending state
if not callback_hash and phone in self._pending_login_state:
    pending_state = self._pending_login_state[phone]
    callback_hash = pending_state.get("phone_code_hash")
    
    if callback_hash == phone_code_hash:
        if phone in self.clients:
            callback_client = self.clients[phone]
            # Update login_callbacks with restored state
            self.login_callbacks[phone] = {
                "phone_code_hash": callback_hash,
                "client": callback_client,
                "phone_code": restored_code or phone_code,
                "restored": True
            }
```

---

## ğŸ“‹ ä¿®å¤åçš„æµç¨‹

### æ­£å¸¸æµç¨‹ï¼š

1. **ç”¨æˆ·ç‚¹å‡»ç™»å½•** â†’ ç³»ç»Ÿæ£€æµ‹åˆ°æ— æ•ˆ session
2. **ç”¨æˆ·è¾“å…¥éªŒè¯ç ** â†’ ç³»ç»Ÿå°è¯•ä½¿ç”¨ç°æœ‰å®¢æˆ·ç«¯æäº¤
3. **å¦‚æœéªŒè¯ç è¿‡æœŸ** â†’ ç«‹å³è¿”å›é”™è¯¯ï¼Œä¸ç»§ç»­å¤„ç†
4. **å¦‚æœéªŒè¯ç æœ‰æ•ˆä½† session æ— æ•ˆ** â†’ ä¿å­˜ `phone_code_hash` åˆ° `_pending_login_state`
5. **ä¼˜é›…æ–­å¼€å®¢æˆ·ç«¯** â†’ å¼ºåˆ¶åœæ­¢å’Œæ–­å¼€ï¼Œç­‰å¾…æ–‡ä»¶å¥æŸ„é‡Šæ”¾
6. **åˆ é™¤ session æ–‡ä»¶** â†’ å¦‚æœå¤±è´¥ä¸”ç”¨æˆ·å·²æäº¤ä»£ç ï¼Œä½¿ç”¨ä¸´æ—¶æ–‡ä»¶
7. **é‡æ–°åˆ›å»ºå®¢æˆ·ç«¯** â†’ ä» `_pending_login_state` æ¢å¤ `phone_code_hash`
8. **ä½¿ç”¨æ¢å¤çš„ hash** â†’ æ–°çš„å®¢æˆ·ç«¯å¯ä»¥ä½¿ç”¨ä¿å­˜çš„ `phone_code_hash`

### é”™è¯¯å¤„ç†æµç¨‹ï¼š

1. **éªŒè¯ç è¿‡æœŸ** â†’ ç«‹å³è¿”å›é”™è¯¯ï¼Œæ¸…é™¤çŠ¶æ€
2. **éªŒè¯ç é”™è¯¯** â†’ è¿”å›é”™è¯¯ï¼Œå…è®¸é‡è¯•
3. **Session æ–‡ä»¶åˆ é™¤å¤±è´¥ï¼ˆç”¨æˆ·å·²æäº¤ä»£ç ï¼‰** â†’ ä½¿ç”¨ä¸´æ—¶æ–‡ä»¶ç»§ç»­
4. **Session æ–‡ä»¶åˆ é™¤å¤±è´¥ï¼ˆç”¨æˆ·æœªæäº¤ä»£ç ï¼‰** â†’ æŠ›å‡ºå¼‚å¸¸ï¼Œä¸ç»§ç»­æ‰§è¡Œ

---

## ğŸ¯ é¢„æœŸæ•ˆæœ

ä¿®å¤ååº”è¯¥èƒ½å¤Ÿï¼š

1. **æ­£ç¡®å¤„ç† WinError 32**ï¼š
   - âœ… åœ¨åˆ é™¤æ–‡ä»¶å‰ï¼Œç¡®ä¿å®¢æˆ·ç«¯å®Œå…¨åœæ­¢å’Œæ–­å¼€
   - âœ… ç­‰å¾…è¶³å¤Ÿçš„æ—¶é—´è®©æ“ä½œç³»ç»Ÿé‡Šæ”¾æ–‡ä»¶å¥æŸ„
   - âœ… ä½¿ç”¨ä¸´æ—¶æ–‡ä»¶ç­–ç•¥ä½œä¸ºåå¤‡æ–¹æ¡ˆ

2. **ä¿ç•™ phone_code_hash**ï¼š
   - âœ… åœ¨å®¢æˆ·ç«¯é‡æ–°åˆ›å»ºå‰ï¼Œä¿å­˜ `phone_code_hash` åˆ°ä¸´æ—¶çŠ¶æ€
   - âœ… åœ¨å®¢æˆ·ç«¯é‡æ–°åˆ›å»ºåï¼Œä»ä¸´æ—¶çŠ¶æ€æ¢å¤
   - âœ… ç¡®ä¿æ–°çš„å®¢æˆ·ç«¯å¯ä»¥ä½¿ç”¨ä¿å­˜çš„ `phone_code_hash`

3. **æ­£ç¡®å¤„ç†éªŒè¯ç è¿‡æœŸ**ï¼š
   - âœ… ç«‹å³è¿”å›é”™è¯¯ï¼Œä¸ç»§ç»­å¤„ç†
   - âœ… æ¸…é™¤ç™»å½•çŠ¶æ€
   - âœ… æä¾›æ¸…æ™°çš„ç”¨æˆ·åé¦ˆ

4. **ç¡®ä¿æ“ä½œåŸå­æ€§**ï¼š
   - âœ… å¦‚æœç”¨æˆ·å·²æäº¤ä»£ç ï¼Œä½¿ç”¨ä¸´æ—¶æ–‡ä»¶ç»§ç»­
   - âœ… å¦‚æœç”¨æˆ·æœªæäº¤ä»£ç ï¼Œå¤±è´¥æ—¶ä¸ç»§ç»­æ‰§è¡Œ

---

## âœ… ä¿®å¤å®Œæˆ

æ‰€æœ‰å…³é”®ä¿®å¤å·²å®Œæˆï¼š
- âœ… ç«‹å³å¤„ç† PhoneCodeExpired é”™è¯¯
- âœ… ä¼˜é›…æ–­å¼€å®¢æˆ·ç«¯ï¼ˆä¿®å¤ WinError 32ï¼‰
- âœ… ä¿ç•™ç™»å½•çŠ¶æ€ï¼ˆphone_code_hashï¼‰
- âœ… åŸå­æ“ä½œï¼ˆSession æ–‡ä»¶åˆ é™¤ï¼‰
- âœ… æ”¹è¿› remove_client æ–¹æ³•
- âœ… æ”¹è¿› sign_in æµç¨‹ä¸­çš„çŠ¶æ€æ¢å¤
- âœ… ä»£ç å·²é€šè¿‡è¯­æ³•æ£€æŸ¥

**è¯·é‡å¯åº”ç”¨å¹¶æµ‹è¯•ç™»å½•åŠŸèƒ½ï¼**

ç°åœ¨ç³»ç»Ÿåº”è¯¥èƒ½å¤Ÿï¼š
- æ­£ç¡®å¤„ç† WinError 32ï¼ˆæ–‡ä»¶é”å®šï¼‰
- ä¿ç•™ phone_code_hash åœ¨å®¢æˆ·ç«¯é‡æ–°åˆ›å»ºè¿‡ç¨‹ä¸­
- æ­£ç¡®å¤„ç†éªŒè¯ç è¿‡æœŸé”™è¯¯
- ç¡®ä¿æ“ä½œçš„åŸå­æ€§

