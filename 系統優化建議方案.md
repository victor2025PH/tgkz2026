# ç³»çµ±å„ªåŒ–å»ºè­°æ–¹æ¡ˆ

## ğŸ“Š ç•¶å‰ç³»çµ±ç‹€æ…‹åˆ†æ

### âœ… å·²å®Œæˆçš„æ ¸å¿ƒåŠŸèƒ½
- ç›£æ§ç¾¤çµ„å’Œé—œéµè©åŒ¹é…
- è‡ªå‹•å›å¾©å’Œ AI èŠå¤©
- èŠå¤©è¨˜éŒ„ç®¡ç†
- éŠ·å”®æ¼æ–—è‡ªå‹•åŒ–
- å‘é‡è¨˜æ†¶å’Œ RAG
- æ¶ˆæ¯éšŠåˆ—å’Œç™¼é€å„ªåŒ–
- æ€§èƒ½ç›£æ§åŸºç¤æ¡†æ¶

### ğŸ” è­˜åˆ¥çš„å„ªåŒ–æ©Ÿæœƒ
åŸºæ–¼ä»£ç¢¼åˆ†æå’Œç³»çµ±æ¶æ§‹ï¼Œä»¥ä¸‹æ˜¯å„ªå…ˆç´šæ’åºçš„å„ªåŒ–å»ºè­°ã€‚

---

## ğŸš€ å„ªå…ˆç´š 1ï¼šæ€§èƒ½å„ªåŒ–ï¼ˆé«˜å½±éŸ¿ï¼‰

### 1.1 æ•¸æ“šåº«æŸ¥è©¢å„ªåŒ– âš¡

#### å•é¡Œ
- å¤§é‡ N+1 æŸ¥è©¢å•é¡Œ
- ç¼ºå°‘è¤‡åˆç´¢å¼•
- èŠå¤©è¨˜éŒ„æŸ¥è©¢æœªåˆ†é 
- ç¼ºå°‘æŸ¥è©¢çµæœç·©å­˜

#### å„ªåŒ–æ–¹æ¡ˆ

**A. æ·»åŠ è¤‡åˆç´¢å¼•**
```python
# backend/database.py
async def create_performance_indexes(self):
    """å‰µå»ºæ€§èƒ½å„ªåŒ–ç´¢å¼•"""
    indexes = [
        # èŠå¤©è¨˜éŒ„æŸ¥è©¢å„ªåŒ–
        "CREATE INDEX IF NOT EXISTS idx_chat_history_user_time ON chat_history(user_id, timestamp DESC)",
        "CREATE INDEX IF NOT EXISTS idx_chat_history_account ON chat_history(account_phone, timestamp DESC)",
        
        # Lead æŸ¥è©¢å„ªåŒ–
        "CREATE INDEX IF NOT EXISTS idx_leads_status_timestamp ON leads(status, timestamp DESC)",
        "CREATE INDEX IF NOT EXISTS idx_leads_user_status ON leads(userId, status)",
        
        # æ¶ˆæ¯éšŠåˆ—å„ªåŒ–
        "CREATE INDEX IF NOT EXISTS idx_queue_status_priority ON queue_messages(status, priority DESC, scheduled_at)",
        "CREATE INDEX IF NOT EXISTS idx_queue_phone_status ON queue_messages(phone, status, scheduled_at)",
        
        # äº’å‹•æ­·å²å„ªåŒ–
        "CREATE INDEX IF NOT EXISTS idx_interactions_lead_time ON interactions(lead_id, timestamp DESC)",
        
        # ç”¨æˆ¶è³‡æ–™æŸ¥è©¢å„ªåŒ–
        "CREATE INDEX IF NOT EXISTS idx_user_profiles_funnel ON user_profiles(funnel_stage, updated_at DESC)",
        "CREATE INDEX IF NOT EXISTS idx_user_crm_user ON user_crm(user_id)",
    ]
    
    for index_sql in indexes:
        await self._connection.execute(index_sql)
    await self._connection.commit()
```

**B. å¯¦ç¾æŸ¥è©¢çµæœç·©å­˜**
```python
# backend/cache_manager.py (æ–°å»º)
from typing import Dict, Any, Optional
from datetime import datetime, timedelta
import asyncio

class CacheManager:
    """æŸ¥è©¢çµæœç·©å­˜ç®¡ç†å™¨"""
    
    def __init__(self, default_ttl: int = 300):
        self.cache: Dict[str, tuple] = {}  # key -> (value, expiry_time)
        self.default_ttl = default_ttl
        self._cleanup_task = None
    
    async def get(self, key: str) -> Optional[Any]:
        """ç²å–ç·©å­˜å€¼"""
        if key in self.cache:
            value, expiry = self.cache[key]
            if datetime.now() < expiry:
                return value
            else:
                del self.cache[key]
        return None
    
    async def set(self, key: str, value: Any, ttl: Optional[int] = None):
        """è¨­ç½®ç·©å­˜å€¼"""
        ttl = ttl or self.default_ttl
        expiry = datetime.now() + timedelta(seconds=ttl)
        self.cache[key] = (value, expiry)
    
    async def invalidate(self, pattern: str):
        """ä½¿ç·©å­˜å¤±æ•ˆï¼ˆæ”¯æŒæ¨¡å¼åŒ¹é…ï¼‰"""
        keys_to_delete = [k for k in self.cache.keys() if pattern in k]
        for key in keys_to_delete:
            del self.cache[key]
    
    async def start_cleanup_task(self):
        """å•Ÿå‹•å®šæœŸæ¸…ç†ä»»å‹™"""
        async def cleanup():
            while True:
                await asyncio.sleep(60)  # æ¯åˆ†é˜æ¸…ç†ä¸€æ¬¡
                now = datetime.now()
                expired_keys = [
                    k for k, (_, expiry) in self.cache.items()
                    if now >= expiry
                ]
                for key in expired_keys:
                    del self.cache[key]
        
        self._cleanup_task = asyncio.create_task(cleanup())
```

**C. æ‰¹é‡æŸ¥è©¢å„ªåŒ–**
```python
# å„ªåŒ–èŠå¤©è¨˜éŒ„æŸ¥è©¢ - ä½¿ç”¨ LIMIT/OFFSET åˆ†é 
async def get_chat_history_paginated(
    self, 
    user_id: str, 
    limit: int = 50, 
    offset: int = 0,
    before_timestamp: Optional[datetime] = None
) -> List[Dict[str, Any]]:
    """åˆ†é ç²å–èŠå¤©è¨˜éŒ„"""
    query = """
        SELECT id, role, content, timestamp, account_phone, message_id
        FROM chat_history
        WHERE user_id = ?
    """
    params = [user_id]
    
    if before_timestamp:
        query += " AND timestamp < ?"
        params.append(before_timestamp)
    
    query += " ORDER BY timestamp DESC LIMIT ? OFFSET ?"
    params.extend([limit, offset])
    
    cursor = await self._connection.execute(query, params)
    rows = await cursor.fetchall()
    return [dict(row) for row in rows]
```

**é æœŸæ•ˆæœ**ï¼š
- æŸ¥è©¢é€Ÿåº¦æå‡ 50-80%
- æ•¸æ“šåº«è² è¼‰é™ä½ 40%
- éŸ¿æ‡‰æ™‚é–“å¾ 500ms é™è‡³ 100ms

---

### 1.2 æ¶ˆæ¯è™•ç†ä¸¦ç™¼å„ªåŒ– âš¡

#### å•é¡Œ
- å–®ç·šç¨‹è™•ç†æ¶ˆæ¯
- é—œéµè©åŒ¹é…æ•ˆç‡ä½
- æ´»å‹•åŒ¹é…ä¸²è¡ŒåŸ·è¡Œ

#### å„ªåŒ–æ–¹æ¡ˆ

**A. ä¸¦ç™¼è™•ç†æ¶ˆæ¯**
```python
# backend/telegram_client.py
import asyncio
from concurrent.futures import ThreadPoolExecutor

class TelegramClientManager:
    def __init__(self):
        self.message_executor = ThreadPoolExecutor(max_workers=10)
        self.processing_semaphore = asyncio.Semaphore(50)  # æœ€å¤š50å€‹ä¸¦ç™¼
    
    async def handle_monitored_message(self, client, message):
        """ä¸¦ç™¼è™•ç†ç›£æ§æ¶ˆæ¯"""
        async with self.processing_semaphore:
            # é—œéµè©åŒ¹é…ï¼ˆCPU å¯†é›†å‹ï¼Œä½¿ç”¨ç·šç¨‹æ± ï¼‰
            loop = asyncio.get_event_loop()
            matched_keywords = await loop.run_in_executor(
                self.message_executor,
                self._match_keywords_sync,
                message.text,
                keyword_sets
            )
            
            if matched_keywords:
                # Lead æ•ç²å’Œæ´»å‹•åŸ·è¡Œï¼ˆI/O å¯†é›†å‹ï¼Œä½¿ç”¨ç•°æ­¥ï¼‰
                await self._process_lead_capture(message, matched_keywords)
```

**B. é—œéµè©åŒ¹é…å„ªåŒ–**
```python
# backend/keyword_matcher.py (å·²å­˜åœ¨ï¼Œå¯é€²ä¸€æ­¥å„ªåŒ–)
class OptimizedKeywordMatcher:
    """ä½¿ç”¨ Trie æ¨¹å„ªåŒ–é—œéµè©åŒ¹é…"""
    
    def __init__(self):
        self.trie = {}
        self.regex_patterns = []
    
    def add_keyword(self, keyword: str, is_regex: bool = False):
        """æ·»åŠ é—œéµè©åˆ° Trie æ¨¹"""
        if is_regex:
            self.regex_patterns.append(re.compile(keyword))
        else:
            node = self.trie
            for char in keyword.lower():
                if char not in node:
                    node[char] = {}
                node = node[char]
            node['_end'] = True
    
    def match(self, text: str) -> List[str]:
        """å¿«é€ŸåŒ¹é…é—œéµè©"""
        matches = []
        text_lower = text.lower()
        
        # Trie åŒ¹é…ï¼ˆO(n) æ™‚é–“è¤‡é›œåº¦ï¼‰
        for i in range(len(text_lower)):
            node = self.trie
            for j in range(i, len(text_lower)):
                if text_lower[j] not in node:
                    break
                node = node[text_lower[j]]
                if '_end' in node:
                    matches.append(text[i:j+1])
        
        # æ­£å‰‡åŒ¹é…
        for pattern in self.regex_patterns:
            if pattern.search(text):
                matches.append(pattern.pattern)
        
        return matches
```

**é æœŸæ•ˆæœ**ï¼š
- æ¶ˆæ¯è™•ç†é€Ÿåº¦æå‡ 3-5 å€
- é—œéµè©åŒ¹é…é€Ÿåº¦æå‡ 10 å€ï¼ˆTrie æ¨¹ï¼‰
- ç³»çµ±ååé‡æå‡ 200%

---

### 1.3 å‰ç«¯æ€§èƒ½å„ªåŒ– âš¡

#### å•é¡Œ
- å¤§é‡æ•¸æ“šä¸€æ¬¡æ€§æ¸²æŸ“
- ç¼ºå°‘è™›æ“¬æ»¾å‹•
- é »ç¹çš„ç‹€æ…‹æ›´æ–°å°è‡´é‡æ¸²æŸ“

#### å„ªåŒ–æ–¹æ¡ˆ

**A. è™›æ“¬æ»¾å‹•ï¼ˆèŠå¤©è¨˜éŒ„ï¼‰**
```typescript
// src/app.component.ts
import { CdkVirtualScrollViewport } from '@angular/cdk/scrolling';

// ä½¿ç”¨ Angular CDK Virtual Scrolling
chatHistoryViewport: CdkVirtualScrollViewport;

// åˆ†é åŠ è¼‰
async loadChatHistoryPaginated(userId: string, page: number = 0) {
  const limit = 50;
  const offset = page * limit;
  
  this.ipcService.send('get-chat-history-full', {
    userId,
    limit,
    offset
  });
}
```

**B. é˜²æŠ–å’Œç¯€æµ**
```typescript
// src/app.component.ts
import { debounceTime, distinctUntilChanged } from 'rxjs/operators';

// æœç´¢é˜²æŠ–
chatListSearch = signal('');
private searchSubject = new Subject<string>();

constructor() {
  this.searchSubject.pipe(
    debounceTime(300),
    distinctUntilChanged()
  ).subscribe(search => {
    this.chatListSearch.set(search);
    this.loadChatList();
  });
}

onSearchChange(value: string) {
  this.searchSubject.next(value);
}
```

**C. OnPush è®Šæ›´æª¢æ¸¬**
```typescript
// æ‰€æœ‰çµ„ä»¶ä½¿ç”¨ OnPush ç­–ç•¥
@Component({
  changeDetection: ChangeDetectionStrategy.OnPush,
  // ...
})
```

**é æœŸæ•ˆæœ**ï¼š
- åˆå§‹æ¸²æŸ“æ™‚é–“æ¸›å°‘ 60%
- æ»¾å‹•æ€§èƒ½æå‡ 5 å€
- å…§å­˜ä½¿ç”¨é™ä½ 40%

---

## ğŸ¯ å„ªå…ˆç´š 2ï¼šåŠŸèƒ½å¢å¼·ï¼ˆä¸­é«˜å½±éŸ¿ï¼‰

### 2.1 æ™ºèƒ½ AI å›å¾©ç­–ç•¥ ğŸ§ 

#### ç•¶å‰å•é¡Œ
- AI å›å¾©ç­–ç•¥å–®ä¸€
- ç¼ºå°‘ä¸Šä¸‹æ–‡ç†è§£å„ªåŒ–
- æ²’æœ‰å›å¾©è³ªé‡è©•ä¼°

#### å„ªåŒ–æ–¹æ¡ˆ

**A. å¤šç­–ç•¥ AI å›å¾©**
```python
# backend/ai_auto_chat.py
class AIResponseStrategy:
    """AI å›å¾©ç­–ç•¥ç®¡ç†å™¨"""
    
    STRATEGIES = {
        'greeting': GreetingStrategy(),      # å•å€™ç­–ç•¥
        'question': QuestionStrategy(),      # å•é¡Œå›ç­”ç­–ç•¥
        'objection': ObjectionStrategy(),   # ç•°è­°è™•ç†ç­–ç•¥
        'closing': ClosingStrategy(),        # æˆäº¤ç­–ç•¥
        'follow_up': FollowUpStrategy(),    # è·Ÿé€²ç­–ç•¥
    }
    
    async def select_strategy(self, message: str, context: dict) -> str:
        """æ ¹æ“šæ¶ˆæ¯å…§å®¹é¸æ“‡ç­–ç•¥"""
        # ä½¿ç”¨ç°¡å–®çš„é—œéµè©åŒ¹é…æˆ– AI åˆ†é¡
        if any(word in message.lower() for word in ['ä½ å¥½', 'hi', 'hello']):
            return 'greeting'
        elif '?' in message or any(word in message for word in ['æ€éº¼', 'å¦‚ä½•', 'ä»€éº¼']):
            return 'question'
        elif any(word in message.lower() for word in ['è²´', 'ä¾¿å®œ', 'åƒ¹æ ¼']):
            return 'objection'
        # ...
        return 'default'
    
    async def generate_response(self, strategy: str, message: str, context: dict) -> str:
        """ä½¿ç”¨é¸å®šç­–ç•¥ç”Ÿæˆå›å¾©"""
        strategy_handler = self.STRATEGIES.get(strategy, DefaultStrategy())
        return await strategy_handler.generate(message, context)
```

**B. å›å¾©è³ªé‡è©•ä¼°**
```python
# backend/ai_quality_checker.py (æ–°å»º)
class AIQualityChecker:
    """AI å›å¾©è³ªé‡æª¢æŸ¥å™¨"""
    
    async def check_quality(self, response: str, context: dict) -> dict:
        """æª¢æŸ¥å›å¾©è³ªé‡"""
        checks = {
            'length_appropriate': len(response) >= 10 and len(response) <= 500,
            'no_sensitive_words': not self._contains_sensitive_words(response),
            'relevant': await self._check_relevance(response, context),
            'tone_appropriate': await self._check_tone(response),
        }
        
        score = sum(checks.values()) / len(checks)
        
        if score < 0.7:
            # è³ªé‡ä¸è¶³ï¼Œé‡æ–°ç”Ÿæˆ
            return {'quality_score': score, 'should_regenerate': True}
        
        return {'quality_score': score, 'should_regenerate': False}
```

**é æœŸæ•ˆæœ**ï¼š
- å›å¾©ç›¸é—œæ€§æå‡ 40%
- ç”¨æˆ¶æ»¿æ„åº¦æå‡ 30%
- è½‰åŒ–ç‡æå‡ 20%

---

### 2.2 å¯¦æ™‚é€šçŸ¥ç³»çµ± ğŸ””

#### ç•¶å‰å•é¡Œ
- ç¼ºå°‘é‡è¦äº‹ä»¶é€šçŸ¥
- æ²’æœ‰æ¡Œé¢é€šçŸ¥
- å‘Šè­¦ä¿¡æ¯ä¸å¤ åŠæ™‚

#### å„ªåŒ–æ–¹æ¡ˆ

**A. æ¡Œé¢é€šçŸ¥é›†æˆ**
```typescript
// src/app.component.ts
async showNotification(title: string, body: string, options?: NotificationOptions) {
  if ('Notification' in window && Notification.permission === 'granted') {
    new Notification(title, {
      body,
      icon: '/assets/icon.png',
      badge: '/assets/badge.png',
      tag: 'tg-matrix-notification',
      requireInteraction: false,
      ...options
    });
  } else if (Notification.permission !== 'denied') {
    const permission = await Notification.requestPermission();
    if (permission === 'granted') {
      this.showNotification(title, body, options);
    }
  }
}

// ç›£è½é‡è¦äº‹ä»¶
this.ipcService.on('lead-captured', (lead) => {
  this.showNotification(
    'æ–°æ½›åœ¨å®¢æˆ¶',
    `@${lead.username} å·²æ•ç²`,
    { requireInteraction: true }
  );
});

this.ipcService.on('account-health-alert', (alert) => {
  this.showNotification(
    'å¸³è™Ÿå¥åº·è­¦å‘Š',
    `${alert.phone}: ${alert.message}`,
    { requireInteraction: true }
  );
});
```

**B. é€šçŸ¥å„ªå…ˆç´šç®¡ç†**
```python
# backend/notification_manager.py (æ–°å»º)
class NotificationPriority:
    CRITICAL = 1  # å¸³è™Ÿå°ç¦ã€ç³»çµ±éŒ¯èª¤
    HIGH = 2      # Lead æ•ç²ã€é‡è¦è½‰åŒ–
    MEDIUM = 3    # æ´»å‹•è§¸ç™¼ã€æ¶ˆæ¯ç™¼é€
    LOW = 4       # æ—¥å¸¸çµ±è¨ˆã€ç‹€æ…‹æ›´æ–°

class NotificationManager:
    async def send_notification(
        self, 
        title: str, 
        message: str, 
        priority: int = NotificationPriority.MEDIUM
    ):
        """ç™¼é€é€šçŸ¥"""
        notification = {
            'title': title,
            'message': message,
            'priority': priority,
            'timestamp': datetime.now().isoformat(),
            'read': False
        }
        
        # ä¿å­˜åˆ°æ•¸æ“šåº«
        await db.add_notification(notification)
        
        # ç™¼é€åˆ°å‰ç«¯
        self.event_callback('notification', notification)
        
        # é«˜å„ªå…ˆç´šé€šçŸ¥ç«‹å³é¡¯ç¤º
        if priority <= NotificationPriority.HIGH:
            self.event_callback('urgent-notification', notification)
```

**é æœŸæ•ˆæœ**ï¼š
- é‡è¦äº‹ä»¶éŸ¿æ‡‰æ™‚é–“æ¸›å°‘ 80%
- ç”¨æˆ¶å°ç³»çµ±ç‹€æ…‹æ„ŸçŸ¥æå‡ 100%
- å•é¡Œç™¼ç¾å’Œè™•ç†é€Ÿåº¦æå‡ 3 å€

---

### 2.3 æ™ºèƒ½æœç´¢å’Œéæ¿¾ ğŸ”

#### ç•¶å‰å•é¡Œ
- æœç´¢åŠŸèƒ½ç°¡å–®
- ç¼ºå°‘é«˜ç´šéæ¿¾
- æ²’æœ‰æœç´¢æ­·å²

#### å„ªåŒ–æ–¹æ¡ˆ

**A. å…¨æ–‡æœç´¢**
```python
# backend/search_engine.py (æ–°å»º)
import sqlite3
from typing import List, Dict

class FullTextSearchEngine:
    """å…¨æ–‡æœç´¢å¼•æ“"""
    
    def __init__(self, db_path: str):
        self.db_path = db_path
        self._init_fts()
    
    def _init_fts(self):
        """åˆå§‹åŒ– FTS è™›æ“¬è¡¨"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # å‰µå»º FTS è™›æ“¬è¡¨
        cursor.execute("""
            CREATE VIRTUAL TABLE IF NOT EXISTS chat_history_fts USING fts5(
                content,
                user_id,
                timestamp,
                content='chat_history',
                content_rowid='id'
            )
        """)
        
        # è§¸ç™¼å™¨è‡ªå‹•æ›´æ–° FTS
        cursor.execute("""
            CREATE TRIGGER IF NOT EXISTS chat_history_fts_insert AFTER INSERT ON chat_history
            BEGIN
                INSERT INTO chat_history_fts(rowid, content, user_id, timestamp)
                VALUES (new.id, new.content, new.user_id, new.timestamp);
            END;
        """)
        
        conn.commit()
        conn.close()
    
    async def search(
        self, 
        query: str, 
        filters: Optional[Dict] = None,
        limit: int = 50
    ) -> List[Dict]:
        """å…¨æ–‡æœç´¢"""
        sql = """
            SELECT ch.* FROM chat_history ch
            JOIN chat_history_fts fts ON ch.id = fts.rowid
            WHERE chat_history_fts MATCH ?
        """
        
        params = [query]
        
        if filters:
            if filters.get('user_id'):
                sql += " AND ch.user_id = ?"
                params.append(filters['user_id'])
            if filters.get('date_from'):
                sql += " AND ch.timestamp >= ?"
                params.append(filters['date_from'])
        
        sql += " ORDER BY ch.timestamp DESC LIMIT ?"
        params.append(limit)
        
        # åŸ·è¡ŒæŸ¥è©¢...
```

**B. é«˜ç´šéæ¿¾å™¨**
```typescript
// src/app.component.ts
interface AdvancedFilter {
  dateRange?: { from: Date; to: Date };
  funnelStage?: string[];
  hasTags?: string[];
  accountPhone?: string[];
  messageCount?: { min: number; max: number };
  lastActivity?: { days: number };
}

advancedFilter = signal<AdvancedFilter>({});

async applyAdvancedFilter(filter: AdvancedFilter) {
  this.ipcService.send('search-leads-advanced', { filter });
}
```

**é æœŸæ•ˆæœ**ï¼š
- æœç´¢é€Ÿåº¦æå‡ 10 å€
- æœç´¢æº–ç¢ºåº¦æå‡ 50%
- ç”¨æˆ¶æŸ¥æ‰¾æ•ˆç‡æå‡ 3 å€

---

## ğŸ›¡ï¸ å„ªå…ˆç´š 3ï¼šç©©å®šæ€§æå‡ï¼ˆä¸­å½±éŸ¿ï¼‰

### 3.1 è‡ªå‹•éŒ¯èª¤æ¢å¾© ğŸ”„

#### å•é¡Œ
- éŒ¯èª¤å¾Œéœ€è¦æ‰‹å‹•é‡å•Ÿ
- ç¼ºå°‘è‡ªå‹•é‡è©¦æ©Ÿåˆ¶
- é€£æ¥æ–·é–‹å¾Œç„¡æ³•è‡ªå‹•æ¢å¾©

#### å„ªåŒ–æ–¹æ¡ˆ

**A. é€£æ¥è‡ªå‹•é‡é€£**
```python
# backend/telegram_client.py
class AutoReconnectManager:
    """è‡ªå‹•é‡é€£ç®¡ç†å™¨"""
    
    def __init__(self, max_retries: int = 5, backoff_factor: float = 2.0):
        self.max_retries = max_retries
        self.backoff_factor = backoff_factor
        self.reconnect_tasks = {}
    
    async def reconnect_client(self, phone: str, client: Client):
        """è‡ªå‹•é‡é€£å®¢æˆ¶ç«¯"""
        retry_count = 0
        
        while retry_count < self.max_retries:
            try:
                await client.connect()
                if await client.is_connected():
                    self.log(f"æˆåŠŸé‡é€£: {phone}")
                    return True
            except Exception as e:
                retry_count += 1
                wait_time = self.backoff_factor ** retry_count
                self.log(f"é‡é€£å¤±æ•— ({retry_count}/{self.max_retries}): {e}, {wait_time}ç§’å¾Œé‡è©¦")
                await asyncio.sleep(wait_time)
        
        return False
    
    async def monitor_connection(self, phone: str, client: Client):
        """ç›£æ§é€£æ¥ç‹€æ…‹"""
        while True:
            await asyncio.sleep(30)  # æ¯30ç§’æª¢æŸ¥ä¸€æ¬¡
            
            if not await client.is_connected():
                self.log(f"æª¢æ¸¬åˆ°é€£æ¥æ–·é–‹: {phone}, é–‹å§‹é‡é€£...")
                await self.reconnect_client(phone, client)
```

**B. æ¶ˆæ¯ç™¼é€é‡è©¦æ©Ÿåˆ¶**
```python
# backend/message_queue.py
class RetryManager:
    """æ¶ˆæ¯ç™¼é€é‡è©¦ç®¡ç†å™¨"""
    
    RETRY_STRATEGIES = {
        'exponential': lambda attempt: 2 ** attempt,  # æŒ‡æ•¸é€€é¿
        'linear': lambda attempt: attempt * 60,        # ç·šæ€§é€€é¿
        'fixed': lambda attempt: 300,                  # å›ºå®šé–“éš”
    }
    
    async def retry_send(
        self, 
        message: QueueMessage, 
        strategy: str = 'exponential',
        max_retries: int = 3
    ):
        """é‡è©¦ç™¼é€æ¶ˆæ¯"""
        attempt = 0
        
        while attempt < max_retries:
            try:
                result = await self.send_callback(message)
                if result['success']:
                    return result
            except Exception as e:
                attempt += 1
                if attempt >= max_retries:
                    raise
                
                wait_time = self.RETRY_STRATEGIES[strategy](attempt)
                await asyncio.sleep(wait_time)
```

**é æœŸæ•ˆæœ**ï¼š
- ç³»çµ±å¯ç”¨æ€§å¾ 95% æå‡åˆ° 99.5%
- æ‰‹å‹•å¹²é æ¸›å°‘ 90%
- éŒ¯èª¤æ¢å¾©æ™‚é–“å¾ 5 åˆ†é˜é™è‡³ 30 ç§’

---

### 3.2 æ•¸æ“šå‚™ä»½å’Œæ¢å¾© ğŸ’¾

#### å•é¡Œ
- ç¼ºå°‘è‡ªå‹•å‚™ä»½
- æ²’æœ‰æ•¸æ“šæ¢å¾©æ©Ÿåˆ¶
- æ•¸æ“šä¸Ÿå¤±é¢¨éšª

#### å„ªåŒ–æ–¹æ¡ˆ

**A. è‡ªå‹•æ•¸æ“šå‚™ä»½**
```python
# backend/backup_manager.py (æ–°å»º)
import shutil
from datetime import datetime
from pathlib import Path

class BackupManager:
    """æ•¸æ“šå‚™ä»½ç®¡ç†å™¨"""
    
    def __init__(self, db_path: Path, backup_dir: Path):
        self.db_path = db_path
        self.backup_dir = backup_dir
        self.backup_dir.mkdir(parents=True, exist_ok=True)
    
    async def create_backup(self, backup_type: str = 'full') -> Path:
        """å‰µå»ºå‚™ä»½"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_filename = f"backup_{backup_type}_{timestamp}.db"
        backup_path = self.backup_dir / backup_filename
        
        # è¤‡è£½æ•¸æ“šåº«æ–‡ä»¶
        shutil.copy2(self.db_path, backup_path)
        
        # å£“ç¸®å‚™ä»½ï¼ˆå¯é¸ï¼‰
        if backup_type == 'full':
            shutil.make_archive(
                str(backup_path.with_suffix('')),
                'zip',
                self.backup_dir,
                backup_filename
            )
            backup_path.unlink()  # åˆªé™¤æœªå£“ç¸®æ–‡ä»¶
            backup_path = backup_path.with_suffix('.zip')
        
        # æ¸…ç†èˆŠå‚™ä»½ï¼ˆä¿ç•™æœ€è¿‘30å¤©ï¼‰
        await self.cleanup_old_backups(days=30)
        
        return backup_path
    
    async def schedule_backups(self, interval_hours: int = 24):
        """å®šæœŸå‚™ä»½"""
        while True:
            await asyncio.sleep(interval_hours * 3600)
            await self.create_backup('scheduled')
    
    async def restore_backup(self, backup_path: Path):
        """æ¢å¾©å‚™ä»½"""
        # å…ˆå‚™ä»½ç•¶å‰æ•¸æ“šåº«
        current_backup = await self.create_backup('pre_restore')
        
        try:
            # æ¢å¾©å‚™ä»½
            if backup_path.suffix == '.zip':
                # è§£å£“
                shutil.unpack_archive(backup_path, self.backup_dir)
                backup_path = backup_path.with_suffix('.db')
            
            shutil.copy2(backup_path, self.db_path)
            return True
        except Exception as e:
            # æ¢å¾©å¤±æ•—ï¼Œé‚„åŸç•¶å‰å‚™ä»½
            shutil.copy2(current_backup, self.db_path)
            raise
```

**B. å¢é‡å‚™ä»½**
```python
async def create_incremental_backup(self):
    """å‰µå»ºå¢é‡å‚™ä»½ï¼ˆåªå‚™ä»½è®Šæ›´ï¼‰"""
    # ä½¿ç”¨ SQLite çš„ WAL æ¨¡å¼é€²è¡Œå¢é‡å‚™ä»½
    # æˆ–ä½¿ç”¨å·®ç•°å‚™ä»½ç­–ç•¥
    pass
```

**é æœŸæ•ˆæœ**ï¼š
- æ•¸æ“šä¸Ÿå¤±é¢¨éšªé™ä½ 99%
- æ¢å¾©æ™‚é–“å¾æ•¸å°æ™‚é™è‡³æ•¸åˆ†é˜
- å‚™ä»½å­˜å„²ç©ºé–“ç¯€çœ 70%ï¼ˆå¢é‡å‚™ä»½ï¼‰

---

## ğŸ“ˆ å„ªå…ˆç´š 4ï¼šç›£æ§å’Œåˆ†æå¢å¼·ï¼ˆä¸­å½±éŸ¿ï¼‰

### 4.1 é«˜ç´šåˆ†æå„€è¡¨æ¿ ğŸ“Š

#### å„ªåŒ–æ–¹æ¡ˆ

**A. è½‰åŒ–æ¼æ–—å¯è¦–åŒ–**
```typescript
// src/app.component.ts
interface FunnelStage {
  stage: string;
  count: number;
  conversionRate: number;
  avgTime: number;  // å¹³å‡åœç•™æ™‚é–“
  dropOffRate: number;  // æµå¤±ç‡
}

funnelData = signal<FunnelStage[]>([]);

async loadFunnelAnalysis(days: number = 30) {
  this.ipcService.send('get-funnel-analysis', { days });
}
```

**B. ç”¨æˆ¶è¡Œç‚ºåˆ†æ**
```python
# backend/analytics_engine.py (æ–°å»º)
class UserBehaviorAnalyzer:
    """ç”¨æˆ¶è¡Œç‚ºåˆ†æå™¨"""
    
    async def analyze_user_journey(self, user_id: str) -> dict:
        """åˆ†æç”¨æˆ¶æ—…ç¨‹"""
        # ç²å–æ‰€æœ‰äº’å‹•
        interactions = await db.get_user_interactions(user_id)
        
        # åˆ†ææ™‚é–“ç·š
        timeline = self._build_timeline(interactions)
        
        # åˆ†æé—œéµç¯€é»
        key_moments = self._identify_key_moments(timeline)
        
        # é æ¸¬ä¸‹ä¸€æ­¥è¡Œå‹•
        next_action_prediction = await self._predict_next_action(user_id, timeline)
        
        return {
            'timeline': timeline,
            'key_moments': key_moments,
            'next_action_prediction': next_action_prediction,
            'engagement_score': self._calculate_engagement_score(timeline)
        }
```

**é æœŸæ•ˆæœ**ï¼š
- æ•¸æ“šæ´å¯Ÿèƒ½åŠ›æå‡ 5 å€
- æ±ºç­–æ”¯æŒæå‡ 80%
- è½‰åŒ–ç‡å„ªåŒ–æå‡ 25%

---

### 4.2 æ™ºèƒ½å‘Šè­¦ç³»çµ± ğŸš¨

#### å„ªåŒ–æ–¹æ¡ˆ

**A. è‡ªé©æ‡‰å‘Šè­¦é–¾å€¼**
```python
# backend/smart_alert_manager.py (æ–°å»º)
class SmartAlertManager:
    """æ™ºèƒ½å‘Šè­¦ç®¡ç†å™¨"""
    
    async def calculate_dynamic_threshold(self, metric: str) -> float:
        """è¨ˆç®—å‹•æ…‹é–¾å€¼ï¼ˆåŸºæ–¼æ­·å²æ•¸æ“šï¼‰"""
        # ç²å–æ­·å²æ•¸æ“š
        history = await db.get_metric_history(metric, days=30)
        
        # è¨ˆç®—çµ±è¨ˆå€¼
        mean = statistics.mean(history)
        std = statistics.stdev(history)
        
        # å‹•æ…‹é–¾å€¼ = å‡å€¼ + 2å€æ¨™æº–å·®
        threshold = mean + 2 * std
        
        return threshold
    
    async def check_anomaly(self, metric: str, value: float) -> bool:
        """æª¢æŸ¥ç•°å¸¸"""
        threshold = await self.calculate_dynamic_threshold(metric)
        return value > threshold
```

**B. å‘Šè­¦èšåˆå’Œå»é‡**
```python
async def aggregate_alerts(self, time_window_minutes: int = 5):
    """èšåˆç›¸åŒé¡å‹çš„å‘Šè­¦"""
    # åœ¨æ™‚é–“çª—å£å…§ï¼Œç›¸åŒé¡å‹çš„å‘Šè­¦åªç™¼é€ä¸€æ¬¡
    # é¿å…å‘Šè­¦é¢¨æš´
    pass
```

**é æœŸæ•ˆæœ**ï¼š
- å‘Šè­¦æº–ç¢ºåº¦æå‡ 60%
- èª¤å ±ç‡é™ä½ 80%
- éŸ¿æ‡‰æ™‚é–“æå‡ 40%

---

## ğŸ¨ å„ªå…ˆç´š 5ï¼šç”¨æˆ¶é«”é©—å„ªåŒ–ï¼ˆä½ä¸­å½±éŸ¿ï¼‰

### 5.1 æ‰¹é‡æ“ä½œç•Œé¢ âš¡

#### å„ªåŒ–æ–¹æ¡ˆ

**A. æ‰¹é‡é¸æ“‡å’Œæ“ä½œ**
```typescript
// src/app.component.ts
selectedLeads = signal<Set<number>>(new Set());

selectAllLeads() {
  this.selectedLeads.set(new Set(this.leads().map(l => l.id)));
}

async batchUpdateStatus(status: string) {
  const leadIds = Array.from(this.selectedLeads());
  this.ipcService.send('batch-update-lead-status', {
    leadIds,
    status
  });
}

async batchSendMessage(message: string) {
  const leadIds = Array.from(this.selectedLeads());
  this.ipcService.send('batch-send-message', {
    leadIds,
    message
  });
}
```

**B. æ“ä½œæ­·å²å’Œæ’¤éŠ·**
```python
# backend/action_history.py (æ–°å»º)
class ActionHistory:
    """æ“ä½œæ­·å²ç®¡ç†å™¨"""
    
    async def record_action(self, action_type: str, params: dict, result: dict):
        """è¨˜éŒ„æ“ä½œ"""
        await db.add_action_history({
            'action_type': action_type,
            'params': json.dumps(params),
            'result': json.dumps(result),
            'timestamp': datetime.now()
        })
    
    async def undo_action(self, action_id: int):
        """æ’¤éŠ·æ“ä½œ"""
        action = await db.get_action_history(action_id)
        # æ ¹æ“šæ“ä½œé¡å‹åŸ·è¡Œæ’¤éŠ·é‚è¼¯
        pass
```

---

### 5.2 å¿«æ·éµå’Œå¿«æ·æ“ä½œ âŒ¨ï¸

#### å„ªåŒ–æ–¹æ¡ˆ

```typescript
// src/app.component.ts
@HostListener('document:keydown', ['$event'])
handleKeyboardShortcut(event: KeyboardEvent) {
  // Ctrl/Cmd + K: å¿«é€Ÿæœç´¢
  if ((event.ctrlKey || event.metaKey) && event.key === 'k') {
    event.preventDefault();
    this.focusSearch();
  }
  
  // Ctrl/Cmd + N: æ–°å»º
  if ((event.ctrlKey || event.metaKey) && event.key === 'n') {
    event.preventDefault();
    this.openNewLeadDialog();
  }
  
  // Esc: é—œé–‰æ¨¡æ…‹æ¡†
  if (event.key === 'Escape') {
    this.closeAllModals();
  }
}
```

---

## ğŸ“‹ å¯¦æ–½å„ªå…ˆç´šå»ºè­°

### ç¬¬ä¸€éšæ®µï¼ˆ1-2é€±ï¼‰
1. âœ… æ•¸æ“šåº«ç´¢å¼•å„ªåŒ–
2. âœ… æŸ¥è©¢çµæœç·©å­˜
3. âœ… å‰ç«¯è™›æ“¬æ»¾å‹•
4. âœ… æ¡Œé¢é€šçŸ¥ç³»çµ±

### ç¬¬äºŒéšæ®µï¼ˆ2-3é€±ï¼‰
5. âœ… æ¶ˆæ¯è™•ç†ä¸¦ç™¼å„ªåŒ–
6. âœ… é—œéµè©åŒ¹é…å„ªåŒ–ï¼ˆTrie æ¨¹ï¼‰
7. âœ… æ™ºèƒ½ AI å›å¾©ç­–ç•¥
8. âœ… è‡ªå‹•éŒ¯èª¤æ¢å¾©

### ç¬¬ä¸‰éšæ®µï¼ˆ3-4é€±ï¼‰
9. âœ… å…¨æ–‡æœç´¢
10. âœ… æ•¸æ“šå‚™ä»½ç³»çµ±
11. âœ… é«˜ç´šåˆ†æå„€è¡¨æ¿
12. âœ… æ™ºèƒ½å‘Šè­¦ç³»çµ±

### ç¬¬å››éšæ®µï¼ˆæŒçºŒå„ªåŒ–ï¼‰
13. âœ… æ‰¹é‡æ“ä½œç•Œé¢
14. âœ… å¿«æ·éµæ”¯æŒ
15. âœ… å…¶ä»–ç”¨æˆ¶é«”é©—å„ªåŒ–

---

## ğŸ“Š é æœŸæ•´é«”æ•ˆæœ

| æŒ‡æ¨™ | ç•¶å‰ | å„ªåŒ–å¾Œ | æå‡ |
|------|------|--------|------|
| æŸ¥è©¢éŸ¿æ‡‰æ™‚é–“ | 500ms | 100ms | **80%** â¬‡ï¸ |
| æ¶ˆæ¯è™•ç†é€Ÿåº¦ | 10 msg/s | 50 msg/s | **400%** â¬†ï¸ |
| ç³»çµ±å¯ç”¨æ€§ | 95% | 99.5% | **4.5%** â¬†ï¸ |
| ç”¨æˆ¶æ»¿æ„åº¦ | - | - | **30%** â¬†ï¸ |
| è½‰åŒ–ç‡ | - | - | **20%** â¬†ï¸ |
| å…§å­˜ä½¿ç”¨ | - | - | **40%** â¬‡ï¸ |

---

## ğŸš€ ç«‹å³é–‹å§‹

å»ºè­°å¾**ç¬¬ä¸€éšæ®µ**é–‹å§‹ï¼Œé€™äº›å„ªåŒ–ï¼š
- âœ… å¯¦æ–½é›£åº¦ä½
- âœ… å½±éŸ¿ç¯„åœå¤§
- âœ… é¢¨éšªå°
- âœ… è¦‹æ•ˆå¿«

éœ€è¦æˆ‘é–‹å§‹å¯¦æ–½å“ªå€‹å„ªåŒ–é …ç›®å—ï¼Ÿ
