# 自動回復和聊天記錄功能實施完成

## ✅ 已完成功能

### 1. 自動回復觸發機制 ✅

#### 實現內容
- **私信消息處理器** (`private_message_handler.py`)
  - 監聽所有發送帳號的私信消息
  - 自動識別用戶回復
  - 觸發 AI 自動回復流程

#### 工作流程
```
用戶發送私信 
→ 私信處理器捕獲 
→ 保存到聊天歷史 
→ 記錄互動 
→ 標記用戶已互動（豁免限額）
→ 分析消息意圖 
→ 更新漏斗階段 
→ 觸發 AI 生成回復 
→ 根據模式發送（full/semi/assist）
```

#### 關鍵特性
- ✅ 只為 `Sender` 角色帳號註冊私信處理器
- ✅ 自動過濾 DNC 列表用戶
- ✅ 自動提取用戶記憶
- ✅ 支持全自動/半自動/輔助三種模式

---

### 2. 聊天記錄查看功能 ✅

#### 新增 API 端點

##### `get-chat-list` - 獲取聊天列表
```javascript
// 請求
send("get-chat-list", {
    limit: 50,
    offset: 0,
    search: "關鍵詞",      // 可選
    funnelStage: "replied" // 可選
})

// 響應
{
    success: true,
    chats: [
        {
            userId: "123456789",
            username: "user123",
            firstName: "張",
            lastName: "三",
            funnelStage: "replied",
            interestLevel: 3,
            lastInteraction: "2026-01-10T10:00:00Z",
            lastMessage: "最近怎麼樣？",
            lastMessageTime: "2026-01-10T10:00:00Z",
            unreadCount: 2
        }
    ],
    total: 100,
    limit: 50,
    offset: 0
}
```

##### `get-chat-history-full` - 獲取完整聊天記錄
```javascript
// 請求
send("get-chat-history-full", {
    userId: "123456789",
    limit: 100,
    offset: 0
})

// 響應
{
    success: true,
    userId: "123456789",
    messages: [
        {
            id: 1,
            role: "user",
            content: "你好",
            timestamp: "2026-01-10T10:00:00Z",
            accountPhone: "+1234567890",
            sourceGroup: null
        },
        {
            id: 2,
            role: "assistant",
            content: "嗨！有什麼可以幫你的嗎？",
            timestamp: "2026-01-10T10:01:00Z",
            accountPhone: "+1234567890",
            sourceGroup: null
        }
    ],
    profile: { ... },
    tags: [ ... ],
    total: 50
}
```

##### `send-ai-response` - 發送 AI 回復（半自動模式）
```javascript
// 請求
send("send-ai-response", {
    userId: "123456789",
    message: "AI 生成的回復內容",
    accountPhone: "+1234567890",  // 可選，不提供則自動選擇
    sourceGroup: null,            // 可選
    username: "user123"           // 可選
})

// 響應
{
    success: true,
    userId: "123456789",
    message: "AI 生成的回復內容",
    accountPhone: "+1234567890"
}
```

---

### 3. 帳號角色管理 ✅

#### 實現內容
- **角色區分**：
  - `Listener` - 監控帳號：只在群組中監聽關鍵詞，不處理私信
  - `Sender` - 發送帳號：處理私信回復，發送消息

#### 註冊邏輯
- 只有 `Sender` 角色帳號會註冊私信處理器
- `Listener` 帳號只註冊群組消息處理器
- 登錄成功時自動註冊對應的處理器
- 系統啟動時為已登錄帳號自動註冊

---

### 4. 已互動用戶豁免發送限額 ✅

#### 實現邏輯
- **檢查機制**：發送前檢查用戶是否已互動
- **互動定義**：用戶在聊天歷史中發送過至少一條消息
- **限額豁免**：
  - 已互動用戶：不計入每日發送限額
  - 未互動用戶：正常計入每日發送限額

#### 應用場景
1. **自動回復**：用戶回復後，AI 自動回復不計入限額
2. **手動發送**：向已互動用戶發送消息不計入限額
3. **活動發送**：向已互動用戶發送活動消息不計入限額

#### 代碼實現
```python
# 檢查用戶是否已互動
has_interacted = await self._user_has_interacted(user_id)

# 未互動用戶才檢查限額
if not has_interacted:
    if account.get('dailySendCount', 0) >= account.get('dailySendLimit', 50):
        # 達到限額，無法發送
        return False

# 發送成功後，未互動用戶才更新計數
if not has_interacted:
    await db.update_account(account_id, {
        'dailySendCount': account.get('dailySendCount', 0) + 1
    })
```

---

### 5. 轉化策略（基於漏斗階段）✅

#### 已實現功能
- **自動階段識別**：根據消息內容自動識別用戶意圖
- **階段自動轉換**：根據互動自動更新漏斗階段
- **個性化回復**：根據階段和興趣度生成不同回復

#### 漏斗階段與回復策略

| 階段 | 識別關鍵詞 | 回復策略 | AI 提示詞 |
|------|-----------|--------|-----------|
| new | 首次接觸 | 友好問候 | 生成一條友好簡短的問候消息（15-30字） |
| replied | 用戶已回復 | 繼續對話 | 根據對話繼續聊天，保持友好 |
| interested | 想了解、怎麼用 | 詳細介紹 | 簡單介紹產品/服務的核心價值（30-50字） |
| negotiating | 價格、多少錢 | 提供報價 | 提供報價信息，強調優惠和價值 |
| follow_up | 長時間無互動 | 溫和提醒 | 生成一條溫和的跟進消息 |
| converted | 成交、付款 | 感謝支持 | 生成感謝消息，提供售後支持信息 |
| churned | 不要、沒興趣 | 禮貌告別 | 禮貌告別，表示隨時歡迎再次聯繫 |

#### 自動跟進機制
- **已聯繫**：24小時無回復 → 自動跟進（最多3次）
- **有興趣**：48小時無互動 → 發送提醒
- **洽談中**：72小時無進展 → 優惠提醒
- **需跟進**：7天無回應 → 標記流失

---

## 🔧 技術實現細節

### 私信處理器架構
```
TelegramClientManager
  └─ register_private_message_handler()
      └─ PrivateMessageHandler
          ├─ register_handler() - 註冊 Pyrogram MessageHandler
          ├─ handle_private_message() - 處理私信
          │   ├─ 保存消息到 chat_history
          │   ├─ 記錄互動到 user_interactions
          │   ├─ 標記用戶已互動
          │   ├─ 分析消息意圖（auto_funnel）
          │   ├─ 觸發 AI 回復（ai_auto_chat）
          │   └─ 提取記憶（vector_memory）
          └─ unregister_handler() - 移除處理器
```

### 消息發送流程
```
AI 生成回復
  ↓
檢查用戶是否已互動
  ↓ (未互動)
檢查帳號每日限額
  ↓ (通過)
加入消息隊列
  ↓
發送消息
  ↓ (成功)
更新每日計數（僅未互動用戶）
  ↓
保存到聊天歷史
```

---

## 📊 數據庫結構

### 新增/使用的表

#### `chat_history` - 聊天歷史
- 所有對話永久保存
- 支持用戶和 AI 消息
- 關聯帳號和群組信息

#### `user_interactions` - 用戶互動記錄
- 詳細記錄每次互動
- 支持情感分析
- 記錄互動方向（inbound/outbound）

#### `user_profiles` - 用戶資料
- 漏斗階段
- 興趣程度
- 最後互動時間
- 總消息數

---

## 🚀 使用方式

### 1. 配置帳號角色
- 在添加帳號時設置 `role: "Sender"` 或 `role: "Listener"`
- `Sender` 帳號會自動註冊私信處理器

### 2. 配置 AI 自動回復
- 設置 `auto_chat_enabled: true`
- 選擇模式：
  - `full` - 全自動：收到回復後自動發送
  - `semi` - 半自動：生成回復，等待人工確認
  - `assist` - 輔助：只提供建議，不發送

### 3. 查看聊天記錄
```javascript
// 獲取聊天列表
send("get-chat-list", { limit: 50 })

// 獲取特定用戶的聊天記錄
send("get-chat-history-full", { userId: "123456789" })

// 發送 AI 回復（半自動模式）
send("send-ai-response", { 
    userId: "123456789", 
    message: "AI 生成的回復" 
})
```

---

## ⚠️ 注意事項

1. **帳號角色**：
   - 確保發送帳號設置為 `Sender` 角色
   - 監控帳號設置為 `Listener` 角色

2. **已互動用戶**：
   - 系統自動識別已互動用戶
   - 已互動用戶的後續消息不計入限額

3. **AI 配置**：
   - 需要配置 AI 端點（`localAiEndpoint`）
   - 需要設置 `auto_chat_enabled: true`

4. **消息發送**：
   - 真實帳號需要先與用戶建立聯繫
   - 建議在群組中先 @ 用戶，或等待用戶主動發送私信

---

## 🐛 已知問題與解決方案

### 問題 1: PEER_ID_INVALID
**原因**：真實帳號無法主動向未聯繫的用戶發送消息

**解決方案**：
- 在群組中先 @ 用戶建立聯繫
- 等待用戶主動發送私信
- 系統會自動記錄用戶聯繫狀態

### 問題 2: NG0955 錯誤（前端）
**原因**：聊天記錄列表的 trackBy 函數產生重複鍵

**解決方案**：
- 前端需要確保每個消息有唯一 ID
- 使用 `message.id` 作為 trackBy 鍵值

---

## 📝 下一步優化建議

1. **前端界面**：
   - 實現聊天記錄列表組件
   - 實現聊天詳情頁面
   - 修復 NG0955 錯誤

2. **轉化優化**：
   - 添加轉化率統計
   - 實現 A/B 測試
   - 優化回復策略

3. **性能優化**：
   - 聊天記錄分頁加載
   - 消息搜索優化
   - 緩存機制

---

## ✅ 測試清單

- [x] 私信處理器註冊
- [x] 用戶回復觸發 AI 回復
- [x] 全自動模式自動發送
- [x] 半自動模式生成回復
- [x] 已互動用戶豁免限額
- [x] 聊天記錄 API
- [x] 漏斗階段自動更新
- [x] 記憶自動提取

---

**實施完成時間**：2026-01-10
**版本**：v1.0
